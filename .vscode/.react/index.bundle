var __DEV__=true,__BUNDLE_START_TIME__=this.nativePerformanceNow?nativePerformanceNow():Date.now(),process=this.process||{};process.env=process.env||{};process.env.NODE_ENV="development";
(function (global) {
  "use strict";

  global.__r = metroRequire;
  global.__d = define;
  global.__c = clear;
  var modules = clear();
  var EMPTY = {};
  var _ref = {},
      hasOwnProperty = _ref.hasOwnProperty;

  function clear() {
    modules = typeof __NUM_MODULES__ === "number" ? Array(__NUM_MODULES__ | 0) : Object.create(null);
    return modules;
  }

  if (__DEV__) {
    var verboseNamesToModuleIds = Object.create(null);
    var initializingModuleIds = [];
  }

  function define(factory, moduleId, dependencyMap) {
    if (modules[moduleId] != null) {
      if (__DEV__) {
        var inverseDependencies = arguments[4];

        if (inverseDependencies) {
          global.__accept(moduleId, factory, dependencyMap, inverseDependencies);
        } else {
          console.warn("Trying to define twice module ID " + moduleId + " in the same bundle");
        }
      }

      return;
    }

    modules[moduleId] = {
      dependencyMap: dependencyMap,
      factory: factory,
      hasError: false,
      importedAll: EMPTY,
      importedDefault: EMPTY,
      isInitialized: false,
      publicModule: {
        exports: {}
      }
    };

    if (__DEV__) {
      modules[moduleId].hot = createHotReloadingObject();
      var _verboseName = arguments[3];

      if (_verboseName) {
        modules[moduleId].verboseName = _verboseName;
        verboseNamesToModuleIds[_verboseName] = moduleId;
      }
    }
  }

  function metroRequire(moduleId) {
    if (__DEV__ && typeof moduleId === "string") {
      var _verboseName2 = moduleId;
      moduleId = verboseNamesToModuleIds[_verboseName2];

      if (moduleId == null) {
        throw new Error('Unknown named module: "' + _verboseName2 + '"');
      } else {
        console.warn('Requiring module "' + _verboseName2 + '" by name is only supported for ' + "debugging purposes and will BREAK IN PRODUCTION!");
      }
    }

    var moduleIdReallyIsNumber = moduleId;

    if (__DEV__) {
      var initializingIndex = initializingModuleIds.indexOf(moduleIdReallyIsNumber);

      if (initializingIndex !== -1) {
        var cycle = initializingModuleIds.slice(initializingIndex).map(function (id) {
          return modules[id].verboseName;
        });
        cycle.push(cycle[0]);
        console.warn("Require cycle: " + cycle.join(" -> ") + "\n\n" + "Require cycles are allowed, but can result in uninitialized values. " + "Consider refactoring to remove the need for a cycle.");
      }
    }

    var module = modules[moduleIdReallyIsNumber];
    return module && module.isInitialized ? module.publicModule.exports : guardedLoadModule(moduleIdReallyIsNumber, module);
  }

  function metroImportDefault(moduleId) {
    if (__DEV__ && typeof moduleId === "string") {
      var _verboseName3 = moduleId;
      moduleId = verboseNamesToModuleIds[_verboseName3];
    }

    var moduleIdReallyIsNumber = moduleId;

    if (modules[moduleIdReallyIsNumber] && modules[moduleIdReallyIsNumber].importedDefault !== EMPTY) {
      return modules[moduleIdReallyIsNumber].importedDefault;
    }

    var exports = metroRequire(moduleIdReallyIsNumber);
    var importedDefault = exports && exports.__esModule ? exports.default : exports;
    return modules[moduleIdReallyIsNumber].importedDefault = importedDefault;
  }

  function metroImportAll(moduleId) {
    if (__DEV__ && typeof moduleId === "string") {
      var _verboseName4 = moduleId;
      moduleId = verboseNamesToModuleIds[_verboseName4];
    }

    var moduleIdReallyIsNumber = moduleId;

    if (modules[moduleIdReallyIsNumber] && modules[moduleIdReallyIsNumber].importedAll !== EMPTY) {
      return modules[moduleIdReallyIsNumber].importedAll;
    }

    var exports = metroRequire(moduleIdReallyIsNumber);
    var importedAll = void 0;

    if (exports && exports.__esModule) {
      importedAll = exports;
    } else {
      importedAll = {};

      if (exports) {
        for (var _key in exports) {
          if (hasOwnProperty.call(exports, _key)) {
            importedAll[_key] = exports[_key];
          }
        }
      }

      importedAll.default = exports;
    }

    return modules[moduleIdReallyIsNumber].importedAll = importedAll;
  }

  var inGuard = false;

  function guardedLoadModule(moduleId, module) {
    if (!inGuard && global.ErrorUtils) {
      inGuard = true;
      var returnValue = void 0;

      try {
        returnValue = loadModuleImplementation(moduleId, module);
      } catch (e) {
        global.ErrorUtils.reportFatalError(e);
      }

      inGuard = false;
      return returnValue;
    } else {
      return loadModuleImplementation(moduleId, module);
    }
  }

  var ID_MASK_SHIFT = 16;
  var LOCAL_ID_MASK = ~0 >>> ID_MASK_SHIFT;

  function unpackModuleId(moduleId) {
    var segmentId = moduleId >>> ID_MASK_SHIFT;
    var localId = moduleId & LOCAL_ID_MASK;
    return {
      segmentId: segmentId,
      localId: localId
    };
  }

  metroRequire.unpackModuleId = unpackModuleId;

  function packModuleId(value) {
    return (value.segmentId << ID_MASK_SHIFT) + value.localId;
  }

  metroRequire.packModuleId = packModuleId;
  var hooks = [];

  function registerHook(cb) {
    var hook = {
      cb: cb
    };
    hooks.push(hook);
    return {
      release: function release() {
        for (var i = 0; i < hooks.length; ++i) {
          if (hooks[i] === hook) {
            hooks.splice(i, 1);
            break;
          }
        }
      }
    };
  }

  metroRequire.registerHook = registerHook;

  function loadModuleImplementation(moduleId, module) {
    if (!module && global.__defineModule) {
      global.__defineModule(moduleId);

      module = modules[moduleId];
    }

    var nativeRequire = global.nativeRequire;

    if (!module && nativeRequire) {
      var _unpackModuleId = unpackModuleId(moduleId),
          _segmentId = _unpackModuleId.segmentId,
          _localId = _unpackModuleId.localId;

      nativeRequire(_localId, _segmentId);
      module = modules[moduleId];
    }

    if (!module) {
      throw unknownModuleError(moduleId);
    }

    if (module.hasError) {
      throw moduleThrewError(moduleId, module.error);
    }

    if (__DEV__) {
      var Systrace = metroRequire.Systrace;
    }

    module.isInitialized = true;
    var _module = module,
        factory = _module.factory,
        dependencyMap = _module.dependencyMap;

    if (__DEV__) {
      initializingModuleIds.push(moduleId);
    }

    try {
      if (__DEV__) {
        Systrace.beginEvent("JS_require_" + (module.verboseName || moduleId));
      }

      var _moduleObject = module.publicModule;

      if (__DEV__) {
        if (module.hot) {
          _moduleObject.hot = module.hot;
        }
      }

      _moduleObject.id = moduleId;

      if (hooks.length > 0) {
        for (var i = 0; i < hooks.length; ++i) {
          hooks[i].cb(moduleId, _moduleObject);
        }
      }

      factory(global, metroRequire, metroImportDefault, metroImportAll, _moduleObject, _moduleObject.exports, dependencyMap);

      if (!__DEV__) {
        module.factory = undefined;
        module.dependencyMap = undefined;
      }

      if (__DEV__) {
        Systrace.endEvent();
      }

      return _moduleObject.exports;
    } catch (e) {
      module.hasError = true;
      module.error = e;
      module.isInitialized = false;
      module.publicModule.exports = undefined;
      throw e;
    } finally {
      if (__DEV__) {
        if (initializingModuleIds.pop() !== moduleId) {
          throw new Error("initializingModuleIds is corrupt; something is terribly wrong");
        }
      }
    }
  }

  function unknownModuleError(id) {
    var message = 'Requiring unknown module "' + id + '".';

    if (__DEV__) {
      message += "If you are sure the module is there, try restarting Metro Bundler. " + "You may also want to run `yarn`, or `npm install` (depending on your environment).";
    }

    return Error(message);
  }

  function moduleThrewError(id, error) {
    var displayName = __DEV__ && modules[id] && modules[id].verboseName || id;
    return Error('Requiring module "' + displayName + '", which threw an exception: ' + error);
  }

  if (__DEV__) {
    metroRequire.Systrace = {
      beginEvent: function beginEvent() {},
      endEvent: function endEvent() {}
    };

    metroRequire.getModules = function () {
      return modules;
    };

    var createHotReloadingObject = function createHotReloadingObject() {
      var hot = {
        acceptCallback: null,
        accept: function accept(callback) {
          hot.acceptCallback = callback;
        },
        disposeCallback: null,
        dispose: function dispose(callback) {
          hot.disposeCallback = callback;
        }
      };
      return hot;
    };

    var metroAcceptAll = function metroAcceptAll(dependentModules, inverseDependencies, patchedModules) {
      if (!dependentModules || dependentModules.length === 0) {
        return true;
      }

      var notAccepted = dependentModules.filter(function (module) {
        return !metroAccept(module, undefined, undefined, inverseDependencies, patchedModules);
      });
      var parents = [];

      for (var i = 0; i < notAccepted.length; i++) {
        if (inverseDependencies[notAccepted[i]].length === 0) {
          return false;
        }

        parents.push.apply(parents, inverseDependencies[notAccepted[i]]);
      }

      return parents.length == 0;
    };

    var metroAccept = function metroAccept(id, factory, dependencyMap, inverseDependencies) {
      var patchedModules = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

      if (id in patchedModules) {
        return true;
      }

      patchedModules[id] = true;
      var mod = modules[id];

      if (!mod && factory) {
        return true;
      }

      var hot = mod.hot;

      if (!hot) {
        console.warn("Cannot accept module because Hot Module Replacement " + "API was not installed.");
        return false;
      }

      if (hot.disposeCallback) {
        try {
          hot.disposeCallback();
        } catch (error) {
          console.error("Error while calling dispose handler for module " + id + ": ", error);
        }
      }

      if (factory) {
        mod.factory = factory;
      }

      if (dependencyMap) {
        mod.dependencyMap = dependencyMap;
      }

      mod.hasError = false;
      mod.isInitialized = false;
      metroRequire(id);

      if (hot.acceptCallback) {
        try {
          hot.acceptCallback();
          return true;
        } catch (error) {
          console.error("Error while calling accept handler for module " + id + ": ", error);
        }
      }

      if (!inverseDependencies) {
        throw new Error("Undefined `inverseDependencies`");
      }

      return metroAcceptAll(inverseDependencies[id], inverseDependencies, patchedModules);
    };

    global.__accept = metroAccept;
  }
})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  Object.assign = function (target, sources) {
    if (__DEV__) {
      if (target == null) {
        throw new TypeError('Object.assign target cannot be null or undefined');
      }

      if (typeof target !== 'object' && typeof target !== 'function') {
        throw new TypeError('In this environment the target of assign MUST be an object. ' + 'This error is a performance optimization and not spec compliant.');
      }
    }

    for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
      var nextSource = arguments[nextIndex];

      if (nextSource == null) {
        continue;
      }

      if (__DEV__) {
        if (typeof nextSource !== 'object' && typeof nextSource !== 'function') {
          throw new TypeError('In this environment the sources for assign MUST be an object. ' + 'This error is a performance optimization and not spec compliant.');
        }
      }

      for (var key in nextSource) {
        if (__DEV__) {
          var hasOwnProperty = Object.prototype.hasOwnProperty;

          if (!hasOwnProperty.call(nextSource, key)) {
            throw new TypeError('One of the sources for assign has an enumerable key on the ' + 'prototype chain. Are you trying to assign a prototype property? ' + "We don't allow it, as this is an edge case that we do not support. " + 'This error is a performance optimization and not spec compliant.');
          }
        }

        target[key] = nextSource[key];
      }
    }

    return target;
  };
})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  var inspect = function () {
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      return formatValue(ctx, obj, opts.depth);
    }

    function stylizeNoColor(str, styleType) {
      return str;
    }

    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }

    function formatValue(ctx, value, recurseTimes) {
      var primitive = formatPrimitive(ctx, value);

      if (primitive) {
        return primitive;
      }

      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }

        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }

        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }

        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = '',
          array = false,
          braces = ['{', '}'];

      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }

      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      if (isError(value)) {
        base = ' ' + formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);
      var output;

      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }

    function formatPrimitive(ctx, value) {
      if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, 'string');
      }

      if (isNumber(value)) return ctx.stylize('' + value, 'number');
      if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
      if (isNull(value)) return ctx.stylize('null', 'null');
    }

    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }

    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];

      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }

      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }

    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
      };

      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }

      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }

      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }

          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }

      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }

        name = JSON.stringify('' + key);

        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }

    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function (prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    function isArray(ar) {
      return Array.isArray(ar);
    }

    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }

    function isNull(arg) {
      return arg === null;
    }

    function isNullOrUndefined(arg) {
      return arg == null;
    }

    function isNumber(arg) {
      return typeof arg === 'number';
    }

    function isString(arg) {
      return typeof arg === 'string';
    }

    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }

    function isUndefined(arg) {
      return arg === void 0;
    }

    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }

    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }

    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }

    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }

    function isFunction(arg) {
      return typeof arg === 'function';
    }

    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
    }

    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }

    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    return inspect;
  }();

  var OBJECT_COLUMN_NAME = '(index)';
  var LOG_LEVELS = {
    trace: 0,
    info: 1,
    warn: 2,
    error: 3
  };
  var INSPECTOR_LEVELS = [];
  INSPECTOR_LEVELS[LOG_LEVELS.trace] = 'debug';
  INSPECTOR_LEVELS[LOG_LEVELS.info] = 'log';
  INSPECTOR_LEVELS[LOG_LEVELS.warn] = 'warning';
  INSPECTOR_LEVELS[LOG_LEVELS.error] = 'error';
  var INSPECTOR_FRAMES_TO_SKIP = __DEV__ ? 2 : 1;

  function getNativeLogFunction(level) {
    return function () {
      var str;

      if (arguments.length === 1 && typeof arguments[0] === 'string') {
        str = arguments[0];
      } else {
        str = Array.prototype.map.call(arguments, function (arg) {
          return inspect(arg, {
            depth: 10
          });
        }).join(', ');
      }

      var logLevel = level;

      if (str.slice(0, 9) === 'Warning: ' && logLevel >= LOG_LEVELS.error) {
        logLevel = LOG_LEVELS.warn;
      }

      if (global.__inspectorLog) {
        global.__inspectorLog(INSPECTOR_LEVELS[logLevel], str, [].slice.call(arguments), INSPECTOR_FRAMES_TO_SKIP);
      }

      if (groupStack.length) {
        str = groupFormat('', str);
      }

      global.nativeLoggingHook(str, logLevel);
    };
  }

  function repeat(element, n) {
    return Array.apply(null, Array(n)).map(function () {
      return element;
    });
  }

  function consoleTablePolyfill(rows) {
    if (!Array.isArray(rows)) {
      var data = rows;
      rows = [];

      for (var key in data) {
        if (data.hasOwnProperty(key)) {
          var row = data[key];
          row[OBJECT_COLUMN_NAME] = key;
          rows.push(row);
        }
      }
    }

    if (rows.length === 0) {
      global.nativeLoggingHook('', LOG_LEVELS.info);
      return;
    }

    var columns = Object.keys(rows[0]).sort();
    var stringRows = [];
    var columnWidths = [];
    columns.forEach(function (k, i) {
      columnWidths[i] = k.length;

      for (var j = 0; j < rows.length; j++) {
        var cellStr = (rows[j][k] || '?').toString();
        stringRows[j] = stringRows[j] || [];
        stringRows[j][i] = cellStr;
        columnWidths[i] = Math.max(columnWidths[i], cellStr.length);
      }
    });

    function joinRow(row, space) {
      var cells = row.map(function (cell, i) {
        var extraSpaces = repeat(' ', columnWidths[i] - cell.length).join('');
        return cell + extraSpaces;
      });
      space = space || ' ';
      return cells.join(space + '|' + space);
    }

    var separators = columnWidths.map(function (columnWidth) {
      return repeat('-', columnWidth).join('');
    });
    var separatorRow = joinRow(separators, '-');
    var header = joinRow(columns);
    var table = [header, separatorRow];

    for (var i = 0; i < rows.length; i++) {
      table.push(joinRow(stringRows[i]));
    }

    global.nativeLoggingHook('\n' + table.join('\n'), LOG_LEVELS.info);
  }

  var GROUP_PAD = "\u2502";
  var GROUP_OPEN = "\u2510";
  var GROUP_CLOSE = "\u2518";
  var groupStack = [];

  function groupFormat(prefix, msg) {
    return groupStack.join('') + prefix + ' ' + (msg || '');
  }

  function consoleGroupPolyfill(label) {
    global.nativeLoggingHook(groupFormat(GROUP_OPEN, label), LOG_LEVELS.info);
    groupStack.push(GROUP_PAD);
  }

  function consoleGroupEndPolyfill() {
    groupStack.pop();
    global.nativeLoggingHook(groupFormat(GROUP_CLOSE), LOG_LEVELS.info);
  }

  if (global.nativeLoggingHook) {
    var originalConsole = global.console;
    global.console = {
      error: getNativeLogFunction(LOG_LEVELS.error),
      info: getNativeLogFunction(LOG_LEVELS.info),
      log: getNativeLogFunction(LOG_LEVELS.info),
      warn: getNativeLogFunction(LOG_LEVELS.warn),
      trace: getNativeLogFunction(LOG_LEVELS.trace),
      debug: getNativeLogFunction(LOG_LEVELS.trace),
      table: consoleTablePolyfill,
      group: consoleGroupPolyfill,
      groupEnd: consoleGroupEndPolyfill
    };

    if (__DEV__ && originalConsole) {
      var descriptor = Object.getOwnPropertyDescriptor(global, 'console');

      if (descriptor) {
        Object.defineProperty(global, 'originalConsole', descriptor);
      }

      Object.keys(console).forEach(function (methodName) {
        var reactNativeMethod = console[methodName];

        if (originalConsole[methodName]) {
          console[methodName] = function () {
            originalConsole[methodName].apply(originalConsole, arguments);
            reactNativeMethod.apply(console, arguments);
          };
        }
      });
    }
  } else if (!global.console) {
    var log = global.print || function consoleLoggingStub() {};

    global.console = {
      error: log,
      info: log,
      log: log,
      warn: log,
      trace: log,
      debug: log,
      table: log
    };
  }
})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  var _inGuard = 0;

  var _globalHandler = function onError(e) {
    throw e;
  };

  var ErrorUtils = {
    setGlobalHandler: function setGlobalHandler(fun) {
      _globalHandler = fun;
    },
    getGlobalHandler: function getGlobalHandler() {
      return _globalHandler;
    },
    reportError: function reportError(error) {
      _globalHandler && _globalHandler(error);
    },
    reportFatalError: function reportFatalError(error) {
      _globalHandler && _globalHandler(error, true);
    },
    applyWithGuard: function applyWithGuard(fun, context, args) {
      try {
        _inGuard++;
        return fun.apply(context, args);
      } catch (e) {
        ErrorUtils.reportError(e);
      } finally {
        _inGuard--;
      }

      return null;
    },
    applyWithGuardIfNeeded: function applyWithGuardIfNeeded(fun, context, args) {
      if (ErrorUtils.inGuard()) {
        return fun.apply(context, args);
      } else {
        ErrorUtils.applyWithGuard(fun, context, args);
      }

      return null;
    },
    inGuard: function inGuard() {
      return _inGuard;
    },
    guard: function guard(fun, name, context) {
      if (typeof fun !== 'function') {
        console.warn('A function must be passed to ErrorUtils.guard, got ', fun);
        return null;
      }

      name = name || fun.name || '<generated guard>';

      function guarded() {
        return ErrorUtils.applyWithGuard(fun, context || this, arguments, null, name);
      }

      return guarded;
    }
  };
  global.ErrorUtils = ErrorUtils;
})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  if (Number.EPSILON === undefined) {
    Object.defineProperty(Number, 'EPSILON', {
      value: Math.pow(2, -52)
    });
  }

  if (Number.MAX_SAFE_INTEGER === undefined) {
    Object.defineProperty(Number, 'MAX_SAFE_INTEGER', {
      value: Math.pow(2, 53) - 1
    });
  }

  if (Number.MIN_SAFE_INTEGER === undefined) {
    Object.defineProperty(Number, 'MIN_SAFE_INTEGER', {
      value: -(Math.pow(2, 53) - 1)
    });
  }

  if (!Number.isNaN) {
    var globalIsNaN = global.isNaN;
    Object.defineProperty(Number, 'isNaN', {
      configurable: true,
      enumerable: false,
      value: function isNaN(value) {
        return typeof value === 'number' && globalIsNaN(value);
      },
      writable: true
    });
  }
})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (search) {
      'use strict';

      if (this == null) {
        throw TypeError();
      }

      var string = String(this);
      var pos = arguments.length > 1 ? Number(arguments[1]) || 0 : 0;
      var start = Math.min(Math.max(pos, 0), string.length);
      return string.indexOf(String(search), pos) === start;
    };
  }

  if (!String.prototype.endsWith) {
    String.prototype.endsWith = function (search) {
      'use strict';

      if (this == null) {
        throw TypeError();
      }

      var string = String(this);
      var stringLength = string.length;
      var searchString = String(search);
      var pos = arguments.length > 1 ? Number(arguments[1]) || 0 : stringLength;
      var end = Math.min(Math.max(pos, 0), stringLength);
      var start = end - searchString.length;

      if (start < 0) {
        return false;
      }

      return string.lastIndexOf(searchString, start) === start;
    };
  }

  if (!String.prototype.repeat) {
    String.prototype.repeat = function (count) {
      'use strict';

      if (this == null) {
        throw TypeError();
      }

      var string = String(this);
      count = Number(count) || 0;

      if (count < 0 || count === Infinity) {
        throw RangeError();
      }

      if (count === 1) {
        return string;
      }

      var result = '';

      while (count) {
        if (count & 1) {
          result += string;
        }

        if (count >>= 1) {
          string += string;
        }
      }

      return result;
    };
  }

  if (!String.prototype.includes) {
    String.prototype.includes = function (search, start) {
      'use strict';

      if (typeof start !== 'number') {
        start = 0;
      }

      if (start + search.length > this.length) {
        return false;
      } else {
        return this.indexOf(search, start) !== -1;
      }
    };
  }

  if (!String.prototype.codePointAt) {
    String.prototype.codePointAt = function (position) {
      if (this == null) {
        throw TypeError();
      }

      var string = String(this);
      var size = string.length;
      var index = position ? Number(position) : 0;

      if (Number.isNaN(index)) {
        index = 0;
      }

      if (index < 0 || index >= size) {
        return undefined;
      }

      var first = string.charCodeAt(index);
      var second;

      if (first >= 0xd800 && first <= 0xdbff && size > index + 1) {
          second = string.charCodeAt(index + 1);

          if (second >= 0xdc00 && second <= 0xdfff) {
            return (first - 0xd800) * 0x400 + second - 0xdc00 + 0x10000;
          }
        }

      return first;
    };
  }

  if (!String.prototype.padEnd) {
    String.prototype.padEnd = function padEnd(targetLength, padString) {
      targetLength = targetLength >> 0;
      padString = String(typeof padString !== 'undefined' ? padString : ' ');

      if (this.length > targetLength) {
        return String(this);
      } else {
        targetLength = targetLength - this.length;

        if (targetLength > padString.length) {
          padString += padString.repeat(targetLength / padString.length);
        }

        return String(this) + padString.slice(0, targetLength);
      }
    };
  }

  if (!String.prototype.padStart) {
    String.prototype.padStart = function padStart(targetLength, padString) {
      targetLength = targetLength >> 0;
      padString = String(typeof padString !== 'undefined' ? padString : ' ');

      if (this.length > targetLength) {
        return String(this);
      } else {
        targetLength = targetLength - this.length;

        if (targetLength > padString.length) {
          padString += padString.repeat(targetLength / padString.length);
        }

        return padString.slice(0, targetLength) + String(this);
      }
    };
  }
})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  function findIndex(predicate, context) {
    if (this == null) {
      throw new TypeError('Array.prototype.findIndex called on null or undefined');
    }

    if (typeof predicate !== 'function') {
      throw new TypeError('predicate must be a function');
    }

    var list = Object(this);
    var length = list.length >>> 0;

    for (var i = 0; i < length; i++) {
      if (predicate.call(context, list[i], i, list)) {
        return i;
      }
    }

    return -1;
  }

  if (!Array.prototype.findIndex) {
    Object.defineProperty(Array.prototype, 'findIndex', {
      enumerable: false,
      writable: true,
      configurable: true,
      value: findIndex
    });
  }

  if (!Array.prototype.find) {
    Object.defineProperty(Array.prototype, 'find', {
      enumerable: false,
      writable: true,
      configurable: true,
      value: function value(predicate, context) {
        if (this == null) {
          throw new TypeError('Array.prototype.find called on null or undefined');
        }

        var index = findIndex.call(this, predicate, context);
        return index === -1 ? undefined : this[index];
      }
    });
  }

  if (!Array.prototype.includes) {
    Object.defineProperty(Array.prototype, 'includes', {
      enumerable: false,
      writable: true,
      configurable: true,
      value: function value(searchElement) {
        var O = Object(this);
        var len = parseInt(O.length) || 0;

        if (len === 0) {
          return false;
        }

        var n = parseInt(arguments[1]) || 0;
        var k;

        if (n >= 0) {
          k = n;
        } else {
          k = len + n;

          if (k < 0) {
            k = 0;
          }
        }

        var currentElement;

        while (k < len) {
          currentElement = O[k];

          if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {
            return true;
          }

          k++;
        }

        return false;
      }
    });
  }
})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  if (!Array.from) {
    Array.from = function (arrayLike) {
      if (arrayLike == null) {
        throw new TypeError('Object is null or undefined');
      }

      var mapFn = arguments[1];
      var thisArg = arguments[2];
      var C = this;
      var items = Object(arrayLike);
      var symbolIterator = typeof Symbol === 'function' ? typeof Symbol === "function" ? Symbol.iterator : "@@iterator" : '@@iterator';
      var mapping = typeof mapFn === 'function';
      var usingIterator = typeof items[symbolIterator] === 'function';
      var key = 0;
      var ret;
      var value;

      if (usingIterator) {
        ret = typeof C === 'function' ? new C() : [];
        var it = items[symbolIterator]();
        var next;

        while (!(next = it.next()).done) {
          value = next.value;

          if (mapping) {
            value = mapFn.call(thisArg, value, key);
          }

          ret[key] = value;
          key += 1;
        }

        ret.length = key;
        return ret;
      }

      var len = items.length;

      if (isNaN(len) || len < 0) {
        len = 0;
      }

      ret = typeof C === 'function' ? new C(len) : new Array(len);

      while (key < len) {
        value = items[key];

        if (mapping) {
          value = mapFn.call(thisArg, value, key);
        }

        ret[key] = value;
        key += 1;
      }

      ret.length = key;
      return ret;
    };
  }
})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  (function () {
    'use strict';

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    if (typeof Object.entries !== 'function') {
      Object.entries = function (object) {
        if (object == null) {
          throw new TypeError('Object.entries called on non-object');
        }

        var entries = [];

        for (var key in object) {
          if (hasOwnProperty.call(object, key)) {
            entries.push([key, object[key]]);
          }
        }

        return entries;
      };
    }

    if (typeof Object.values !== 'function') {
      Object.values = function (object) {
        if (object == null) {
          throw new TypeError('Object.values called on non-object');
        }

        var values = [];

        for (var key in object) {
          if (hasOwnProperty.call(object, key)) {
            values.push(object[key]);
          }
        }

        return values;
      };
    }
  })();
})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  _$$_REQUIRE(_dependencyMap[0], "es6-symbol/implement");

  var _AndroidBundle = _$$_REQUIRE(_dependencyMap[1], "./src/Bundle/AndroidBundle");

  bundle = new _AndroidBundle.AndroidBundle();
  bundle.run();
},0,[1,22],"index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (!_$$_REQUIRE(_dependencyMap[0], "./is-implemented")()) {
    Object.defineProperty(_$$_REQUIRE(_dependencyMap[1], "es5-ext/global"), 'Symbol', {
      value: _$$_REQUIRE(_dependencyMap[2], "./polyfill"),
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
},1,[2,3,4],"node_modules\\es6-symbol\\implement.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var validTypes = {
    object: true,
    symbol: true
  };

  module.exports = function () {
    var symbol;
    if (typeof Symbol !== 'function') return false;
    symbol = Symbol('test symbol');

    try {
      String(symbol);
    } catch (e) {
      return false;
    }

    if (!validTypes[typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator")]) return false;
    if (!validTypes[typeof (typeof Symbol === "function" ? Symbol.toPrimitive : "@@toPrimitive")]) return false;
    if (!validTypes[typeof (typeof Symbol === "function" ? Symbol.toStringTag : "@@toStringTag")]) return false;
    return true;
  };
},2,[],"node_modules\\es6-symbol\\is-implemented.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = function () {
    return this;
  }();
},3,[],"node_modules\\es5-ext\\global.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var d = _$$_REQUIRE(_dependencyMap[0], "d"),
      validateSymbol = _$$_REQUIRE(_dependencyMap[1], "./validate-symbol"),
      create = Object.create,
      defineProperties = Object.defineProperties,
      defineProperty = Object.defineProperty,
      objPrototype = Object.prototype,
      NativeSymbol,
      SymbolPolyfill,
      HiddenSymbol,
      globalSymbols = create(null),
      isNativeSafe;

  if (typeof Symbol === 'function') {
    NativeSymbol = Symbol;

    try {
      String(NativeSymbol());
      isNativeSafe = true;
    } catch (ignore) {}
  }

  var generateName = function () {
    var created = create(null);
    return function (desc) {
      var postfix = 0,
          name,
          ie11BugWorkaround;

      while (created[desc + (postfix || '')]) {
        ++postfix;
      }

      desc += postfix || '';
      created[desc] = true;
      name = '@@' + desc;
      defineProperty(objPrototype, name, d.gs(null, function (value) {
        if (ie11BugWorkaround) return;
        ie11BugWorkaround = true;
        defineProperty(this, name, d(value));
        ie11BugWorkaround = false;
      }));
      return name;
    };
  }();

  HiddenSymbol = function Symbol(description) {
    if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
    return SymbolPolyfill(description);
  };

  module.exports = SymbolPolyfill = function Symbol(description) {
    var symbol;
    if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
    if (isNativeSafe) return NativeSymbol(description);
    symbol = create(HiddenSymbol.prototype);
    description = description === undefined ? '' : String(description);
    return defineProperties(symbol, {
      __description__: d('', description),
      __name__: d('', generateName(description))
    });
  };

  defineProperties(SymbolPolyfill, {
    for: d(function (key) {
      if (globalSymbols[key]) return globalSymbols[key];
      return globalSymbols[key] = SymbolPolyfill(String(key));
    }),
    keyFor: d(function (s) {
      var key;
      validateSymbol(s);

      for (key in globalSymbols) {
        if (globalSymbols[key] === s) return key;
      }
    }),
    hasInstance: d('', NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill('hasInstance')),
    isConcatSpreadable: d('', NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill('isConcatSpreadable')),
    iterator: d('', NativeSymbol && NativeSymbol.iterator || SymbolPolyfill('iterator')),
    match: d('', NativeSymbol && NativeSymbol.match || SymbolPolyfill('match')),
    replace: d('', NativeSymbol && NativeSymbol.replace || SymbolPolyfill('replace')),
    search: d('', NativeSymbol && NativeSymbol.search || SymbolPolyfill('search')),
    species: d('', NativeSymbol && NativeSymbol.species || SymbolPolyfill('species')),
    split: d('', NativeSymbol && NativeSymbol.split || SymbolPolyfill('split')),
    toPrimitive: d('', NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill('toPrimitive')),
    toStringTag: d('', NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill('toStringTag')),
    unscopables: d('', NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill('unscopables'))
  });
  defineProperties(HiddenSymbol.prototype, {
    constructor: d(SymbolPolyfill),
    toString: d('', function () {
      return this.__name__;
    })
  });
  defineProperties(SymbolPolyfill.prototype, {
    toString: d(function () {
      return 'Symbol (' + validateSymbol(this).__description__ + ')';
    }),
    valueOf: d(function () {
      return validateSymbol(this);
    })
  });
  defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {
    var symbol = validateSymbol(this);
    if (typeof symbol === 'symbol') return symbol;
    return symbol.toString();
  }));
  defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));
  defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag, d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));
  defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive, d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));
},4,[5,20],"node_modules\\es6-symbol\\polyfill.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var assign = _$$_REQUIRE(_dependencyMap[0], "es5-ext/object/assign"),
      normalizeOpts = _$$_REQUIRE(_dependencyMap[1], "es5-ext/object/normalize-options"),
      isCallable = _$$_REQUIRE(_dependencyMap[2], "es5-ext/object/is-callable"),
      contains = _$$_REQUIRE(_dependencyMap[3], "es5-ext/string/#/contains"),
      d;

  d = module.exports = function (dscr, value) {
    var c, e, w, options, desc;

    if (arguments.length < 2 || typeof dscr !== 'string') {
      options = value;
      value = dscr;
      dscr = null;
    } else {
      options = arguments[2];
    }

    if (dscr == null) {
      c = w = true;
      e = false;
    } else {
      c = contains.call(dscr, 'c');
      e = contains.call(dscr, 'e');
      w = contains.call(dscr, 'w');
    }

    desc = {
      value: value,
      configurable: c,
      enumerable: e,
      writable: w
    };
    return !options ? desc : assign(normalizeOpts(options), desc);
  };

  d.gs = function (dscr, get, set) {
    var c, e, options, desc;

    if (typeof dscr !== 'string') {
      options = set;
      set = get;
      get = dscr;
      dscr = null;
    } else {
      options = arguments[3];
    }

    if (get == null) {
      get = undefined;
    } else if (!isCallable(get)) {
      options = get;
      get = set = undefined;
    } else if (set == null) {
      set = undefined;
    } else if (!isCallable(set)) {
      options = set;
      set = undefined;
    }

    if (dscr == null) {
      c = true;
      e = false;
    } else {
      c = contains.call(dscr, 'c');
      e = contains.call(dscr, 'e');
    }

    desc = {
      get: get,
      set: set,
      configurable: c,
      enumerable: e
    };
    return !options ? desc : assign(normalizeOpts(options), desc);
  };
},5,[6,15,16,17],"node_modules\\d\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  module.exports = _$$_REQUIRE(_dependencyMap[0], "./is-implemented")() ? Object.assign : _$$_REQUIRE(_dependencyMap[1], "./shim");
},6,[7,8],"node_modules\\es5-ext\\object\\assign\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  module.exports = function () {
    var assign = Object.assign,
        obj;
    if (typeof assign !== "function") return false;
    obj = {
      foo: "raz"
    };
    assign(obj, {
      bar: "dwa"
    }, {
      trzy: "trzy"
    });
    return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
  };
},7,[],"node_modules\\es5-ext\\object\\assign\\is-implemented.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var keys = _$$_REQUIRE(_dependencyMap[0], "../keys"),
      value = _$$_REQUIRE(_dependencyMap[1], "../valid-value"),
      max = Math.max;

  module.exports = function (dest, src) {
    var error,
        i,
        length = max(arguments.length, 2),
        assign;
    dest = Object(value(dest));

    assign = function assign(key) {
      try {
        dest[key] = src[key];
      } catch (e) {
        if (!error) error = e;
      }
    };

    for (i = 1; i < length; ++i) {
      src = arguments[i];
      keys(src).forEach(assign);
    }

    if (error !== undefined) throw error;
    return dest;
  };
},8,[9,14],"node_modules\\es5-ext\\object\\assign\\shim.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  module.exports = _$$_REQUIRE(_dependencyMap[0], "./is-implemented")() ? Object.keys : _$$_REQUIRE(_dependencyMap[1], "./shim");
},9,[10,11],"node_modules\\es5-ext\\object\\keys\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  module.exports = function () {
    try {
      Object.keys("primitive");
      return true;
    } catch (e) {
      return false;
    }
  };
},10,[],"node_modules\\es5-ext\\object\\keys\\is-implemented.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var isValue = _$$_REQUIRE(_dependencyMap[0], "../is-value");

  var keys = Object.keys;

  module.exports = function (object) {
    return keys(isValue(object) ? Object(object) : object);
  };
},11,[12],"node_modules\\es5-ext\\object\\keys\\shim.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _undefined = _$$_REQUIRE(_dependencyMap[0], "../function/noop")();

  module.exports = function (val) {
    return val !== _undefined && val !== null;
  };
},12,[13],"node_modules\\es5-ext\\object\\is-value.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  module.exports = function () {};
},13,[],"node_modules\\es5-ext\\function\\noop.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var isValue = _$$_REQUIRE(_dependencyMap[0], "./is-value");

  module.exports = function (value) {
    if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
    return value;
  };
},14,[12],"node_modules\\es5-ext\\object\\valid-value.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var isValue = _$$_REQUIRE(_dependencyMap[0], "./is-value");

  var forEach = Array.prototype.forEach,
      create = Object.create;

  var process = function process(src, obj) {
    var key;

    for (key in src) {
      obj[key] = src[key];
    }
  };

  module.exports = function (opts1) {
    var result = create(null);
    forEach.call(arguments, function (options) {
      if (!isValue(options)) return;
      process(Object(options), result);
    });
    return result;
  };
},15,[12],"node_modules\\es5-ext\\object\\normalize-options.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  module.exports = function (obj) {
    return typeof obj === "function";
  };
},16,[],"node_modules\\es5-ext\\object\\is-callable.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  module.exports = _$$_REQUIRE(_dependencyMap[0], "./is-implemented")() ? String.prototype.contains : _$$_REQUIRE(_dependencyMap[1], "./shim");
},17,[18,19],"node_modules\\es5-ext\\string\\#\\contains\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var str = "razdwatrzy";

  module.exports = function () {
    if (typeof str.contains !== "function") return false;
    return str.contains("dwa") === true && str.contains("foo") === false;
  };
},18,[],"node_modules\\es5-ext\\string\\#\\contains\\is-implemented.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var indexOf = String.prototype.indexOf;

  module.exports = function (searchString) {
    return indexOf.call(this, searchString, arguments[1]) > -1;
  };
},19,[],"node_modules\\es5-ext\\string\\#\\contains\\shim.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var isSymbol = _$$_REQUIRE(_dependencyMap[0], "./is-symbol");

  module.exports = function (value) {
    if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
    return value;
  };
},20,[21],"node_modules\\es6-symbol\\validate-symbol.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = function (x) {
    if (!x) return false;
    if (typeof x === 'symbol') return true;
    if (!x.constructor) return false;
    if (x.constructor.name !== 'Symbol') return false;
    return x[x.constructor.toStringTag] === 'Symbol';
  };
},21,[],"node_modules\\es6-symbol\\is-symbol.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AndroidBundle = void 0;

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf3 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits"));

  var _assertThisInitialized2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized"));

  var _defineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty"));

  var _protoculture = _$$_REQUIRE(_dependencyMap[8], "protoculture");

  var _ReactNativeServiceProvider = _$$_REQUIRE(_dependencyMap[9], "../Layer/ReactNative/ReactNativeServiceProvider");

  var AndroidBundle = function (_Bundle) {
    (0, _inherits2.default)(AndroidBundle, _Bundle);

    function AndroidBundle() {
      var _getPrototypeOf2;

      var _this;

      (0, _classCallCheck2.default)(this, AndroidBundle);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(AndroidBundle)).call.apply(_getPrototypeOf2, [this].concat(args)));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "name", "react-native-tinkering-android");
      return _this;
    }

    (0, _createClass2.default)(AndroidBundle, [{
      key: "serviceProviders",
      get: function get() {
        return [_ReactNativeServiceProvider.ReactNativeServiceProvider];
      }
    }]);
    return AndroidBundle;
  }(_protoculture.Bundle);

  exports.AndroidBundle = AndroidBundle;
},22,[23,24,25,26,29,30,28,32,33,104],"src\\Bundle\\AndroidBundle.tsx");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  module.exports = _interopRequireDefault;
},23,[],"node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  module.exports = _classCallCheck;
},24,[],"node_modules\\@babel\\runtime\\helpers\\classCallCheck.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  module.exports = _createClass;
},25,[],"node_modules\\@babel\\runtime\\helpers\\createClass.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _typeof = _$$_REQUIRE(_dependencyMap[0], "../helpers/typeof");

  var assertThisInitialized = _$$_REQUIRE(_dependencyMap[1], "./assertThisInitialized");

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }

    return assertThisInitialized(self);
  }

  module.exports = _possibleConstructorReturn;
},26,[27,28],"node_modules\\@babel\\runtime\\helpers\\possibleConstructorReturn.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _typeof2(obj) {
    if (typeof Symbol === "function" && typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") === "symbol") {
      _typeof2 = function _typeof2(obj) {
        return typeof obj;
      };
    } else {
      _typeof2 = function _typeof2(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
      };
    }

    return _typeof2(obj);
  }

  function _typeof(obj) {
    if (typeof Symbol === "function" && _typeof2(typeof Symbol === "function" ? Symbol.iterator : "@@iterator") === "symbol") {
      module.exports = _typeof = function _typeof(obj) {
        return _typeof2(obj);
      };
    } else {
      module.exports = _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : _typeof2(obj);
      };
    }

    return _typeof(obj);
  }

  module.exports = _typeof;
},27,[],"node_modules\\@babel\\runtime\\helpers\\typeof.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  module.exports = _assertThisInitialized;
},28,[],"node_modules\\@babel\\runtime\\helpers\\assertThisInitialized.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _getPrototypeOf(o) {
    module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  module.exports = _getPrototypeOf;
},29,[],"node_modules\\@babel\\runtime\\helpers\\getPrototypeOf.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var setPrototypeOf = _$$_REQUIRE(_dependencyMap[0], "./setPrototypeOf");

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) setPrototypeOf(subClass, superClass);
  }

  module.exports = _inherits;
},30,[31],"node_modules\\@babel\\runtime\\helpers\\inherits.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _setPrototypeOf(o, p) {
    module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  module.exports = _setPrototypeOf;
},31,[],"node_modules\\@babel\\runtime\\helpers\\setPrototypeOf.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  module.exports = _defineProperty;
},32,[],"node_modules\\@babel\\runtime\\helpers\\defineProperty.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var Util_1 = _$$_REQUIRE(_dependencyMap[0], "./Util");

  exports.createDeferred = Util_1.createDeferred;

  var Bundle_1 = _$$_REQUIRE(_dependencyMap[1], "./Bundle");

  exports.Bundle = Bundle_1.Bundle;

  var App_1 = _$$_REQUIRE(_dependencyMap[2], "./App");

  exports.BaseApp = App_1.BaseApp;

  var ServiceProvider_1 = _$$_REQUIRE(_dependencyMap[3], "./ServiceProvider");

  exports.ServiceProvider = ServiceProvider_1.ServiceProvider;

  var LogServiceProvider_1 = _$$_REQUIRE(_dependencyMap[4], "./Log/LogServiceProvider");

  exports.LogServiceProvider = LogServiceProvider_1.LogServiceProvider;

  var LogService_1 = _$$_REQUIRE(_dependencyMap[5], "./Log/LogService");

  exports.LogService = LogService_1.LogService;

  var LazyLoad_1 = _$$_REQUIRE(_dependencyMap[6], "./Web/LazyLoad");

  exports.lazyLoad = LazyLoad_1.lazyLoad;

  var DomReady_1 = _$$_REQUIRE(_dependencyMap[7], "./Web/DomReady");

  exports.domReady = DomReady_1.domReady;
  exports.protocultureSymbols = {
    App: Symbol("App"),
    Bundle: Symbol("Bundle"),
    MessageBus: Symbol("MessageBus"),
    LogService: Symbol("Log"),
    Tracer: Symbol("Tracer")
  };
},33,[34,35,83,82,84,101,102,103],"node_modules\\protoculture\\lib\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  function createDeferred() {
    var deferred = {
      promise: null,
      resolve: null,
      reject: null
    };
    deferred.promise = new Promise(function (resolve, reject) {
      deferred.resolve = resolve;
      deferred.reject = reject;
    });
    return deferred;
  }

  exports.createDeferred = createDeferred;
},34,[],"node_modules\\protoculture\\lib\\Util.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : new P(function (resolve) {
          resolve(result.value);
        }).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator = this && this.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  _$$_REQUIRE(_dependencyMap[0], "reflect-metadata");

  var lodash_1 = __importDefault(_$$_REQUIRE(_dependencyMap[1], "lodash"));

  var inversify_1 = _$$_REQUIRE(_dependencyMap[2], "inversify");

  var index_1 = _$$_REQUIRE(_dependencyMap[3], "./index");

  var ProtocultureServiceProvider_1 = _$$_REQUIRE(_dependencyMap[4], "./ProtocultureServiceProvider");

  var Bundle = function () {
    function Bundle() {
      this.loadServiceProviders();
    }

    Object.defineProperty(Bundle.prototype, "containerConfiguration", {
      get: function get() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Bundle.prototype, "heartbeatInterval", {
      get: function get() {
        return 1;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Bundle.prototype, "serviceProviders", {
      get: function get() {
        return [];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Bundle.prototype, "container", {
      get: function get() {
        return this._container;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Bundle.prototype, "workingApps", {
      get: function get() {
        return lodash_1.default.filter(this.apps, function (app) {
          return app.working;
        });
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Bundle.prototype, "longRunning", {
      get: function get() {
        return !!this.workingApps.length;
      },
      enumerable: true,
      configurable: true
    });

    Bundle.prototype.boot = function () {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              this.booted = false;
              this.bootContainer();
              return [4, this.bootServiceProviders()];

            case 1:
              _a.sent();

              return [4, this.bootLogging()];

            case 2:
              _a.sent();

              this.booted = true;
              return [2];
          }
        });
      });
    };

    Bundle.prototype.run = function () {
      return __awaiter(this, void 0, void 0, function () {
        var error_1, error_2;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              if (!!this.booted) return [3, 2];
              return [4, this.boot()];

            case 1:
              _a.sent();

              _a.label = 2;

            case 2:
              if (!lodash_1.default.isEmpty(this.apps)) {
                this.logger.log("Bundle already running.", null);
                return [2];
              }

              this.logger.log("Running bundle.", null);
              _a.label = 3;

            case 3:
              _a.trys.push([3, 5,, 6]);

              return [4, this.buildApps()];

            case 4:
              _a.sent();

              return [3, 6];

            case 5:
              error_1 = _a.sent();
              this.logger.log("Unable to build apps: " + error_1, null);
              return [3, 6];

            case 6:
              _a.trys.push([6, 8,, 9]);

              return [4, this.runApps()];

            case 7:
              _a.sent();

              return [3, 9];

            case 8:
              error_2 = _a.sent();
              this.logger.log("Error running apps: " + error_2, null);
              return [3, 9];

            case 9:
              return [2];
          }
        });
      });
    };

    Bundle.prototype.bootChild = function () {
      return __awaiter(this, void 0, void 0, function () {
        var childContainer, bootPromises;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              childContainer = this.container.createChild();
              bootPromises = lodash_1.default.map(this.loadedServiceProviders, function (serviceProvider) {
                return serviceProvider.bootChild(childContainer);
              });
              return [4, Promise.all(bootPromises)];

            case 1:
              _a.sent();

              return [2, childContainer];
          }
        });
      });
    };

    Bundle.prototype.stop = function () {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          try {
            this.logger.log("Teardown APIs have not been implemented yet.", null);
          } catch (error) {
            this.logger.log(error.stack, null);
          }

          return [2];
        });
      });
    };

    Bundle.prototype.loadServiceProviders = function () {
      var _this = this;

      var internalServiceProviders = [ProtocultureServiceProvider_1.ProtocultureServiceProvider, index_1.LogServiceProvider];
      var serviceProviders = lodash_1.default.concat(internalServiceProviders, this.serviceProviders);
      this.loadedServiceProviders = lodash_1.default.map(serviceProviders, function (serviceProvider) {
        return new serviceProvider(_this);
      });
    };

    Bundle.prototype.bootContainer = function () {
      if (this.containerConfiguration) {
        this._container = new inversify_1.Container(this.containerConfiguration);
      } else {
        this._container = new inversify_1.Container();
      }
    };

    Bundle.prototype.bootServiceProviders = function () {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4, lodash_1.default.reduce(this.loadedServiceProviders, function (previous, current) {
                return previous.then(function () {
                  return current.boot();
                });
              }, new Promise(function (resolve) {
                return resolve();
              }))];

            case 1:
              _a.sent();

              return [2];
          }
        });
      });
    };

    Bundle.prototype.bootLogging = function () {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          this.logger = this.container.get(index_1.protocultureSymbols.LogService) || this.logger;
          return [2];
        });
      });
    };

    Bundle.prototype.buildApps = function () {
      this.logger.log("Building apps", null);
      this.apps = this.container.getAll(index_1.protocultureSymbols.App);
    };

    Bundle.prototype.startHeartbeat = function () {
      var _this = this;

      var interval = this.heartbeatInterval * 1000;
      var timer;
      var complete;
      var deferred = new Promise(function (resolve) {
        return complete = resolve;
      });
      timer = setInterval(function () {
        return _this.tick(timer, complete);
      }, interval);
      return deferred;
    };

    Bundle.prototype.tick = function (timer, complete) {
      this.logger.log("Beat...", null);

      if (!this.longRunning) {
        this.logger.log("...Heart beat.", null);
        clearInterval(timer);
        complete();
      }
    };

    Bundle.prototype.runApps = function () {
      return __awaiter(this, void 0, void 0, function () {
        var appPromises;

        var _this = this;

        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              this.logger.log("Running apps", null);
              appPromises = lodash_1.default.map(this.apps, function (app) {
                return _this.runApp(app);
              });
              this.logger.log("All apps started", null);
              return [4, Promise.all(appPromises)];

            case 1:
              _a.sent();

              return [4, this.longRunning];

            case 2:
              _a.sent() ? this.startHeartbeat() : null;
              return [4, this.stop()];

            case 3:
              _a.sent();

              return [2];
          }
        });
      });
    };

    Bundle.prototype.runApp = function (app) {
      return __awaiter(this, void 0, void 0, function () {
        var error_3;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              this.logger.log("Starting app", app);
              app.bundle = this;
              _a.label = 1;

            case 1:
              _a.trys.push([1, 3,, 4]);

              return [4, app.run()];

            case 2:
              _a.sent();

              return [3, 4];

            case 3:
              error_3 = _a.sent();
              this.logger.log(error_3.stack, app);
              return [3, 4];

            case 4:
              return [2];
          }
        });
      });
    };

    return Bundle;
  }();

  exports.Bundle = Bundle;
},35,[36,37,38,33,80],"node_modules\\protoculture\\lib\\Bundle.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Reflect;

  (function (Reflect) {
    (function (factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
      var exporter = makeExporter(Reflect);

      if (typeof root.Reflect === "undefined") {
        root.Reflect = Reflect;
      } else {
        exporter = makeExporter(root.Reflect, exporter);
      }

      factory(exporter);

      function makeExporter(target, previous) {
        return function (key, value) {
          if (typeof target[key] !== "function") {
            Object.defineProperty(target, key, {
              configurable: true,
              writable: true,
              value: value
            });
          }

          if (previous) previous(key, value);
        };
      }
    })(function (exporter) {
      var hasOwn = Object.prototype.hasOwnProperty;
      var supportsSymbol = typeof Symbol === "function";
      var toPrimitiveSymbol = supportsSymbol && typeof (typeof Symbol === "function" ? Symbol.toPrimitive : "@@toPrimitive") !== "undefined" ? typeof Symbol === "function" ? Symbol.toPrimitive : "@@toPrimitive" : "@@toPrimitive";
      var iteratorSymbol = supportsSymbol && typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") !== "undefined" ? typeof Symbol === "function" ? Symbol.iterator : "@@iterator" : "@@iterator";
      var supportsCreate = typeof Object.create === "function";
      var supportsProto = {
        __proto__: []
      } instanceof Array;
      var downLevel = !supportsCreate && !supportsProto;
      var HashMap = {
        create: supportsCreate ? function () {
          return MakeDictionary(Object.create(null));
        } : supportsProto ? function () {
          return MakeDictionary({
            __proto__: null
          });
        } : function () {
          return MakeDictionary({});
        },
        has: downLevel ? function (map, key) {
          return hasOwn.call(map, key);
        } : function (map, key) {
          return key in map;
        },
        get: downLevel ? function (map, key) {
          return hasOwn.call(map, key) ? map[key] : undefined;
        } : function (map, key) {
          return map[key];
        }
      };
      var functionPrototype = Object.getPrototypeOf(Function);
      var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";

      var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();

      var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();

      var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();

      var Metadata = new _WeakMap();

      function decorate(decorators, target, propertyKey, attributes) {
        if (!IsUndefined(propertyKey)) {
          if (!IsArray(decorators)) throw new TypeError();
          if (!IsObject(target)) throw new TypeError();
          if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes)) throw new TypeError();
          if (IsNull(attributes)) attributes = undefined;
          propertyKey = ToPropertyKey(propertyKey);
          return DecorateProperty(decorators, target, propertyKey, attributes);
        } else {
          if (!IsArray(decorators)) throw new TypeError();
          if (!IsConstructor(target)) throw new TypeError();
          return DecorateConstructor(decorators, target);
        }
      }

      exporter("decorate", decorate);

      function metadata(metadataKey, metadataValue) {
        function decorator(target, propertyKey) {
          if (!IsObject(target)) throw new TypeError();
          if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey)) throw new TypeError();
          OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }

        return decorator;
      }

      exporter("metadata", metadata);

      function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }

      exporter("defineMetadata", defineMetadata);

      function hasMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasMetadata(metadataKey, target, propertyKey);
      }

      exporter("hasMetadata", hasMetadata);

      function hasOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
      }

      exporter("hasOwnMetadata", hasOwnMetadata);

      function getMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetMetadata(metadataKey, target, propertyKey);
      }

      exporter("getMetadata", getMetadata);

      function getOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
      }

      exporter("getOwnMetadata", getOwnMetadata);

      function getMetadataKeys(target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryMetadataKeys(target, propertyKey);
      }

      exporter("getMetadataKeys", getMetadataKeys);

      function getOwnMetadataKeys(target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryOwnMetadataKeys(target, propertyKey);
      }

      exporter("getOwnMetadataKeys", getOwnMetadataKeys);

      function deleteMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        var metadataMap = GetOrCreateMetadataMap(target, propertyKey, false);
        if (IsUndefined(metadataMap)) return false;
        if (!metadataMap.delete(metadataKey)) return false;
        if (metadataMap.size > 0) return true;
        var targetMetadata = Metadata.get(target);
        targetMetadata.delete(propertyKey);
        if (targetMetadata.size > 0) return true;
        Metadata.delete(target);
        return true;
      }

      exporter("deleteMetadata", deleteMetadata);

      function DecorateConstructor(decorators, target) {
        for (var i = decorators.length - 1; i >= 0; --i) {
          var decorator = decorators[i];
          var decorated = decorator(target);

          if (!IsUndefined(decorated) && !IsNull(decorated)) {
            if (!IsConstructor(decorated)) throw new TypeError();
            target = decorated;
          }
        }

        return target;
      }

      function DecorateProperty(decorators, target, propertyKey, descriptor) {
        for (var i = decorators.length - 1; i >= 0; --i) {
          var decorator = decorators[i];
          var decorated = decorator(target, propertyKey, descriptor);

          if (!IsUndefined(decorated) && !IsNull(decorated)) {
            if (!IsObject(decorated)) throw new TypeError();
            descriptor = decorated;
          }
        }

        return descriptor;
      }

      function GetOrCreateMetadataMap(O, P, Create) {
        var targetMetadata = Metadata.get(O);

        if (IsUndefined(targetMetadata)) {
          if (!Create) return undefined;
          targetMetadata = new _Map();
          Metadata.set(O, targetMetadata);
        }

        var metadataMap = targetMetadata.get(P);

        if (IsUndefined(metadataMap)) {
          if (!Create) return undefined;
          metadataMap = new _Map();
          targetMetadata.set(P, metadataMap);
        }

        return metadataMap;
      }

      function OrdinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn) return true;
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent)) return OrdinaryHasMetadata(MetadataKey, parent, P);
        return false;
      }

      function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, false);
        if (IsUndefined(metadataMap)) return false;
        return ToBoolean(metadataMap.has(MetadataKey));
      }

      function OrdinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn) return OrdinaryGetOwnMetadata(MetadataKey, O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent)) return OrdinaryGetMetadata(MetadataKey, parent, P);
        return undefined;
      }

      function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, false);
        if (IsUndefined(metadataMap)) return undefined;
        return metadataMap.get(MetadataKey);
      }

      function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, true);
        metadataMap.set(MetadataKey, MetadataValue);
      }

      function OrdinaryMetadataKeys(O, P) {
        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (parent === null) return ownKeys;
        var parentKeys = OrdinaryMetadataKeys(parent, P);
        if (parentKeys.length <= 0) return ownKeys;
        if (ownKeys.length <= 0) return parentKeys;
        var set = new _Set();
        var keys = [];

        for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
          var key = ownKeys_1[_i];
          var hasKey = set.has(key);

          if (!hasKey) {
            set.add(key);
            keys.push(key);
          }
        }

        for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
          var key = parentKeys_1[_a];
          var hasKey = set.has(key);

          if (!hasKey) {
            set.add(key);
            keys.push(key);
          }
        }

        return keys;
      }

      function OrdinaryOwnMetadataKeys(O, P) {
        var keys = [];
        var metadataMap = GetOrCreateMetadataMap(O, P, false);
        if (IsUndefined(metadataMap)) return keys;
        var keysObj = metadataMap.keys();
        var iterator = GetIterator(keysObj);
        var k = 0;

        while (true) {
          var next = IteratorStep(iterator);

          if (!next) {
            keys.length = k;
            return keys;
          }

          var nextValue = IteratorValue(next);

          try {
            keys[k] = nextValue;
          } catch (e) {
            try {
              IteratorClose(iterator);
            } finally {
              throw e;
            }
          }

          k++;
        }
      }

      function Type(x) {
        if (x === null) return 1;

        switch (typeof x) {
          case "undefined":
            return 0;

          case "boolean":
            return 2;

          case "string":
            return 3;

          case "symbol":
            return 4;

          case "number":
            return 5;

          case "object":
            return x === null ? 1 : 6;

          default:
            return 6;
        }
      }

      function IsUndefined(x) {
        return x === undefined;
      }

      function IsNull(x) {
        return x === null;
      }

      function IsSymbol(x) {
        return typeof x === "symbol";
      }

      function IsObject(x) {
        return typeof x === "object" ? x !== null : typeof x === "function";
      }

      function ToPrimitive(input, PreferredType) {
        switch (Type(input)) {
          case 0:
            return input;

          case 1:
            return input;

          case 2:
            return input;

          case 3:
            return input;

          case 4:
            return input;

          case 5:
            return input;
        }

        var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
        var exoticToPrim = GetMethod(input, toPrimitiveSymbol);

        if (exoticToPrim !== undefined) {
          var result = exoticToPrim.call(input, hint);
          if (IsObject(result)) throw new TypeError();
          return result;
        }

        return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
      }

      function OrdinaryToPrimitive(O, hint) {
        if (hint === "string") {
          var toString_1 = O.toString;

          if (IsCallable(toString_1)) {
            var result = toString_1.call(O);
            if (!IsObject(result)) return result;
          }

          var valueOf = O.valueOf;

          if (IsCallable(valueOf)) {
            var result = valueOf.call(O);
            if (!IsObject(result)) return result;
          }
        } else {
          var valueOf = O.valueOf;

          if (IsCallable(valueOf)) {
            var result = valueOf.call(O);
            if (!IsObject(result)) return result;
          }

          var toString_2 = O.toString;

          if (IsCallable(toString_2)) {
            var result = toString_2.call(O);
            if (!IsObject(result)) return result;
          }
        }

        throw new TypeError();
      }

      function ToBoolean(argument) {
        return !!argument;
      }

      function ToString(argument) {
        return "" + argument;
      }

      function ToPropertyKey(argument) {
        var key = ToPrimitive(argument, 3);
        if (IsSymbol(key)) return key;
        return ToString(key);
      }

      function IsArray(argument) {
        return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
      }

      function IsCallable(argument) {
        return typeof argument === "function";
      }

      function IsConstructor(argument) {
        return typeof argument === "function";
      }

      function IsPropertyKey(argument) {
        switch (Type(argument)) {
          case 3:
            return true;

          case 4:
            return true;

          default:
            return false;
        }
      }

      function GetMethod(V, P) {
        var func = V[P];
        if (func === undefined || func === null) return undefined;
        if (!IsCallable(func)) throw new TypeError();
        return func;
      }

      function GetIterator(obj) {
        var method = GetMethod(obj, iteratorSymbol);
        if (!IsCallable(method)) throw new TypeError();
        var iterator = method.call(obj);
        if (!IsObject(iterator)) throw new TypeError();
        return iterator;
      }

      function IteratorValue(iterResult) {
        return iterResult.value;
      }

      function IteratorStep(iterator) {
        var result = iterator.next();
        return result.done ? false : result;
      }

      function IteratorClose(iterator) {
        var f = iterator["return"];
        if (f) f.call(iterator);
      }

      function OrdinaryGetPrototypeOf(O) {
        var proto = Object.getPrototypeOf(O);
        if (typeof O !== "function" || O === functionPrototype) return proto;
        if (proto !== functionPrototype) return proto;
        var prototype = O.prototype;
        var prototypeProto = prototype && Object.getPrototypeOf(prototype);
        if (prototypeProto == null || prototypeProto === Object.prototype) return proto;
        var constructor = prototypeProto.constructor;
        if (typeof constructor !== "function") return proto;
        if (constructor === O) return proto;
        return constructor;
      }

      function CreateMapPolyfill() {
        var cacheSentinel = {};
        var arraySentinel = [];

        var MapIterator = function () {
          function MapIterator(keys, values, selector) {
            this._index = 0;
            this._keys = keys;
            this._values = values;
            this._selector = selector;
          }

          MapIterator.prototype["@@iterator"] = function () {
            return this;
          };

          MapIterator.prototype[iteratorSymbol] = function () {
            return this;
          };

          MapIterator.prototype.next = function () {
            var index = this._index;

            if (index >= 0 && index < this._keys.length) {
              var result = this._selector(this._keys[index], this._values[index]);

              if (index + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }

              return {
                value: result,
                done: false
              };
            }

            return {
              value: undefined,
              done: true
            };
          };

          MapIterator.prototype.throw = function (error) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }

            throw error;
          };

          MapIterator.prototype.return = function (value) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }

            return {
              value: value,
              done: true
            };
          };

          return MapIterator;
        }();

        return function () {
          function Map() {
            this._keys = [];
            this._values = [];
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          }

          Object.defineProperty(Map.prototype, "size", {
            get: function get() {
              return this._keys.length;
            },
            enumerable: true,
            configurable: true
          });

          Map.prototype.has = function (key) {
            return this._find(key, false) >= 0;
          };

          Map.prototype.get = function (key) {
            var index = this._find(key, false);

            return index >= 0 ? this._values[index] : undefined;
          };

          Map.prototype.set = function (key, value) {
            var index = this._find(key, true);

            this._values[index] = value;
            return this;
          };

          Map.prototype.delete = function (key) {
            var index = this._find(key, false);

            if (index >= 0) {
              var size = this._keys.length;

              for (var i = index + 1; i < size; i++) {
                this._keys[i - 1] = this._keys[i];
                this._values[i - 1] = this._values[i];
              }

              this._keys.length--;
              this._values.length--;

              if (key === this._cacheKey) {
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }

              return true;
            }

            return false;
          };

          Map.prototype.clear = function () {
            this._keys.length = 0;
            this._values.length = 0;
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          };

          Map.prototype.keys = function () {
            return new MapIterator(this._keys, this._values, getKey);
          };

          Map.prototype.values = function () {
            return new MapIterator(this._keys, this._values, getValue);
          };

          Map.prototype.entries = function () {
            return new MapIterator(this._keys, this._values, getEntry);
          };

          Map.prototype["@@iterator"] = function () {
            return this.entries();
          };

          Map.prototype[iteratorSymbol] = function () {
            return this.entries();
          };

          Map.prototype._find = function (key, insert) {
            if (this._cacheKey !== key) {
              this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
            }

            if (this._cacheIndex < 0 && insert) {
              this._cacheIndex = this._keys.length;

              this._keys.push(key);

              this._values.push(undefined);
            }

            return this._cacheIndex;
          };

          return Map;
        }();

        function getKey(key, _) {
          return key;
        }

        function getValue(_, value) {
          return value;
        }

        function getEntry(key, value) {
          return [key, value];
        }
      }

      function CreateSetPolyfill() {
        return function () {
          function Set() {
            this._map = new _Map();
          }

          Object.defineProperty(Set.prototype, "size", {
            get: function get() {
              return this._map.size;
            },
            enumerable: true,
            configurable: true
          });

          Set.prototype.has = function (value) {
            return this._map.has(value);
          };

          Set.prototype.add = function (value) {
            return this._map.set(value, value), this;
          };

          Set.prototype.delete = function (value) {
            return this._map.delete(value);
          };

          Set.prototype.clear = function () {
            this._map.clear();
          };

          Set.prototype.keys = function () {
            return this._map.keys();
          };

          Set.prototype.values = function () {
            return this._map.values();
          };

          Set.prototype.entries = function () {
            return this._map.entries();
          };

          Set.prototype["@@iterator"] = function () {
            return this.keys();
          };

          Set.prototype[iteratorSymbol] = function () {
            return this.keys();
          };

          return Set;
        }();
      }

      function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16;
        var keys = HashMap.create();
        var rootKey = CreateUniqueKey();
        return function () {
          function WeakMap() {
            this._key = CreateUniqueKey();
          }

          WeakMap.prototype.has = function (target) {
            var table = GetOrCreateWeakMapTable(target, false);
            return table !== undefined ? HashMap.has(table, this._key) : false;
          };

          WeakMap.prototype.get = function (target) {
            var table = GetOrCreateWeakMapTable(target, false);
            return table !== undefined ? HashMap.get(table, this._key) : undefined;
          };

          WeakMap.prototype.set = function (target, value) {
            var table = GetOrCreateWeakMapTable(target, true);
            table[this._key] = value;
            return this;
          };

          WeakMap.prototype.delete = function (target) {
            var table = GetOrCreateWeakMapTable(target, false);
            return table !== undefined ? delete table[this._key] : false;
          };

          WeakMap.prototype.clear = function () {
            this._key = CreateUniqueKey();
          };

          return WeakMap;
        }();

        function CreateUniqueKey() {
          var key;

          do {
            key = "@@WeakMap@@" + CreateUUID();
          } while (HashMap.has(keys, key));

          keys[key] = true;
          return key;
        }

        function GetOrCreateWeakMapTable(target, create) {
          if (!hasOwn.call(target, rootKey)) {
            if (!create) return undefined;
            Object.defineProperty(target, rootKey, {
              value: HashMap.create()
            });
          }

          return target[rootKey];
        }

        function FillRandomBytes(buffer, size) {
          for (var i = 0; i < size; ++i) {
            buffer[i] = Math.random() * 0xff | 0;
          }

          return buffer;
        }

        function GenRandomBytes(size) {
          if (typeof Uint8Array === "function") {
            if (typeof crypto !== "undefined") return crypto.getRandomValues(new Uint8Array(size));
            if (typeof msCrypto !== "undefined") return msCrypto.getRandomValues(new Uint8Array(size));
            return FillRandomBytes(new Uint8Array(size), size);
          }

          return FillRandomBytes(new Array(size), size);
        }

        function CreateUUID() {
          var data = GenRandomBytes(UUID_SIZE);
          data[6] = data[6] & 0x4f | 0x40;
          data[8] = data[8] & 0xbf | 0x80;
          var result = "";

          for (var offset = 0; offset < UUID_SIZE; ++offset) {
            var byte = data[offset];
            if (offset === 4 || offset === 6 || offset === 8) result += "-";
            if (byte < 16) result += "0";
            result += byte.toString(16).toLowerCase();
          }

          return result;
        }
      }

      function MakeDictionary(obj) {
        obj.__ = undefined;
        delete obj.__;
        return obj;
      }
    });
  })(Reflect || (Reflect = {}));
},36,[],"node_modules\\reflect-metadata\\Reflect.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright JS Foundation and other contributors <https://js.foundation/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */
  ;
  (function () {
    var undefined;
    var VERSION = '4.17.11';
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
        FUNC_ERROR_TEXT = 'Expected a function';
    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = '__lodash_placeholder__';
    var CLONE_DEEP_FLAG = 1,
        CLONE_FLAT_FLAG = 2,
        CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1,
        WRAP_BIND_KEY_FLAG = 2,
        WRAP_CURRY_BOUND_FLAG = 4,
        WRAP_CURRY_FLAG = 8,
        WRAP_CURRY_RIGHT_FLAG = 16,
        WRAP_PARTIAL_FLAG = 32,
        WRAP_PARTIAL_RIGHT_FLAG = 64,
        WRAP_ARY_FLAG = 128,
        WRAP_REARG_FLAG = 256,
        WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30,
        DEFAULT_TRUNC_OMISSION = '...';
    var HOT_COUNT = 800,
        HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1,
        LAZY_MAP_FLAG = 2,
        LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0,
        MAX_SAFE_INTEGER = 9007199254740991,
        MAX_INTEGER = 1.7976931348623157e+308,
        NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [['ary', WRAP_ARY_FLAG], ['bind', WRAP_BIND_FLAG], ['bindKey', WRAP_BIND_KEY_FLAG], ['curry', WRAP_CURRY_FLAG], ['curryRight', WRAP_CURRY_RIGHT_FLAG], ['flip', WRAP_FLIP_FLAG], ['partial', WRAP_PARTIAL_FLAG], ['partialRight', WRAP_PARTIAL_RIGHT_FLAG], ['rearg', WRAP_REARG_FLAG]];
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        asyncTag = '[object AsyncFunction]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        domExcTag = '[object DOMException]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        nullTag = '[object Null]',
        objectTag = '[object Object]',
        promiseTag = '[object Promise]',
        proxyTag = '[object Proxy]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]',
        undefinedTag = '[object Undefined]',
        weakMapTag = '[object WeakMap]',
        weakSetTag = '[object WeakSet]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    var reEmptyStringLeading = /\b__p \+= '';/g,
        reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
        reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
        reUnescapedHtml = /[&<>"']/g,
        reHasEscapedHtml = RegExp(reEscapedHtml.source),
        reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g,
        reEvaluate = /<%([\s\S]+?)%>/g,
        reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/,
        rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
        reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrim = /^\s+|\s+$/g,
        reTrimStart = /^\s+/,
        reTrimEnd = /\s+$/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
        reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
        reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff",
        rsComboMarksRange = "\\u0300-\\u036f",
        reComboHalfMarksRange = "\\ufe20-\\ufe2f",
        rsComboSymbolsRange = "\\u20d0-\\u20ff",
        rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
        rsDingbatRange = "\\u2700-\\u27bf",
        rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
        rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
        rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
        rsPunctuationRange = "\\u2000-\\u206f",
        rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
        rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
        rsVarRange = "\\ufe0e\\ufe0f",
        rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]",
        rsAstral = '[' + rsAstralRange + ']',
        rsBreak = '[' + rsBreakRange + ']',
        rsCombo = '[' + rsComboRange + ']',
        rsDigits = '\\d+',
        rsDingbat = '[' + rsDingbatRange + ']',
        rsLower = '[' + rsLowerRange + ']',
        rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
        rsFitz = "\\ud83c[\\udffb-\\udfff]",
        rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
        rsNonAstral = '[^' + rsAstralRange + ']',
        rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
        rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
        rsUpper = '[' + rsUpperRange + ']',
        rsZWJ = "\\u200d";
    var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
        rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
        rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
        rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
        reOptMod = rsModifier + '?',
        rsOptVar = '[' + rsVarRange + ']?',
        rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
        rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
        rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
        rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
    var reApos = RegExp(rsApos, 'g');
    var reComboMark = RegExp(rsCombo, 'g');
    var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
    var reUnicodeWord = RegExp([rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')', rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')', rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower, rsUpper + '+' + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join('|'), 'g');
    var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = ['Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object', 'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap', '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      '\xc0': 'A',
      '\xc1': 'A',
      '\xc2': 'A',
      '\xc3': 'A',
      '\xc4': 'A',
      '\xc5': 'A',
      '\xe0': 'a',
      '\xe1': 'a',
      '\xe2': 'a',
      '\xe3': 'a',
      '\xe4': 'a',
      '\xe5': 'a',
      '\xc7': 'C',
      '\xe7': 'c',
      '\xd0': 'D',
      '\xf0': 'd',
      '\xc8': 'E',
      '\xc9': 'E',
      '\xca': 'E',
      '\xcb': 'E',
      '\xe8': 'e',
      '\xe9': 'e',
      '\xea': 'e',
      '\xeb': 'e',
      '\xcc': 'I',
      '\xcd': 'I',
      '\xce': 'I',
      '\xcf': 'I',
      '\xec': 'i',
      '\xed': 'i',
      '\xee': 'i',
      '\xef': 'i',
      '\xd1': 'N',
      '\xf1': 'n',
      '\xd2': 'O',
      '\xd3': 'O',
      '\xd4': 'O',
      '\xd5': 'O',
      '\xd6': 'O',
      '\xd8': 'O',
      '\xf2': 'o',
      '\xf3': 'o',
      '\xf4': 'o',
      '\xf5': 'o',
      '\xf6': 'o',
      '\xf8': 'o',
      '\xd9': 'U',
      '\xda': 'U',
      '\xdb': 'U',
      '\xdc': 'U',
      '\xf9': 'u',
      '\xfa': 'u',
      '\xfb': 'u',
      '\xfc': 'u',
      '\xdd': 'Y',
      '\xfd': 'y',
      '\xff': 'y',
      '\xc6': 'Ae',
      '\xe6': 'ae',
      '\xde': 'Th',
      '\xfe': 'th',
      '\xdf': 'ss',
      "\u0100": 'A',
      "\u0102": 'A',
      "\u0104": 'A',
      "\u0101": 'a',
      "\u0103": 'a',
      "\u0105": 'a',
      "\u0106": 'C',
      "\u0108": 'C',
      "\u010A": 'C',
      "\u010C": 'C',
      "\u0107": 'c',
      "\u0109": 'c',
      "\u010B": 'c',
      "\u010D": 'c',
      "\u010E": 'D',
      "\u0110": 'D',
      "\u010F": 'd',
      "\u0111": 'd',
      "\u0112": 'E',
      "\u0114": 'E',
      "\u0116": 'E',
      "\u0118": 'E',
      "\u011A": 'E',
      "\u0113": 'e',
      "\u0115": 'e',
      "\u0117": 'e',
      "\u0119": 'e',
      "\u011B": 'e',
      "\u011C": 'G',
      "\u011E": 'G',
      "\u0120": 'G',
      "\u0122": 'G',
      "\u011D": 'g',
      "\u011F": 'g',
      "\u0121": 'g',
      "\u0123": 'g',
      "\u0124": 'H',
      "\u0126": 'H',
      "\u0125": 'h',
      "\u0127": 'h',
      "\u0128": 'I',
      "\u012A": 'I',
      "\u012C": 'I',
      "\u012E": 'I',
      "\u0130": 'I',
      "\u0129": 'i',
      "\u012B": 'i',
      "\u012D": 'i',
      "\u012F": 'i',
      "\u0131": 'i',
      "\u0134": 'J',
      "\u0135": 'j',
      "\u0136": 'K',
      "\u0137": 'k',
      "\u0138": 'k',
      "\u0139": 'L',
      "\u013B": 'L',
      "\u013D": 'L',
      "\u013F": 'L',
      "\u0141": 'L',
      "\u013A": 'l',
      "\u013C": 'l',
      "\u013E": 'l',
      "\u0140": 'l',
      "\u0142": 'l',
      "\u0143": 'N',
      "\u0145": 'N',
      "\u0147": 'N',
      "\u014A": 'N',
      "\u0144": 'n',
      "\u0146": 'n',
      "\u0148": 'n',
      "\u014B": 'n',
      "\u014C": 'O',
      "\u014E": 'O',
      "\u0150": 'O',
      "\u014D": 'o',
      "\u014F": 'o',
      "\u0151": 'o',
      "\u0154": 'R',
      "\u0156": 'R',
      "\u0158": 'R',
      "\u0155": 'r',
      "\u0157": 'r',
      "\u0159": 'r',
      "\u015A": 'S',
      "\u015C": 'S',
      "\u015E": 'S',
      "\u0160": 'S',
      "\u015B": 's',
      "\u015D": 's',
      "\u015F": 's',
      "\u0161": 's',
      "\u0162": 'T',
      "\u0164": 'T',
      "\u0166": 'T',
      "\u0163": 't',
      "\u0165": 't',
      "\u0167": 't',
      "\u0168": 'U',
      "\u016A": 'U',
      "\u016C": 'U',
      "\u016E": 'U',
      "\u0170": 'U',
      "\u0172": 'U',
      "\u0169": 'u',
      "\u016B": 'u',
      "\u016D": 'u',
      "\u016F": 'u',
      "\u0171": 'u',
      "\u0173": 'u',
      "\u0174": 'W',
      "\u0175": 'w',
      "\u0176": 'Y',
      "\u0177": 'y',
      "\u0178": 'Y',
      "\u0179": 'Z',
      "\u017B": 'Z',
      "\u017D": 'Z',
      "\u017A": 'z',
      "\u017C": 'z',
      "\u017E": 'z',
      "\u0132": 'IJ',
      "\u0133": 'ij',
      "\u0152": 'Oe',
      "\u0153": 'oe',
      "\u0149": "'n",
      "\u017F": 's'
    };
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    var htmlUnescapes = {
      '&amp;': '&',
      '&lt;': '<',
      '&gt;': '>',
      '&quot;': '"',
      '&#39;': "'"
    };
    var stringEscapes = {
      '\\': '\\',
      "'": "'",
      '\n': 'n',
      '\r': 'r',
      "\u2028": 'u2028',
      "\u2029": 'u2029'
    };
    var freeParseFloat = parseFloat,
        freeParseInt = parseInt;
    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function('return this')();
    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;

    var nodeUtil = function () {
      try {
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        }

        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();

    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
        nodeIsDate = nodeUtil && nodeUtil.isDate,
        nodeIsMap = nodeUtil && nodeUtil.isMap,
        nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
        nodeIsSet = nodeUtil && nodeUtil.isSet,
        nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);

        case 1:
          return func.call(thisArg, args[0]);

        case 2:
          return func.call(thisArg, args[0], args[1]);

        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }

      return func.apply(thisArg, args);
    }

    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }

      return accumulator;
    }

    function arrayEach(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }

      return array;
    }

    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }

      return array;
    }

    function arrayEvery(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }

      return true;
    }

    function arrayFilter(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }

      return result;
    }

    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }

    function arrayIncludesWith(array, value, comparator) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }

      return false;
    }

    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }

      return result;
    }

    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }

      return array;
    }

    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array == null ? 0 : array.length;

      if (initAccum && length) {
        accumulator = array[++index];
      }

      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }

      return accumulator;
    }

    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;

      if (initAccum && length) {
        accumulator = array[--length];
      }

      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }

      return accumulator;
    }

    function arraySome(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }

      return false;
    }

    var asciiSize = baseProperty('length');

    function asciiToArray(string) {
      return string.split('');
    }

    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }

    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function (value, key, collection) {
        if (predicate(value, key, collection)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);

      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }

      return -1;
    }

    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }

    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }

      return -1;
    }

    function baseIsNaN(value) {
      return value !== value;
    }

    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }

    function baseProperty(key) {
      return function (object) {
        return object == null ? undefined : object[key];
      };
    }

    function basePropertyOf(object) {
      return function (key) {
        return object == null ? undefined : object[key];
      };
    }

    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function (value, index, collection) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);

      while (length--) {
        array[length] = array[length].value;
      }

      return array;
    }

    function baseSum(array, iteratee) {
      var result,
          index = -1,
          length = array.length;

      while (++index < length) {
        var current = iteratee(array[index]);

        if (current !== undefined) {
          result = result === undefined ? current : result + current;
        }
      }

      return result;
    }

    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }

      return result;
    }

    function baseToPairs(object, props) {
      return arrayMap(props, function (key) {
        return [key, object[key]];
      });
    }

    function baseUnary(func) {
      return function (value) {
        return func(value);
      };
    }

    function baseValues(object, props) {
      return arrayMap(props, function (key) {
        return object[key];
      });
    }

    function cacheHas(cache, key) {
      return cache.has(key);
    }

    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1,
          length = strSymbols.length;

      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}

      return index;
    }

    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;

      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}

      return index;
    }

    function countHolders(array, placeholder) {
      var length = array.length,
          result = 0;

      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }

      return result;
    }

    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);

    function escapeStringChar(chr) {
      return '\\' + stringEscapes[chr];
    }

    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }

    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }

    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }

    function iteratorToArray(iterator) {
      var data,
          result = [];

      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }

      return result;
    }

    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);
      map.forEach(function (value, key) {
        result[++index] = [key, value];
      });
      return result;
    }

    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }

    function replaceHolders(array, placeholder) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }

      return result;
    }

    function setToArray(set) {
      var index = -1,
          result = Array(set.size);
      set.forEach(function (value) {
        result[++index] = value;
      });
      return result;
    }

    function setToPairs(set) {
      var index = -1,
          result = Array(set.size);
      set.forEach(function (value) {
        result[++index] = [value, value];
      });
      return result;
    }

    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }

      return -1;
    }

    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;

      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }

      return index;
    }

    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }

    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }

    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;

      while (reUnicode.test(string)) {
        ++result;
      }

      return result;
    }

    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }

    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }

    var runInContext = function runInContext(context) {
      context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
      var Array = context.Array,
          Date = context.Date,
          Error = context.Error,
          Function = context.Function,
          Math = context.Math,
          Object = context.Object,
          RegExp = context.RegExp,
          String = context.String,
          TypeError = context.TypeError;
      var arrayProto = Array.prototype,
          funcProto = Function.prototype,
          objectProto = Object.prototype;
      var coreJsData = context['__core-js_shared__'];
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var idCounter = 0;

      var maskSrcKey = function () {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
        return uid ? 'Symbol(src)_1.' + uid : '';
      }();

      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object);
      var oldDash = root._;
      var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
      var Buffer = moduleExports ? context.Buffer : undefined,
          Symbol = context.Symbol,
          Uint8Array = context.Uint8Array,
          allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
          getPrototype = overArg(Object.getPrototypeOf, Object),
          objectCreate = Object.create,
          propertyIsEnumerable = objectProto.propertyIsEnumerable,
          splice = arrayProto.splice,
          spreadableSymbol = Symbol ? typeof Symbol === "function" ? Symbol.isConcatSpreadable : "@@isConcatSpreadable" : undefined,
          symIterator = Symbol ? typeof Symbol === "function" ? Symbol.iterator : "@@iterator" : undefined,
          symToStringTag = Symbol ? typeof Symbol === "function" ? Symbol.toStringTag : "@@toStringTag" : undefined;

      var defineProperty = function () {
        try {
          var func = getNative(Object, 'defineProperty');
          func({}, '', {});
          return func;
        } catch (e) {}
      }();

      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
          ctxNow = Date && Date.now !== root.Date.now && Date.now,
          ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var nativeCeil = Math.ceil,
          nativeFloor = Math.floor,
          nativeGetSymbols = Object.getOwnPropertySymbols,
          nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
          nativeIsFinite = context.isFinite,
          nativeJoin = arrayProto.join,
          nativeKeys = overArg(Object.keys, Object),
          nativeMax = Math.max,
          nativeMin = Math.min,
          nativeNow = Date.now,
          nativeParseInt = context.parseInt,
          nativeRandom = Math.random,
          nativeReverse = arrayProto.reverse;
      var DataView = getNative(context, 'DataView'),
          Map = getNative(context, 'Map'),
          Promise = getNative(context, 'Promise'),
          Set = getNative(context, 'Set'),
          WeakMap = getNative(context, 'WeakMap'),
          nativeCreate = getNative(Object, 'create');
      var metaMap = WeakMap && new WeakMap();
      var realNames = {};
      var dataViewCtorString = toSource(DataView),
          mapCtorString = toSource(Map),
          promiseCtorString = toSource(Promise),
          setCtorString = toSource(Set),
          weakMapCtorString = toSource(WeakMap);
      var symbolProto = Symbol ? typeof Symbol === "function" ? Symbol.prototype : "@@prototype" : undefined,
          symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
          symbolToString = symbolProto ? symbolProto.toString : undefined;

      function lodash(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }

          if (hasOwnProperty.call(value, '__wrapped__')) {
            return wrapperClone(value);
          }
        }

        return new LodashWrapper(value);
      }

      var baseCreate = function () {
        function object() {}

        return function (proto) {
          if (!isObject(proto)) {
            return {};
          }

          if (objectCreate) {
            return objectCreate(proto);
          }

          object.prototype = proto;
          var result = new object();
          object.prototype = undefined;
          return result;
        };
      }();

      function baseLodash() {}

      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined;
      }

      lodash.templateSettings = {
        'escape': reEscape,
        'evaluate': reEvaluate,
        'interpolate': reInterpolate,
        'variable': '',
        'imports': {
          '_': lodash
        }
      };
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;

      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }

      function lazyClone() {
        var result = new LazyWrapper(this.__wrapped__);
        result.__actions__ = copyArray(this.__actions__);
        result.__dir__ = this.__dir__;
        result.__filtered__ = this.__filtered__;
        result.__iteratees__ = copyArray(this.__iteratees__);
        result.__takeCount__ = this.__takeCount__;
        result.__views__ = copyArray(this.__views__);
        return result;
      }

      function lazyReverse() {
        if (this.__filtered__) {
          var result = new LazyWrapper(this);
          result.__dir__ = -1;
          result.__filtered__ = true;
        } else {
          result = this.clone();
          result.__dir__ *= -1;
        }

        return result;
      }

      function lazyValue() {
        var array = this.__wrapped__.value(),
            dir = this.__dir__,
            isArr = isArray(array),
            isRight = dir < 0,
            arrLength = isArr ? array.length : 0,
            view = getView(0, arrLength, this.__views__),
            start = view.start,
            end = view.end,
            length = end - start,
            index = isRight ? end : start - 1,
            iteratees = this.__iteratees__,
            iterLength = iteratees.length,
            resIndex = 0,
            takeCount = nativeMin(length, this.__takeCount__);

        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }

        var result = [];

        outer: while (length-- && resIndex < takeCount) {
          index += dir;
          var iterIndex = -1,
              value = array[index];

          while (++iterIndex < iterLength) {
            var data = iteratees[iterIndex],
                iteratee = data.iteratee,
                type = data.type,
                computed = iteratee(value);

            if (type == LAZY_MAP_FLAG) {
              value = computed;
            } else if (!computed) {
              if (type == LAZY_FILTER_FLAG) {
                continue outer;
              } else {
                break outer;
              }
            }
          }

          result[resIndex++] = value;
        }

        return result;
      }

      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;

      function Hash(entries) {
        var index = -1,
            length = entries == null ? 0 : entries.length;
        this.clear();

        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }

      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }

      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }

      function hashGet(key) {
        var data = this.__data__;

        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? undefined : result;
        }

        return hasOwnProperty.call(data, key) ? data[key] : undefined;
      }

      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
      }

      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
        return this;
      }

      Hash.prototype.clear = hashClear;
      Hash.prototype['delete'] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;

      function ListCache(entries) {
        var index = -1,
            length = entries == null ? 0 : entries.length;
        this.clear();

        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }

      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }

      function listCacheDelete(key) {
        var data = this.__data__,
            index = assocIndexOf(data, key);

        if (index < 0) {
          return false;
        }

        var lastIndex = data.length - 1;

        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }

        --this.size;
        return true;
      }

      function listCacheGet(key) {
        var data = this.__data__,
            index = assocIndexOf(data, key);
        return index < 0 ? undefined : data[index][1];
      }

      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }

      function listCacheSet(key, value) {
        var data = this.__data__,
            index = assocIndexOf(data, key);

        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }

        return this;
      }

      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype['delete'] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;

      function MapCache(entries) {
        var index = -1,
            length = entries == null ? 0 : entries.length;
        this.clear();

        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }

      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          'hash': new Hash(),
          'map': new (Map || ListCache)(),
          'string': new Hash()
        };
      }

      function mapCacheDelete(key) {
        var result = getMapData(this, key)['delete'](key);
        this.size -= result ? 1 : 0;
        return result;
      }

      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }

      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }

      function mapCacheSet(key, value) {
        var data = getMapData(this, key),
            size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }

      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype['delete'] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;

      function SetCache(values) {
        var index = -1,
            length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();

        while (++index < length) {
          this.add(values[index]);
        }
      }

      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);

        return this;
      }

      function setCacheHas(value) {
        return this.__data__.has(value);
      }

      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;

      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }

      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }

      function stackDelete(key) {
        var data = this.__data__,
            result = data['delete'](key);
        this.size = data.size;
        return result;
      }

      function stackGet(key) {
        return this.__data__.get(key);
      }

      function stackHas(key) {
        return this.__data__.has(key);
      }

      function stackSet(key, value) {
        var data = this.__data__;

        if (data instanceof ListCache) {
          var pairs = data.__data__;

          if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }

          data = this.__data__ = new MapCache(pairs);
        }

        data.set(key, value);
        this.size = data.size;
        return this;
      }

      Stack.prototype.clear = stackClear;
      Stack.prototype['delete'] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;

      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value),
            isArg = !isArr && isArguments(value),
            isBuff = !isArr && !isArg && isBuffer(value),
            isType = !isArr && !isArg && !isBuff && isTypedArray(value),
            skipIndexes = isArr || isArg || isBuff || isType,
            result = skipIndexes ? baseTimes(value.length, String) : [],
            length = result.length;

        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || isIndex(key, length)))) {
            result.push(key);
          }
        }

        return result;
      }

      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined;
      }

      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }

      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }

      function assignMergeValue(object, key, value) {
        if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }

      function assignValue(object, key, value) {
        var objValue = object[key];

        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }

      function assocIndexOf(array, key) {
        var length = array.length;

        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }

        return -1;
      }

      function baseAggregator(collection, setter, iteratee, accumulator) {
        baseEach(collection, function (value, key, collection) {
          setter(accumulator, value, iteratee(value), collection);
        });
        return accumulator;
      }

      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }

      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }

      function baseAssignValue(object, key, value) {
        if (key == '__proto__' && defineProperty) {
          defineProperty(object, key, {
            'configurable': true,
            'enumerable': true,
            'value': value,
            'writable': true
          });
        } else {
          object[key] = value;
        }
      }

      function baseAt(object, paths) {
        var index = -1,
            length = paths.length,
            result = Array(length),
            skip = object == null;

        while (++index < length) {
          result[index] = skip ? undefined : get(object, paths[index]);
        }

        return result;
      }

      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined) {
            number = number <= upper ? number : upper;
          }

          if (lower !== undefined) {
            number = number >= lower ? number : lower;
          }
        }

        return number;
      }

      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result,
            isDeep = bitmask & CLONE_DEEP_FLAG,
            isFlat = bitmask & CLONE_FLAT_FLAG,
            isFull = bitmask & CLONE_SYMBOLS_FLAG;

        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value);
        }

        if (result !== undefined) {
          return result;
        }

        if (!isObject(value)) {
          return value;
        }

        var isArr = isArray(value);

        if (isArr) {
          result = initCloneArray(value);

          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag(value),
              isFunc = tag == funcTag || tag == genTag;

          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }

          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result = isFlat || isFunc ? {} : initCloneObject(value);

            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }

            result = initCloneByTag(value, tag, isDeep);
          }
        }

        stack || (stack = new Stack());
        var stacked = stack.get(value);

        if (stacked) {
          return stacked;
        }

        stack.set(value, result);

        if (isSet(value)) {
          value.forEach(function (subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
          return result;
        }

        if (isMap(value)) {
          value.forEach(function (subValue, key) {
            result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
          });
          return result;
        }

        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined : keysFunc(value);
        arrayEach(props || value, function (subValue, key) {
          if (props) {
            key = subValue;
            subValue = value[key];
          }

          assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
        return result;
      }

      function baseConforms(source) {
        var props = keys(source);
        return function (object) {
          return baseConformsTo(object, source, props);
        };
      }

      function baseConformsTo(object, source, props) {
        var length = props.length;

        if (object == null) {
          return !length;
        }

        object = Object(object);

        while (length--) {
          var key = props[length],
              predicate = source[key],
              value = object[key];

          if (value === undefined && !(key in object) || !predicate(value)) {
            return false;
          }
        }

        return true;
      }

      function baseDelay(func, wait, args) {
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }

        return setTimeout(function () {
          func.apply(undefined, args);
        }, wait);
      }

      function baseDifference(array, values, iteratee, comparator) {
        var index = -1,
            includes = arrayIncludes,
            isCommon = true,
            length = array.length,
            result = [],
            valuesLength = values.length;

        if (!length) {
          return result;
        }

        if (iteratee) {
          values = arrayMap(values, baseUnary(iteratee));
        }

        if (comparator) {
          includes = arrayIncludesWith;
          isCommon = false;
        } else if (values.length >= LARGE_ARRAY_SIZE) {
          includes = cacheHas;
          isCommon = false;
          values = new SetCache(values);
        }

        outer: while (++index < length) {
          var value = array[index],
              computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;

          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;

            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }

            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }

        return result;
      }

      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);

      function baseEvery(collection, predicate) {
        var result = true;
        baseEach(collection, function (value, index, collection) {
          result = !!predicate(value, index, collection);
          return result;
        });
        return result;
      }

      function baseExtremum(array, iteratee, comparator) {
        var index = -1,
            length = array.length;

        while (++index < length) {
          var value = array[index],
              current = iteratee(value);

          if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current,
                result = value;
          }
        }

        return result;
      }

      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger(start);

        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }

        end = end === undefined || end > length ? length : toInteger(end);

        if (end < 0) {
          end += length;
        }

        end = start > end ? 0 : toLength(end);

        while (start < end) {
          array[start++] = value;
        }

        return array;
      }

      function baseFilter(collection, predicate) {
        var result = [];
        baseEach(collection, function (value, index, collection) {
          if (predicate(value, index, collection)) {
            result.push(value);
          }
        });
        return result;
      }

      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1,
            length = array.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);

        while (++index < length) {
          var value = array[index];

          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }

        return result;
      }

      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);

      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
      }

      function baseForOwnRight(object, iteratee) {
        return object && baseForRight(object, iteratee, keys);
      }

      function baseFunctions(object, props) {
        return arrayFilter(props, function (key) {
          return isFunction(object[key]);
        });
      }

      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0,
            length = path.length;

        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }

        return index && index == length ? object : undefined;
      }

      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
      }

      function baseGetTag(value) {
        if (value == null) {
          return value === undefined ? undefinedTag : nullTag;
        }

        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }

      function baseGt(value, other) {
        return value > other;
      }

      function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key);
      }

      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }

      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }

      function baseIntersection(arrays, iteratee, comparator) {
        var includes = comparator ? arrayIncludesWith : arrayIncludes,
            length = arrays[0].length,
            othLength = arrays.length,
            othIndex = othLength,
            caches = Array(othLength),
            maxLength = Infinity,
            result = [];

        while (othIndex--) {
          var array = arrays[othIndex];

          if (othIndex && iteratee) {
            array = arrayMap(array, baseUnary(iteratee));
          }

          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
        }

        array = arrays[0];
        var index = -1,
            seen = caches[0];

        outer: while (++index < length && result.length < maxLength) {
          var value = array[index],
              computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;

          if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
            othIndex = othLength;

            while (--othIndex) {
              var cache = caches[othIndex];

              if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                continue outer;
              }
            }

            if (seen) {
              seen.push(computed);
            }

            result.push(value);
          }
        }

        return result;
      }

      function baseInverter(object, setter, iteratee, accumulator) {
        baseForOwn(object, function (value, key, object) {
          setter(accumulator, iteratee(value), key, object);
        });
        return accumulator;
      }

      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined : apply(func, object, args);
      }

      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }

      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }

      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }

      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }

        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }

        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }

      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object),
            othIsArr = isArray(other),
            objTag = objIsArr ? arrayTag : getTag(object),
            othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag,
            othIsObj = othTag == objectTag,
            isSameTag = objTag == othTag;

        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }

          objIsArr = true;
          objIsObj = false;
        }

        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }

        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
              othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object,
                othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }

        if (!isSameTag) {
          return false;
        }

        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }

      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }

      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length,
            length = index,
            noCustomizer = !customizer;

        if (object == null) {
          return !length;
        }

        object = Object(object);

        while (index--) {
          var data = matchData[index];

          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }

        while (++index < length) {
          data = matchData[index];
          var key = data[0],
              objValue = object[key],
              srcValue = data[1];

          if (noCustomizer && data[2]) {
            if (objValue === undefined && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();

            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack);
            }

            if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
              return false;
            }
          }
        }

        return true;
      }

      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }

        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }

      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }

      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }

      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }

      function baseIteratee(value) {
        if (typeof value == 'function') {
          return value;
        }

        if (value == null) {
          return identity;
        }

        if (typeof value == 'object') {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }

        return property(value);
      }

      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }

        var result = [];

        for (var key in Object(object)) {
          if (hasOwnProperty.call(object, key) && key != 'constructor') {
            result.push(key);
          }
        }

        return result;
      }

      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }

        var isProto = isPrototype(object),
            result = [];

        for (var key in object) {
          if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
          }
        }

        return result;
      }

      function baseLt(value, other) {
        return value < other;
      }

      function baseMap(collection, iteratee) {
        var index = -1,
            result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach(collection, function (value, key, collection) {
          result[++index] = iteratee(value, key, collection);
        });
        return result;
      }

      function baseMatches(source) {
        var matchData = getMatchData(source);

        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }

        return function (object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }

      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }

        return function (object) {
          var objValue = get(object, path);
          return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }

      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }

        baseFor(source, function (srcValue, key) {
          if (isObject(srcValue)) {
            stack || (stack = new Stack());
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

            if (newValue === undefined) {
              newValue = srcValue;
            }

            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }

      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key),
            srcValue = safeGet(source, key),
            stacked = stack.get(srcValue);

        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }

        var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
        var isCommon = newValue === undefined;

        if (isCommon) {
          var isArr = isArray(srcValue),
              isBuff = !isArr && isBuffer(srcValue),
              isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;

          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;

            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }

        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack['delete'](srcValue);
        }

        assignMergeValue(object, key, newValue);
      }

      function baseNth(array, n) {
        var length = array.length;

        if (!length) {
          return;
        }

        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined;
      }

      function baseOrderBy(collection, iteratees, orders) {
        var index = -1;
        iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
        var result = baseMap(collection, function (value, key, collection) {
          var criteria = arrayMap(iteratees, function (iteratee) {
            return iteratee(value);
          });
          return {
            'criteria': criteria,
            'index': ++index,
            'value': value
          };
        });
        return baseSortBy(result, function (object, other) {
          return compareMultiple(object, other, orders);
        });
      }

      function basePick(object, paths) {
        return basePickBy(object, paths, function (value, path) {
          return hasIn(object, path);
        });
      }

      function basePickBy(object, paths, predicate) {
        var index = -1,
            length = paths.length,
            result = {};

        while (++index < length) {
          var path = paths[index],
              value = baseGet(object, path);

          if (predicate(value, path)) {
            baseSet(result, castPath(path, object), value);
          }
        }

        return result;
      }

      function basePropertyDeep(path) {
        return function (object) {
          return baseGet(object, path);
        };
      }

      function basePullAll(array, values, iteratee, comparator) {
        var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
            index = -1,
            length = values.length,
            seen = array;

        if (array === values) {
          values = copyArray(values);
        }

        if (iteratee) {
          seen = arrayMap(array, baseUnary(iteratee));
        }

        while (++index < length) {
          var fromIndex = 0,
              value = values[index],
              computed = iteratee ? iteratee(value) : value;

          while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }

            splice.call(array, fromIndex, 1);
          }
        }

        return array;
      }

      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0,
            lastIndex = length - 1;

        while (length--) {
          var index = indexes[length];

          if (length == lastIndex || index !== previous) {
            var previous = index;

            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }

        return array;
      }

      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }

      function baseRange(start, end, step, fromRight) {
        var index = -1,
            length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
            result = Array(length);

        while (length--) {
          result[fromRight ? length : ++index] = start;
          start += step;
        }

        return result;
      }

      function baseRepeat(string, n) {
        var result = '';

        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result;
        }

        do {
          if (n % 2) {
            result += string;
          }

          n = nativeFloor(n / 2);

          if (n) {
            string += string;
          }
        } while (n);

        return result;
      }

      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + '');
      }

      function baseSample(collection) {
        return arraySample(values(collection));
      }

      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }

      function baseSet(object, path, value, customizer) {
        if (!isObject(object)) {
          return object;
        }

        path = castPath(path, object);
        var index = -1,
            length = path.length,
            lastIndex = length - 1,
            nested = object;

        while (nested != null && ++index < length) {
          var key = toKey(path[index]),
              newValue = value;

          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined;

            if (newValue === undefined) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }

          assignValue(nested, key, newValue);
          nested = nested[key];
        }

        return object;
      }

      var baseSetData = !metaMap ? identity : function (func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function (func, string) {
        return defineProperty(func, 'toString', {
          'configurable': true,
          'enumerable': false,
          'value': constant(string),
          'writable': true
        });
      };

      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }

      function baseSlice(array, start, end) {
        var index = -1,
            length = array.length;

        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }

        end = end > length ? length : end;

        if (end < 0) {
          end += length;
        }

        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result = Array(length);

        while (++index < length) {
          result[index] = array[index + start];
        }

        return result;
      }

      function baseSome(collection, predicate) {
        var result;
        baseEach(collection, function (value, index, collection) {
          result = predicate(value, index, collection);
          return !result;
        });
        return !!result;
      }

      function baseSortedIndex(array, value, retHighest) {
        var low = 0,
            high = array == null ? low : array.length;

        if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1,
                computed = array[mid];

            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }

          return high;
        }

        return baseSortedIndexBy(array, value, identity, retHighest);
      }

      function baseSortedIndexBy(array, value, iteratee, retHighest) {
        value = iteratee(value);
        var low = 0,
            high = array == null ? 0 : array.length,
            valIsNaN = value !== value,
            valIsNull = value === null,
            valIsSymbol = isSymbol(value),
            valIsUndefined = value === undefined;

        while (low < high) {
          var mid = nativeFloor((low + high) / 2),
              computed = iteratee(array[mid]),
              othIsDefined = computed !== undefined,
              othIsNull = computed === null,
              othIsReflexive = computed === computed,
              othIsSymbol = isSymbol(computed);

          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }

          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }

        return nativeMin(high, MAX_ARRAY_INDEX);
      }

      function baseSortedUniq(array, iteratee) {
        var index = -1,
            length = array.length,
            resIndex = 0,
            result = [];

        while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value) : value;

          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result[resIndex++] = value === 0 ? 0 : value;
          }
        }

        return result;
      }

      function baseToNumber(value) {
        if (typeof value == 'number') {
          return value;
        }

        if (isSymbol(value)) {
          return NAN;
        }

        return +value;
      }

      function baseToString(value) {
        if (typeof value == 'string') {
          return value;
        }

        if (isArray(value)) {
          return arrayMap(value, baseToString) + '';
        }

        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : '';
        }

        var result = value + '';
        return result == '0' && 1 / value == -INFINITY ? '-0' : result;
      }

      function baseUniq(array, iteratee, comparator) {
        var index = -1,
            includes = arrayIncludes,
            length = array.length,
            isCommon = true,
            result = [],
            seen = result;

        if (comparator) {
          isCommon = false;
          includes = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set = iteratee ? null : createSet(array);

          if (set) {
            return setToArray(set);
          }

          isCommon = false;
          includes = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee ? [] : result;
        }

        outer: while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;

          if (isCommon && computed === computed) {
            var seenIndex = seen.length;

            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }

            if (iteratee) {
              seen.push(computed);
            }

            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }

            result.push(value);
          }
        }

        return result;
      }

      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }

      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }

      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length,
            index = fromRight ? length : -1;

        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}

        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }

      function baseWrapperValue(value, actions) {
        var result = value;

        if (result instanceof LazyWrapper) {
          result = result.value();
        }

        return arrayReduce(actions, function (result, action) {
          return action.func.apply(action.thisArg, arrayPush([result], action.args));
        }, result);
      }

      function baseXor(arrays, iteratee, comparator) {
        var length = arrays.length;

        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }

        var index = -1,
            result = Array(length);

        while (++index < length) {
          var array = arrays[index],
              othIndex = -1;

          while (++othIndex < length) {
            if (othIndex != index) {
              result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
            }
          }
        }

        return baseUniq(baseFlatten(result, 1), iteratee, comparator);
      }

      function baseZipObject(props, values, assignFunc) {
        var index = -1,
            length = props.length,
            valsLength = values.length,
            result = {};

        while (++index < length) {
          var value = index < valsLength ? values[index] : undefined;
          assignFunc(result, props[index], value);
        }

        return result;
      }

      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }

      function castFunction(value) {
        return typeof value == 'function' ? value : identity;
      }

      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }

        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }

      var castRest = baseRest;

      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }

      var clearTimeout = ctxClearTimeout || function (id) {
        return root.clearTimeout(id);
      };

      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }

        var length = buffer.length,
            result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }

      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array(result).set(new Uint8Array(arrayBuffer));
        return result;
      }

      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }

      function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }

      function cloneSymbol(symbol) {
        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
      }

      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }

      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined,
              valIsNull = value === null,
              valIsReflexive = value === value,
              valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined,
              othIsNull = other === null,
              othIsReflexive = other === other,
              othIsSymbol = isSymbol(other);

          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }

          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }

        return 0;
      }

      function compareMultiple(object, other, orders) {
        var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;

        while (++index < length) {
          var result = compareAscending(objCriteria[index], othCriteria[index]);

          if (result) {
            if (index >= ordersLength) {
              return result;
            }

            var order = orders[index];
            return result * (order == 'desc' ? -1 : 1);
          }
        }

        return object.index - other.index;
      }

      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1,
            argsLength = args.length,
            holdersLength = holders.length,
            leftIndex = -1,
            leftLength = partials.length,
            rangeLength = nativeMax(argsLength - holdersLength, 0),
            result = Array(leftLength + rangeLength),
            isUncurried = !isCurried;

        while (++leftIndex < leftLength) {
          result[leftIndex] = partials[leftIndex];
        }

        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result[holders[argsIndex]] = args[argsIndex];
          }
        }

        while (rangeLength--) {
          result[leftIndex++] = args[argsIndex++];
        }

        return result;
      }

      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1,
            argsLength = args.length,
            holdersIndex = -1,
            holdersLength = holders.length,
            rightIndex = -1,
            rightLength = partials.length,
            rangeLength = nativeMax(argsLength - holdersLength, 0),
            result = Array(rangeLength + rightLength),
            isUncurried = !isCurried;

        while (++argsIndex < rangeLength) {
          result[argsIndex] = args[argsIndex];
        }

        var offset = argsIndex;

        while (++rightIndex < rightLength) {
          result[offset + rightIndex] = partials[rightIndex];
        }

        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }

        return result;
      }

      function copyArray(source, array) {
        var index = -1,
            length = source.length;
        array || (array = Array(length));

        while (++index < length) {
          array[index] = source[index];
        }

        return array;
      }

      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

          if (newValue === undefined) {
            newValue = source[key];
          }

          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }

        return object;
      }

      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }

      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }

      function createAggregator(setter, initializer) {
        return function (collection, iteratee) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator,
              accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee, 2), accumulator);
        };
      }

      function createAssigner(assigner) {
        return baseRest(function (object, sources) {
          var index = -1,
              length = sources.length,
              customizer = length > 1 ? sources[length - 1] : undefined,
              guard = length > 2 ? sources[2] : undefined;
          customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined : customizer;
            length = 1;
          }

          object = Object(object);

          while (++index < length) {
            var source = sources[index];

            if (source) {
              assigner(object, source, index, customizer);
            }
          }

          return object;
        });
      }

      function createBaseEach(eachFunc, fromRight) {
        return function (collection, iteratee) {
          if (collection == null) {
            return collection;
          }

          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
          }

          var length = collection.length,
              index = fromRight ? length : -1,
              iterable = Object(collection);

          while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }

          return collection;
        };
      }

      function createBaseFor(fromRight) {
        return function (object, iteratee, keysFunc) {
          var index = -1,
              iterable = Object(object),
              props = keysFunc(object),
              length = props.length;

          while (length--) {
            var key = props[fromRight ? length : ++index];

            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }

          return object;
        };
      }

      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG,
            Ctor = createCtor(func);

        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }

        return wrapper;
      }

      function createCaseFirst(methodName) {
        return function (string) {
          string = toString(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }

      function createCompounder(callback) {
        return function (string) {
          return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
        };
      }

      function createCtor(Ctor) {
        return function () {
          var args = arguments;

          switch (args.length) {
            case 0:
              return new Ctor();

            case 1:
              return new Ctor(args[0]);

            case 2:
              return new Ctor(args[0], args[1]);

            case 3:
              return new Ctor(args[0], args[1], args[2]);

            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);

            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);

            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);

            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }

          var thisBinding = baseCreate(Ctor.prototype),
              result = Ctor.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        };
      }

      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);

        function wrapper() {
          var length = arguments.length,
              args = Array(length),
              index = length,
              placeholder = getHolder(wrapper);

          while (index--) {
            args[index] = arguments[index];
          }

          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;

          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
          }

          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }

        return wrapper;
      }

      function createFind(findIndexFunc) {
        return function (collection, predicate, fromIndex) {
          var iterable = Object(collection);

          if (!isArrayLike(collection)) {
            var iteratee = getIteratee(predicate, 3);
            collection = keys(collection);

            predicate = function predicate(key) {
              return iteratee(iterable[key], key, iterable);
            };
          }

          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
        };
      }

      function createFlow(fromRight) {
        return flatRest(function (funcs) {
          var length = funcs.length,
              index = length,
              prereq = LodashWrapper.prototype.thru;

          if (fromRight) {
            funcs.reverse();
          }

          while (index--) {
            var func = funcs[index];

            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
              var wrapper = new LodashWrapper([], true);
            }
          }

          index = wrapper ? index : length;

          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func),
                data = funcName == 'wrapper' ? getData(func) : undefined;

            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }

          return function () {
            var args = arguments,
                value = args[0];

            if (wrapper && args.length == 1 && isArray(value)) {
              return wrapper.plant(value).value();
            }

            var index = 0,
                result = length ? funcs[index].apply(this, args) : value;

            while (++index < length) {
              result = funcs[index].call(this, result);
            }

            return result;
          };
        });
      }

      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG,
            isBind = bitmask & WRAP_BIND_FLAG,
            isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
            isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
            isFlip = bitmask & WRAP_FLIP_FLAG,
            Ctor = isBindKey ? undefined : createCtor(func);

        function wrapper() {
          var length = arguments.length,
              args = Array(length),
              index = length;

          while (index--) {
            args[index] = arguments[index];
          }

          if (isCurried) {
            var placeholder = getHolder(wrapper),
                holdersCount = countHolders(args, placeholder);
          }

          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }

          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }

          length -= holdersCount;

          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
          }

          var thisBinding = isBind ? thisArg : this,
              fn = isBindKey ? thisBinding[func] : func;
          length = args.length;

          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }

          if (isAry && ary < length) {
            args.length = ary;
          }

          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }

          return fn.apply(thisBinding, args);
        }

        return wrapper;
      }

      function createInverter(setter, toIteratee) {
        return function (object, iteratee) {
          return baseInverter(object, setter, toIteratee(iteratee), {});
        };
      }

      function createMathOperation(operator, defaultValue) {
        return function (value, other) {
          var result;

          if (value === undefined && other === undefined) {
            return defaultValue;
          }

          if (value !== undefined) {
            result = value;
          }

          if (other !== undefined) {
            if (result === undefined) {
              return other;
            }

            if (typeof value == 'string' || typeof other == 'string') {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }

            result = operator(value, other);
          }

          return result;
        };
      }

      function createOver(arrayFunc) {
        return flatRest(function (iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function (args) {
            var thisArg = this;
            return arrayFunc(iteratees, function (iteratee) {
              return apply(iteratee, thisArg, args);
            });
          });
        });
      }

      function createPadding(length, chars) {
        chars = chars === undefined ? ' ' : baseToString(chars);
        var charsLength = chars.length;

        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }

        var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
      }

      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG,
            Ctor = createCtor(func);

        function wrapper() {
          var argsIndex = -1,
              argsLength = arguments.length,
              leftIndex = -1,
              leftLength = partials.length,
              args = Array(leftLength + argsLength),
              fn = this && this !== root && this instanceof wrapper ? Ctor : func;

          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }

          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }

          return apply(fn, isBind ? thisArg : this, args);
        }

        return wrapper;
      }

      function createRange(fromRight) {
        return function (start, end, step) {
          if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
            end = step = undefined;
          }

          start = toFinite(start);

          if (end === undefined) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }

          step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }

      function createRelationalOperation(operator) {
        return function (value, other) {
          if (!(typeof value == 'string' && typeof other == 'string')) {
            value = toNumber(value);
            other = toNumber(other);
          }

          return operator(value, other);
        };
      }

      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG,
            newHolders = isCurry ? holders : undefined,
            newHoldersRight = isCurry ? undefined : holders,
            newPartials = isCurry ? partials : undefined,
            newPartialsRight = isCurry ? undefined : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }

        var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity];
        var result = wrapFunc.apply(undefined, newData);

        if (isLaziable(func)) {
          setData(result, newData);
        }

        result.placeholder = placeholder;
        return setWrapToString(result, func, bitmask);
      }

      function createRound(methodName) {
        var func = Math[methodName];
        return function (number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);

          if (precision) {
            var pair = (toString(number) + 'e').split('e'),
                value = func(pair[0] + 'e' + (+pair[1] + precision));
            pair = (toString(value) + 'e').split('e');
            return +(pair[0] + 'e' + (+pair[1] - precision));
          }

          return func(number);
        };
      }

      var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
        return new Set(values);
      };

      function createToPairs(keysFunc) {
        return function (object) {
          var tag = getTag(object);

          if (tag == mapTag) {
            return mapToArray(object);
          }

          if (tag == setTag) {
            return setToPairs(object);
          }

          return baseToPairs(object, keysFunc(object));
        };
      }

      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;

        if (!isBindKey && typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }

        var length = partials ? partials.length : 0;

        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined;
        }

        ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
        arity = arity === undefined ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;

        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials,
              holdersRight = holders;
          partials = holders = undefined;
        }

        var data = isBindKey ? undefined : getData(func);
        var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

        if (data) {
          mergeData(newData, data);
        }

        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);

        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }

        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result = createPartial(func, bitmask, thisArg, partials);
        } else {
          result = createHybrid.apply(undefined, newData);
        }

        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result, newData), func, bitmask);
      }

      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
          return srcValue;
        }

        return objValue;
      }

      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject(objValue) && isObject(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
          stack['delete'](srcValue);
        }

        return objValue;
      }

      function customOmitClone(value) {
        return isPlainObject(value) ? undefined : value;
      }

      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
            arrLength = array.length,
            othLength = other.length;

        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }

        var stacked = stack.get(array);

        if (stacked && stack.get(other)) {
          return stacked == other;
        }

        var index = -1,
            result = true,
            seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
        stack.set(array, other);
        stack.set(other, array);

        while (++index < arrLength) {
          var arrValue = array[index],
              othValue = other[index];

          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }

          if (compared !== undefined) {
            if (compared) {
              continue;
            }

            result = false;
            break;
          }

          if (seen) {
            if (!arraySome(other, function (othValue, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }

        stack['delete'](array);
        stack['delete'](other);
        return result;
      }

      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }

            object = object.buffer;
            other = other.buffer;

          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
              return false;
            }

            return true;

          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);

          case errorTag:
            return object.name == other.name && object.message == other.message;

          case regexpTag:
          case stringTag:
            return object == other + '';

          case mapTag:
            var convert = mapToArray;

          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);

            if (object.size != other.size && !isPartial) {
              return false;
            }

            var stacked = stack.get(object);

            if (stacked) {
              return stacked == other;
            }

            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack['delete'](object);
            return result;

          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }

        }

        return false;
      }

      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
            objProps = getAllKeys(object),
            objLength = objProps.length,
            othProps = getAllKeys(other),
            othLength = othProps.length;

        if (objLength != othLength && !isPartial) {
          return false;
        }

        var index = objLength;

        while (index--) {
          var key = objProps[index];

          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }

        var stacked = stack.get(object);

        if (stacked && stack.get(other)) {
          return stacked == other;
        }

        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;

        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key],
              othValue = other[key];

          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }

          if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }

          skipCtor || (skipCtor = key == 'constructor');
        }

        if (result && !skipCtor) {
          var objCtor = object.constructor,
              othCtor = other.constructor;

          if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
            result = false;
          }
        }

        stack['delete'](object);
        stack['delete'](other);
        return result;
      }

      function flatRest(func) {
        return setToString(overRest(func, undefined, flatten), func + '');
      }

      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }

      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }

      var getData = !metaMap ? noop : function (func) {
        return metaMap.get(func);
      };

      function getFuncName(func) {
        var result = func.name + '',
            array = realNames[result],
            length = hasOwnProperty.call(realNames, result) ? array.length : 0;

        while (length--) {
          var data = array[length],
              otherFunc = data.func;

          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }

        return result;
      }

      function getHolder(func) {
        var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
        return object.placeholder;
      }

      function getIteratee() {
        var result = lodash.iteratee || iteratee;
        result = result === iteratee ? baseIteratee : result;
        return arguments.length ? result(arguments[0], arguments[1]) : result;
      }

      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
      }

      function getMatchData(object) {
        var result = keys(object),
            length = result.length;

        while (length--) {
          var key = result[length],
              value = object[key];
          result[length] = [key, value, isStrictComparable(value)];
        }

        return result;
      }

      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined;
      }

      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag),
            tag = value[symToStringTag];

        try {
          value[symToStringTag] = undefined;
          var unmasked = true;
        } catch (e) {}

        var result = nativeObjectToString.call(value);

        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }

        return result;
      }

      var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
        if (object == null) {
          return [];
        }

        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function (symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
        var result = [];

        while (object) {
          arrayPush(result, getSymbols(object));
          object = getPrototype(object);
        }

        return result;
      };
      var getTag = baseGetTag;

      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
        getTag = function getTag(value) {
          var result = baseGetTag(value),
              Ctor = result == objectTag ? value.constructor : undefined,
              ctorString = Ctor ? toSource(Ctor) : '';

          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;

              case mapCtorString:
                return mapTag;

              case promiseCtorString:
                return promiseTag;

              case setCtorString:
                return setTag;

              case weakMapCtorString:
                return weakMapTag;
            }
          }

          return result;
        };
      }

      function getView(start, end, transforms) {
        var index = -1,
            length = transforms.length;

        while (++index < length) {
          var data = transforms[index],
              size = data.size;

          switch (data.type) {
            case 'drop':
              start += size;
              break;

            case 'dropRight':
              end -= size;
              break;

            case 'take':
              end = nativeMin(end, start + size);
              break;

            case 'takeRight':
              start = nativeMax(start, end - size);
              break;
          }
        }

        return {
          'start': start,
          'end': end
        };
      }

      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }

      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1,
            length = path.length,
            result = false;

        while (++index < length) {
          var key = toKey(path[index]);

          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }

          object = object[key];
        }

        if (result || ++index != length) {
          return result;
        }

        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }

      function initCloneArray(array) {
        var length = array.length,
            result = new array.constructor(length);

        if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
          result.index = array.index;
          result.input = array.input;
        }

        return result;
      }

      function initCloneObject(object) {
        return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }

      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;

        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);

          case boolTag:
          case dateTag:
            return new Ctor(+object);

          case dataViewTag:
            return cloneDataView(object, isDeep);

          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);

          case mapTag:
            return new Ctor();

          case numberTag:
          case stringTag:
            return new Ctor(object);

          case regexpTag:
            return cloneRegExp(object);

          case setTag:
            return new Ctor();

          case symbolTag:
            return cloneSymbol(object);
        }
      }

      function insertWrapDetails(source, details) {
        var length = details.length;

        if (!length) {
          return source;
        }

        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
        details = details.join(length > 2 ? ', ' : ' ');
        return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
      }

      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }

      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
      }

      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }

        var type = typeof index;

        if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
          return eq(object[index], value);
        }

        return false;
      }

      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }

        var type = typeof value;

        if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
          return true;
        }

        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }

      function isKeyable(value) {
        var type = typeof value;
        return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
      }

      function isLaziable(func) {
        var funcName = getFuncName(func),
            other = lodash[funcName];

        if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
          return false;
        }

        if (func === other) {
          return true;
        }

        var data = getData(other);
        return !!data && func === data[0];
      }

      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }

      var isMaskable = coreJsData ? isFunction : stubFalse;

      function isPrototype(value) {
        var Ctor = value && value.constructor,
            proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
        return value === proto;
      }

      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }

      function matchesStrictComparable(key, srcValue) {
        return function (object) {
          if (object == null) {
            return false;
          }

          return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
        };
      }

      function memoizeCapped(func) {
        var result = memoize(func, function (key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }

          return key;
        });
        var cache = result.cache;
        return result;
      }

      function mergeData(data, source) {
        var bitmask = data[1],
            srcBitmask = source[1],
            newBitmask = bitmask | srcBitmask,
            isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;

        if (!(isCommon || isCombo)) {
          return data;
        }

        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }

        var value = source[3];

        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }

        value = source[5];

        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }

        value = source[7];

        if (value) {
          data[7] = value;
        }

        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }

        if (data[9] == null) {
          data[9] = source[9];
        }

        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }

      function nativeKeysIn(object) {
        var result = [];

        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }

        return result;
      }

      function objectToString(value) {
        return nativeObjectToString.call(value);
      }

      function overRest(func, start, transform) {
        start = nativeMax(start === undefined ? func.length - 1 : start, 0);
        return function () {
          var args = arguments,
              index = -1,
              length = nativeMax(args.length - start, 0),
              array = Array(length);

          while (++index < length) {
            array[index] = args[start + index];
          }

          index = -1;
          var otherArgs = Array(start + 1);

          while (++index < start) {
            otherArgs[index] = args[index];
          }

          otherArgs[start] = transform(array);
          return apply(func, this, otherArgs);
        };
      }

      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }

      function reorder(array, indexes) {
        var arrLength = array.length,
            length = nativeMin(indexes.length, arrLength),
            oldArray = copyArray(array);

        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
        }

        return array;
      }

      function safeGet(object, key) {
        if (key == '__proto__') {
          return;
        }

        return object[key];
      }

      var setData = shortOut(baseSetData);

      var setTimeout = ctxSetTimeout || function (func, wait) {
        return root.setTimeout(func, wait);
      };

      var setToString = shortOut(baseSetToString);

      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + '';
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }

      function shortOut(func) {
        var count = 0,
            lastCalled = 0;
        return function () {
          var stamp = nativeNow(),
              remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;

          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }

          return func.apply(undefined, arguments);
        };
      }

      function shuffleSelf(array, size) {
        var index = -1,
            length = array.length,
            lastIndex = length - 1;
        size = size === undefined ? length : size;

        while (++index < size) {
          var rand = baseRandom(index, lastIndex),
              value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }

        array.length = size;
        return array;
      }

      var stringToPath = memoizeCapped(function (string) {
        var result = [];

        if (string.charCodeAt(0) === 46) {
            result.push('');
          }

        string.replace(rePropName, function (match, number, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
        });
        return result;
      });

      function toKey(value) {
        if (typeof value == 'string' || isSymbol(value)) {
          return value;
        }

        var result = value + '';
        return result == '0' && 1 / value == -INFINITY ? '-0' : result;
      }

      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {}

          try {
            return func + '';
          } catch (e) {}
        }

        return '';
      }

      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function (pair) {
          var value = '_.' + pair[0];

          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }

      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }

        var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result.__actions__ = copyArray(wrapper.__actions__);
        result.__index__ = wrapper.__index__;
        result.__values__ = wrapper.__values__;
        return result;
      }

      function chunk(array, size, guard) {
        if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
          size = 1;
        } else {
          size = nativeMax(toInteger(size), 0);
        }

        var length = array == null ? 0 : array.length;

        if (!length || size < 1) {
          return [];
        }

        var index = 0,
            resIndex = 0,
            result = Array(nativeCeil(length / size));

        while (index < length) {
          result[resIndex++] = baseSlice(array, index, index += size);
        }

        return result;
      }

      function compact(array) {
        var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result = [];

        while (++index < length) {
          var value = array[index];

          if (value) {
            result[resIndex++] = value;
          }
        }

        return result;
      }

      function concat() {
        var length = arguments.length;

        if (!length) {
          return [];
        }

        var args = Array(length - 1),
            array = arguments[0],
            index = length;

        while (index--) {
          args[index - 1] = arguments[index];
        }

        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }

      var difference = baseRest(function (array, values) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function (array, values) {
        var iteratee = last(values);

        if (isArrayLikeObject(iteratee)) {
          iteratee = undefined;
        }

        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : [];
      });
      var differenceWith = baseRest(function (array, values) {
        var comparator = last(values);

        if (isArrayLikeObject(comparator)) {
          comparator = undefined;
        }

        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
      });

      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;

        if (!length) {
          return [];
        }

        n = guard || n === undefined ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }

      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;

        if (!length) {
          return [];
        }

        n = guard || n === undefined ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }

      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }

      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }

      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;

        if (!length) {
          return [];
        }

        if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }

        return baseFill(array, value, start, end);
      }

      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;

        if (!length) {
          return -1;
        }

        var index = fromIndex == null ? 0 : toInteger(fromIndex);

        if (index < 0) {
          index = nativeMax(length + index, 0);
        }

        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }

      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;

        if (!length) {
          return -1;
        }

        var index = length - 1;

        if (fromIndex !== undefined) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }

        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }

      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }

      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }

      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;

        if (!length) {
          return [];
        }

        depth = depth === undefined ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }

      function fromPairs(pairs) {
        var index = -1,
            length = pairs == null ? 0 : pairs.length,
            result = {};

        while (++index < length) {
          var pair = pairs[index];
          result[pair[0]] = pair[1];
        }

        return result;
      }

      function head(array) {
        return array && array.length ? array[0] : undefined;
      }

      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;

        if (!length) {
          return -1;
        }

        var index = fromIndex == null ? 0 : toInteger(fromIndex);

        if (index < 0) {
          index = nativeMax(length + index, 0);
        }

        return baseIndexOf(array, value, index);
      }

      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }

      var intersection = baseRest(function (arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function (arrays) {
        var iteratee = last(arrays),
            mapped = arrayMap(arrays, castArrayLikeObject);

        if (iteratee === last(mapped)) {
          iteratee = undefined;
        } else {
          mapped.pop();
        }

        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
      });
      var intersectionWith = baseRest(function (arrays) {
        var comparator = last(arrays),
            mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == 'function' ? comparator : undefined;

        if (comparator) {
          mapped.pop();
        }

        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
      });

      function join(array, separator) {
        return array == null ? '' : nativeJoin.call(array, separator);
      }

      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined;
      }

      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;

        if (!length) {
          return -1;
        }

        var index = length;

        if (fromIndex !== undefined) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }

        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }

      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined;
      }

      var pull = baseRest(pullAll);

      function pullAll(array, values) {
        return array && array.length && values && values.length ? basePullAll(array, values) : array;
      }

      function pullAllBy(array, values, iteratee) {
        return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array;
      }

      function pullAllWith(array, values, comparator) {
        return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
      }

      var pullAt = flatRest(function (array, indexes) {
        var length = array == null ? 0 : array.length,
            result = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function (index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result;
      });

      function remove(array, predicate) {
        var result = [];

        if (!(array && array.length)) {
          return result;
        }

        var index = -1,
            indexes = [],
            length = array.length;
        predicate = getIteratee(predicate, 3);

        while (++index < length) {
          var value = array[index];

          if (predicate(value, index, array)) {
            result.push(value);
            indexes.push(index);
          }
        }

        basePullAt(array, indexes);
        return result;
      }

      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }

      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;

        if (!length) {
          return [];
        }

        if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined ? length : toInteger(end);
        }

        return baseSlice(array, start, end);
      }

      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }

      function sortedIndexBy(array, value, iteratee) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
      }

      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;

        if (length) {
          var index = baseSortedIndex(array, value);

          if (index < length && eq(array[index], value)) {
            return index;
          }
        }

        return -1;
      }

      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }

      function sortedLastIndexBy(array, value, iteratee) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
      }

      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;

        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;

          if (eq(array[index], value)) {
            return index;
          }
        }

        return -1;
      }

      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }

      function sortedUniqBy(array, iteratee) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
      }

      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }

      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }

        n = guard || n === undefined ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }

      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;

        if (!length) {
          return [];
        }

        n = guard || n === undefined ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }

      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }

      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }

      var union = baseRest(function (arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function (arrays) {
        var iteratee = last(arrays);

        if (isArrayLikeObject(iteratee)) {
          iteratee = undefined;
        }

        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
      });
      var unionWith = baseRest(function (arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == 'function' ? comparator : undefined;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
      });

      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }

      function uniqBy(array, iteratee) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : [];
      }

      function uniqWith(array, comparator) {
        comparator = typeof comparator == 'function' ? comparator : undefined;
        return array && array.length ? baseUniq(array, undefined, comparator) : [];
      }

      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }

        var length = 0;
        array = arrayFilter(array, function (group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function (index) {
          return arrayMap(array, baseProperty(index));
        });
      }

      function unzipWith(array, iteratee) {
        if (!(array && array.length)) {
          return [];
        }

        var result = unzip(array);

        if (iteratee == null) {
          return result;
        }

        return arrayMap(result, function (group) {
          return apply(iteratee, undefined, group);
        });
      }

      var without = baseRest(function (array, values) {
        return isArrayLikeObject(array) ? baseDifference(array, values) : [];
      });
      var xor = baseRest(function (arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function (arrays) {
        var iteratee = last(arrays);

        if (isArrayLikeObject(iteratee)) {
          iteratee = undefined;
        }

        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
      });
      var xorWith = baseRest(function (arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == 'function' ? comparator : undefined;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
      });
      var zip = baseRest(unzip);

      function zipObject(props, values) {
        return baseZipObject(props || [], values || [], assignValue);
      }

      function zipObjectDeep(props, values) {
        return baseZipObject(props || [], values || [], baseSet);
      }

      var zipWith = baseRest(function (arrays) {
        var length = arrays.length,
            iteratee = length > 1 ? arrays[length - 1] : undefined;
        iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
        return unzipWith(arrays, iteratee);
      });

      function chain(value) {
        var result = lodash(value);
        result.__chain__ = true;
        return result;
      }

      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }

      function thru(value, interceptor) {
        return interceptor(value);
      }

      var wrapperAt = flatRest(function (paths) {
        var length = paths.length,
            start = length ? paths[0] : 0,
            value = this.__wrapped__,
            interceptor = function interceptor(object) {
          return baseAt(object, paths);
        };

        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }

        value = value.slice(start, +start + (length ? 1 : 0));

        value.__actions__.push({
          'func': thru,
          'args': [interceptor],
          'thisArg': undefined
        });

        return new LodashWrapper(value, this.__chain__).thru(function (array) {
          if (length && !array.length) {
            array.push(undefined);
          }

          return array;
        });
      });

      function wrapperChain() {
        return chain(this);
      }

      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }

      function wrapperNext() {
        if (this.__values__ === undefined) {
          this.__values__ = toArray(this.value());
        }

        var done = this.__index__ >= this.__values__.length,
            value = done ? undefined : this.__values__[this.__index__++];
        return {
          'done': done,
          'value': value
        };
      }

      function wrapperToIterator() {
        return this;
      }

      function wrapperPlant(value) {
        var result,
            parent = this;

        while (parent instanceof baseLodash) {
          var clone = wrapperClone(parent);
          clone.__index__ = 0;
          clone.__values__ = undefined;

          if (result) {
            previous.__wrapped__ = clone;
          } else {
            result = clone;
          }

          var previous = clone;
          parent = parent.__wrapped__;
        }

        previous.__wrapped__ = value;
        return result;
      }

      function wrapperReverse() {
        var value = this.__wrapped__;

        if (value instanceof LazyWrapper) {
          var wrapped = value;

          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }

          wrapped = wrapped.reverse();

          wrapped.__actions__.push({
            'func': thru,
            'args': [reverse],
            'thisArg': undefined
          });

          return new LodashWrapper(wrapped, this.__chain__);
        }

        return this.thru(reverse);
      }

      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }

      var countBy = createAggregator(function (result, value, key) {
        if (hasOwnProperty.call(result, key)) {
          ++result[key];
        } else {
          baseAssignValue(result, key, 1);
        }
      });

      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;

        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined;
        }

        return func(collection, getIteratee(predicate, 3));
      }

      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }

      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);

      function flatMap(collection, iteratee) {
        return baseFlatten(map(collection, iteratee), 1);
      }

      function flatMapDeep(collection, iteratee) {
        return baseFlatten(map(collection, iteratee), INFINITY);
      }

      function flatMapDepth(collection, iteratee, depth) {
        depth = depth === undefined ? 1 : toInteger(depth);
        return baseFlatten(map(collection, iteratee), depth);
      }

      function forEach(collection, iteratee) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee, 3));
      }

      function forEachRight(collection, iteratee) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee, 3));
      }

      var groupBy = createAggregator(function (result, value, key) {
        if (hasOwnProperty.call(result, key)) {
          result[key].push(value);
        } else {
          baseAssignValue(result, key, [value]);
        }
      });

      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;

        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }

        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }

      var invokeMap = baseRest(function (collection, path, args) {
        var index = -1,
            isFunc = typeof path == 'function',
            result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach(collection, function (value) {
          result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result;
      });
      var keyBy = createAggregator(function (result, value, key) {
        baseAssignValue(result, key, value);
      });

      function map(collection, iteratee) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee, 3));
      }

      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }

        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }

        orders = guard ? undefined : orders;

        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }

        return baseOrderBy(collection, iteratees, orders);
      }

      var partition = createAggregator(function (result, value, key) {
        result[key ? 0 : 1].push(value);
      }, function () {
        return [[], []];
      });

      function reduce(collection, iteratee, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce,
            initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
      }

      function reduceRight(collection, iteratee, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce,
            initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
      }

      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }

      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }

      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined) {
          n = 1;
        } else {
          n = toInteger(n);
        }

        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }

      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }

      function size(collection) {
        if (collection == null) {
          return 0;
        }

        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }

        var tag = getTag(collection);

        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }

        return baseKeys(collection).length;
      }

      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;

        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined;
        }

        return func(collection, getIteratee(predicate, 3));
      }

      var sortBy = baseRest(function (collection, iteratees) {
        if (collection == null) {
          return [];
        }

        var length = iteratees.length;

        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }

        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });

      var now = ctxNow || function () {
        return root.Date.now();
      };

      function after(n, func) {
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }

        n = toInteger(n);
        return function () {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }

      function ary(func, n, guard) {
        n = guard ? undefined : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
      }

      function before(n, func) {
        var result;

        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }

        n = toInteger(n);
        return function () {
          if (--n > 0) {
            result = func.apply(this, arguments);
          }

          if (n <= 1) {
            func = undefined;
          }

          return result;
        };
      }

      var bind = baseRest(function (func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;

        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }

        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function (object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;

        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }

        return createWrap(key, bitmask, object, partials, holders);
      });

      function curry(func, arity, guard) {
        arity = guard ? undefined : arity;
        var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
        result.placeholder = curry.placeholder;
        return result;
      }

      function curryRight(func, arity, guard) {
        arity = guard ? undefined : arity;
        var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
        result.placeholder = curryRight.placeholder;
        return result;
      }

      function debounce(func, wait, options) {
        var lastArgs,
            lastThis,
            maxWait,
            result,
            timerId,
            lastCallTime,
            lastInvokeTime = 0,
            leading = false,
            maxing = false,
            trailing = true;

        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }

        wait = toNumber(wait) || 0;

        if (isObject(options)) {
          leading = !!options.leading;
          maxing = 'maxWait' in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = 'trailing' in options ? !!options.trailing : trailing;
        }

        function invokeFunc(time) {
          var args = lastArgs,
              thisArg = lastThis;
          lastArgs = lastThis = undefined;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }

        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }

        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime,
              timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }

        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }

        function timerExpired() {
          var time = now();

          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }

          timerId = setTimeout(timerExpired, remainingWait(time));
        }

        function trailingEdge(time) {
          timerId = undefined;

          if (trailing && lastArgs) {
            return invokeFunc(time);
          }

          lastArgs = lastThis = undefined;
          return result;
        }

        function cancel() {
          if (timerId !== undefined) {
            clearTimeout(timerId);
          }

          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined;
        }

        function flush() {
          return timerId === undefined ? result : trailingEdge(now());
        }

        function debounced() {
          var time = now(),
              isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;

          if (isInvoking) {
            if (timerId === undefined) {
              return leadingEdge(lastCallTime);
            }

            if (maxing) {
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }

          if (timerId === undefined) {
            timerId = setTimeout(timerExpired, wait);
          }

          return result;
        }

        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }

      var defer = baseRest(function (func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function (func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });

      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }

      function memoize(func, resolver) {
        if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }

        var memoized = function memoized() {
          var args = arguments,
              key = resolver ? resolver.apply(this, args) : args[0],
              cache = memoized.cache;

          if (cache.has(key)) {
            return cache.get(key);
          }

          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };

        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }

      memoize.Cache = MapCache;

      function negate(predicate) {
        if (typeof predicate != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }

        return function () {
          var args = arguments;

          switch (args.length) {
            case 0:
              return !predicate.call(this);

            case 1:
              return !predicate.call(this, args[0]);

            case 2:
              return !predicate.call(this, args[0], args[1]);

            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }

          return !predicate.apply(this, args);
        };
      }

      function once(func) {
        return before(2, func);
      }

      var overArgs = castRest(function (func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function (args) {
          var index = -1,
              length = nativeMin(args.length, funcsLength);

          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }

          return apply(func, this, args);
        });
      });
      var partial = baseRest(function (func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
      });
      var partialRight = baseRest(function (func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
      });
      var rearg = flatRest(function (func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
      });

      function rest(func, start) {
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }

        start = start === undefined ? start : toInteger(start);
        return baseRest(func, start);
      }

      function spread(func, start) {
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }

        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function (args) {
          var array = args[start],
              otherArgs = castSlice(args, 0, start);

          if (array) {
            arrayPush(otherArgs, array);
          }

          return apply(func, this, otherArgs);
        });
      }

      function throttle(func, wait, options) {
        var leading = true,
            trailing = true;

        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }

        if (isObject(options)) {
          leading = 'leading' in options ? !!options.leading : leading;
          trailing = 'trailing' in options ? !!options.trailing : trailing;
        }

        return debounce(func, wait, {
          'leading': leading,
          'maxWait': wait,
          'trailing': trailing
        });
      }

      function unary(func) {
        return ary(func, 1);
      }

      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }

      function castArray() {
        if (!arguments.length) {
          return [];
        }

        var value = arguments[0];
        return isArray(value) ? value : [value];
      }

      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }

      function cloneWith(value, customizer) {
        customizer = typeof customizer == 'function' ? customizer : undefined;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }

      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }

      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == 'function' ? customizer : undefined;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }

      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }

      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }

      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function (value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function () {
        return arguments;
      }()) ? baseIsArguments : function (value) {
        return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
      };
      var isArray = Array.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }

      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }

      function isBoolean(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }

      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
      }

      function isEmpty(value) {
        if (value == null) {
          return true;
        }

        if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }

        var tag = getTag(value);

        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }

        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }

        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }

        return true;
      }

      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }

      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == 'function' ? customizer : undefined;
        var result = customizer ? customizer(value, other) : undefined;
        return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
      }

      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }

        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value);
      }

      function isFinite(value) {
        return typeof value == 'number' && nativeIsFinite(value);
      }

      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }

        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }

      function isInteger(value) {
        return typeof value == 'number' && value == toInteger(value);
      }

      function isLength(value) {
        return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }

      function isObject(value) {
        var type = typeof value;
        return value != null && (type == 'object' || type == 'function');
      }

      function isObjectLike(value) {
        return value != null && typeof value == 'object';
      }

      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }

      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == 'function' ? customizer : undefined;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }

      function isNaN(value) {
        return isNumber(value) && value != +value;
      }

      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error(CORE_ERROR_TEXT);
        }

        return baseIsNative(value);
      }

      function isNull(value) {
        return value === null;
      }

      function isNil(value) {
        return value == null;
      }

      function isNumber(value) {
        return typeof value == 'number' || isObjectLike(value) && baseGetTag(value) == numberTag;
      }

      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }

        var proto = getPrototype(value);

        if (proto === null) {
          return true;
        }

        var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
        return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }

      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }

      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

      function isString(value) {
        return typeof value == 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }

      function isSymbol(value) {
        return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }

      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

      function isUndefined(value) {
        return value === undefined;
      }

      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }

      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }

      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function (value, other) {
        return value <= other;
      });

      function toArray(value) {
        if (!value) {
          return [];
        }

        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }

        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }

        var tag = getTag(value),
            func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }

      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }

        value = toNumber(value);

        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }

        return value === value ? value : 0;
      }

      function toInteger(value) {
        var result = toFinite(value),
            remainder = result % 1;
        return result === result ? remainder ? result - remainder : result : 0;
      }

      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }

      function toNumber(value) {
        if (typeof value == 'number') {
          return value;
        }

        if (isSymbol(value)) {
          return NAN;
        }

        if (isObject(value)) {
          var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
          value = isObject(other) ? other + '' : other;
        }

        if (typeof value != 'string') {
          return value === 0 ? value : +value;
        }

        value = value.replace(reTrim, '');
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }

      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }

      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }

      function toString(value) {
        return value == null ? '' : baseToString(value);
      }

      var assign = createAssigner(function (object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }

        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function (object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function (object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = flatRest(baseAt);

      function create(prototype, properties) {
        var result = baseCreate(prototype);
        return properties == null ? result : baseAssign(result, properties);
      }

      var defaults = baseRest(function (object, sources) {
        object = Object(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }

        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;

          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];

            if (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              object[key] = source[key];
            }
          }
        }

        return object;
      });
      var defaultsDeep = baseRest(function (args) {
        args.push(undefined, customDefaultsMerge);
        return apply(mergeWith, undefined, args);
      });

      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }

      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }

      function forIn(object, iteratee) {
        return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
      }

      function forInRight(object, iteratee) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
      }

      function forOwn(object, iteratee) {
        return object && baseForOwn(object, getIteratee(iteratee, 3));
      }

      function forOwnRight(object, iteratee) {
        return object && baseForOwnRight(object, getIteratee(iteratee, 3));
      }

      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }

      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }

      function get(object, path, defaultValue) {
        var result = object == null ? undefined : baseGet(object, path);
        return result === undefined ? defaultValue : result;
      }

      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }

      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }

      var invert = createInverter(function (result, value, key) {
        if (value != null && typeof value.toString != 'function') {
          value = nativeObjectToString.call(value);
        }

        result[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function (result, value, key) {
        if (value != null && typeof value.toString != 'function') {
          value = nativeObjectToString.call(value);
        }

        if (hasOwnProperty.call(result, value)) {
          result[value].push(key);
        } else {
          result[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);

      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }

      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }

      function mapKeys(object, iteratee) {
        var result = {};
        iteratee = getIteratee(iteratee, 3);
        baseForOwn(object, function (value, key, object) {
          baseAssignValue(result, iteratee(value, key, object), value);
        });
        return result;
      }

      function mapValues(object, iteratee) {
        var result = {};
        iteratee = getIteratee(iteratee, 3);
        baseForOwn(object, function (value, key, object) {
          baseAssignValue(result, key, iteratee(value, key, object));
        });
        return result;
      }

      var merge = createAssigner(function (object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function (object, paths) {
        var result = {};

        if (object == null) {
          return result;
        }

        var isDeep = false;
        paths = arrayMap(paths, function (path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result);

        if (isDeep) {
          result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }

        var length = paths.length;

        while (length--) {
          baseUnset(result, paths[length]);
        }

        return result;
      });

      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }

      var pick = flatRest(function (object, paths) {
        return object == null ? {} : basePick(object, paths);
      });

      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }

        var props = arrayMap(getAllKeysIn(object), function (prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function (value, path) {
          return predicate(value, path[0]);
        });
      }

      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index = -1,
            length = path.length;

        if (!length) {
          length = 1;
          object = undefined;
        }

        while (++index < length) {
          var value = object == null ? undefined : object[toKey(path[index])];

          if (value === undefined) {
            index = length;
            value = defaultValue;
          }

          object = isFunction(value) ? value.call(object) : value;
        }

        return object;
      }

      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }

      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == 'function' ? customizer : undefined;
        return object == null ? object : baseSet(object, path, value, customizer);
      }

      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);

      function transform(object, iteratee, accumulator) {
        var isArr = isArray(object),
            isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee = getIteratee(iteratee, 4);

        if (accumulator == null) {
          var Ctor = object && object.constructor;

          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject(object)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }

        (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
          return iteratee(accumulator, value, index, object);
        });
        return accumulator;
      }

      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }

      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }

      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == 'function' ? customizer : undefined;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }

      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }

      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }

      function clamp(number, lower, upper) {
        if (upper === undefined) {
          upper = lower;
          lower = undefined;
        }

        if (upper !== undefined) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }

        if (lower !== undefined) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }

        return baseClamp(toNumber(number), lower, upper);
      }

      function inRange(number, start, end) {
        start = toFinite(start);

        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }

        number = toNumber(number);
        return baseInRange(number, start, end);
      }

      function random(lower, upper, floating) {
        if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined;
        }

        if (floating === undefined) {
          if (typeof upper == 'boolean') {
            floating = upper;
            upper = undefined;
          } else if (typeof lower == 'boolean') {
            floating = lower;
            lower = undefined;
          }
        }

        if (lower === undefined && upper === undefined) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);

          if (upper === undefined) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }

        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }

        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1))), upper);
        }

        return baseRandom(lower, upper);
      }

      var camelCase = createCompounder(function (result, word, index) {
        word = word.toLowerCase();
        return result + (index ? capitalize(word) : word);
      });

      function capitalize(string) {
        return upperFirst(toString(string).toLowerCase());
      }

      function deburr(string) {
        string = toString(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
      }

      function endsWith(string, target, position) {
        string = toString(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }

      function escape(string) {
        string = toString(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }

      function escapeRegExp(string) {
        string = toString(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, '\\$&') : string;
      }

      var kebabCase = createCompounder(function (result, word, index) {
        return result + (index ? '-' : '') + word.toLowerCase();
      });
      var lowerCase = createCompounder(function (result, word, index) {
        return result + (index ? ' ' : '') + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst('toLowerCase');

      function pad(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;

        if (!length || strLength >= length) {
          return string;
        }

        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }

      function padEnd(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }

      function padStart(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }

      function parseInt(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }

        return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
      }

      function repeat(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
          n = 1;
        } else {
          n = toInteger(n);
        }

        return baseRepeat(toString(string), n);
      }

      function replace() {
        var args = arguments,
            string = toString(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }

      var snakeCase = createCompounder(function (result, word, index) {
        return result + (index ? '_' : '') + word.toLowerCase();
      });

      function split(string, separator, limit) {
        if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined;
        }

        limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;

        if (!limit) {
          return [];
        }

        string = toString(string);

        if (string && (typeof separator == 'string' || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);

          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }

        return string.split(separator, limit);
      }

      var startCase = createCompounder(function (result, word, index) {
        return result + (index ? ' ' : '') + upperFirst(word);
      });

      function startsWith(string, target, position) {
        string = toString(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }

      function template(string, options, guard) {
        var settings = lodash.templateSettings;

        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined;
        }

        string = toString(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
            importsKeys = keys(imports),
            importsValues = baseValues(imports, importsKeys);
        var isEscaping,
            isEvaluating,
            index = 0,
            interpolate = options.interpolate || reNoMatch,
            source = "__p += '";
        var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
        var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : 'lodash.templateSources[' + ++templateCounter + ']') + '\n';
        string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }

          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }

          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }

          index = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = options.variable;

        if (!variable) {
          source = 'with (obj) {\n' + source + '\n}\n';
        }

        source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
        source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
        var result = attempt(function () {
          return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
        });
        result.source = source;

        if (isError(result)) {
          throw result;
        }

        return result;
      }

      function toLower(value) {
        return toString(value).toLowerCase();
      }

      function toUpper(value) {
        return toString(value).toUpperCase();
      }

      function trim(string, chars, guard) {
        string = toString(string);

        if (string && (guard || chars === undefined)) {
          return string.replace(reTrim, '');
        }

        if (!string || !(chars = baseToString(chars))) {
          return string;
        }

        var strSymbols = stringToArray(string),
            chrSymbols = stringToArray(chars),
            start = charsStartIndex(strSymbols, chrSymbols),
            end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join('');
      }

      function trimEnd(string, chars, guard) {
        string = toString(string);

        if (string && (guard || chars === undefined)) {
          return string.replace(reTrimEnd, '');
        }

        if (!string || !(chars = baseToString(chars))) {
          return string;
        }

        var strSymbols = stringToArray(string),
            end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join('');
      }

      function trimStart(string, chars, guard) {
        string = toString(string);

        if (string && (guard || chars === undefined)) {
          return string.replace(reTrimStart, '');
        }

        if (!string || !(chars = baseToString(chars))) {
          return string;
        }

        var strSymbols = stringToArray(string),
            start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join('');
      }

      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH,
            omission = DEFAULT_TRUNC_OMISSION;

        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? toInteger(options.length) : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        }

        string = toString(string);
        var strLength = string.length;

        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }

        if (length >= strLength) {
          return string;
        }

        var end = length - stringSize(omission);

        if (end < 1) {
          return omission;
        }

        var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end);

        if (separator === undefined) {
          return result + omission;
        }

        if (strSymbols) {
          end += result.length - end;
        }

        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match,
                substring = result;

            if (!separator.global) {
              separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
            }

            separator.lastIndex = 0;

            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }

            result = result.slice(0, newEnd === undefined ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result.lastIndexOf(separator);

          if (index > -1) {
            result = result.slice(0, index);
          }
        }

        return result + omission;
      }

      function unescape(string) {
        string = toString(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }

      var upperCase = createCompounder(function (result, word, index) {
        return result + (index ? ' ' : '') + word.toUpperCase();
      });
      var upperFirst = createCaseFirst('toUpperCase');

      function words(string, pattern, guard) {
        string = toString(string);
        pattern = guard ? undefined : pattern;

        if (pattern === undefined) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }

        return string.match(pattern) || [];
      }

      var attempt = baseRest(function (func, args) {
        try {
          return apply(func, undefined, args);
        } catch (e) {
          return isError(e) ? e : new Error(e);
        }
      });
      var bindAll = flatRest(function (object, methodNames) {
        arrayEach(methodNames, function (key) {
          key = toKey(key);
          baseAssignValue(object, key, bind(object[key], object));
        });
        return object;
      });

      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length,
            toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function (pair) {
          if (typeof pair[1] != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }

          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function (args) {
          var index = -1;

          while (++index < length) {
            var pair = pairs[index];

            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }

      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }

      function constant(value) {
        return function () {
          return value;
        };
      }

      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }

      var flow = createFlow();
      var flowRight = createFlow(true);

      function identity(value) {
        return value;
      }

      function iteratee(func) {
        return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
      }

      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }

      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }

      var method = baseRest(function (path, args) {
        return function (object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function (object, args) {
        return function (path) {
          return baseInvoke(object, path, args);
        };
      });

      function mixin(object, source, options) {
        var props = keys(source),
            methodNames = baseFunctions(source, props);

        if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }

        var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
            isFunc = isFunction(object);
        arrayEach(methodNames, function (methodName) {
          var func = source[methodName];
          object[methodName] = func;

          if (isFunc) {
            object.prototype[methodName] = function () {
              var chainAll = this.__chain__;

              if (chain || chainAll) {
                var result = object(this.__wrapped__),
                    actions = result.__actions__ = copyArray(this.__actions__);
                actions.push({
                  'func': func,
                  'args': arguments,
                  'thisArg': object
                });
                result.__chain__ = chainAll;
                return result;
              }

              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }

      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }

        return this;
      }

      function noop() {}

      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function (args) {
          return baseNth(args, n);
        });
      }

      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);

      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }

      function propertyOf(object) {
        return function (path) {
          return object == null ? undefined : baseGet(object, path);
        };
      }

      var range = createRange();
      var rangeRight = createRange(true);

      function stubArray() {
        return [];
      }

      function stubFalse() {
        return false;
      }

      function stubObject() {
        return {};
      }

      function stubString() {
        return '';
      }

      function stubTrue() {
        return true;
      }

      function times(n, iteratee) {
        n = toInteger(n);

        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }

        var index = MAX_ARRAY_LENGTH,
            length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee = getIteratee(iteratee);
        n -= MAX_ARRAY_LENGTH;
        var result = baseTimes(length, iteratee);

        while (++index < n) {
          iteratee(index);
        }

        return result;
      }

      function toPath(value) {
        if (isArray(value)) {
          return arrayMap(value, toKey);
        }

        return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
      }

      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }

      var add = createMathOperation(function (augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound('ceil');
      var divide = createMathOperation(function (dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound('floor');

      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
      }

      function maxBy(array, iteratee) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined;
      }

      function mean(array) {
        return baseMean(array, identity);
      }

      function meanBy(array, iteratee) {
        return baseMean(array, getIteratee(iteratee, 2));
      }

      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
      }

      function minBy(array, iteratee) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined;
      }

      var multiply = createMathOperation(function (multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound('round');
      var subtract = createMathOperation(function (minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);

      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }

      function sumBy(array, iteratee) {
        return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0;
      }

      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at;
      lodash.before = before;
      lodash.bind = bind;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.concat = concat;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter;
      lodash.flatMap = flatMap;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map;
      lodash.mapKeys = mapKeys;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit;
      lodash.omitBy = omitBy;
      lodash.once = once;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial;
      lodash.partialRight = partialRight;
      lodash.partition = partition;
      lodash.pick = pick;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject;
      lodash.remove = remove;
      lodash.rest = rest;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle;
      lodash.slice = slice;
      lodash.sortBy = sortBy;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform;
      lodash.unary = unary;
      lodash.union = union;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update;
      lodash.updateWith = updateWith;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap;
      lodash.xor = xor;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;
      mixin(lodash, lodash);
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize;
      lodash.ceil = ceil;
      lodash.clamp = clamp;
      lodash.clone = clone;
      lodash.cloneDeep = cloneDeep;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide;
      lodash.endsWith = endsWith;
      lodash.eq = eq;
      lodash.escape = escape;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor;
      lodash.forEach = forEach;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get;
      lodash.gt = gt;
      lodash.gte = gte;
      lodash.has = has;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isArrayBuffer = isArrayBuffer;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty;
      lodash.isEqual = isEqual;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError;
      lodash.isFinite = isFinite;
      lodash.isFunction = isFunction;
      lodash.isInteger = isInteger;
      lodash.isLength = isLength;
      lodash.isMap = isMap;
      lodash.isMatch = isMatch;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN;
      lodash.isNative = isNative;
      lodash.isNil = isNil;
      lodash.isNull = isNull;
      lodash.isNumber = isNumber;
      lodash.isObject = isObject;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject;
      lodash.isRegExp = isRegExp;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet;
      lodash.isString = isString;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt;
      lodash.lte = lte;
      lodash.max = max;
      lodash.maxBy = maxBy;
      lodash.mean = mean;
      lodash.meanBy = meanBy;
      lodash.min = min;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart;
      lodash.parseInt = parseInt;
      lodash.random = random;
      lodash.reduce = reduce;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.replace = replace;
      lodash.result = result;
      lodash.round = round;
      lodash.runInContext = runInContext;
      lodash.sample = sample;
      lodash.size = size;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.subtract = subtract;
      lodash.sum = sum;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString;
      lodash.toUpper = toUpper;
      lodash.trim = trim;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate;
      lodash.unescape = unescape;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;
      lodash.each = forEach;
      lodash.eachRight = forEachRight;
      lodash.first = head;
      mixin(lodash, function () {
        var source = {};
        baseForOwn(lodash, function (func, methodName) {
          if (!hasOwnProperty.call(lodash.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), {
        'chain': false
      });
      lodash.VERSION = VERSION;
      arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach(['drop', 'take'], function (methodName, index) {
        LazyWrapper.prototype[methodName] = function (n) {
          n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
          var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();

          if (result.__filtered__) {
            result.__takeCount__ = nativeMin(n, result.__takeCount__);
          } else {
            result.__views__.push({
              'size': nativeMin(n, MAX_ARRAY_LENGTH),
              'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
            });
          }

          return result;
        };

        LazyWrapper.prototype[methodName + 'Right'] = function (n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {
        var type = index + 1,
            isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

        LazyWrapper.prototype[methodName] = function (iteratee) {
          var result = this.clone();

          result.__iteratees__.push({
            'iteratee': getIteratee(iteratee, 3),
            'type': type
          });

          result.__filtered__ = result.__filtered__ || isFilter;
          return result;
        };
      });
      arrayEach(['head', 'last'], function (methodName, index) {
        var takeName = 'take' + (index ? 'Right' : '');

        LazyWrapper.prototype[methodName] = function () {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(['initial', 'tail'], function (methodName, index) {
        var dropName = 'drop' + (index ? '' : 'Right');

        LazyWrapper.prototype[methodName] = function () {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });

      LazyWrapper.prototype.compact = function () {
        return this.filter(identity);
      };

      LazyWrapper.prototype.find = function (predicate) {
        return this.filter(predicate).head();
      };

      LazyWrapper.prototype.findLast = function (predicate) {
        return this.reverse().find(predicate);
      };

      LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
        if (typeof path == 'function') {
          return new LazyWrapper(this);
        }

        return this.map(function (value) {
          return baseInvoke(value, path, args);
        });
      });

      LazyWrapper.prototype.reject = function (predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };

      LazyWrapper.prototype.slice = function (start, end) {
        start = toInteger(start);
        var result = this;

        if (result.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result);
        }

        if (start < 0) {
          result = result.takeRight(-start);
        } else if (start) {
          result = result.drop(start);
        }

        if (end !== undefined) {
          end = toInteger(end);
          result = end < 0 ? result.dropRight(-end) : result.take(end - start);
        }

        return result;
      };

      LazyWrapper.prototype.takeRightWhile = function (predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };

      LazyWrapper.prototype.toArray = function () {
        return this.take(MAX_ARRAY_LENGTH);
      };

      baseForOwn(LazyWrapper.prototype, function (func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
            isTaker = /^(?:head|last)$/.test(methodName),
            lodashFunc = lodash[isTaker ? 'take' + (methodName == 'last' ? 'Right' : '') : methodName],
            retUnwrapped = isTaker || /^find/.test(methodName);

        if (!lodashFunc) {
          return;
        }

        lodash.prototype[methodName] = function () {
          var value = this.__wrapped__,
              args = isTaker ? [1] : arguments,
              isLazy = value instanceof LazyWrapper,
              iteratee = args[0],
              useLazy = isLazy || isArray(value);

          var interceptor = function interceptor(value) {
            var result = lodashFunc.apply(lodash, arrayPush([value], args));
            return isTaker && chainAll ? result[0] : result;
          };

          if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
            isLazy = useLazy = false;
          }

          var chainAll = this.__chain__,
              isHybrid = !!this.__actions__.length,
              isUnwrapped = retUnwrapped && !chainAll,
              onlyLazy = isLazy && !isHybrid;

          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result = func.apply(value, args);

            result.__actions__.push({
              'func': thru,
              'args': [interceptor],
              'thisArg': undefined
            });

            return new LodashWrapper(result, chainAll);
          }

          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }

          result = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result;
        };
      });
      arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function (methodName) {
        var func = arrayProto[methodName],
            chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
            retUnwrapped = /^(?:pop|shift)$/.test(methodName);

        lodash.prototype[methodName] = function () {
          var args = arguments;

          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
          }

          return this[chainName](function (value) {
            return func.apply(isArray(value) ? value : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function (func, methodName) {
        var lodashFunc = lodash[methodName];

        if (lodashFunc) {
          var key = lodashFunc.name + '',
              names = realNames[key] || (realNames[key] = []);
          names.push({
            'name': methodName,
            'func': lodashFunc
          });
        }
      });
      realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
        'name': 'wrapper',
        'func': undefined
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
      lodash.prototype.first = lodash.prototype.head;

      if (symIterator) {
        lodash.prototype[symIterator] = wrapperToIterator;
      }

      return lodash;
    };

    var _ = runInContext();

    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      root._ = _;
      define(function () {
        return _;
      });
    } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
  }).call(this);
},37,[],"node_modules\\lodash\\lodash.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var keys = _$$_REQUIRE(_dependencyMap[0], "./constants/metadata_keys");

  exports.METADATA_KEY = keys;

  var container_1 = _$$_REQUIRE(_dependencyMap[1], "./container/container");

  exports.Container = container_1.Container;

  var literal_types_1 = _$$_REQUIRE(_dependencyMap[2], "./constants/literal_types");

  exports.BindingScopeEnum = literal_types_1.BindingScopeEnum;
  exports.BindingTypeEnum = literal_types_1.BindingTypeEnum;
  exports.TargetTypeEnum = literal_types_1.TargetTypeEnum;

  var container_module_1 = _$$_REQUIRE(_dependencyMap[3], "./container/container_module");

  exports.AsyncContainerModule = container_module_1.AsyncContainerModule;
  exports.ContainerModule = container_module_1.ContainerModule;

  var injectable_1 = _$$_REQUIRE(_dependencyMap[4], "./annotation/injectable");

  exports.injectable = injectable_1.injectable;

  var tagged_1 = _$$_REQUIRE(_dependencyMap[5], "./annotation/tagged");

  exports.tagged = tagged_1.tagged;

  var named_1 = _$$_REQUIRE(_dependencyMap[6], "./annotation/named");

  exports.named = named_1.named;

  var inject_1 = _$$_REQUIRE(_dependencyMap[7], "./annotation/inject");

  exports.inject = inject_1.inject;
  exports.LazyServiceIdentifer = inject_1.LazyServiceIdentifer;

  var optional_1 = _$$_REQUIRE(_dependencyMap[8], "./annotation/optional");

  exports.optional = optional_1.optional;

  var unmanaged_1 = _$$_REQUIRE(_dependencyMap[9], "./annotation/unmanaged");

  exports.unmanaged = unmanaged_1.unmanaged;

  var multi_inject_1 = _$$_REQUIRE(_dependencyMap[10], "./annotation/multi_inject");

  exports.multiInject = multi_inject_1.multiInject;

  var target_name_1 = _$$_REQUIRE(_dependencyMap[11], "./annotation/target_name");

  exports.targetName = target_name_1.targetName;

  var post_construct_1 = _$$_REQUIRE(_dependencyMap[12], "./annotation/post_construct");

  exports.postConstruct = post_construct_1.postConstruct;

  var metadata_reader_1 = _$$_REQUIRE(_dependencyMap[13], "./planning/metadata_reader");

  exports.MetadataReader = metadata_reader_1.MetadataReader;

  var id_1 = _$$_REQUIRE(_dependencyMap[14], "./utils/id");

  exports.id = id_1.id;

  var decorator_utils_1 = _$$_REQUIRE(_dependencyMap[15], "./annotation/decorator_utils");

  exports.decorate = decorator_utils_1.decorate;

  var constraint_helpers_1 = _$$_REQUIRE(_dependencyMap[16], "./syntax/constraint_helpers");

  exports.traverseAncerstors = constraint_helpers_1.traverseAncerstors;
  exports.taggedConstraint = constraint_helpers_1.taggedConstraint;
  exports.namedConstraint = constraint_helpers_1.namedConstraint;
  exports.typeConstraint = constraint_helpers_1.typeConstraint;

  var serialization_1 = _$$_REQUIRE(_dependencyMap[17], "./utils/serialization");

  exports.getServiceIdentifierAsString = serialization_1.getServiceIdentifierAsString;

  var binding_utils_1 = _$$_REQUIRE(_dependencyMap[18], "./utils/binding_utils");

  exports.multiBindToService = binding_utils_1.multiBindToService;
},38,[39,40,42,70,71,72,73,54,74,75,76,77,78,45,43,55,67,49,79],"node_modules\\inversify\\lib\\inversify.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NAMED_TAG = "named";
  exports.NAME_TAG = "name";
  exports.UNMANAGED_TAG = "unmanaged";
  exports.OPTIONAL_TAG = "optional";
  exports.INJECT_TAG = "inject";
  exports.MULTI_INJECT_TAG = "multi_inject";
  exports.TAGGED = "inversify:tagged";
  exports.TAGGED_PROP = "inversify:tagged_props";
  exports.PARAM_TYPES = "inversify:paramtypes";
  exports.DESIGN_PARAM_TYPES = "design:paramtypes";
  exports.POST_CONSTRUCT = "post_construct";
},39,[],"node_modules\\inversify\\lib\\constants\\metadata_keys.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : new P(function (resolve) {
          resolve(result.value);
        }).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator = this && this.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [0, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var binding_1 = _$$_REQUIRE(_dependencyMap[0], "../bindings/binding");

  var ERROR_MSGS = _$$_REQUIRE(_dependencyMap[1], "../constants/error_msgs");

  var literal_types_1 = _$$_REQUIRE(_dependencyMap[2], "../constants/literal_types");

  var METADATA_KEY = _$$_REQUIRE(_dependencyMap[3], "../constants/metadata_keys");

  var metadata_reader_1 = _$$_REQUIRE(_dependencyMap[4], "../planning/metadata_reader");

  var planner_1 = _$$_REQUIRE(_dependencyMap[5], "../planning/planner");

  var resolver_1 = _$$_REQUIRE(_dependencyMap[6], "../resolution/resolver");

  var binding_to_syntax_1 = _$$_REQUIRE(_dependencyMap[7], "../syntax/binding_to_syntax");

  var id_1 = _$$_REQUIRE(_dependencyMap[8], "../utils/id");

  var serialization_1 = _$$_REQUIRE(_dependencyMap[9], "../utils/serialization");

  var container_snapshot_1 = _$$_REQUIRE(_dependencyMap[10], "./container_snapshot");

  var lookup_1 = _$$_REQUIRE(_dependencyMap[11], "./lookup");

  var Container = function () {
    function Container(containerOptions) {
      var options = containerOptions || {};

      if (typeof options !== "object") {
        throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT);
      }

      if (options.defaultScope === undefined) {
        options.defaultScope = literal_types_1.BindingScopeEnum.Transient;
      } else if (options.defaultScope !== literal_types_1.BindingScopeEnum.Singleton && options.defaultScope !== literal_types_1.BindingScopeEnum.Transient && options.defaultScope !== literal_types_1.BindingScopeEnum.Request) {
        throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE);
      }

      if (options.autoBindInjectable === undefined) {
        options.autoBindInjectable = false;
      } else if (typeof options.autoBindInjectable !== "boolean") {
        throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE);
      }

      if (options.skipBaseClassChecks === undefined) {
        options.skipBaseClassChecks = false;
      } else if (typeof options.skipBaseClassChecks !== "boolean") {
        throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK);
      }

      this.options = {
        autoBindInjectable: options.autoBindInjectable,
        defaultScope: options.defaultScope,
        skipBaseClassChecks: options.skipBaseClassChecks
      };
      this.id = id_1.id();
      this._bindingDictionary = new lookup_1.Lookup();
      this._snapshots = [];
      this._middleware = null;
      this.parent = null;
      this._metadataReader = new metadata_reader_1.MetadataReader();
    }

    Container.merge = function (container1, container2) {
      var container = new Container();
      var bindingDictionary = planner_1.getBindingDictionary(container);
      var bindingDictionary1 = planner_1.getBindingDictionary(container1);
      var bindingDictionary2 = planner_1.getBindingDictionary(container2);

      function copyDictionary(origin, destination) {
        origin.traverse(function (key, value) {
          value.forEach(function (binding) {
            destination.add(binding.serviceIdentifier, binding.clone());
          });
        });
      }

      copyDictionary(bindingDictionary1, bindingDictionary);
      copyDictionary(bindingDictionary2, bindingDictionary);
      return container;
    };

    Container.prototype.load = function () {
      var modules = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        modules[_i] = arguments[_i];
      }

      var getHelpers = this._getContainerModuleHelpersFactory();

      for (var _a = 0, modules_1 = modules; _a < modules_1.length; _a++) {
        var currentModule = modules_1[_a];
        var containerModuleHelpers = getHelpers(currentModule.id);
        currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction);
      }
    };

    Container.prototype.loadAsync = function () {
      var modules = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        modules[_i] = arguments[_i];
      }

      return __awaiter(this, void 0, void 0, function () {
        var getHelpers, _a, modules_2, currentModule, containerModuleHelpers;

        return __generator(this, function (_b) {
          switch (_b.label) {
            case 0:
              getHelpers = this._getContainerModuleHelpersFactory();
              _a = 0, modules_2 = modules;
              _b.label = 1;

            case 1:
              if (!(_a < modules_2.length)) return [3, 4];
              currentModule = modules_2[_a];
              containerModuleHelpers = getHelpers(currentModule.id);
              return [4, currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction)];

            case 2:
              _b.sent();

              _b.label = 3;

            case 3:
              _a++;
              return [3, 1];

            case 4:
              return [2];
          }
        });
      });
    };

    Container.prototype.unload = function () {
      var _this = this;

      var modules = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        modules[_i] = arguments[_i];
      }

      var conditionFactory = function conditionFactory(expected) {
        return function (item) {
          return item.moduleId === expected;
        };
      };

      modules.forEach(function (module) {
        var condition = conditionFactory(module.id);

        _this._bindingDictionary.removeByCondition(condition);
      });
    };

    Container.prototype.bind = function (serviceIdentifier) {
      var scope = this.options.defaultScope || literal_types_1.BindingScopeEnum.Transient;
      var binding = new binding_1.Binding(serviceIdentifier, scope);

      this._bindingDictionary.add(serviceIdentifier, binding);

      return new binding_to_syntax_1.BindingToSyntax(binding);
    };

    Container.prototype.rebind = function (serviceIdentifier) {
      this.unbind(serviceIdentifier);
      return this.bind(serviceIdentifier);
    };

    Container.prototype.unbind = function (serviceIdentifier) {
      try {
        this._bindingDictionary.remove(serviceIdentifier);
      } catch (e) {
        throw new Error(ERROR_MSGS.CANNOT_UNBIND + " " + serialization_1.getServiceIdentifierAsString(serviceIdentifier));
      }
    };

    Container.prototype.unbindAll = function () {
      this._bindingDictionary = new lookup_1.Lookup();
    };

    Container.prototype.isBound = function (serviceIdentifier) {
      var bound = this._bindingDictionary.hasKey(serviceIdentifier);

      if (!bound && this.parent) {
        bound = this.parent.isBound(serviceIdentifier);
      }

      return bound;
    };

    Container.prototype.isBoundNamed = function (serviceIdentifier, named) {
      return this.isBoundTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
    };

    Container.prototype.isBoundTagged = function (serviceIdentifier, key, value) {
      var bound = false;

      if (this._bindingDictionary.hasKey(serviceIdentifier)) {
        var bindings = this._bindingDictionary.get(serviceIdentifier);

        var request_1 = planner_1.createMockRequest(this, serviceIdentifier, key, value);
        bound = bindings.some(function (b) {
          return b.constraint(request_1);
        });
      }

      if (!bound && this.parent) {
        bound = this.parent.isBoundTagged(serviceIdentifier, key, value);
      }

      return bound;
    };

    Container.prototype.snapshot = function () {
      this._snapshots.push(container_snapshot_1.ContainerSnapshot.of(this._bindingDictionary.clone(), this._middleware));
    };

    Container.prototype.restore = function () {
      var snapshot = this._snapshots.pop();

      if (snapshot === undefined) {
        throw new Error(ERROR_MSGS.NO_MORE_SNAPSHOTS_AVAILABLE);
      }

      this._bindingDictionary = snapshot.bindings;
      this._middleware = snapshot.middleware;
    };

    Container.prototype.createChild = function (containerOptions) {
      var child = new Container(containerOptions || this.options);
      child.parent = this;
      return child;
    };

    Container.prototype.applyMiddleware = function () {
      var middlewares = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        middlewares[_i] = arguments[_i];
      }

      var initial = this._middleware ? this._middleware : this._planAndResolve();
      this._middleware = middlewares.reduce(function (prev, curr) {
        return curr(prev);
      }, initial);
    };

    Container.prototype.applyCustomMetadataReader = function (metadataReader) {
      this._metadataReader = metadataReader;
    };

    Container.prototype.get = function (serviceIdentifier) {
      return this._get(false, false, literal_types_1.TargetTypeEnum.Variable, serviceIdentifier);
    };

    Container.prototype.getTagged = function (serviceIdentifier, key, value) {
      return this._get(false, false, literal_types_1.TargetTypeEnum.Variable, serviceIdentifier, key, value);
    };

    Container.prototype.getNamed = function (serviceIdentifier, named) {
      return this.getTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
    };

    Container.prototype.getAll = function (serviceIdentifier) {
      return this._get(true, true, literal_types_1.TargetTypeEnum.Variable, serviceIdentifier);
    };

    Container.prototype.getAllTagged = function (serviceIdentifier, key, value) {
      return this._get(false, true, literal_types_1.TargetTypeEnum.Variable, serviceIdentifier, key, value);
    };

    Container.prototype.getAllNamed = function (serviceIdentifier, named) {
      return this.getAllTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
    };

    Container.prototype.resolve = function (constructorFunction) {
      var tempContainer = this.createChild();
      tempContainer.bind(constructorFunction).toSelf();
      return tempContainer.get(constructorFunction);
    };

    Container.prototype._getContainerModuleHelpersFactory = function () {
      var _this = this;

      var setModuleId = function setModuleId(bindingToSyntax, moduleId) {
        bindingToSyntax._binding.moduleId = moduleId;
      };

      var getBindFunction = function getBindFunction(moduleId) {
        return function (serviceIdentifier) {
          var _bind = _this.bind.bind(_this);

          var bindingToSyntax = _bind(serviceIdentifier);

          setModuleId(bindingToSyntax, moduleId);
          return bindingToSyntax;
        };
      };

      var getUnbindFunction = function getUnbindFunction(moduleId) {
        return function (serviceIdentifier) {
          var _unbind = _this.unbind.bind(_this);

          _unbind(serviceIdentifier);
        };
      };

      var getIsboundFunction = function getIsboundFunction(moduleId) {
        return function (serviceIdentifier) {
          var _isBound = _this.isBound.bind(_this);

          return _isBound(serviceIdentifier);
        };
      };

      var getRebindFunction = function getRebindFunction(moduleId) {
        return function (serviceIdentifier) {
          var _rebind = _this.rebind.bind(_this);

          var bindingToSyntax = _rebind(serviceIdentifier);

          setModuleId(bindingToSyntax, moduleId);
          return bindingToSyntax;
        };
      };

      return function (mId) {
        return {
          bindFunction: getBindFunction(mId),
          isboundFunction: getIsboundFunction(mId),
          rebindFunction: getRebindFunction(mId),
          unbindFunction: getUnbindFunction(mId)
        };
      };
    };

    Container.prototype._get = function (avoidConstraints, isMultiInject, targetType, serviceIdentifier, key, value) {
      var result = null;
      var defaultArgs = {
        avoidConstraints: avoidConstraints,
        contextInterceptor: function contextInterceptor(context) {
          return context;
        },
        isMultiInject: isMultiInject,
        key: key,
        serviceIdentifier: serviceIdentifier,
        targetType: targetType,
        value: value
      };

      if (this._middleware) {
        result = this._middleware(defaultArgs);

        if (result === undefined || result === null) {
          throw new Error(ERROR_MSGS.INVALID_MIDDLEWARE_RETURN);
        }
      } else {
        result = this._planAndResolve()(defaultArgs);
      }

      return result;
    };

    Container.prototype._planAndResolve = function () {
      var _this = this;

      return function (args) {
        var context = planner_1.plan(_this._metadataReader, _this, args.isMultiInject, args.targetType, args.serviceIdentifier, args.key, args.value, args.avoidConstraints);
        context = args.contextInterceptor(context);
        var result = resolver_1.resolve(context);
        return result;
      };
    };

    return Container;
  }();

  exports.Container = Container;
},40,[41,44,42,39,45,46,59,61,43,49,68,69],"node_modules\\inversify\\lib\\container\\container.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var literal_types_1 = _$$_REQUIRE(_dependencyMap[0], "../constants/literal_types");

  var id_1 = _$$_REQUIRE(_dependencyMap[1], "../utils/id");

  var Binding = function () {
    function Binding(serviceIdentifier, scope) {
      this.id = id_1.id();
      this.activated = false;
      this.serviceIdentifier = serviceIdentifier;
      this.scope = scope;
      this.type = literal_types_1.BindingTypeEnum.Invalid;

      this.constraint = function (request) {
        return true;
      };

      this.implementationType = null;
      this.cache = null;
      this.factory = null;
      this.provider = null;
      this.onActivation = null;
      this.dynamicValue = null;
    }

    Binding.prototype.clone = function () {
      var clone = new Binding(this.serviceIdentifier, this.scope);
      clone.activated = false;
      clone.implementationType = this.implementationType;
      clone.dynamicValue = this.dynamicValue;
      clone.scope = this.scope;
      clone.type = this.type;
      clone.factory = this.factory;
      clone.provider = this.provider;
      clone.constraint = this.constraint;
      clone.onActivation = this.onActivation;
      clone.cache = this.cache;
      return clone;
    };

    return Binding;
  }();

  exports.Binding = Binding;
},41,[42,43],"node_modules\\inversify\\lib\\bindings\\binding.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var BindingScopeEnum = {
    Request: "Request",
    Singleton: "Singleton",
    Transient: "Transient"
  };
  exports.BindingScopeEnum = BindingScopeEnum;
  var BindingTypeEnum = {
    ConstantValue: "ConstantValue",
    Constructor: "Constructor",
    DynamicValue: "DynamicValue",
    Factory: "Factory",
    Function: "Function",
    Instance: "Instance",
    Invalid: "Invalid",
    Provider: "Provider"
  };
  exports.BindingTypeEnum = BindingTypeEnum;
  var TargetTypeEnum = {
    ClassProperty: "ClassProperty",
    ConstructorArgument: "ConstructorArgument",
    Variable: "Variable"
  };
  exports.TargetTypeEnum = TargetTypeEnum;
},42,[],"node_modules\\inversify\\lib\\constants\\literal_types.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var idCounter = 0;

  function id() {
    return idCounter++;
  }

  exports.id = id;
},43,[],"node_modules\\inversify\\lib\\utils\\id.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DUPLICATED_INJECTABLE_DECORATOR = "Cannot apply @injectable decorator multiple times.";
  exports.DUPLICATED_METADATA = "Metadata key was used more than once in a parameter:";
  exports.NULL_ARGUMENT = "NULL argument";
  exports.KEY_NOT_FOUND = "Key Not Found";
  exports.AMBIGUOUS_MATCH = "Ambiguous match found for serviceIdentifier:";
  exports.CANNOT_UNBIND = "Could not unbind serviceIdentifier:";
  exports.NOT_REGISTERED = "No matching bindings found for serviceIdentifier:";
  exports.MISSING_INJECTABLE_ANNOTATION = "Missing required @injectable annotation in:";
  exports.MISSING_INJECT_ANNOTATION = "Missing required @inject or @multiInject annotation in:";

  exports.UNDEFINED_INJECT_ANNOTATION = function (name) {
    return "@inject called with undefined this could mean that the class " + name + " has " + "a circular dependency problem. You can use a LazyServiceIdentifer to  " + "overcome this limitation.";
  };

  exports.CIRCULAR_DEPENDENCY = "Circular dependency found:";
  exports.NOT_IMPLEMENTED = "Sorry, this feature is not fully implemented yet.";
  exports.INVALID_BINDING_TYPE = "Invalid binding type:";
  exports.NO_MORE_SNAPSHOTS_AVAILABLE = "No snapshot available to restore.";
  exports.INVALID_MIDDLEWARE_RETURN = "Invalid return type in middleware. Middleware must return!";
  exports.INVALID_FUNCTION_BINDING = "Value provided to function binding must be a function!";
  exports.INVALID_TO_SELF_VALUE = "The toSelf function can only be applied when a constructor is " + "used as service identifier";
  exports.INVALID_DECORATOR_OPERATION = "The @inject @multiInject @tagged and @named decorators " + "must be applied to the parameters of a class constructor or a class property.";

  exports.ARGUMENTS_LENGTH_MISMATCH = function () {
    var values = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }

    return "The number of constructor arguments in the derived class " + (values[0] + " must be >= than the number of constructor arguments of its base class.");
  };

  exports.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = "Invalid Container constructor argument. Container options " + "must be an object.";
  exports.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = "Invalid Container option. Default scope must " + "be a string ('singleton' or 'transient').";
  exports.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = "Invalid Container option. Auto bind injectable must " + "be a boolean";
  exports.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = "Invalid Container option. Skip base check must " + "be a boolean";
  exports.MULTIPLE_POST_CONSTRUCT_METHODS = "Cannot apply @postConstruct decorator multiple times in the same class";

  exports.POST_CONSTRUCT_ERROR = function () {
    var values = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }

    return "@postConstruct error in class " + values[0] + ": " + values[1];
  };

  exports.CIRCULAR_DEPENDENCY_IN_FACTORY = function () {
    var values = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }

    return "It looks like there is a circular dependency " + ("in one of the '" + values[0] + "' bindings. Please investigate bindings with") + ("service identifier '" + values[1] + "'.");
  };

  exports.STACK_OVERFLOW = "Maximum call stack size exceeded";
},44,[],"node_modules\\inversify\\lib\\constants\\error_msgs.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var METADATA_KEY = _$$_REQUIRE(_dependencyMap[0], "../constants/metadata_keys");

  var MetadataReader = function () {
    function MetadataReader() {}

    MetadataReader.prototype.getConstructorMetadata = function (constructorFunc) {
      var compilerGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.PARAM_TYPES, constructorFunc);
      var userGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED, constructorFunc);
      return {
        compilerGeneratedMetadata: compilerGeneratedMetadata,
        userGeneratedMetadata: userGeneratedMetadata || {}
      };
    };

    MetadataReader.prototype.getPropertiesMetadata = function (constructorFunc) {
      var userGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED_PROP, constructorFunc) || [];
      return userGeneratedMetadata;
    };

    return MetadataReader;
  }();

  exports.MetadataReader = MetadataReader;
},45,[39],"node_modules\\inversify\\lib\\planning\\metadata_reader.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var binding_count_1 = _$$_REQUIRE(_dependencyMap[0], "../bindings/binding_count");

  var ERROR_MSGS = _$$_REQUIRE(_dependencyMap[1], "../constants/error_msgs");

  var literal_types_1 = _$$_REQUIRE(_dependencyMap[2], "../constants/literal_types");

  var METADATA_KEY = _$$_REQUIRE(_dependencyMap[3], "../constants/metadata_keys");

  var exceptions_1 = _$$_REQUIRE(_dependencyMap[4], "../utils/exceptions");

  var serialization_1 = _$$_REQUIRE(_dependencyMap[5], "../utils/serialization");

  var context_1 = _$$_REQUIRE(_dependencyMap[6], "./context");

  var metadata_1 = _$$_REQUIRE(_dependencyMap[7], "./metadata");

  var plan_1 = _$$_REQUIRE(_dependencyMap[8], "./plan");

  var reflection_utils_1 = _$$_REQUIRE(_dependencyMap[9], "./reflection_utils");

  var request_1 = _$$_REQUIRE(_dependencyMap[10], "./request");

  var target_1 = _$$_REQUIRE(_dependencyMap[11], "./target");

  function getBindingDictionary(cntnr) {
    return cntnr._bindingDictionary;
  }

  exports.getBindingDictionary = getBindingDictionary;

  function _createTarget(isMultiInject, targetType, serviceIdentifier, name, key, value) {
    var metadataKey = isMultiInject ? METADATA_KEY.MULTI_INJECT_TAG : METADATA_KEY.INJECT_TAG;
    var injectMetadata = new metadata_1.Metadata(metadataKey, serviceIdentifier);
    var target = new target_1.Target(targetType, name, serviceIdentifier, injectMetadata);

    if (key !== undefined) {
      var tagMetadata = new metadata_1.Metadata(key, value);
      target.metadata.push(tagMetadata);
    }

    return target;
  }

  function _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target) {
    var bindings = getBindings(context.container, target.serviceIdentifier);
    var activeBindings = [];

    if (bindings.length === binding_count_1.BindingCount.NoBindingsAvailable && context.container.options.autoBindInjectable && typeof target.serviceIdentifier === "function" && metadataReader.getConstructorMetadata(target.serviceIdentifier).compilerGeneratedMetadata) {
      context.container.bind(target.serviceIdentifier).toSelf();
      bindings = getBindings(context.container, target.serviceIdentifier);
    }

    if (!avoidConstraints) {
      activeBindings = bindings.filter(function (binding) {
        var request = new request_1.Request(binding.serviceIdentifier, context, parentRequest, binding, target);
        return binding.constraint(request);
      });
    } else {
      activeBindings = bindings;
    }

    _validateActiveBindingCount(target.serviceIdentifier, activeBindings, target, context.container);

    return activeBindings;
  }

  function _validateActiveBindingCount(serviceIdentifier, bindings, target, container) {
    switch (bindings.length) {
      case binding_count_1.BindingCount.NoBindingsAvailable:
        if (target.isOptional()) {
          return bindings;
        } else {
          var serviceIdentifierString = serialization_1.getServiceIdentifierAsString(serviceIdentifier);
          var msg = ERROR_MSGS.NOT_REGISTERED;
          msg += serialization_1.listMetadataForTarget(serviceIdentifierString, target);
          msg += serialization_1.listRegisteredBindingsForServiceIdentifier(container, serviceIdentifierString, getBindings);
          throw new Error(msg);
        }

      case binding_count_1.BindingCount.OnlyOneBindingAvailable:
        if (!target.isArray()) {
          return bindings;
        }

      case binding_count_1.BindingCount.MultipleBindingsAvailable:
      default:
        if (!target.isArray()) {
          var serviceIdentifierString = serialization_1.getServiceIdentifierAsString(serviceIdentifier);
          var msg = ERROR_MSGS.AMBIGUOUS_MATCH + " " + serviceIdentifierString;
          msg += serialization_1.listRegisteredBindingsForServiceIdentifier(container, serviceIdentifierString, getBindings);
          throw new Error(msg);
        } else {
          return bindings;
        }

    }
  }

  function _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, parentRequest, target) {
    var activeBindings;
    var childRequest;

    if (parentRequest === null) {
      activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, null, target);
      childRequest = new request_1.Request(serviceIdentifier, context, null, activeBindings, target);
      var thePlan = new plan_1.Plan(context, childRequest);
      context.addPlan(thePlan);
    } else {
      activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target);
      childRequest = parentRequest.addChildRequest(target.serviceIdentifier, activeBindings, target);
    }

    activeBindings.forEach(function (binding) {
      var subChildRequest = null;

      if (target.isArray()) {
        subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);
      } else {
        if (binding.cache) {
          return;
        }

        subChildRequest = childRequest;
      }

      if (binding.type === literal_types_1.BindingTypeEnum.Instance && binding.implementationType !== null) {
        var dependencies = reflection_utils_1.getDependencies(metadataReader, binding.implementationType);

        if (!context.container.options.skipBaseClassChecks) {
          var baseClassDependencyCount = reflection_utils_1.getBaseClassDependencyCount(metadataReader, binding.implementationType);

          if (dependencies.length < baseClassDependencyCount) {
            var error = ERROR_MSGS.ARGUMENTS_LENGTH_MISMATCH(reflection_utils_1.getFunctionName(binding.implementationType));
            throw new Error(error);
          }
        }

        dependencies.forEach(function (dependency) {
          _createSubRequests(metadataReader, false, dependency.serviceIdentifier, context, subChildRequest, dependency);
        });
      }
    });
  }

  function getBindings(container, serviceIdentifier) {
    var bindings = [];
    var bindingDictionary = getBindingDictionary(container);

    if (bindingDictionary.hasKey(serviceIdentifier)) {
      bindings = bindingDictionary.get(serviceIdentifier);
    } else if (container.parent !== null) {
      bindings = getBindings(container.parent, serviceIdentifier);
    }

    return bindings;
  }

  function plan(metadataReader, container, isMultiInject, targetType, serviceIdentifier, key, value, avoidConstraints) {
    if (avoidConstraints === void 0) {
      avoidConstraints = false;
    }

    var context = new context_1.Context(container);

    var target = _createTarget(isMultiInject, targetType, serviceIdentifier, "", key, value);

    try {
      _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, null, target);

      return context;
    } catch (error) {
      if (exceptions_1.isStackOverflowExeption(error)) {
        if (context.plan) {
          serialization_1.circularDependencyToException(context.plan.rootRequest);
        }
      }

      throw error;
    }
  }

  exports.plan = plan;

  function createMockRequest(container, serviceIdentifier, key, value) {
    var target = new target_1.Target(literal_types_1.TargetTypeEnum.Variable, "", serviceIdentifier, new metadata_1.Metadata(key, value));
    var context = new context_1.Context(container);
    var request = new request_1.Request(serviceIdentifier, context, null, [], target);
    return request;
  }

  exports.createMockRequest = createMockRequest;
},46,[47,44,42,39,48,49,50,51,52,53,58,56],"node_modules\\inversify\\lib\\planning\\planner.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var BindingCount = {
    MultipleBindingsAvailable: 2,
    NoBindingsAvailable: 0,
    OnlyOneBindingAvailable: 1
  };
  exports.BindingCount = BindingCount;
},47,[],"node_modules\\inversify\\lib\\bindings\\binding_count.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var ERROR_MSGS = _$$_REQUIRE(_dependencyMap[0], "../constants/error_msgs");

  function isStackOverflowExeption(error) {
    return error instanceof RangeError || error.message === ERROR_MSGS.STACK_OVERFLOW;
  }

  exports.isStackOverflowExeption = isStackOverflowExeption;
},48,[44],"node_modules\\inversify\\lib\\utils\\exceptions.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var ERROR_MSGS = _$$_REQUIRE(_dependencyMap[0], "../constants/error_msgs");

  function getServiceIdentifierAsString(serviceIdentifier) {
    if (typeof serviceIdentifier === "function") {
      var _serviceIdentifier = serviceIdentifier;
      return _serviceIdentifier.name;
    } else if (typeof serviceIdentifier === "symbol") {
      return serviceIdentifier.toString();
    } else {
      var _serviceIdentifier = serviceIdentifier;
      return _serviceIdentifier;
    }
  }

  exports.getServiceIdentifierAsString = getServiceIdentifierAsString;

  function listRegisteredBindingsForServiceIdentifier(container, serviceIdentifier, getBindings) {
    var registeredBindingsList = "";
    var registeredBindings = getBindings(container, serviceIdentifier);

    if (registeredBindings.length !== 0) {
      registeredBindingsList = "\nRegistered bindings:";
      registeredBindings.forEach(function (binding) {
        var name = "Object";

        if (binding.implementationType !== null) {
          name = getFunctionName(binding.implementationType);
        }

        registeredBindingsList = registeredBindingsList + "\n " + name;

        if (binding.constraint.metaData) {
          registeredBindingsList = registeredBindingsList + " - " + binding.constraint.metaData;
        }
      });
    }

    return registeredBindingsList;
  }

  exports.listRegisteredBindingsForServiceIdentifier = listRegisteredBindingsForServiceIdentifier;

  function alreadyDependencyChain(request, serviceIdentifier) {
    if (request.parentRequest === null) {
      return false;
    } else if (request.parentRequest.serviceIdentifier === serviceIdentifier) {
      return true;
    } else {
      return alreadyDependencyChain(request.parentRequest, serviceIdentifier);
    }
  }

  function dependencyChainToString(request) {
    function _createStringArr(req, result) {
      if (result === void 0) {
        result = [];
      }

      var serviceIdentifier = getServiceIdentifierAsString(req.serviceIdentifier);
      result.push(serviceIdentifier);

      if (req.parentRequest !== null) {
        return _createStringArr(req.parentRequest, result);
      }

      return result;
    }

    var stringArr = _createStringArr(request);

    return stringArr.reverse().join(" --> ");
  }

  function circularDependencyToException(request) {
    request.childRequests.forEach(function (childRequest) {
      if (alreadyDependencyChain(childRequest, childRequest.serviceIdentifier)) {
        var services = dependencyChainToString(childRequest);
        throw new Error(ERROR_MSGS.CIRCULAR_DEPENDENCY + " " + services);
      } else {
        circularDependencyToException(childRequest);
      }
    });
  }

  exports.circularDependencyToException = circularDependencyToException;

  function listMetadataForTarget(serviceIdentifierString, target) {
    if (target.isTagged() || target.isNamed()) {
      var m_1 = "";
      var namedTag = target.getNamedTag();
      var otherTags = target.getCustomTags();

      if (namedTag !== null) {
        m_1 += namedTag.toString() + "\n";
      }

      if (otherTags !== null) {
        otherTags.forEach(function (tag) {
          m_1 += tag.toString() + "\n";
        });
      }

      return " " + serviceIdentifierString + "\n " + serviceIdentifierString + " - " + m_1;
    } else {
      return " " + serviceIdentifierString;
    }
  }

  exports.listMetadataForTarget = listMetadataForTarget;

  function getFunctionName(v) {
    if (v.name) {
      return v.name;
    } else {
      var name_1 = v.toString();
      var match = name_1.match(/^function\s*([^\s(]+)/);
      return match ? match[1] : "Anonymous function: " + name_1;
    }
  }

  exports.getFunctionName = getFunctionName;
},49,[44],"node_modules\\inversify\\lib\\utils\\serialization.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var id_1 = _$$_REQUIRE(_dependencyMap[0], "../utils/id");

  var Context = function () {
    function Context(container) {
      this.id = id_1.id();
      this.container = container;
    }

    Context.prototype.addPlan = function (plan) {
      this.plan = plan;
    };

    Context.prototype.setCurrentRequest = function (currentRequest) {
      this.currentRequest = currentRequest;
    };

    return Context;
  }();

  exports.Context = Context;
},50,[43],"node_modules\\inversify\\lib\\planning\\context.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var METADATA_KEY = _$$_REQUIRE(_dependencyMap[0], "../constants/metadata_keys");

  var Metadata = function () {
    function Metadata(key, value) {
      this.key = key;
      this.value = value;
    }

    Metadata.prototype.toString = function () {
      if (this.key === METADATA_KEY.NAMED_TAG) {
        return "named: " + this.value.toString() + " ";
      } else {
        return "tagged: { key:" + this.key.toString() + ", value: " + this.value + " }";
      }
    };

    return Metadata;
  }();

  exports.Metadata = Metadata;
},51,[39],"node_modules\\inversify\\lib\\planning\\metadata.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var Plan = function () {
    function Plan(parentContext, rootRequest) {
      this.parentContext = parentContext;
      this.rootRequest = rootRequest;
    }

    return Plan;
  }();

  exports.Plan = Plan;
},52,[],"node_modules\\inversify\\lib\\planning\\plan.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var inject_1 = _$$_REQUIRE(_dependencyMap[0], "../annotation/inject");

  var ERROR_MSGS = _$$_REQUIRE(_dependencyMap[1], "../constants/error_msgs");

  var literal_types_1 = _$$_REQUIRE(_dependencyMap[2], "../constants/literal_types");

  var METADATA_KEY = _$$_REQUIRE(_dependencyMap[3], "../constants/metadata_keys");

  var serialization_1 = _$$_REQUIRE(_dependencyMap[4], "../utils/serialization");

  exports.getFunctionName = serialization_1.getFunctionName;

  var target_1 = _$$_REQUIRE(_dependencyMap[5], "./target");

  function getDependencies(metadataReader, func) {
    var constructorName = serialization_1.getFunctionName(func);
    var targets = getTargets(metadataReader, constructorName, func, false);
    return targets;
  }

  exports.getDependencies = getDependencies;

  function getTargets(metadataReader, constructorName, func, isBaseClass) {
    var metadata = metadataReader.getConstructorMetadata(func);
    var serviceIdentifiers = metadata.compilerGeneratedMetadata;

    if (serviceIdentifiers === undefined) {
      var msg = ERROR_MSGS.MISSING_INJECTABLE_ANNOTATION + " " + constructorName + ".";
      throw new Error(msg);
    }

    var constructorArgsMetadata = metadata.userGeneratedMetadata;
    var keys = Object.keys(constructorArgsMetadata);
    var hasUserDeclaredUnknownInjections = func.length === 0 && keys.length > 0;
    var iterations = hasUserDeclaredUnknownInjections ? keys.length : func.length;
    var constructorTargets = getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations);
    var propertyTargets = getClassPropsAsTargets(metadataReader, func);
    var targets = constructorTargets.concat(propertyTargets);
    return targets;
  }

  function getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata) {
    var targetMetadata = constructorArgsMetadata[index.toString()] || [];
    var metadata = formatTargetMetadata(targetMetadata);
    var isManaged = metadata.unmanaged !== true;
    var serviceIdentifier = serviceIdentifiers[index];
    var injectIdentifier = metadata.inject || metadata.multiInject;
    serviceIdentifier = injectIdentifier ? injectIdentifier : serviceIdentifier;

    if (serviceIdentifier instanceof inject_1.LazyServiceIdentifer) {
      serviceIdentifier = serviceIdentifier.unwrap();
    }

    if (isManaged) {
      var isObject = serviceIdentifier === Object;
      var isFunction = serviceIdentifier === Function;
      var isUndefined = serviceIdentifier === undefined;
      var isUnknownType = isObject || isFunction || isUndefined;

      if (!isBaseClass && isUnknownType) {
        var msg = ERROR_MSGS.MISSING_INJECT_ANNOTATION + " argument " + index + " in class " + constructorName + ".";
        throw new Error(msg);
      }

      var target = new target_1.Target(literal_types_1.TargetTypeEnum.ConstructorArgument, metadata.targetName, serviceIdentifier);
      target.metadata = targetMetadata;
      return target;
    }

    return null;
  }

  function getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations) {
    var targets = [];

    for (var i = 0; i < iterations; i++) {
      var index = i;
      var target = getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata);

      if (target !== null) {
        targets.push(target);
      }
    }

    return targets;
  }

  function getClassPropsAsTargets(metadataReader, constructorFunc) {
    var classPropsMetadata = metadataReader.getPropertiesMetadata(constructorFunc);
    var targets = [];
    var keys = Object.keys(classPropsMetadata);

    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
      var key = keys_1[_i];
      var targetMetadata = classPropsMetadata[key];
      var metadata = formatTargetMetadata(classPropsMetadata[key]);
      var targetName = metadata.targetName || key;
      var serviceIdentifier = metadata.inject || metadata.multiInject;
      var target = new target_1.Target(literal_types_1.TargetTypeEnum.ClassProperty, targetName, serviceIdentifier);
      target.metadata = targetMetadata;
      targets.push(target);
    }

    var baseConstructor = Object.getPrototypeOf(constructorFunc.prototype).constructor;

    if (baseConstructor !== Object) {
      var baseTargets = getClassPropsAsTargets(metadataReader, baseConstructor);
      targets = targets.concat(baseTargets);
    }

    return targets;
  }

  function getBaseClassDependencyCount(metadataReader, func) {
    var baseConstructor = Object.getPrototypeOf(func.prototype).constructor;

    if (baseConstructor !== Object) {
      var baseConstructorName = serialization_1.getFunctionName(baseConstructor);
      var targets = getTargets(metadataReader, baseConstructorName, baseConstructor, true);
      var metadata = targets.map(function (t) {
        return t.metadata.filter(function (m) {
          return m.key === METADATA_KEY.UNMANAGED_TAG;
        });
      });
      var unmanagedCount = [].concat.apply([], metadata).length;
      var dependencyCount = targets.length - unmanagedCount;

      if (dependencyCount > 0) {
        return dependencyCount;
      } else {
        return getBaseClassDependencyCount(metadataReader, baseConstructor);
      }
    } else {
      return 0;
    }
  }

  exports.getBaseClassDependencyCount = getBaseClassDependencyCount;

  function formatTargetMetadata(targetMetadata) {
    var targetMetadataMap = {};
    targetMetadata.forEach(function (m) {
      targetMetadataMap[m.key.toString()] = m.value;
    });
    return {
      inject: targetMetadataMap[METADATA_KEY.INJECT_TAG],
      multiInject: targetMetadataMap[METADATA_KEY.MULTI_INJECT_TAG],
      targetName: targetMetadataMap[METADATA_KEY.NAME_TAG],
      unmanaged: targetMetadataMap[METADATA_KEY.UNMANAGED_TAG]
    };
  }
},53,[54,44,42,39,49,56],"node_modules\\inversify\\lib\\planning\\reflection_utils.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var error_msgs_1 = _$$_REQUIRE(_dependencyMap[0], "../constants/error_msgs");

  var METADATA_KEY = _$$_REQUIRE(_dependencyMap[1], "../constants/metadata_keys");

  var metadata_1 = _$$_REQUIRE(_dependencyMap[2], "../planning/metadata");

  var decorator_utils_1 = _$$_REQUIRE(_dependencyMap[3], "./decorator_utils");

  var LazyServiceIdentifer = function () {
    function LazyServiceIdentifer(cb) {
      this._cb = cb;
    }

    LazyServiceIdentifer.prototype.unwrap = function () {
      return this._cb();
    };

    return LazyServiceIdentifer;
  }();

  exports.LazyServiceIdentifer = LazyServiceIdentifer;

  function inject(serviceIdentifier) {
    return function (target, targetKey, index) {
      if (serviceIdentifier === undefined) {
        throw new Error(error_msgs_1.UNDEFINED_INJECT_ANNOTATION(target.name));
      }

      var metadata = new metadata_1.Metadata(METADATA_KEY.INJECT_TAG, serviceIdentifier);

      if (typeof index === "number") {
        decorator_utils_1.tagParameter(target, targetKey, index, metadata);
      } else {
        decorator_utils_1.tagProperty(target, targetKey, metadata);
      }
    };
  }

  exports.inject = inject;
},54,[44,39,51,55],"node_modules\\inversify\\lib\\annotation\\inject.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var ERROR_MSGS = _$$_REQUIRE(_dependencyMap[0], "../constants/error_msgs");

  var METADATA_KEY = _$$_REQUIRE(_dependencyMap[1], "../constants/metadata_keys");

  function tagParameter(annotationTarget, propertyName, parameterIndex, metadata) {
    var metadataKey = METADATA_KEY.TAGGED;

    _tagParameterOrProperty(metadataKey, annotationTarget, propertyName, metadata, parameterIndex);
  }

  exports.tagParameter = tagParameter;

  function tagProperty(annotationTarget, propertyName, metadata) {
    var metadataKey = METADATA_KEY.TAGGED_PROP;

    _tagParameterOrProperty(metadataKey, annotationTarget.constructor, propertyName, metadata);
  }

  exports.tagProperty = tagProperty;

  function _tagParameterOrProperty(metadataKey, annotationTarget, propertyName, metadata, parameterIndex) {
    var paramsOrPropertiesMetadata = {};
    var isParameterDecorator = typeof parameterIndex === "number";
    var key = parameterIndex !== undefined && isParameterDecorator ? parameterIndex.toString() : propertyName;

    if (isParameterDecorator && propertyName !== undefined) {
      throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);
    }

    if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {
      paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);
    }

    var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];

    if (!Array.isArray(paramOrPropertyMetadata)) {
      paramOrPropertyMetadata = [];
    } else {
      for (var _i = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i < paramOrPropertyMetadata_1.length; _i++) {
        var m = paramOrPropertyMetadata_1[_i];

        if (m.key === metadata.key) {
          throw new Error(ERROR_MSGS.DUPLICATED_METADATA + " " + m.key.toString());
        }
      }
    }

    paramOrPropertyMetadata.push(metadata);
    paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;
    Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
  }

  function _decorate(decorators, target) {
    Reflect.decorate(decorators, target);
  }

  function _param(paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  }

  function decorate(decorator, target, parameterIndex) {
    if (typeof parameterIndex === "number") {
      _decorate([_param(parameterIndex, decorator)], target);
    } else if (typeof parameterIndex === "string") {
      Reflect.decorate([decorator], target, parameterIndex);
    } else {
      _decorate([decorator], target);
    }
  }

  exports.decorate = decorate;
},55,[44,39],"node_modules\\inversify\\lib\\annotation\\decorator_utils.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var METADATA_KEY = _$$_REQUIRE(_dependencyMap[0], "../constants/metadata_keys");

  var id_1 = _$$_REQUIRE(_dependencyMap[1], "../utils/id");

  var metadata_1 = _$$_REQUIRE(_dependencyMap[2], "./metadata");

  var queryable_string_1 = _$$_REQUIRE(_dependencyMap[3], "./queryable_string");

  var Target = function () {
    function Target(type, name, serviceIdentifier, namedOrTagged) {
      this.id = id_1.id();
      this.type = type;
      this.serviceIdentifier = serviceIdentifier;
      this.name = new queryable_string_1.QueryableString(name || "");
      this.metadata = new Array();
      var metadataItem = null;

      if (typeof namedOrTagged === "string") {
        metadataItem = new metadata_1.Metadata(METADATA_KEY.NAMED_TAG, namedOrTagged);
      } else if (namedOrTagged instanceof metadata_1.Metadata) {
        metadataItem = namedOrTagged;
      }

      if (metadataItem !== null) {
        this.metadata.push(metadataItem);
      }
    }

    Target.prototype.hasTag = function (key) {
      for (var _i = 0, _a = this.metadata; _i < _a.length; _i++) {
        var m = _a[_i];

        if (m.key === key) {
          return true;
        }
      }

      return false;
    };

    Target.prototype.isArray = function () {
      return this.hasTag(METADATA_KEY.MULTI_INJECT_TAG);
    };

    Target.prototype.matchesArray = function (name) {
      return this.matchesTag(METADATA_KEY.MULTI_INJECT_TAG)(name);
    };

    Target.prototype.isNamed = function () {
      return this.hasTag(METADATA_KEY.NAMED_TAG);
    };

    Target.prototype.isTagged = function () {
      return this.metadata.some(function (m) {
        return m.key !== METADATA_KEY.INJECT_TAG && m.key !== METADATA_KEY.MULTI_INJECT_TAG && m.key !== METADATA_KEY.NAME_TAG && m.key !== METADATA_KEY.UNMANAGED_TAG && m.key !== METADATA_KEY.NAMED_TAG;
      });
    };

    Target.prototype.isOptional = function () {
      return this.matchesTag(METADATA_KEY.OPTIONAL_TAG)(true);
    };

    Target.prototype.getNamedTag = function () {
      if (this.isNamed()) {
        return this.metadata.filter(function (m) {
          return m.key === METADATA_KEY.NAMED_TAG;
        })[0];
      }

      return null;
    };

    Target.prototype.getCustomTags = function () {
      if (this.isTagged()) {
        return this.metadata.filter(function (m) {
          return m.key !== METADATA_KEY.INJECT_TAG && m.key !== METADATA_KEY.MULTI_INJECT_TAG && m.key !== METADATA_KEY.NAME_TAG && m.key !== METADATA_KEY.UNMANAGED_TAG && m.key !== METADATA_KEY.NAMED_TAG;
        });
      }

      return null;
    };

    Target.prototype.matchesNamedTag = function (name) {
      return this.matchesTag(METADATA_KEY.NAMED_TAG)(name);
    };

    Target.prototype.matchesTag = function (key) {
      var _this = this;

      return function (value) {
        for (var _i = 0, _a = _this.metadata; _i < _a.length; _i++) {
          var m = _a[_i];

          if (m.key === key && m.value === value) {
            return true;
          }
        }

        return false;
      };
    };

    return Target;
  }();

  exports.Target = Target;
},56,[39,43,51,57],"node_modules\\inversify\\lib\\planning\\target.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var QueryableString = function () {
    function QueryableString(str) {
      this.str = str;
    }

    QueryableString.prototype.startsWith = function (searchString) {
      return this.str.indexOf(searchString) === 0;
    };

    QueryableString.prototype.endsWith = function (searchString) {
      var reverseString = "";
      var reverseSearchString = searchString.split("").reverse().join("");
      reverseString = this.str.split("").reverse().join("");
      return this.startsWith.call({
        str: reverseString
      }, reverseSearchString);
    };

    QueryableString.prototype.contains = function (searchString) {
      return this.str.indexOf(searchString) !== -1;
    };

    QueryableString.prototype.equals = function (compareString) {
      return this.str === compareString;
    };

    QueryableString.prototype.value = function () {
      return this.str;
    };

    return QueryableString;
  }();

  exports.QueryableString = QueryableString;
},57,[],"node_modules\\inversify\\lib\\planning\\queryable_string.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var id_1 = _$$_REQUIRE(_dependencyMap[0], "../utils/id");

  var Request = function () {
    function Request(serviceIdentifier, parentContext, parentRequest, bindings, target) {
      this.id = id_1.id();
      this.serviceIdentifier = serviceIdentifier;
      this.parentContext = parentContext;
      this.parentRequest = parentRequest;
      this.target = target;
      this.childRequests = [];
      this.bindings = Array.isArray(bindings) ? bindings : [bindings];
      this.requestScope = parentRequest === null ? new Map() : null;
    }

    Request.prototype.addChildRequest = function (serviceIdentifier, bindings, target) {
      var child = new Request(serviceIdentifier, this.parentContext, this, bindings, target);
      this.childRequests.push(child);
      return child;
    };

    return Request;
  }();

  exports.Request = Request;
},58,[43],"node_modules\\inversify\\lib\\planning\\request.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var ERROR_MSGS = _$$_REQUIRE(_dependencyMap[0], "../constants/error_msgs");

  var literal_types_1 = _$$_REQUIRE(_dependencyMap[1], "../constants/literal_types");

  var exceptions_1 = _$$_REQUIRE(_dependencyMap[2], "../utils/exceptions");

  var serialization_1 = _$$_REQUIRE(_dependencyMap[3], "../utils/serialization");

  var instantiation_1 = _$$_REQUIRE(_dependencyMap[4], "./instantiation");

  var invokeFactory = function invokeFactory(factoryType, serviceIdentifier, fn) {
    try {
      return fn();
    } catch (error) {
      if (exceptions_1.isStackOverflowExeption(error)) {
        throw new Error(ERROR_MSGS.CIRCULAR_DEPENDENCY_IN_FACTORY(factoryType, serviceIdentifier.toString()));
      } else {
        throw error;
      }
    }
  };

  var _resolveRequest = function _resolveRequest(requestScope) {
    return function (request) {
      request.parentContext.setCurrentRequest(request);
      var bindings = request.bindings;
      var childRequests = request.childRequests;
      var targetIsAnArray = request.target && request.target.isArray();
      var targetParentIsNotAnArray = !request.parentRequest || !request.parentRequest.target || !request.target || !request.parentRequest.target.matchesArray(request.target.serviceIdentifier);

      if (targetIsAnArray && targetParentIsNotAnArray) {
        return childRequests.map(function (childRequest) {
          var _f = _resolveRequest(requestScope);

          return _f(childRequest);
        });
      } else {
        var result = null;

        if (request.target.isOptional() && bindings.length === 0) {
          return undefined;
        }

        var binding_1 = bindings[0];
        var isSingleton = binding_1.scope === literal_types_1.BindingScopeEnum.Singleton;
        var isRequestSingleton = binding_1.scope === literal_types_1.BindingScopeEnum.Request;

        if (isSingleton && binding_1.activated) {
          return binding_1.cache;
        }

        if (isRequestSingleton && requestScope !== null && requestScope.has(binding_1.id)) {
          return requestScope.get(binding_1.id);
        }

        if (binding_1.type === literal_types_1.BindingTypeEnum.ConstantValue) {
          result = binding_1.cache;
        } else if (binding_1.type === literal_types_1.BindingTypeEnum.Function) {
          result = binding_1.cache;
        } else if (binding_1.type === literal_types_1.BindingTypeEnum.Constructor) {
          result = binding_1.implementationType;
        } else if (binding_1.type === literal_types_1.BindingTypeEnum.DynamicValue && binding_1.dynamicValue !== null) {
          result = invokeFactory("toDynamicValue", binding_1.serviceIdentifier, function () {
            return binding_1.dynamicValue(request.parentContext);
          });
        } else if (binding_1.type === literal_types_1.BindingTypeEnum.Factory && binding_1.factory !== null) {
          result = invokeFactory("toFactory", binding_1.serviceIdentifier, function () {
            return binding_1.factory(request.parentContext);
          });
        } else if (binding_1.type === literal_types_1.BindingTypeEnum.Provider && binding_1.provider !== null) {
          result = invokeFactory("toProvider", binding_1.serviceIdentifier, function () {
            return binding_1.provider(request.parentContext);
          });
        } else if (binding_1.type === literal_types_1.BindingTypeEnum.Instance && binding_1.implementationType !== null) {
          result = instantiation_1.resolveInstance(binding_1.implementationType, childRequests, _resolveRequest(requestScope));
        } else {
          var serviceIdentifier = serialization_1.getServiceIdentifierAsString(request.serviceIdentifier);
          throw new Error(ERROR_MSGS.INVALID_BINDING_TYPE + " " + serviceIdentifier);
        }

        if (typeof binding_1.onActivation === "function") {
          result = binding_1.onActivation(request.parentContext, result);
        }

        if (isSingleton) {
          binding_1.cache = result;
          binding_1.activated = true;
        }

        if (isRequestSingleton && requestScope !== null && !requestScope.has(binding_1.id)) {
          requestScope.set(binding_1.id, result);
        }

        return result;
      }
    };
  };

  function resolve(context) {
    var _f = _resolveRequest(context.plan.rootRequest.requestScope);

    return _f(context.plan.rootRequest);
  }

  exports.resolve = resolve;
},59,[44,42,48,49,60],"node_modules\\inversify\\lib\\resolution\\resolver.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var error_msgs_1 = _$$_REQUIRE(_dependencyMap[0], "../constants/error_msgs");

  var literal_types_1 = _$$_REQUIRE(_dependencyMap[1], "../constants/literal_types");

  var METADATA_KEY = _$$_REQUIRE(_dependencyMap[2], "../constants/metadata_keys");

  function _injectProperties(instance, childRequests, resolveRequest) {
    var propertyInjectionsRequests = childRequests.filter(function (childRequest) {
      return childRequest.target !== null && childRequest.target.type === literal_types_1.TargetTypeEnum.ClassProperty;
    });
    var propertyInjections = propertyInjectionsRequests.map(resolveRequest);
    propertyInjectionsRequests.forEach(function (r, index) {
      var propertyName = "";
      propertyName = r.target.name.value();
      var injection = propertyInjections[index];
      instance[propertyName] = injection;
    });
    return instance;
  }

  function _createInstance(Func, injections) {
    return new (Func.bind.apply(Func, [void 0].concat(injections)))();
  }

  function _postConstruct(constr, result) {
    if (Reflect.hasMetadata(METADATA_KEY.POST_CONSTRUCT, constr)) {
      var data = Reflect.getMetadata(METADATA_KEY.POST_CONSTRUCT, constr);

      try {
        result[data.value]();
      } catch (e) {
        throw new Error(error_msgs_1.POST_CONSTRUCT_ERROR(constr.name, e.message));
      }
    }
  }

  function resolveInstance(constr, childRequests, resolveRequest) {
    var result = null;

    if (childRequests.length > 0) {
      var constructorInjectionsRequests = childRequests.filter(function (childRequest) {
        return childRequest.target !== null && childRequest.target.type === literal_types_1.TargetTypeEnum.ConstructorArgument;
      });
      var constructorInjections = constructorInjectionsRequests.map(resolveRequest);
      result = _createInstance(constr, constructorInjections);
      result = _injectProperties(result, childRequests, resolveRequest);
    } else {
      result = new constr();
    }

    _postConstruct(constr, result);

    return result;
  }

  exports.resolveInstance = resolveInstance;
},60,[44,42,39],"node_modules\\inversify\\lib\\resolution\\instantiation.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var ERROR_MSGS = _$$_REQUIRE(_dependencyMap[0], "../constants/error_msgs");

  var literal_types_1 = _$$_REQUIRE(_dependencyMap[1], "../constants/literal_types");

  var binding_in_when_on_syntax_1 = _$$_REQUIRE(_dependencyMap[2], "./binding_in_when_on_syntax");

  var binding_when_on_syntax_1 = _$$_REQUIRE(_dependencyMap[3], "./binding_when_on_syntax");

  var BindingToSyntax = function () {
    function BindingToSyntax(binding) {
      this._binding = binding;
    }

    BindingToSyntax.prototype.to = function (constructor) {
      this._binding.type = literal_types_1.BindingTypeEnum.Instance;
      this._binding.implementationType = constructor;
      return new binding_in_when_on_syntax_1.BindingInWhenOnSyntax(this._binding);
    };

    BindingToSyntax.prototype.toSelf = function () {
      if (typeof this._binding.serviceIdentifier !== "function") {
        throw new Error("" + ERROR_MSGS.INVALID_TO_SELF_VALUE);
      }

      var self = this._binding.serviceIdentifier;
      return this.to(self);
    };

    BindingToSyntax.prototype.toConstantValue = function (value) {
      this._binding.type = literal_types_1.BindingTypeEnum.ConstantValue;
      this._binding.cache = value;
      this._binding.dynamicValue = null;
      this._binding.implementationType = null;
      return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
    };

    BindingToSyntax.prototype.toDynamicValue = function (func) {
      this._binding.type = literal_types_1.BindingTypeEnum.DynamicValue;
      this._binding.cache = null;
      this._binding.dynamicValue = func;
      this._binding.implementationType = null;
      return new binding_in_when_on_syntax_1.BindingInWhenOnSyntax(this._binding);
    };

    BindingToSyntax.prototype.toConstructor = function (constructor) {
      this._binding.type = literal_types_1.BindingTypeEnum.Constructor;
      this._binding.implementationType = constructor;
      return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
    };

    BindingToSyntax.prototype.toFactory = function (factory) {
      this._binding.type = literal_types_1.BindingTypeEnum.Factory;
      this._binding.factory = factory;
      return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
    };

    BindingToSyntax.prototype.toFunction = function (func) {
      if (typeof func !== "function") {
        throw new Error(ERROR_MSGS.INVALID_FUNCTION_BINDING);
      }

      var bindingWhenOnSyntax = this.toConstantValue(func);
      this._binding.type = literal_types_1.BindingTypeEnum.Function;
      return bindingWhenOnSyntax;
    };

    BindingToSyntax.prototype.toAutoFactory = function (serviceIdentifier) {
      this._binding.type = literal_types_1.BindingTypeEnum.Factory;

      this._binding.factory = function (context) {
        var autofactory = function autofactory() {
          return context.container.get(serviceIdentifier);
        };

        return autofactory;
      };

      return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
    };

    BindingToSyntax.prototype.toProvider = function (provider) {
      this._binding.type = literal_types_1.BindingTypeEnum.Provider;
      this._binding.provider = provider;
      return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
    };

    BindingToSyntax.prototype.toService = function (service) {
      this.toDynamicValue(function (context) {
        return context.container.get(service);
      });
    };

    return BindingToSyntax;
  }();

  exports.BindingToSyntax = BindingToSyntax;
},61,[44,42,62,64],"node_modules\\inversify\\lib\\syntax\\binding_to_syntax.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var binding_in_syntax_1 = _$$_REQUIRE(_dependencyMap[0], "./binding_in_syntax");

  var binding_on_syntax_1 = _$$_REQUIRE(_dependencyMap[1], "./binding_on_syntax");

  var binding_when_syntax_1 = _$$_REQUIRE(_dependencyMap[2], "./binding_when_syntax");

  var BindingInWhenOnSyntax = function () {
    function BindingInWhenOnSyntax(binding) {
      this._binding = binding;
      this._bindingWhenSyntax = new binding_when_syntax_1.BindingWhenSyntax(this._binding);
      this._bindingOnSyntax = new binding_on_syntax_1.BindingOnSyntax(this._binding);
      this._bindingInSyntax = new binding_in_syntax_1.BindingInSyntax(binding);
    }

    BindingInWhenOnSyntax.prototype.inRequestScope = function () {
      return this._bindingInSyntax.inRequestScope();
    };

    BindingInWhenOnSyntax.prototype.inSingletonScope = function () {
      return this._bindingInSyntax.inSingletonScope();
    };

    BindingInWhenOnSyntax.prototype.inTransientScope = function () {
      return this._bindingInSyntax.inTransientScope();
    };

    BindingInWhenOnSyntax.prototype.when = function (constraint) {
      return this._bindingWhenSyntax.when(constraint);
    };

    BindingInWhenOnSyntax.prototype.whenTargetNamed = function (name) {
      return this._bindingWhenSyntax.whenTargetNamed(name);
    };

    BindingInWhenOnSyntax.prototype.whenTargetIsDefault = function () {
      return this._bindingWhenSyntax.whenTargetIsDefault();
    };

    BindingInWhenOnSyntax.prototype.whenTargetTagged = function (tag, value) {
      return this._bindingWhenSyntax.whenTargetTagged(tag, value);
    };

    BindingInWhenOnSyntax.prototype.whenInjectedInto = function (parent) {
      return this._bindingWhenSyntax.whenInjectedInto(parent);
    };

    BindingInWhenOnSyntax.prototype.whenParentNamed = function (name) {
      return this._bindingWhenSyntax.whenParentNamed(name);
    };

    BindingInWhenOnSyntax.prototype.whenParentTagged = function (tag, value) {
      return this._bindingWhenSyntax.whenParentTagged(tag, value);
    };

    BindingInWhenOnSyntax.prototype.whenAnyAncestorIs = function (ancestor) {
      return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
    };

    BindingInWhenOnSyntax.prototype.whenNoAncestorIs = function (ancestor) {
      return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
    };

    BindingInWhenOnSyntax.prototype.whenAnyAncestorNamed = function (name) {
      return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
    };

    BindingInWhenOnSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {
      return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
    };

    BindingInWhenOnSyntax.prototype.whenNoAncestorNamed = function (name) {
      return this._bindingWhenSyntax.whenNoAncestorNamed(name);
    };

    BindingInWhenOnSyntax.prototype.whenNoAncestorTagged = function (tag, value) {
      return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
    };

    BindingInWhenOnSyntax.prototype.whenAnyAncestorMatches = function (constraint) {
      return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
    };

    BindingInWhenOnSyntax.prototype.whenNoAncestorMatches = function (constraint) {
      return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
    };

    BindingInWhenOnSyntax.prototype.onActivation = function (handler) {
      return this._bindingOnSyntax.onActivation(handler);
    };

    return BindingInWhenOnSyntax;
  }();

  exports.BindingInWhenOnSyntax = BindingInWhenOnSyntax;
},62,[63,65,66],"node_modules\\inversify\\lib\\syntax\\binding_in_when_on_syntax.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var literal_types_1 = _$$_REQUIRE(_dependencyMap[0], "../constants/literal_types");

  var binding_when_on_syntax_1 = _$$_REQUIRE(_dependencyMap[1], "./binding_when_on_syntax");

  var BindingInSyntax = function () {
    function BindingInSyntax(binding) {
      this._binding = binding;
    }

    BindingInSyntax.prototype.inRequestScope = function () {
      this._binding.scope = literal_types_1.BindingScopeEnum.Request;
      return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
    };

    BindingInSyntax.prototype.inSingletonScope = function () {
      this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
      return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
    };

    BindingInSyntax.prototype.inTransientScope = function () {
      this._binding.scope = literal_types_1.BindingScopeEnum.Transient;
      return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
    };

    return BindingInSyntax;
  }();

  exports.BindingInSyntax = BindingInSyntax;
},63,[42,64],"node_modules\\inversify\\lib\\syntax\\binding_in_syntax.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var binding_on_syntax_1 = _$$_REQUIRE(_dependencyMap[0], "./binding_on_syntax");

  var binding_when_syntax_1 = _$$_REQUIRE(_dependencyMap[1], "./binding_when_syntax");

  var BindingWhenOnSyntax = function () {
    function BindingWhenOnSyntax(binding) {
      this._binding = binding;
      this._bindingWhenSyntax = new binding_when_syntax_1.BindingWhenSyntax(this._binding);
      this._bindingOnSyntax = new binding_on_syntax_1.BindingOnSyntax(this._binding);
    }

    BindingWhenOnSyntax.prototype.when = function (constraint) {
      return this._bindingWhenSyntax.when(constraint);
    };

    BindingWhenOnSyntax.prototype.whenTargetNamed = function (name) {
      return this._bindingWhenSyntax.whenTargetNamed(name);
    };

    BindingWhenOnSyntax.prototype.whenTargetIsDefault = function () {
      return this._bindingWhenSyntax.whenTargetIsDefault();
    };

    BindingWhenOnSyntax.prototype.whenTargetTagged = function (tag, value) {
      return this._bindingWhenSyntax.whenTargetTagged(tag, value);
    };

    BindingWhenOnSyntax.prototype.whenInjectedInto = function (parent) {
      return this._bindingWhenSyntax.whenInjectedInto(parent);
    };

    BindingWhenOnSyntax.prototype.whenParentNamed = function (name) {
      return this._bindingWhenSyntax.whenParentNamed(name);
    };

    BindingWhenOnSyntax.prototype.whenParentTagged = function (tag, value) {
      return this._bindingWhenSyntax.whenParentTagged(tag, value);
    };

    BindingWhenOnSyntax.prototype.whenAnyAncestorIs = function (ancestor) {
      return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
    };

    BindingWhenOnSyntax.prototype.whenNoAncestorIs = function (ancestor) {
      return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
    };

    BindingWhenOnSyntax.prototype.whenAnyAncestorNamed = function (name) {
      return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
    };

    BindingWhenOnSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {
      return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
    };

    BindingWhenOnSyntax.prototype.whenNoAncestorNamed = function (name) {
      return this._bindingWhenSyntax.whenNoAncestorNamed(name);
    };

    BindingWhenOnSyntax.prototype.whenNoAncestorTagged = function (tag, value) {
      return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
    };

    BindingWhenOnSyntax.prototype.whenAnyAncestorMatches = function (constraint) {
      return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
    };

    BindingWhenOnSyntax.prototype.whenNoAncestorMatches = function (constraint) {
      return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
    };

    BindingWhenOnSyntax.prototype.onActivation = function (handler) {
      return this._bindingOnSyntax.onActivation(handler);
    };

    return BindingWhenOnSyntax;
  }();

  exports.BindingWhenOnSyntax = BindingWhenOnSyntax;
},64,[65,66],"node_modules\\inversify\\lib\\syntax\\binding_when_on_syntax.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var binding_when_syntax_1 = _$$_REQUIRE(_dependencyMap[0], "./binding_when_syntax");

  var BindingOnSyntax = function () {
    function BindingOnSyntax(binding) {
      this._binding = binding;
    }

    BindingOnSyntax.prototype.onActivation = function (handler) {
      this._binding.onActivation = handler;
      return new binding_when_syntax_1.BindingWhenSyntax(this._binding);
    };

    return BindingOnSyntax;
  }();

  exports.BindingOnSyntax = BindingOnSyntax;
},65,[66],"node_modules\\inversify\\lib\\syntax\\binding_on_syntax.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var binding_on_syntax_1 = _$$_REQUIRE(_dependencyMap[0], "./binding_on_syntax");

  var constraint_helpers_1 = _$$_REQUIRE(_dependencyMap[1], "./constraint_helpers");

  var BindingWhenSyntax = function () {
    function BindingWhenSyntax(binding) {
      this._binding = binding;
    }

    BindingWhenSyntax.prototype.when = function (constraint) {
      this._binding.constraint = constraint;
      return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };

    BindingWhenSyntax.prototype.whenTargetNamed = function (name) {
      this._binding.constraint = constraint_helpers_1.namedConstraint(name);
      return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };

    BindingWhenSyntax.prototype.whenTargetIsDefault = function () {
      this._binding.constraint = function (request) {
        var targetIsDefault = request.target !== null && !request.target.isNamed() && !request.target.isTagged();
        return targetIsDefault;
      };

      return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };

    BindingWhenSyntax.prototype.whenTargetTagged = function (tag, value) {
      this._binding.constraint = constraint_helpers_1.taggedConstraint(tag)(value);
      return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };

    BindingWhenSyntax.prototype.whenInjectedInto = function (parent) {
      this._binding.constraint = function (request) {
        return constraint_helpers_1.typeConstraint(parent)(request.parentRequest);
      };

      return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };

    BindingWhenSyntax.prototype.whenParentNamed = function (name) {
      this._binding.constraint = function (request) {
        return constraint_helpers_1.namedConstraint(name)(request.parentRequest);
      };

      return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };

    BindingWhenSyntax.prototype.whenParentTagged = function (tag, value) {
      this._binding.constraint = function (request) {
        return constraint_helpers_1.taggedConstraint(tag)(value)(request.parentRequest);
      };

      return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };

    BindingWhenSyntax.prototype.whenAnyAncestorIs = function (ancestor) {
      this._binding.constraint = function (request) {
        return constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.typeConstraint(ancestor));
      };

      return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };

    BindingWhenSyntax.prototype.whenNoAncestorIs = function (ancestor) {
      this._binding.constraint = function (request) {
        return !constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.typeConstraint(ancestor));
      };

      return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };

    BindingWhenSyntax.prototype.whenAnyAncestorNamed = function (name) {
      this._binding.constraint = function (request) {
        return constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.namedConstraint(name));
      };

      return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };

    BindingWhenSyntax.prototype.whenNoAncestorNamed = function (name) {
      this._binding.constraint = function (request) {
        return !constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.namedConstraint(name));
      };

      return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };

    BindingWhenSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {
      this._binding.constraint = function (request) {
        return constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.taggedConstraint(tag)(value));
      };

      return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };

    BindingWhenSyntax.prototype.whenNoAncestorTagged = function (tag, value) {
      this._binding.constraint = function (request) {
        return !constraint_helpers_1.traverseAncerstors(request, constraint_helpers_1.taggedConstraint(tag)(value));
      };

      return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };

    BindingWhenSyntax.prototype.whenAnyAncestorMatches = function (constraint) {
      this._binding.constraint = function (request) {
        return constraint_helpers_1.traverseAncerstors(request, constraint);
      };

      return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };

    BindingWhenSyntax.prototype.whenNoAncestorMatches = function (constraint) {
      this._binding.constraint = function (request) {
        return !constraint_helpers_1.traverseAncerstors(request, constraint);
      };

      return new binding_on_syntax_1.BindingOnSyntax(this._binding);
    };

    return BindingWhenSyntax;
  }();

  exports.BindingWhenSyntax = BindingWhenSyntax;
},66,[65,67],"node_modules\\inversify\\lib\\syntax\\binding_when_syntax.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var METADATA_KEY = _$$_REQUIRE(_dependencyMap[0], "../constants/metadata_keys");

  var metadata_1 = _$$_REQUIRE(_dependencyMap[1], "../planning/metadata");

  var traverseAncerstors = function traverseAncerstors(request, constraint) {
    var parent = request.parentRequest;

    if (parent !== null) {
      return constraint(parent) ? true : traverseAncerstors(parent, constraint);
    } else {
      return false;
    }
  };

  exports.traverseAncerstors = traverseAncerstors;

  var taggedConstraint = function taggedConstraint(key) {
    return function (value) {
      var constraint = function constraint(request) {
        return request !== null && request.target !== null && request.target.matchesTag(key)(value);
      };

      constraint.metaData = new metadata_1.Metadata(key, value);
      return constraint;
    };
  };

  exports.taggedConstraint = taggedConstraint;
  var namedConstraint = taggedConstraint(METADATA_KEY.NAMED_TAG);
  exports.namedConstraint = namedConstraint;

  var typeConstraint = function typeConstraint(type) {
    return function (request) {
      var binding = null;

      if (request !== null) {
        binding = request.bindings[0];

        if (typeof type === "string") {
          var serviceIdentifier = binding.serviceIdentifier;
          return serviceIdentifier === type;
        } else {
          var constructor = request.bindings[0].implementationType;
          return type === constructor;
        }
      }

      return false;
    };
  };

  exports.typeConstraint = typeConstraint;
},67,[39,51],"node_modules\\inversify\\lib\\syntax\\constraint_helpers.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var ContainerSnapshot = function () {
    function ContainerSnapshot() {}

    ContainerSnapshot.of = function (bindings, middleware) {
      var snapshot = new ContainerSnapshot();
      snapshot.bindings = bindings;
      snapshot.middleware = middleware;
      return snapshot;
    };

    return ContainerSnapshot;
  }();

  exports.ContainerSnapshot = ContainerSnapshot;
},68,[],"node_modules\\inversify\\lib\\container\\container_snapshot.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var ERROR_MSGS = _$$_REQUIRE(_dependencyMap[0], "../constants/error_msgs");

  var Lookup = function () {
    function Lookup() {
      this._map = new Map();
    }

    Lookup.prototype.getMap = function () {
      return this._map;
    };

    Lookup.prototype.add = function (serviceIdentifier, value) {
      if (serviceIdentifier === null || serviceIdentifier === undefined) {
        throw new Error(ERROR_MSGS.NULL_ARGUMENT);
      }

      if (value === null || value === undefined) {
        throw new Error(ERROR_MSGS.NULL_ARGUMENT);
      }

      var entry = this._map.get(serviceIdentifier);

      if (entry !== undefined) {
        entry.push(value);

        this._map.set(serviceIdentifier, entry);
      } else {
        this._map.set(serviceIdentifier, [value]);
      }
    };

    Lookup.prototype.get = function (serviceIdentifier) {
      if (serviceIdentifier === null || serviceIdentifier === undefined) {
        throw new Error(ERROR_MSGS.NULL_ARGUMENT);
      }

      var entry = this._map.get(serviceIdentifier);

      if (entry !== undefined) {
        return entry;
      } else {
        throw new Error(ERROR_MSGS.KEY_NOT_FOUND);
      }
    };

    Lookup.prototype.remove = function (serviceIdentifier) {
      if (serviceIdentifier === null || serviceIdentifier === undefined) {
        throw new Error(ERROR_MSGS.NULL_ARGUMENT);
      }

      if (!this._map.delete(serviceIdentifier)) {
        throw new Error(ERROR_MSGS.KEY_NOT_FOUND);
      }
    };

    Lookup.prototype.removeByCondition = function (condition) {
      var _this = this;

      this._map.forEach(function (entries, key) {
        var updatedEntries = entries.filter(function (entry) {
          return !condition(entry);
        });

        if (updatedEntries.length > 0) {
          _this._map.set(key, updatedEntries);
        } else {
          _this._map.delete(key);
        }
      });
    };

    Lookup.prototype.hasKey = function (serviceIdentifier) {
      if (serviceIdentifier === null || serviceIdentifier === undefined) {
        throw new Error(ERROR_MSGS.NULL_ARGUMENT);
      }

      return this._map.has(serviceIdentifier);
    };

    Lookup.prototype.clone = function () {
      var copy = new Lookup();

      this._map.forEach(function (value, key) {
        value.forEach(function (b) {
          return copy.add(key, b.clone());
        });
      });

      return copy;
    };

    Lookup.prototype.traverse = function (func) {
      this._map.forEach(function (value, key) {
        func(key, value);
      });
    };

    return Lookup;
  }();

  exports.Lookup = Lookup;
},69,[44],"node_modules\\inversify\\lib\\container\\lookup.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var id_1 = _$$_REQUIRE(_dependencyMap[0], "../utils/id");

  var ContainerModule = function () {
    function ContainerModule(registry) {
      this.id = id_1.id();
      this.registry = registry;
    }

    return ContainerModule;
  }();

  exports.ContainerModule = ContainerModule;

  var AsyncContainerModule = function () {
    function AsyncContainerModule(registry) {
      this.id = id_1.id();
      this.registry = registry;
    }

    return AsyncContainerModule;
  }();

  exports.AsyncContainerModule = AsyncContainerModule;
},70,[43],"node_modules\\inversify\\lib\\container\\container_module.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var ERRORS_MSGS = _$$_REQUIRE(_dependencyMap[0], "../constants/error_msgs");

  var METADATA_KEY = _$$_REQUIRE(_dependencyMap[1], "../constants/metadata_keys");

  function injectable() {
    return function (target) {
      if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target)) {
        throw new Error(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);
      }

      var types = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, target) || [];
      Reflect.defineMetadata(METADATA_KEY.PARAM_TYPES, types, target);
      return target;
    };
  }

  exports.injectable = injectable;
},71,[44,39],"node_modules\\inversify\\lib\\annotation\\injectable.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var metadata_1 = _$$_REQUIRE(_dependencyMap[0], "../planning/metadata");

  var decorator_utils_1 = _$$_REQUIRE(_dependencyMap[1], "./decorator_utils");

  function tagged(metadataKey, metadataValue) {
    return function (target, targetKey, index) {
      var metadata = new metadata_1.Metadata(metadataKey, metadataValue);

      if (typeof index === "number") {
        decorator_utils_1.tagParameter(target, targetKey, index, metadata);
      } else {
        decorator_utils_1.tagProperty(target, targetKey, metadata);
      }
    };
  }

  exports.tagged = tagged;
},72,[51,55],"node_modules\\inversify\\lib\\annotation\\tagged.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var METADATA_KEY = _$$_REQUIRE(_dependencyMap[0], "../constants/metadata_keys");

  var metadata_1 = _$$_REQUIRE(_dependencyMap[1], "../planning/metadata");

  var decorator_utils_1 = _$$_REQUIRE(_dependencyMap[2], "./decorator_utils");

  function named(name) {
    return function (target, targetKey, index) {
      var metadata = new metadata_1.Metadata(METADATA_KEY.NAMED_TAG, name);

      if (typeof index === "number") {
        decorator_utils_1.tagParameter(target, targetKey, index, metadata);
      } else {
        decorator_utils_1.tagProperty(target, targetKey, metadata);
      }
    };
  }

  exports.named = named;
},73,[39,51,55],"node_modules\\inversify\\lib\\annotation\\named.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var METADATA_KEY = _$$_REQUIRE(_dependencyMap[0], "../constants/metadata_keys");

  var metadata_1 = _$$_REQUIRE(_dependencyMap[1], "../planning/metadata");

  var decorator_utils_1 = _$$_REQUIRE(_dependencyMap[2], "./decorator_utils");

  function optional() {
    return function (target, targetKey, index) {
      var metadata = new metadata_1.Metadata(METADATA_KEY.OPTIONAL_TAG, true);

      if (typeof index === "number") {
        decorator_utils_1.tagParameter(target, targetKey, index, metadata);
      } else {
        decorator_utils_1.tagProperty(target, targetKey, metadata);
      }
    };
  }

  exports.optional = optional;
},74,[39,51,55],"node_modules\\inversify\\lib\\annotation\\optional.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var METADATA_KEY = _$$_REQUIRE(_dependencyMap[0], "../constants/metadata_keys");

  var metadata_1 = _$$_REQUIRE(_dependencyMap[1], "../planning/metadata");

  var decorator_utils_1 = _$$_REQUIRE(_dependencyMap[2], "./decorator_utils");

  function unmanaged() {
    return function (target, targetKey, index) {
      var metadata = new metadata_1.Metadata(METADATA_KEY.UNMANAGED_TAG, true);
      decorator_utils_1.tagParameter(target, targetKey, index, metadata);
    };
  }

  exports.unmanaged = unmanaged;
},75,[39,51,55],"node_modules\\inversify\\lib\\annotation\\unmanaged.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var METADATA_KEY = _$$_REQUIRE(_dependencyMap[0], "../constants/metadata_keys");

  var metadata_1 = _$$_REQUIRE(_dependencyMap[1], "../planning/metadata");

  var decorator_utils_1 = _$$_REQUIRE(_dependencyMap[2], "./decorator_utils");

  function multiInject(serviceIdentifier) {
    return function (target, targetKey, index) {
      var metadata = new metadata_1.Metadata(METADATA_KEY.MULTI_INJECT_TAG, serviceIdentifier);

      if (typeof index === "number") {
        decorator_utils_1.tagParameter(target, targetKey, index, metadata);
      } else {
        decorator_utils_1.tagProperty(target, targetKey, metadata);
      }
    };
  }

  exports.multiInject = multiInject;
},76,[39,51,55],"node_modules\\inversify\\lib\\annotation\\multi_inject.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var METADATA_KEY = _$$_REQUIRE(_dependencyMap[0], "../constants/metadata_keys");

  var metadata_1 = _$$_REQUIRE(_dependencyMap[1], "../planning/metadata");

  var decorator_utils_1 = _$$_REQUIRE(_dependencyMap[2], "./decorator_utils");

  function targetName(name) {
    return function (target, targetKey, index) {
      var metadata = new metadata_1.Metadata(METADATA_KEY.NAME_TAG, name);
      decorator_utils_1.tagParameter(target, targetKey, index, metadata);
    };
  }

  exports.targetName = targetName;
},77,[39,51,55],"node_modules\\inversify\\lib\\annotation\\target_name.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var ERRORS_MSGS = _$$_REQUIRE(_dependencyMap[0], "../constants/error_msgs");

  var METADATA_KEY = _$$_REQUIRE(_dependencyMap[1], "../constants/metadata_keys");

  var metadata_1 = _$$_REQUIRE(_dependencyMap[2], "../planning/metadata");

  function postConstruct() {
    return function (target, propertyKey, descriptor) {
      var metadata = new metadata_1.Metadata(METADATA_KEY.POST_CONSTRUCT, propertyKey);

      if (Reflect.hasOwnMetadata(METADATA_KEY.POST_CONSTRUCT, target.constructor)) {
        throw new Error(ERRORS_MSGS.MULTIPLE_POST_CONSTRUCT_METHODS);
      }

      Reflect.defineMetadata(METADATA_KEY.POST_CONSTRUCT, metadata, target.constructor);
    };
  }

  exports.postConstruct = postConstruct;
},78,[44,39,51],"node_modules\\inversify\\lib\\annotation\\post_construct.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.multiBindToService = function (container) {
    return function (service) {
      return function () {
        var types = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          types[_i] = arguments[_i];
        }

        return types.forEach(function (t) {
          return container.bind(t).toService(service);
        });
      };
    };
  };
},79,[],"node_modules\\inversify\\lib\\utils\\binding_utils.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : new P(function (resolve) {
          resolve(result.value);
        }).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator = this && this.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var mitt_1 = __importDefault(_$$_REQUIRE(_dependencyMap[0], "mitt"));

  var ServiceProvider_1 = _$$_REQUIRE(_dependencyMap[1], "./ServiceProvider");

  var App_1 = _$$_REQUIRE(_dependencyMap[2], "./App");

  var _1 = _$$_REQUIRE(_dependencyMap[3], ".");

  var ProtocultureServiceProvider = function (_super) {
    __extends(ProtocultureServiceProvider, _super);

    function ProtocultureServiceProvider() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    ProtocultureServiceProvider.prototype.boot = function () {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          this.makeInjectable(App_1.BaseApp);
          this.bundle.container.bind(_1.protocultureSymbols.Bundle).toConstantValue(this.bundle);
          this.bundle.container.bind(_1.protocultureSymbols.MessageBus).toConstantValue(new mitt_1.default());
          return [2];
        });
      });
    };

    return ProtocultureServiceProvider;
  }(ServiceProvider_1.ServiceProvider);

  exports.ProtocultureServiceProvider = ProtocultureServiceProvider;
},80,[81,82,83,33],"node_modules\\protoculture\\lib\\ProtocultureServiceProvider.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function n(n) {
    return n = n || Object.create(null), {
      on: function on(c, e) {
        (n[c] || (n[c] = [])).push(e);
      },
      off: function off(c, e) {
        n[c] && n[c].splice(n[c].indexOf(e) >>> 0, 1);
      },
      emit: function emit(c, e) {
        (n[c] || []).slice().map(function (n) {
          n(e);
        }), (n["*"] || []).slice().map(function (n) {
          n(c, e);
        });
      }
    };
  }

  module.exports = n;
},81,[],"node_modules\\mitt\\dist\\mitt.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : new P(function (resolve) {
          resolve(result.value);
        }).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator = this && this.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var lodash_1 = __importDefault(_$$_REQUIRE(_dependencyMap[0], "lodash"));

  var inversify_1 = _$$_REQUIRE(_dependencyMap[1], "inversify");

  var index_1 = _$$_REQUIRE(_dependencyMap[2], "./index");

  var ServiceProvider = function () {
    function ServiceProvider(bundle) {
      this.bundle = bundle;
    }

    ServiceProvider.addDecoratedType = function (key, constructor) {
      if (!ServiceProvider.decoratedTypes[key]) {
        ServiceProvider.decoratedTypes[key] = [];
      }

      ServiceProvider.decoratedTypes[key].push(constructor);
    };

    ServiceProvider.getDecoratedTypes = function (key) {
      return ServiceProvider.decoratedTypes[key] || [];
    };

    ServiceProvider.prototype.boot = function () {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          return [2];
        });
      });
    };

    ServiceProvider.prototype.bootChild = function (container) {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          return [2];
        });
      });
    };

    ServiceProvider.prototype.bindApp = function (app) {
      this.makeInjectable(app);
      return this.bindConstructor(index_1.protocultureSymbols.App, app);
    };

    ServiceProvider.prototype.makeInjectable = function (object) {
      inversify_1.decorate(inversify_1.injectable(), object);
    };

    ServiceProvider.prototype.bindConstructor = function (symbol, staticType) {
      return this.bundle.container.bind(symbol).to(staticType).inSingletonScope();
    };

    ServiceProvider.prototype.bindConstructorParameter = function (symbol, staticType, position) {
      if (lodash_1.default.isArray(symbol)) {
        inversify_1.decorate(inversify_1.multiInject(symbol[0]), staticType, position);
      } else {
        inversify_1.decorate(inversify_1.inject(symbol), staticType, position);
      }
    };

    ServiceProvider.decoratedTypes = {};
    return ServiceProvider;
  }();

  exports.ServiceProvider = ServiceProvider;
},82,[37,38,33],"node_modules\\protoculture\\lib\\ServiceProvider.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : new P(function (resolve) {
          resolve(result.value);
        }).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator = this && this.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var BaseApp = function () {
    function BaseApp() {}

    Object.defineProperty(BaseApp.prototype, "bundle", {
      get: function get() {
        return this._bundle;
      },
      set: function set(bundle) {
        this._bundle = bundle;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BaseApp.prototype, "working", {
      get: function get() {
        return false;
      },
      enumerable: true,
      configurable: true
    });

    BaseApp.prototype.run = function () {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          throw new Error("Run not implemented!");
        });
      });
    };

    BaseApp.prototype.log = function (eventName, message) {
      this._logger.log(eventName, this, message);
    };

    return BaseApp;
  }();

  exports.BaseApp = BaseApp;
},83,[],"node_modules\\protoculture\\lib\\App.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __extends = this && this.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    return function (d, b) {
      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : new P(function (resolve) {
          resolve(result.value);
        }).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator = this && this.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var ServiceProvider_1 = _$$_REQUIRE(_dependencyMap[0], "../ServiceProvider");

  var __1 = _$$_REQUIRE(_dependencyMap[1], "../");

  var opentracing_1 = _$$_REQUIRE(_dependencyMap[2], "opentracing");

  var __2 = _$$_REQUIRE(_dependencyMap[3], "..");

  var LogServiceProvider = function (_super) {
    __extends(LogServiceProvider, _super);

    function LogServiceProvider() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    LogServiceProvider.prototype.boot = function () {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          this.makeInjectable(opentracing_1.Tracer);
          this.makeInjectable(opentracing_1.MockTracer);
          this.bindConstructor(__2.protocultureSymbols.Tracer, opentracing_1.MockTracer);
          this.makeInjectable(__1.LogService);
          this.bindConstructor(__2.protocultureSymbols.LogService, __1.LogService);
          this.bindConstructorParameter(__2.protocultureSymbols.Bundle, __1.LogService, 0);
          this.bindConstructorParameter(__2.protocultureSymbols.Tracer, __1.LogService, 1);
          return [2];
        });
      });
    };

    return LogServiceProvider;
  }(ServiceProvider_1.ServiceProvider);

  exports.LogServiceProvider = LogServiceProvider;
},84,[82,33,85,33],"node_modules\\protoculture\\lib\\Log\\LogServiceProvider.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  function __export(m) {
    for (var p in m) {
      if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
  }

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var binary_carrier_1 = _$$_REQUIRE(_dependencyMap[0], "./binary_carrier");

  exports.BinaryCarrier = binary_carrier_1.default;

  var Tags = _$$_REQUIRE(_dependencyMap[1], "./ext/tags");

  exports.Tags = Tags;

  var Noop = _$$_REQUIRE(_dependencyMap[2], "./noop");

  var reference_1 = _$$_REQUIRE(_dependencyMap[3], "./reference");

  exports.Reference = reference_1.default;

  var span_1 = _$$_REQUIRE(_dependencyMap[4], "./span");

  exports.Span = span_1.default;

  var span_context_1 = _$$_REQUIRE(_dependencyMap[5], "./span_context");

  exports.SpanContext = span_context_1.default;

  var tracer_1 = _$$_REQUIRE(_dependencyMap[6], "./tracer");

  exports.Tracer = tracer_1.Tracer;

  var mock_tracer_1 = _$$_REQUIRE(_dependencyMap[7], "./mock_tracer");

  exports.MockTracer = mock_tracer_1.MockTracer;

  __export(_$$_REQUIRE(_dependencyMap[8], "./global_tracer"));

  __export(_$$_REQUIRE(_dependencyMap[9], "./constants"));

  __export(_$$_REQUIRE(_dependencyMap[10], "./functions"));

  Noop.initialize();
},85,[86,87,88,94,89,90,91,95,100,93,92],"node_modules\\opentracing\\lib\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var BinaryCarrier = function () {
    function BinaryCarrier(buffer) {
      this.buffer = buffer;
    }

    return BinaryCarrier;
  }();

  exports.default = BinaryCarrier;
},86,[],"node_modules\\opentracing\\lib\\binary_carrier.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SPAN_KIND = 'span.kind';
  exports.SPAN_KIND_RPC_CLIENT = 'client';
  exports.SPAN_KIND_RPC_SERVER = 'server';
  exports.SPAN_KIND_MESSAGING_PRODUCER = 'producer';
  exports.SPAN_KIND_MESSAGING_CONSUMER = 'consumer';
  exports.ERROR = 'error';
  exports.COMPONENT = 'component';
  exports.SAMPLING_PRIORITY = 'sampling.priority';
  exports.PEER_SERVICE = 'peer.service';
  exports.PEER_HOSTNAME = 'peer.hostname';
  exports.PEER_ADDRESS = 'peer.address';
  exports.PEER_HOST_IPV4 = 'peer.ipv4';
  exports.PEER_HOST_IPV6 = 'peer.ipv6';
  exports.PEER_PORT = 'peer.port';
  exports.HTTP_URL = 'http.url';
  exports.HTTP_METHOD = 'http.method';
  exports.HTTP_STATUS_CODE = 'http.status_code';
  exports.MESSAGE_BUS_DESTINATION = 'message_bus.destination';
  exports.DB_INSTANCE = 'db.instance';
  exports.DB_STATEMENT = 'db.statement';
  exports.DB_TYPE = 'db.type';
  exports.DB_USER = 'db.user';
},87,[],"node_modules\\opentracing\\lib\\ext\\tags.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var span_1 = _$$_REQUIRE(_dependencyMap[0], "./span");

  var span_context_1 = _$$_REQUIRE(_dependencyMap[1], "./span_context");

  var tracer_1 = _$$_REQUIRE(_dependencyMap[2], "./tracer");

  exports.tracer = null;
  exports.spanContext = null;
  exports.span = null;

  function initialize() {
    exports.tracer = new tracer_1.default();
    exports.span = new span_1.default();
    exports.spanContext = new span_context_1.default();
  }

  exports.initialize = initialize;
},88,[89,90,91],"node_modules\\opentracing\\lib\\noop.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var noop = _$$_REQUIRE(_dependencyMap[0], "./noop");

  var Span = function () {
    function Span() {}

    Span.prototype.context = function () {
      return this._context();
    };

    Span.prototype.tracer = function () {
      return this._tracer();
    };

    Span.prototype.setOperationName = function (name) {
      this._setOperationName(name);

      return this;
    };

    Span.prototype.setBaggageItem = function (key, value) {
      this._setBaggageItem(key, value);

      return this;
    };

    Span.prototype.getBaggageItem = function (key) {
      return this._getBaggageItem(key);
    };

    Span.prototype.setTag = function (key, value) {
      this._addTags((_a = {}, _a[key] = value, _a));

      return this;

      var _a;
    };

    Span.prototype.addTags = function (keyValueMap) {
      this._addTags(keyValueMap);

      return this;
    };

    Span.prototype.log = function (keyValuePairs, timestamp) {
      this._log(keyValuePairs, timestamp);

      return this;
    };

    Span.prototype.logEvent = function (eventName, payload) {
      return this._log({
        event: eventName,
        payload: payload
      });
    };

    Span.prototype.finish = function (finishTime) {
      this._finish(finishTime);
    };

    Span.prototype._context = function () {
      return noop.spanContext;
    };

    Span.prototype._tracer = function () {
      return noop.tracer;
    };

    Span.prototype._setOperationName = function (name) {};

    Span.prototype._setBaggageItem = function (key, value) {};

    Span.prototype._getBaggageItem = function (key) {
      return undefined;
    };

    Span.prototype._addTags = function (keyValuePairs) {};

    Span.prototype._log = function (keyValuePairs, timestamp) {};

    Span.prototype._finish = function (finishTime) {};

    return Span;
  }();

  exports.Span = Span;
  exports.default = Span;
},89,[88],"node_modules\\opentracing\\lib\\span.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var SpanContext = function () {
    function SpanContext() {}

    return SpanContext;
  }();

  exports.SpanContext = SpanContext;
  exports.default = SpanContext;
},90,[],"node_modules\\opentracing\\lib\\span_context.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var Functions = _$$_REQUIRE(_dependencyMap[0], "./functions");

  var Noop = _$$_REQUIRE(_dependencyMap[1], "./noop");

  var span_1 = _$$_REQUIRE(_dependencyMap[2], "./span");

  var Tracer = function () {
    function Tracer() {}

    Tracer.prototype.startSpan = function (name, options) {
      if (options === void 0) {
        options = {};
      }

      if (options.childOf) {
        var childOf = Functions.childOf(options.childOf);

        if (options.references) {
          options.references.push(childOf);
        } else {
          options.references = [childOf];
        }

        delete options.childOf;
      }

      return this._startSpan(name, options);
    };

    Tracer.prototype.inject = function (spanContext, format, carrier) {
      if (spanContext instanceof span_1.default) {
        spanContext = spanContext.context();
      }

      return this._inject(spanContext, format, carrier);
    };

    Tracer.prototype.extract = function (format, carrier) {
      return this._extract(format, carrier);
    };

    Tracer.prototype._startSpan = function (name, fields) {
      return Noop.span;
    };

    Tracer.prototype._inject = function (spanContext, format, carrier) {};

    Tracer.prototype._extract = function (format, carrier) {
      return Noop.spanContext;
    };

    return Tracer;
  }();

  exports.Tracer = Tracer;
  exports.default = Tracer;
},91,[92,88,89],"node_modules\\opentracing\\lib\\tracer.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var Constants = _$$_REQUIRE(_dependencyMap[0], "./constants");

  var reference_1 = _$$_REQUIRE(_dependencyMap[1], "./reference");

  var span_1 = _$$_REQUIRE(_dependencyMap[2], "./span");

  function childOf(spanContext) {
    if (spanContext instanceof span_1.default) {
      spanContext = spanContext.context();
    }

    return new reference_1.default(Constants.REFERENCE_CHILD_OF, spanContext);
  }

  exports.childOf = childOf;

  function followsFrom(spanContext) {
    if (spanContext instanceof span_1.default) {
      spanContext = spanContext.context();
    }

    return new reference_1.default(Constants.REFERENCE_FOLLOWS_FROM, spanContext);
  }

  exports.followsFrom = followsFrom;
},92,[93,94,89],"node_modules\\opentracing\\lib\\functions.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.FORMAT_BINARY = 'binary';
  exports.FORMAT_TEXT_MAP = 'text_map';
  exports.FORMAT_HTTP_HEADERS = 'http_headers';
  exports.REFERENCE_CHILD_OF = 'child_of';
  exports.REFERENCE_FOLLOWS_FROM = 'follows_from';
},93,[],"node_modules\\opentracing\\lib\\constants.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var span_1 = _$$_REQUIRE(_dependencyMap[0], "./span");

  var Reference = function () {
    function Reference(type, referencedContext) {
      this._type = type;
      this._referencedContext = referencedContext instanceof span_1.default ? referencedContext.context() : referencedContext;
    }

    Reference.prototype.type = function () {
      return this._type;
    };

    Reference.prototype.referencedContext = function () {
      return this._referencedContext;
    };

    return Reference;
  }();

  exports.default = Reference;
},94,[89],"node_modules\\opentracing\\lib\\reference.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var mock_context_1 = _$$_REQUIRE(_dependencyMap[0], "./mock_context");

  exports.MockContext = mock_context_1.default;

  var mock_span_1 = _$$_REQUIRE(_dependencyMap[1], "./mock_span");

  exports.MockSpan = mock_span_1.default;

  var mock_tracer_1 = _$$_REQUIRE(_dependencyMap[2], "./mock_tracer");

  exports.MockTracer = mock_tracer_1.default;
},95,[96,97,98],"node_modules\\opentracing\\lib\\mock_tracer\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return function (d, b) {
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var opentracing = _$$_REQUIRE(_dependencyMap[0], "../index");

  var MockContext = function (_super) {
    __extends(MockContext, _super);

    function MockContext(span) {
      var _this = _super.call(this) || this;

      _this._span = span;
      return _this;
    }

    MockContext.prototype.span = function () {
      return this._span;
    };

    return MockContext;
  }(opentracing.SpanContext);

  exports.MockContext = MockContext;
  exports.default = MockContext;
},96,[85],"node_modules\\opentracing\\lib\\mock_tracer\\mock_context.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return function (d, b) {
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var opentracing = _$$_REQUIRE(_dependencyMap[0], "../index");

  var mock_context_1 = _$$_REQUIRE(_dependencyMap[1], "./mock_context");

  var MockSpan = function (_super) {
    __extends(MockSpan, _super);

    function MockSpan(tracer) {
      var _this = _super.call(this) || this;

      _this._mockTracer = tracer;
      _this._uuid = _this._generateUUID();
      _this._startMs = Date.now();
      _this._finishMs = 0;
      _this._operationName = '';
      _this._tags = {};
      _this._logs = [];
      return _this;
    }

    MockSpan.prototype._context = function () {
      return new mock_context_1.default(this);
    };

    MockSpan.prototype._setOperationName = function (name) {
      this._operationName = name;
    };

    MockSpan.prototype._addTags = function (set) {
      var keys = Object.keys(set);

      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        this._tags[key] = set[key];
      }
    };

    MockSpan.prototype._log = function (fields, timestamp) {
      this._logs.push({
        fields: fields,
        timestamp: timestamp
      });
    };

    MockSpan.prototype._finish = function (finishTime) {
      this._finishMs = finishTime || Date.now();
    };

    MockSpan.prototype.uuid = function () {
      return this._uuid;
    };

    MockSpan.prototype.operationName = function () {
      return this._operationName;
    };

    MockSpan.prototype.durationMs = function () {
      return this._finishMs - this._startMs;
    };

    MockSpan.prototype.tags = function () {
      return this._tags;
    };

    MockSpan.prototype.tracer = function () {
      return this._mockTracer;
    };

    MockSpan.prototype._generateUUID = function () {
      var p0 = ("00000000" + Math.abs(Math.random() * 0xFFFFFFFF | 0).toString(16)).substr(-8);
      var p1 = ("00000000" + Math.abs(Math.random() * 0xFFFFFFFF | 0).toString(16)).substr(-8);
      return "" + p0 + p1;
    };

    MockSpan.prototype.addReference = function (ref) {};

    MockSpan.prototype.debug = function () {
      var obj = {
        uuid: this._uuid,
        operation: this._operationName,
        millis: [this._finishMs - this._startMs, this._startMs, this._finishMs]
      };

      if (Object.keys(this._tags).length) {
        obj.tags = this._tags;
      }

      return obj;
    };

    return MockSpan;
  }(opentracing.Span);

  exports.MockSpan = MockSpan;
  exports.default = MockSpan;
},97,[85,96],"node_modules\\opentracing\\lib\\mock_tracer\\mock_span.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return function (d, b) {
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var opentracing = _$$_REQUIRE(_dependencyMap[0], "../index");

  var mock_report_1 = _$$_REQUIRE(_dependencyMap[1], "./mock_report");

  var mock_span_1 = _$$_REQUIRE(_dependencyMap[2], "./mock_span");

  var MockTracer = function (_super) {
    __extends(MockTracer, _super);

    function MockTracer() {
      var _this = _super.call(this) || this;

      _this._spans = [];
      return _this;
    }

    MockTracer.prototype._startSpan = function (name, fields) {
      var span = this._allocSpan();

      span.setOperationName(name);

      this._spans.push(span);

      if (fields.references) {
        for (var _i = 0, _a = fields.references; _i < _a.length; _i++) {
          var ref = _a[_i];
          span.addReference(ref);
        }
      }

      span._startStack = new Error().stack;
      return span;
    };

    MockTracer.prototype._inject = function (span, format, carrier) {
      throw new Error('NOT YET IMPLEMENTED');
    };

    MockTracer.prototype._extract = function (format, carrier) {
      throw new Error('NOT YET IMPLEMENTED');
    };

    MockTracer.prototype._allocSpan = function () {
      return new mock_span_1.default(this);
    };

    MockTracer.prototype.clear = function () {
      this._spans = [];
    };

    MockTracer.prototype.report = function () {
      return new mock_report_1.default(this._spans);
    };

    return MockTracer;
  }(opentracing.Tracer);

  exports.MockTracer = MockTracer;
  exports.default = MockTracer;
},98,[85,99,97],"node_modules\\opentracing\\lib\\mock_tracer\\mock_tracer.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var MockReport = function () {
    function MockReport(spans) {
      var _this = this;

      this.spans = spans;
      this.spansByUUID = {};
      this.spansByTag = {};
      this.debugSpans = [];
      this.unfinishedSpans = [];
      spans.forEach(function (span) {
        if (span._finishMs === 0) {
          _this.unfinishedSpans.push(span);
        }

        _this.spansByUUID[span.uuid()] = span;

        _this.debugSpans.push(span.debug());

        var tags = span.tags();
        Object.keys(tags).forEach(function (key) {
          var val = tags[key];
          _this.spansByTag[key] = _this.spansByTag[key] || {};
          _this.spansByTag[key][val] = _this.spansByTag[key][val] || [];

          _this.spansByTag[key][val].push(span);
        });
      });
    }

    MockReport.prototype.firstSpanWithTagValue = function (key, val) {
      var m = this.spansByTag[key];

      if (!m) {
        return null;
      }

      var n = m[val];

      if (!n) {
        return null;
      }

      return n[0];
    };

    return MockReport;
  }();

  exports.MockReport = MockReport;
  exports.default = MockReport;
},99,[],"node_modules\\opentracing\\lib\\mock_tracer\\mock_report.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return function (d, b) {
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var tracer_1 = _$$_REQUIRE(_dependencyMap[0], "./tracer");

  var noopTracer = new tracer_1.default();
  var _globalTracer = null;

  var GlobalTracerDelegate = function (_super) {
    __extends(GlobalTracerDelegate, _super);

    function GlobalTracerDelegate() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    GlobalTracerDelegate.prototype.startSpan = function () {
      var tracer = _globalTracer || noopTracer;
      return tracer.startSpan.apply(tracer, arguments);
    };

    GlobalTracerDelegate.prototype.inject = function () {
      var tracer = _globalTracer || noopTracer;
      return tracer.inject.apply(tracer, arguments);
    };

    GlobalTracerDelegate.prototype.extract = function () {
      var tracer = _globalTracer || noopTracer;
      return tracer.extract.apply(tracer, arguments);
    };

    return GlobalTracerDelegate;
  }(tracer_1.default);

  var globalTracerDelegate = new GlobalTracerDelegate();

  function initGlobalTracer(tracer) {
    _globalTracer = tracer;
  }

  exports.initGlobalTracer = initGlobalTracer;

  function globalTracer() {
    return globalTracerDelegate;
  }

  exports.globalTracer = globalTracer;
},100,[91],"node_modules\\opentracing\\lib\\global_tracer.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var lodash_1 = __importDefault(_$$_REQUIRE(_dependencyMap[0], "lodash"));

  var LogService = function () {
    function LogService(bundle, tracer) {
      this.bundle = bundle;
      this.tracer = tracer;
    }

    LogService.prototype.log = function (eventName, app, message) {
      console.log(eventName);
      var span = this.beginTrace(eventName, app);

      if (message) {
        span.log({
          message: message
        });
      }

      span.finish();
    };

    LogService.prototype.beginTrace = function (eventName, app) {
      return this.tracer.startSpan(eventName, {
        tags: this.buildDefaultTags(app)
      });
    };

    LogService.prototype.buildLogMessage = function (message, app) {
      if (app === void 0) {
        app = null;
      }

      var messageLines = lodash_1.default.isString(message) ? message.split("\n") : [message];
      var logLinePrefix = this.buildDefaultTags(app);
      return lodash_1.default.map(messageLines, function (messageLine) {
        return "" + logLinePrefix + messageLine;
      });
    };

    LogService.prototype.buildDefaultTags = function (app) {
      return {
        "framework": "protoculture",
        "bundle": this.bundle.name,
        "app": app ? app.name : null
      };
    };

    return LogService;
  }();

  exports.LogService = LogService;
},101,[37],"node_modules\\protoculture\\lib\\Log\\LogService.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : new P(function (resolve) {
          resolve(result.value);
        }).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  var __generator = this && this.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  function lazyLoad(uri) {
    return __awaiter(this, void 0, void 0, function () {
      var resolveDeferred, rejectDeferred, deferred, scriptTag;
      return __generator(this, function (_a) {
        deferred = new Promise(function (resolve, reject) {
          resolveDeferred = resolve;
          rejectDeferred = reject;
        });
        scriptTag = document.createElement("script");
        scriptTag.src = uri;
        scriptTag.type = "text/javascript";
        scriptTag.async = true;
        scriptTag.defer = true;

        scriptTag.onload = function (event) {
          resolveDeferred(event);
        };

        document.getElementsByTagName("head")[0].appendChild(scriptTag);
        return [2, deferred];
      });
    });
  }

  exports.lazyLoad = lazyLoad;
},102,[],"node_modules\\protoculture\\lib\\Web\\LazyLoad.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  function domReady() {
    var resolveDeferred;
    var rejectDeferred;
    var deferred = new Promise(function (resolve, reject) {
      resolveDeferred = resolve;
      rejectDeferred = reject;
    });

    document.onreadystatechange = function () {
      if (document.readyState === "complete") {
        resolveDeferred();
      }
    };

    if (document.readyState === "complete") {
      resolveDeferred();
    }

    return deferred;
  }

  exports.domReady = domReady;
},103,[],"node_modules\\protoculture\\lib\\Web\\DomReady.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ReactNativeServiceProvider = void 0;

  var _regenerator = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/regenerator"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/inherits"));

  var _protoculture = _$$_REQUIRE(_dependencyMap[7], "protoculture");

  var _ReactNativeApp = _$$_REQUIRE(_dependencyMap[8], "./ReactNativeApp");

  var ReactNativeServiceProvider = function (_ServiceProvider) {
    (0, _inherits2.default)(ReactNativeServiceProvider, _ServiceProvider);

    function ReactNativeServiceProvider() {
      (0, _classCallCheck2.default)(this, ReactNativeServiceProvider);
      return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ReactNativeServiceProvider).apply(this, arguments));
    }

    (0, _createClass2.default)(ReactNativeServiceProvider, [{
      key: "boot",
      value: function boot() {
        return _regenerator.default.async(function boot$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.bindApp(_ReactNativeApp.ReactNativeApp);

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, null, this);
      }
    }]);
    return ReactNativeServiceProvider;
  }(_protoculture.ServiceProvider);

  exports.ReactNativeServiceProvider = ReactNativeServiceProvider;
},104,[23,105,24,25,26,29,30,33,108],"src\\Layer\\ReactNative\\ReactNativeServiceProvider.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0], "regenerator-runtime");
},105,[106],"node_modules\\@babel\\runtime\\regenerator\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var g = function () {
    return this || typeof self === "object" && self;
  }() || Function("return this")();

  var hadRuntime = g.regeneratorRuntime && Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
  var oldRuntime = hadRuntime && g.regeneratorRuntime;
  g.regeneratorRuntime = undefined;
  module.exports = _$$_REQUIRE(_dependencyMap[0], "./runtime");

  if (hadRuntime) {
    g.regeneratorRuntime = oldRuntime;
  } else {
    try {
      delete g.regeneratorRuntime;
    } catch (e) {
      g.regeneratorRuntime = undefined;
    }
  }
},106,[107],"node_modules\\@babel\\runtime\\node_modules\\regenerator-runtime\\runtime-module.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  !function (global) {
    "use strict";

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    var inModule = typeof module === "object";
    var runtime = global.regeneratorRuntime;

    if (runtime) {
      if (inModule) {
        module.exports = runtime;
      }

      return;
    }

    runtime = global.regeneratorRuntime = inModule ? module.exports : {};

    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    runtime.wrap = wrap;

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {}

    var IteratorPrototype = {};

    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        prototype[method] = function (arg) {
          return this._invoke(method, arg);
        };
      });
    }

    runtime.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    runtime.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;

        if (!(toStringTagSymbol in genFun)) {
          genFun[toStringTagSymbol] = "GeneratorFunction";
        }
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    runtime.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return Promise.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return Promise.resolve(value).then(function (unwrapped) {
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new Promise(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }

      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);

    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };

    runtime.AsyncIterator = AsyncIterator;

    runtime.async = function (innerFn, outerFn, self, tryLocsList) {
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
      return runtime.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined) {
        context.delegate = null;

        if (context.method === "throw") {
          if (delegate.iterator.return) {
            context.method = "return";
            context.arg = undefined;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        context[delegate.resultName] = info.value;
        context.next = delegate.nextLoc;

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined;
        }
      } else {
        return info;
      }

      context.delegate = null;
      return ContinueSentinel;
    }

    defineIteratorMethods(Gp);
    Gp[toStringTagSymbol] = "Generator";

    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    runtime.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse();
      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      }

      return {
        next: doneResult
      };
    }

    runtime.values = values;

    function doneResult() {
      return {
        value: undefined,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            context.method = "next";
            context.arg = undefined;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        }

        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          this.arg = undefined;
        }

        return ContinueSentinel;
      }
    };
  }(function () {
    return this || typeof self === "object" && self;
  }() || Function("return this")());
},107,[],"node_modules\\@babel\\runtime\\node_modules\\regenerator-runtime\\runtime.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ReactNativeApp = void 0;

  var _regenerator = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/regenerator"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass"));

  var _defineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/defineProperty"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[6], "react-native");

  var _reactNativeElements = _$$_REQUIRE(_dependencyMap[7], "react-native-elements");

  var _app = _$$_REQUIRE(_dependencyMap[8], "../../../app.json");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\src\\Layer\\ReactNative\\ReactNativeApp.tsx";

  var ReactNativeApp = function () {
    function ReactNativeApp() {
      (0, _classCallCheck2.default)(this, ReactNativeApp);
      (0, _defineProperty2.default)(this, "name", "react-native");
      (0, _defineProperty2.default)(this, "working", true);
      (0, _defineProperty2.default)(this, "bundle", null);
    }

    (0, _createClass2.default)(ReactNativeApp, [{
      key: "run",
      value: function run() {
        return _regenerator.default.async(function run$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                console.log("registering");

                _reactNative.AppRegistry.registerComponent(_app.name, function () {
                  return function (props) {
                    return _react.default.createElement(_reactNative.View, {
                      __source: {
                        fileName: _jsxFileName,
                        lineNumber: 18
                      }
                    }, _react.default.createElement(_reactNativeElements.Header, {
                      leftComponent: {
                        icon: "menu",
                        color: "#fff"
                      },
                      centerComponent: {
                        text: "Bwaaaaagh",
                        style: {
                          color: "#fff"
                        }
                      },
                      rightComponent: {
                        icon: "home",
                        color: "#fff"
                      },
                      __source: {
                        fileName: _jsxFileName,
                        lineNumber: 20
                      }
                    }), _react.default.createElement(_reactNativeElements.Card, {
                      title: "Login",
                      __source: {
                        fileName: _jsxFileName,
                        lineNumber: 25
                      }
                    }, _react.default.createElement(_reactNative.Text, {
                      __source: {
                        fileName: _jsxFileName,
                        lineNumber: 26
                      }
                    }, "This is a React Native application!")));
                  };
                });

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, null, this);
      }
    }]);
    return ReactNativeApp;
  }();

  exports.ReactNativeApp = ReactNativeApp;
},108,[23,105,24,25,32,109,116,636,745],"src\\Layer\\ReactNative\\ReactNativeApp.tsx");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = _$$_REQUIRE(_dependencyMap[0], "./cjs/react.production.min.js");
  } else {
    module.exports = _$$_REQUIRE(_dependencyMap[1], "./cjs/react.development.js");
  }
},109,[110,113],"node_modules\\react\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /** @license React v16.6.1
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  var k = _$$_REQUIRE(_dependencyMap[0], "object-assign"),
      n = "function" === typeof Symbol && (typeof Symbol === "function" ? Symbol.for : "@@for"),
      p = n ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.element") : 60103,
      q = n ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.portal") : 60106,
      r = n ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.fragment") : 60107,
      t = n ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.strict_mode") : 60108,
      u = n ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.profiler") : 60114,
      v = n ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.provider") : 60109,
      w = n ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.context") : 60110,
      x = n ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.concurrent_mode") : 60111,
      y = n ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.forward_ref") : 60112,
      z = n ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.suspense") : 60113,
      A = n ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.memo") : 60115,
      B = n ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.lazy") : 60116,
      C = "function" === typeof Symbol && (typeof Symbol === "function" ? Symbol.iterator : "@@iterator");

  function aa(a, b, e, c, d, g, h, f) {
    if (!a) {
      a = void 0;
      if (void 0 === b) a = Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else {
        var l = [e, c, d, g, h, f],
            m = 0;
        a = Error(b.replace(/%s/g, function () {
          return l[m++];
        }));
        a.name = "Invariant Violation";
      }
      a.framesToPop = 1;
      throw a;
    }
  }

  function D(a) {
    for (var b = arguments.length - 1, e = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 0; c < b; c++) {
      e += "&args[]=" + encodeURIComponent(arguments[c + 1]);
    }

    aa(!1, "Minified React error #" + a + "; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ", e);
  }

  var E = {
    isMounted: function isMounted() {
      return !1;
    },
    enqueueForceUpdate: function enqueueForceUpdate() {},
    enqueueReplaceState: function enqueueReplaceState() {},
    enqueueSetState: function enqueueSetState() {}
  },
      F = {};

  function G(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = F;
    this.updater = e || E;
  }

  G.prototype.isReactComponent = {};

  G.prototype.setState = function (a, b) {
    "object" !== typeof a && "function" !== typeof a && null != a ? D("85") : void 0;
    this.updater.enqueueSetState(this, a, b, "setState");
  };

  G.prototype.forceUpdate = function (a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
  };

  function H() {}

  H.prototype = G.prototype;

  function I(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = F;
    this.updater = e || E;
  }

  var J = I.prototype = new H();
  J.constructor = I;
  k(J, G.prototype);
  J.isPureReactComponent = !0;
  var K = {
    current: null,
    currentDispatcher: null
  },
      L = Object.prototype.hasOwnProperty,
      M = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
  };

  function N(a, b, e) {
    var c = void 0,
        d = {},
        g = null,
        h = null;
    if (null != b) for (c in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (g = "" + b.key), b) {
      L.call(b, c) && !M.hasOwnProperty(c) && (d[c] = b[c]);
    }
    var f = arguments.length - 2;
    if (1 === f) d.children = e;else if (1 < f) {
      for (var l = Array(f), m = 0; m < f; m++) {
        l[m] = arguments[m + 2];
      }

      d.children = l;
    }
    if (a && a.defaultProps) for (c in f = a.defaultProps, f) {
      void 0 === d[c] && (d[c] = f[c]);
    }
    return {
      $$typeof: p,
      type: a,
      key: g,
      ref: h,
      props: d,
      _owner: K.current
    };
  }

  function ba(a, b) {
    return {
      $$typeof: p,
      type: a.type,
      key: b,
      ref: a.ref,
      props: a.props,
      _owner: a._owner
    };
  }

  function O(a) {
    return "object" === typeof a && null !== a && a.$$typeof === p;
  }

  function escape(a) {
    var b = {
      "=": "=0",
      ":": "=2"
    };
    return "$" + ("" + a).replace(/[=:]/g, function (a) {
      return b[a];
    });
  }

  var P = /\/+/g,
      Q = [];

  function R(a, b, e, c) {
    if (Q.length) {
      var d = Q.pop();
      d.result = a;
      d.keyPrefix = b;
      d.func = e;
      d.context = c;
      d.count = 0;
      return d;
    }

    return {
      result: a,
      keyPrefix: b,
      func: e,
      context: c,
      count: 0
    };
  }

  function S(a) {
    a.result = null;
    a.keyPrefix = null;
    a.func = null;
    a.context = null;
    a.count = 0;
    10 > Q.length && Q.push(a);
  }

  function T(a, b, e, c) {
    var d = typeof a;
    if ("undefined" === d || "boolean" === d) a = null;
    var g = !1;
    if (null === a) g = !0;else switch (d) {
      case "string":
      case "number":
        g = !0;
        break;

      case "object":
        switch (a.$$typeof) {
          case p:
          case q:
            g = !0;
        }

    }
    if (g) return e(c, a, "" === b ? "." + U(a, 0) : b), 1;
    g = 0;
    b = "" === b ? "." : b + ":";
    if (Array.isArray(a)) for (var h = 0; h < a.length; h++) {
      d = a[h];
      var f = b + U(d, h);
      g += T(d, f, e, c);
    } else if (null === a || "object" !== typeof a ? f = null : (f = C && a[C] || a["@@iterator"], f = "function" === typeof f ? f : null), "function" === typeof f) for (a = f.call(a), h = 0; !(d = a.next()).done;) {
      d = d.value, f = b + U(d, h++), g += T(d, f, e, c);
    } else "object" === d && (e = "" + a, D("31", "[object Object]" === e ? "object with keys {" + Object.keys(a).join(", ") + "}" : e, ""));
    return g;
  }

  function V(a, b, e) {
    return null == a ? 0 : T(a, "", b, e);
  }

  function U(a, b) {
    return "object" === typeof a && null !== a && null != a.key ? escape(a.key) : b.toString(36);
  }

  function ca(a, b) {
    a.func.call(a.context, b, a.count++);
  }

  function da(a, b, e) {
    var c = a.result,
        d = a.keyPrefix;
    a = a.func.call(a.context, b, a.count++);
    Array.isArray(a) ? W(a, c, e, function (a) {
      return a;
    }) : null != a && (O(a) && (a = ba(a, d + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(P, "$&/") + "/") + e)), c.push(a));
  }

  function W(a, b, e, c, d) {
    var g = "";
    null != e && (g = ("" + e).replace(P, "$&/") + "/");
    b = R(b, g, c, d);
    V(a, da, b);
    S(b);
  }

  var X = {
    Children: {
      map: function map(a, b, e) {
        if (null == a) return a;
        var c = [];
        W(a, c, null, b, e);
        return c;
      },
      forEach: function forEach(a, b, e) {
        if (null == a) return a;
        b = R(null, null, b, e);
        V(a, ca, b);
        S(b);
      },
      count: function count(a) {
        return V(a, function () {
          return null;
        }, null);
      },
      toArray: function toArray(a) {
        var b = [];
        W(a, b, null, function (a) {
          return a;
        });
        return b;
      },
      only: function only(a) {
        O(a) ? void 0 : D("143");
        return a;
      }
    },
    createRef: function createRef() {
      return {
        current: null
      };
    },
    Component: G,
    PureComponent: I,
    createContext: function createContext(a, b) {
      void 0 === b && (b = null);
      a = {
        $$typeof: w,
        _calculateChangedBits: b,
        _currentValue: a,
        _currentValue2: a,
        Provider: null,
        Consumer: null
      };
      a.Provider = {
        $$typeof: v,
        _context: a
      };
      return a.Consumer = a;
    },
    forwardRef: function forwardRef(a) {
      return {
        $$typeof: y,
        render: a
      };
    },
    lazy: function lazy(a) {
      return {
        $$typeof: B,
        _ctor: a,
        _status: -1,
        _result: null
      };
    },
    memo: function memo(a, b) {
      return {
        $$typeof: A,
        type: a,
        compare: void 0 === b ? null : b
      };
    },
    Fragment: r,
    StrictMode: t,
    Suspense: z,
    createElement: N,
    cloneElement: function cloneElement(a, b, e) {
      null === a || void 0 === a ? D("267", a) : void 0;
      var c = void 0,
          d = k({}, a.props),
          g = a.key,
          h = a.ref,
          f = a._owner;

      if (null != b) {
        void 0 !== b.ref && (h = b.ref, f = K.current);
        void 0 !== b.key && (g = "" + b.key);
        var l = void 0;
        a.type && a.type.defaultProps && (l = a.type.defaultProps);

        for (c in b) {
          L.call(b, c) && !M.hasOwnProperty(c) && (d[c] = void 0 === b[c] && void 0 !== l ? l[c] : b[c]);
        }
      }

      c = arguments.length - 2;
      if (1 === c) d.children = e;else if (1 < c) {
        l = Array(c);

        for (var m = 0; m < c; m++) {
          l[m] = arguments[m + 2];
        }

        d.children = l;
      }
      return {
        $$typeof: p,
        type: a.type,
        key: g,
        ref: h,
        props: d,
        _owner: f
      };
    },
    createFactory: function createFactory(a) {
      var b = N.bind(null, a);
      b.type = a;
      return b;
    },
    isValidElement: O,
    version: "16.6.1",
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
      ReactCurrentOwner: K,
      assign: k
    }
  };
  X.unstable_ConcurrentMode = x;
  X.unstable_Profiler = u;
  var Y = {
    default: X
  },
      Z = Y && X || Y;
  module.exports = Z.default || Z;
},110,[111],"node_modules\\react\\cjs\\react.production.min.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;

  function toObject(val) {
    if (val === null || val === undefined) {
      throw new TypeError('Object.assign cannot be called with null or undefined');
    }

    return Object(val);
  }

  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }

      var test1 = new String('abc');
      test1[5] = 'de';

      if (Object.getOwnPropertyNames(test1)[0] === '5') {
        return false;
      }

      var test2 = {};

      for (var i = 0; i < 10; i++) {
        test2['_' + String.fromCharCode(i)] = i;
      }

      var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
        return test2[n];
      });

      if (order2.join('') !== '0123456789') {
        return false;
      }

      var test3 = {};
      'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
        test3[letter] = letter;
      });

      if (Object.keys(_extends({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
        return false;
      }

      return true;
    } catch (err) {
      return false;
    }
  }

  module.exports = shouldUseNative() ? Object.assign : function (target, source) {
    var from;
    var to = toObject(target);
    var symbols;

    for (var s = 1; s < arguments.length; s++) {
      from = Object(arguments[s]);

      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }

      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);

        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            to[symbols[i]] = from[symbols[i]];
          }
        }
      }
    }

    return to;
  };
},111,[112],"node_modules\\object-assign\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _extends() {
    module.exports = _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  module.exports = _extends;
},112,[],"node_modules\\@babel\\runtime\\helpers\\extends.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /** @license React v16.6.1
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  if (process.env.NODE_ENV !== "production") {
    (function () {
      'use strict';

      var _assign = _$$_REQUIRE(_dependencyMap[0], "object-assign");

      var checkPropTypes = _$$_REQUIRE(_dependencyMap[1], "prop-types/checkPropTypes");

      var ReactVersion = '16.6.1';
      var hasSymbol = typeof Symbol === 'function' && (typeof Symbol === "function" ? Symbol.for : "@@for");
      var REACT_ELEMENT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")('react.element') : 0xeac7;
      var REACT_PORTAL_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")('react.portal') : 0xeaca;
      var REACT_FRAGMENT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")('react.fragment') : 0xeacb;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")('react.strict_mode') : 0xeacc;
      var REACT_PROFILER_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")('react.profiler') : 0xead2;
      var REACT_PROVIDER_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")('react.provider') : 0xeacd;
      var REACT_CONTEXT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")('react.context') : 0xeace;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")('react.concurrent_mode') : 0xeacf;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")('react.forward_ref') : 0xead0;
      var REACT_SUSPENSE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")('react.suspense') : 0xead1;
      var REACT_MEMO_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")('react.memo') : 0xead3;
      var REACT_LAZY_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")('react.lazy') : 0xead4;
      var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && (typeof Symbol === "function" ? Symbol.iterator : "@@iterator");
      var FAUX_ITERATOR_SYMBOL = '@@iterator';

      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== 'object') {
          return null;
        }

        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

        if (typeof maybeIterator === 'function') {
          return maybeIterator;
        }

        return null;
      }

      var enableHooks = false;
      var enableStableConcurrentModeAPIs = false;

      var validateFormat = function validateFormat() {};

      {
        validateFormat = function validateFormat(format) {
          if (format === undefined) {
            throw new Error('invariant requires an error message argument');
          }
        };
      }

      function invariant(condition, format, a, b, c, d, e, f) {
        validateFormat(format);

        if (!condition) {
          var error = void 0;

          if (format === undefined) {
            error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
          } else {
            var args = [a, b, c, d, e, f];
            var argIndex = 0;
            error = new Error(format.replace(/%s/g, function () {
              return args[argIndex++];
            }));
            error.name = 'Invariant Violation';
          }

          error.framesToPop = 1;
          throw error;
        }
      }

      var lowPriorityWarning = function lowPriorityWarning() {};

      {
        var printWarning = function printWarning(format) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          var argIndex = 0;
          var message = 'Warning: ' + format.replace(/%s/g, function () {
            return args[argIndex++];
          });

          if (typeof console !== 'undefined') {
            console.warn(message);
          }

          try {
            throw new Error(message);
          } catch (x) {}
        };

        lowPriorityWarning = function lowPriorityWarning(condition, format) {
          if (format === undefined) {
            throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
          }

          if (!condition) {
            for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
              args[_key2 - 2] = arguments[_key2];
            }

            printWarning.apply(undefined, [format].concat(args));
          }
        };
      }
      var lowPriorityWarning$1 = lowPriorityWarning;

      var warningWithoutStack = function warningWithoutStack() {};

      {
        warningWithoutStack = function warningWithoutStack(condition, format) {
          for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          if (format === undefined) {
            throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
          }

          if (args.length > 8) {
            throw new Error('warningWithoutStack() currently supports at most 8 arguments.');
          }

          if (condition) {
            return;
          }

          if (typeof console !== 'undefined') {
            var argsWithFormat = args.map(function (item) {
              return '' + item;
            });
            argsWithFormat.unshift('Warning: ' + format);
            Function.prototype.apply.call(console.error, console, argsWithFormat);
          }

          try {
            var argIndex = 0;
            var message = 'Warning: ' + format.replace(/%s/g, function () {
              return args[argIndex++];
            });
            throw new Error(message);
          } catch (x) {}
        };
      }
      var warningWithoutStack$1 = warningWithoutStack;
      var didWarnStateUpdateForUnmountedComponent = {};

      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor;
          var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
          var warningKey = componentName + '.' + callerName;

          if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
            return;
          }

          warningWithoutStack$1(false, "Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
          didWarnStateUpdateForUnmountedComponent[warningKey] = true;
        }
      }

      var ReactNoopUpdateQueue = {
        isMounted: function isMounted(publicInstance) {
          return false;
        },
        enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {
          warnNoop(publicInstance, 'forceUpdate');
        },
        enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {
          warnNoop(publicInstance, 'replaceState');
        },
        enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {
          warnNoop(publicInstance, 'setState');
        }
      };
      var emptyObject = {};
      {
        Object.freeze(emptyObject);
      }

      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }

      Component.prototype.isReactComponent = {};

      Component.prototype.setState = function (partialState, callback) {
        !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
        this.updater.enqueueSetState(this, partialState, callback, 'setState');
      };

      Component.prototype.forceUpdate = function (callback) {
        this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
      };

      {
        var deprecatedAPIs = {
          isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
          replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
        };

        var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function get() {
              lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
              return undefined;
            }
          });
        };

        for (var fnName in deprecatedAPIs) {
          if (deprecatedAPIs.hasOwnProperty(fnName)) {
            defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
          }
        }
      }

      function ComponentDummy() {}

      ComponentDummy.prototype = Component.prototype;

      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }

      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent;

      _assign(pureComponentPrototype, Component.prototype);

      pureComponentPrototype.isPureReactComponent = true;

      function createRef() {
        var refObject = {
          current: null
        };
        {
          Object.seal(refObject);
        }
        return refObject;
      }

      var ReactCurrentOwner = {
        current: null,
        currentDispatcher: null
      };
      var BEFORE_SLASH_RE = /^(.*)[\\\/]/;

      var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
        var sourceInfo = '';

        if (source) {
          var path = source.fileName;
          var fileName = path.replace(BEFORE_SLASH_RE, '');
          {
            if (/^index\./.test(fileName)) {
              var match = path.match(BEFORE_SLASH_RE);

              if (match) {
                var pathBeforeSlash = match[1];

                if (pathBeforeSlash) {
                  var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');
                  fileName = folderName + '/' + fileName;
                }
              }
            }
          }
          sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
        } else if (ownerName) {
          sourceInfo = ' (created by ' + ownerName + ')';
        }

        return '\n    in ' + (name || 'Unknown') + sourceInfo;
      };

      var Resolved = 1;

      function refineResolvedLazyComponent(lazyComponent) {
        return lazyComponent._status === Resolved ? lazyComponent._result : null;
      }

      function getWrappedName(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || '';
        return outerType.displayName || (functionName !== '' ? wrapperName + '(' + functionName + ')' : wrapperName);
      }

      function getComponentName(type) {
        if (type == null) {
          return null;
        }

        {
          if (typeof type.tag === 'number') {
            warningWithoutStack$1(false, 'Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
          }
        }

        if (typeof type === 'function') {
          return type.displayName || type.name || null;
        }

        if (typeof type === 'string') {
          return type;
        }

        switch (type) {
          case REACT_CONCURRENT_MODE_TYPE:
            return 'ConcurrentMode';

          case REACT_FRAGMENT_TYPE:
            return 'Fragment';

          case REACT_PORTAL_TYPE:
            return 'Portal';

          case REACT_PROFILER_TYPE:
            return 'Profiler';

          case REACT_STRICT_MODE_TYPE:
            return 'StrictMode';

          case REACT_SUSPENSE_TYPE:
            return 'Suspense';
        }

        if (typeof type === 'object') {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              return 'Context.Consumer';

            case REACT_PROVIDER_TYPE:
              return 'Context.Provider';

            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, 'ForwardRef');

            case REACT_MEMO_TYPE:
              return getComponentName(type.type);

            case REACT_LAZY_TYPE:
              {
                var thenable = type;
                var resolvedThenable = refineResolvedLazyComponent(thenable);

                if (resolvedThenable) {
                  return getComponentName(resolvedThenable);
                }
              }
          }
        }

        return null;
      }

      var ReactDebugCurrentFrame = {};
      var currentlyValidatingElement = null;

      function setCurrentlyValidatingElement(element) {
        {
          currentlyValidatingElement = element;
        }
      }

      {
        ReactDebugCurrentFrame.getCurrentStack = null;

        ReactDebugCurrentFrame.getStackAddendum = function () {
          var stack = '';

          if (currentlyValidatingElement) {
            var name = getComponentName(currentlyValidatingElement.type);
            var owner = currentlyValidatingElement._owner;
            stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));
          }

          var impl = ReactDebugCurrentFrame.getCurrentStack;

          if (impl) {
            stack += impl() || '';
          }

          return stack;
        };
      }
      var ReactSharedInternals = {
        ReactCurrentOwner: ReactCurrentOwner,
        assign: _assign
      };
      {
        _assign(ReactSharedInternals, {
          ReactDebugCurrentFrame: ReactDebugCurrentFrame,
          ReactComponentTreeHook: {}
        });
      }
      var warning = warningWithoutStack$1;
      {
        warning = function warning(condition, format) {
          if (condition) {
            return;
          }

          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame.getStackAddendum();

          for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          warningWithoutStack$1.apply(undefined, [false, format + '%s'].concat(args, [stack]));
        };
      }
      var warning$1 = warning;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown = void 0;
      var specialPropRefWarningShown = void 0;

      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, 'ref')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== undefined;
      }

      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, 'key')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== undefined;
      }

      function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function warnAboutAccessingKey() {
          if (!specialPropKeyWarningShown) {
            specialPropKeyWarningShown = true;
            warningWithoutStack$1(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
          }
        };

        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, 'key', {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }

      function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function warnAboutAccessingRef() {
          if (!specialPropRefWarningShown) {
            specialPropRefWarningShown = true;
            warningWithoutStack$1(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
          }
        };

        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, 'ref', {
          get: warnAboutAccessingRef,
          configurable: true
        });
      }

      var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type: type,
          key: key,
          ref: ref,
          props: props,
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, 'validated', {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, '_self', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
          });
          Object.defineProperty(element, '_source', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });

          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };

      function createElement(type, config, children) {
        var propName = void 0;
        var props = {};
        var key = null;
        var ref = null;
        var self = null;
        var source = null;

        if (config != null) {
          if (hasValidRef(config)) {
            ref = config.ref;
          }

          if (hasValidKey(config)) {
            key = '' + config.key;
          }

          self = config.__self === undefined ? null : config.__self;
          source = config.__source === undefined ? null : config.__source;

          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
        }

        var childrenLength = arguments.length - 2;

        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);

          for (var i = 0; i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }

          {
            if (Object.freeze) {
              Object.freeze(childArray);
            }
          }
          props.children = childArray;
        }

        if (type && type.defaultProps) {
          var defaultProps = type.defaultProps;

          for (propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
        }

        {
          if (key || ref) {
            var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }

            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
      }

      function cloneAndReplaceKey(oldElement, newKey) {
        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
        return newElement;
      }

      function cloneElement(element, config, children) {
        !!(element === null || element === undefined) ? invariant(false, 'React.cloneElement(...): The argument must be a React element, but you passed %s.', element) : void 0;
        var propName = void 0;

        var props = _assign({}, element.props);

        var key = element.key;
        var ref = element.ref;
        var self = element._self;
        var source = element._source;
        var owner = element._owner;

        if (config != null) {
          if (hasValidRef(config)) {
            ref = config.ref;
            owner = ReactCurrentOwner.current;
          }

          if (hasValidKey(config)) {
            key = '' + config.key;
          }

          var defaultProps = void 0;

          if (element.type && element.type.defaultProps) {
            defaultProps = element.type.defaultProps;
          }

          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              if (config[propName] === undefined && defaultProps !== undefined) {
                props[propName] = defaultProps[propName];
              } else {
                props[propName] = config[propName];
              }
            }
          }
        }

        var childrenLength = arguments.length - 2;

        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);

          for (var i = 0; i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }

          props.children = childArray;
        }

        return ReactElement(element.type, key, ref, self, source, owner, props);
      }

      function isValidElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }

      var SEPARATOR = '.';
      var SUBSEPARATOR = ':';

      function escape(key) {
        var escapeRegex = /[=:]/g;
        var escaperLookup = {
          '=': '=0',
          ':': '=2'
        };
        var escapedString = ('' + key).replace(escapeRegex, function (match) {
          return escaperLookup[match];
        });
        return '$' + escapedString;
      }

      var didWarnAboutMaps = false;
      var userProvidedKeyEscapeRegex = /\/+/g;

      function escapeUserProvidedKey(text) {
        return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
      }

      var POOL_SIZE = 10;
      var traverseContextPool = [];

      function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
        if (traverseContextPool.length) {
          var traverseContext = traverseContextPool.pop();
          traverseContext.result = mapResult;
          traverseContext.keyPrefix = keyPrefix;
          traverseContext.func = mapFunction;
          traverseContext.context = mapContext;
          traverseContext.count = 0;
          return traverseContext;
        } else {
          return {
            result: mapResult,
            keyPrefix: keyPrefix,
            func: mapFunction,
            context: mapContext,
            count: 0
          };
        }
      }

      function releaseTraverseContext(traverseContext) {
        traverseContext.result = null;
        traverseContext.keyPrefix = null;
        traverseContext.func = null;
        traverseContext.context = null;
        traverseContext.count = 0;

        if (traverseContextPool.length < POOL_SIZE) {
          traverseContextPool.push(traverseContext);
        }
      }

      function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
        var type = typeof children;

        if (type === 'undefined' || type === 'boolean') {
          children = null;
        }

        var invokeCallback = false;

        if (children === null) {
          invokeCallback = true;
        } else {
          switch (type) {
            case 'string':
            case 'number':
              invokeCallback = true;
              break;

            case 'object':
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
              }

          }
        }

        if (invokeCallback) {
          callback(traverseContext, children, nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
          return 1;
        }

        var child = void 0;
        var nextName = void 0;
        var subtreeCount = 0;
        var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

        if (Array.isArray(children)) {
          for (var i = 0; i < children.length; i++) {
            child = children[i];
            nextName = nextNamePrefix + getComponentKey(child, i);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        } else {
          var iteratorFn = getIteratorFn(children);

          if (typeof iteratorFn === 'function') {
            {
              if (iteratorFn === children.entries) {
                !didWarnAboutMaps ? warning$1(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.') : void 0;
                didWarnAboutMaps = true;
              }
            }
            var iterator = iteratorFn.call(children);
            var step = void 0;
            var ii = 0;

            while (!(step = iterator.next()).done) {
              child = step.value;
              nextName = nextNamePrefix + getComponentKey(child, ii++);
              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
          } else if (type === 'object') {
            var addendum = '';
            {
              addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
            }
            var childrenString = '' + children;
            invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
          }
        }

        return subtreeCount;
      }

      function traverseAllChildren(children, callback, traverseContext) {
        if (children == null) {
          return 0;
        }

        return traverseAllChildrenImpl(children, '', callback, traverseContext);
      }

      function getComponentKey(component, index) {
        if (typeof component === 'object' && component !== null && component.key != null) {
          return escape(component.key);
        }

        return index.toString(36);
      }

      function forEachSingleChild(bookKeeping, child, name) {
        var func = bookKeeping.func,
            context = bookKeeping.context;
        func.call(context, child, bookKeeping.count++);
      }

      function forEachChildren(children, forEachFunc, forEachContext) {
        if (children == null) {
          return children;
        }

        var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
        traverseAllChildren(children, forEachSingleChild, traverseContext);
        releaseTraverseContext(traverseContext);
      }

      function mapSingleChildIntoContext(bookKeeping, child, childKey) {
        var result = bookKeeping.result,
            keyPrefix = bookKeeping.keyPrefix,
            func = bookKeeping.func,
            context = bookKeeping.context;
        var mappedChild = func.call(context, child, bookKeeping.count++);

        if (Array.isArray(mappedChild)) {
          mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function (c) {
            return c;
          });
        } else if (mappedChild != null) {
          if (isValidElement(mappedChild)) {
            mappedChild = cloneAndReplaceKey(mappedChild, keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
          }

          result.push(mappedChild);
        }
      }

      function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
        var escapedPrefix = '';

        if (prefix != null) {
          escapedPrefix = escapeUserProvidedKey(prefix) + '/';
        }

        var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
        traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
        releaseTraverseContext(traverseContext);
      }

      function mapChildren(children, func, context) {
        if (children == null) {
          return children;
        }

        var result = [];
        mapIntoWithKeyPrefixInternal(children, result, null, func, context);
        return result;
      }

      function countChildren(children) {
        return traverseAllChildren(children, function () {
          return null;
        }, null);
      }

      function toArray(children) {
        var result = [];
        mapIntoWithKeyPrefixInternal(children, result, null, function (child) {
          return child;
        });
        return result;
      }

      function onlyChild(children) {
        !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
        return children;
      }

      function createContext(defaultValue, calculateChangedBits) {
        if (calculateChangedBits === undefined) {
          calculateChangedBits = null;
        } else {
          {
            !(calculateChangedBits === null || typeof calculateChangedBits === 'function') ? warningWithoutStack$1(false, 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits) : void 0;
          }
        }

        var context = {
          $$typeof: REACT_CONTEXT_TYPE,
          _calculateChangedBits: calculateChangedBits,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          Provider: null,
          Consumer: null
        };
        context.Provider = {
          $$typeof: REACT_PROVIDER_TYPE,
          _context: context
        };
        var hasWarnedAboutUsingNestedContextConsumers = false;
        var hasWarnedAboutUsingConsumerProvider = false;
        {
          var Consumer = {
            $$typeof: REACT_CONTEXT_TYPE,
            _context: context,
            _calculateChangedBits: context._calculateChangedBits
          };
          Object.defineProperties(Consumer, {
            Provider: {
              get: function get() {
                if (!hasWarnedAboutUsingConsumerProvider) {
                  hasWarnedAboutUsingConsumerProvider = true;
                  warning$1(false, 'Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
                }

                return context.Provider;
              },
              set: function set(_Provider) {
                context.Provider = _Provider;
              }
            },
            _currentValue: {
              get: function get() {
                return context._currentValue;
              },
              set: function set(_currentValue) {
                context._currentValue = _currentValue;
              }
            },
            _currentValue2: {
              get: function get() {
                return context._currentValue2;
              },
              set: function set(_currentValue2) {
                context._currentValue2 = _currentValue2;
              }
            },
            Consumer: {
              get: function get() {
                if (!hasWarnedAboutUsingNestedContextConsumers) {
                  hasWarnedAboutUsingNestedContextConsumers = true;
                  warning$1(false, 'Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
                }

                return context.Consumer;
              }
            }
          });
          context.Consumer = Consumer;
        }
        {
          context._currentRenderer = null;
          context._currentRenderer2 = null;
        }
        return context;
      }

      function lazy(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _ctor: ctor,
          _status: -1,
          _result: null
        };
      }

      function forwardRef(render) {
        {
          if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
            warningWithoutStack$1(false, 'forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
          } else if (typeof render !== 'function') {
            warningWithoutStack$1(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
          } else {
            !(render.length === 0 || render.length === 2) ? warningWithoutStack$1(false, 'forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.') : void 0;
          }

          if (render != null) {
            !(render.defaultProps == null && render.propTypes == null) ? warningWithoutStack$1(false, 'forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?') : void 0;
          }
        }
        return {
          $$typeof: REACT_FORWARD_REF_TYPE,
          render: render
        };
      }

      function isValidElementType(type) {
        return typeof type === 'string' || typeof type === 'function' || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
      }

      function memo(type, compare) {
        {
          if (!isValidElementType(type)) {
            warningWithoutStack$1(false, 'memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
          }
        }
        return {
          $$typeof: REACT_MEMO_TYPE,
          type: type,
          compare: compare === undefined ? null : compare
        };
      }

      function resolveDispatcher() {
        var dispatcher = ReactCurrentOwner.currentDispatcher;
        !(dispatcher !== null) ? invariant(false, 'Hooks can only be called inside the body of a function component.') : void 0;
        return dispatcher;
      }

      function useContext(Context, observedBits) {
        var dispatcher = resolveDispatcher();
        {
          if (Context._context !== undefined) {
            var realContext = Context._context;

            if (realContext.Consumer === Context) {
              warning$1(false, 'Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
            } else if (realContext.Provider === Context) {
              warning$1(false, 'Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
            }
          }
        }
        return dispatcher.useContext(Context, observedBits);
      }

      function useState(initialState) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useState(initialState);
      }

      function useReducer(reducer, initialState, initialAction) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useReducer(reducer, initialState, initialAction);
      }

      function useRef(initialValue) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useRef(initialValue);
      }

      function useEffect(create, inputs) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useEffect(create, inputs);
      }

      function useMutationEffect(create, inputs) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useMutationEffect(create, inputs);
      }

      function useLayoutEffect(create, inputs) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useLayoutEffect(create, inputs);
      }

      function useCallback(callback, inputs) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useCallback(callback, inputs);
      }

      function useMemo(create, inputs) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useMemo(create, inputs);
      }

      function useImperativeMethods(ref, create, inputs) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useImperativeMethods(ref, create, inputs);
      }

      var propTypesMisspellWarningShown = void 0;
      {
        propTypesMisspellWarningShown = false;
      }

      function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner.current) {
          var name = getComponentName(ReactCurrentOwner.current.type);

          if (name) {
            return '\n\nCheck the render method of `' + name + '`.';
          }
        }

        return '';
      }

      function getSourceInfoErrorAddendum(elementProps) {
        if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
          var source = elementProps.__source;
          var fileName = source.fileName.replace(/^.*[\\\/]/, '');
          var lineNumber = source.lineNumber;
          return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
        }

        return '';
      }

      var ownerHasKeyUseWarning = {};

      function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();

        if (!info) {
          var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

          if (parentName) {
            info = '\n\nCheck the top-level render call using <' + parentName + '>.';
          }
        }

        return info;
      }

      function validateExplicitKey(element, parentType) {
        if (!element._store || element._store.validated || element.key != null) {
          return;
        }

        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
          return;
        }

        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
        var childOwner = '';

        if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
          childOwner = ' It was passed a child from ' + getComponentName(element._owner.type) + '.';
        }

        setCurrentlyValidatingElement(element);
        {
          warning$1(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);
        }
        setCurrentlyValidatingElement(null);
      }

      function validateChildKeys(node, parentType) {
        if (typeof node !== 'object') {
          return;
        }

        if (Array.isArray(node)) {
          for (var i = 0; i < node.length; i++) {
            var child = node[i];

            if (isValidElement(child)) {
              validateExplicitKey(child, parentType);
            }
          }
        } else if (isValidElement(node)) {
          if (node._store) {
            node._store.validated = true;
          }
        } else if (node) {
          var iteratorFn = getIteratorFn(node);

          if (typeof iteratorFn === 'function') {
            if (iteratorFn !== node.entries) {
              var iterator = iteratorFn.call(node);
              var step = void 0;

              while (!(step = iterator.next()).done) {
                if (isValidElement(step.value)) {
                  validateExplicitKey(step.value, parentType);
                }
              }
            }
          }
        }
      }

      function validatePropTypes(element) {
        var type = element.type;
        var name = void 0,
            propTypes = void 0;

        if (typeof type === 'function') {
          name = type.displayName || type.name;
          propTypes = type.propTypes;
        } else if (typeof type === 'object' && type !== null && type.$$typeof === REACT_FORWARD_REF_TYPE) {
          var functionName = type.render.displayName || type.render.name || '';
          name = type.displayName || (functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef');
          propTypes = type.propTypes;
        } else {
          return;
        }

        if (propTypes) {
          setCurrentlyValidatingElement(element);
          checkPropTypes(propTypes, element.props, 'prop', name, ReactDebugCurrentFrame.getStackAddendum);
          setCurrentlyValidatingElement(null);
        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
          propTypesMisspellWarningShown = true;
          warningWithoutStack$1(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
        }

        if (typeof type.getDefaultProps === 'function') {
          !type.getDefaultProps.isReactClassApproved ? warningWithoutStack$1(false, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
        }
      }

      function validateFragmentProps(fragment) {
        setCurrentlyValidatingElement(fragment);
        var keys = Object.keys(fragment.props);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];

          if (key !== 'children' && key !== 'key') {
            warning$1(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
            break;
          }
        }

        if (fragment.ref !== null) {
          warning$1(false, 'Invalid attribute `ref` supplied to `React.Fragment`.');
        }

        setCurrentlyValidatingElement(null);
      }

      function createElementWithValidation(type, props, children) {
        var validType = isValidElementType(type);

        if (!validType) {
          var info = '';

          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
            info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
          }

          var sourceInfo = getSourceInfoErrorAddendum(props);

          if (sourceInfo) {
            info += sourceInfo;
          } else {
            info += getDeclarationErrorAddendum();
          }

          var typeString = void 0;

          if (type === null) {
            typeString = 'null';
          } else if (Array.isArray(type)) {
            typeString = 'array';
          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
            typeString = '<' + (getComponentName(type.type) || 'Unknown') + ' />';
            info = ' Did you accidentally export a JSX literal instead of a component?';
          } else {
            typeString = typeof type;
          }

          warning$1(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
        }

        var element = createElement.apply(this, arguments);

        if (element == null) {
          return element;
        }

        if (validType) {
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], type);
          }
        }

        if (type === REACT_FRAGMENT_TYPE) {
          validateFragmentProps(element);
        } else {
          validatePropTypes(element);
        }

        return element;
      }

      function createFactoryWithValidation(type) {
        var validatedFactory = createElementWithValidation.bind(null, type);
        validatedFactory.type = type;
        {
          Object.defineProperty(validatedFactory, 'type', {
            enumerable: false,
            get: function get() {
              lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
              Object.defineProperty(this, 'type', {
                value: type
              });
              return type;
            }
          });
        }
        return validatedFactory;
      }

      function cloneElementWithValidation(element, props, children) {
        var newElement = cloneElement.apply(this, arguments);

        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], newElement.type);
        }

        validatePropTypes(newElement);
        return newElement;
      }

      var React = {
        Children: {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray: toArray,
          only: onlyChild
        },
        createRef: createRef,
        Component: Component,
        PureComponent: PureComponent,
        createContext: createContext,
        forwardRef: forwardRef,
        lazy: lazy,
        memo: memo,
        Fragment: REACT_FRAGMENT_TYPE,
        StrictMode: REACT_STRICT_MODE_TYPE,
        Suspense: REACT_SUSPENSE_TYPE,
        createElement: createElementWithValidation,
        cloneElement: cloneElementWithValidation,
        createFactory: createFactoryWithValidation,
        isValidElement: isValidElement,
        version: ReactVersion,
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals
      };

      if (enableStableConcurrentModeAPIs) {
        React.ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        React.Profiler = REACT_PROFILER_TYPE;
      } else {
        React.unstable_ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        React.unstable_Profiler = REACT_PROFILER_TYPE;
      }

      if (enableHooks) {
        React.useCallback = useCallback;
        React.useContext = useContext;
        React.useEffect = useEffect;
        React.useImperativeMethods = useImperativeMethods;
        React.useLayoutEffect = useLayoutEffect;
        React.useMemo = useMemo;
        React.useMutationEffect = useMutationEffect;
        React.useReducer = useReducer;
        React.useRef = useRef;
        React.useState = useState;
      }

      var React$2 = Object.freeze({
        default: React
      });
      var React$3 = React$2 && React || React$2;
      var react = React$3.default || React$3;
      module.exports = react;
    })();
  }
},113,[111,114],"node_modules\\react\\cjs\\react.development.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var printWarning = function printWarning() {};

  if (process.env.NODE_ENV !== 'production') {
    var ReactPropTypesSecret = _$$_REQUIRE(_dependencyMap[0], "./lib/ReactPropTypesSecret");

    var loggedTypeFailures = {};

    printWarning = function printWarning(text) {
      var message = 'Warning: ' + text;

      if (typeof console !== 'undefined') {
        console.error(message);
      }

      try {
        throw new Error(message);
      } catch (x) {}
    };
  }

  function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
    if (process.env.NODE_ENV !== 'production') {
      for (var typeSpecName in typeSpecs) {
        if (typeSpecs.hasOwnProperty(typeSpecName)) {
          var error;

          try {
            if (typeof typeSpecs[typeSpecName] !== 'function') {
              var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.');
              err.name = 'Invariant Violation';
              throw err;
            }

            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
          } catch (ex) {
            error = ex;
          }

          if (error && !(error instanceof Error)) {
            printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
          }

          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            var stack = getStack ? getStack() : '';
            printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
          }
        }
      }
    }
  }

  module.exports = checkPropTypes;
},114,[115],"node_modules\\prop-types\\checkPropTypes.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
  module.exports = ReactPropTypesSecret;
},115,[],"node_modules\\prop-types\\lib\\ReactPropTypesSecret.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var invariant = _$$_REQUIRE(_dependencyMap[0], "fbjs/lib/invariant");

  var showedListViewDeprecation = false;
  var showedSwipeableListViewDeprecation = false;
  var ReactNative = {
    get AccessibilityInfo() {
      return _$$_REQUIRE(_dependencyMap[1], "AccessibilityInfo");
    },

    get ActivityIndicator() {
      return _$$_REQUIRE(_dependencyMap[2], "ActivityIndicator");
    },

    get ART() {
      return _$$_REQUIRE(_dependencyMap[3], "ReactNativeART");
    },

    get Button() {
      return _$$_REQUIRE(_dependencyMap[4], "Button");
    },

    get CheckBox() {
      return _$$_REQUIRE(_dependencyMap[5], "CheckBox");
    },

    get DatePickerIOS() {
      return _$$_REQUIRE(_dependencyMap[6], "DatePickerIOS");
    },

    get DrawerLayoutAndroid() {
      return _$$_REQUIRE(_dependencyMap[7], "DrawerLayoutAndroid");
    },

    get FlatList() {
      return _$$_REQUIRE(_dependencyMap[8], "FlatList");
    },

    get Image() {
      return _$$_REQUIRE(_dependencyMap[9], "Image");
    },

    get ImageBackground() {
      return _$$_REQUIRE(_dependencyMap[10], "ImageBackground");
    },

    get ImageEditor() {
      return _$$_REQUIRE(_dependencyMap[11], "ImageEditor");
    },

    get ImageStore() {
      return _$$_REQUIRE(_dependencyMap[12], "ImageStore");
    },

    get InputAccessoryView() {
      return _$$_REQUIRE(_dependencyMap[13], "InputAccessoryView");
    },

    get KeyboardAvoidingView() {
      return _$$_REQUIRE(_dependencyMap[14], "KeyboardAvoidingView");
    },

    get ListView() {
      if (!showedListViewDeprecation) {
        console.warn('ListView is deprecated and will be removed in a future release. ' + 'See https://fb.me/nolistview for more information');
        showedListViewDeprecation = true;
      }

      return _$$_REQUIRE(_dependencyMap[15], "ListView");
    },

    get MaskedViewIOS() {
      return _$$_REQUIRE(_dependencyMap[16], "MaskedViewIOS");
    },

    get Modal() {
      return _$$_REQUIRE(_dependencyMap[17], "Modal");
    },

    get NavigatorIOS() {
      return _$$_REQUIRE(_dependencyMap[18], "NavigatorIOS");
    },

    get Picker() {
      return _$$_REQUIRE(_dependencyMap[19], "Picker");
    },

    get PickerIOS() {
      return _$$_REQUIRE(_dependencyMap[20], "PickerIOS");
    },

    get ProgressBarAndroid() {
      return _$$_REQUIRE(_dependencyMap[21], "ProgressBarAndroid");
    },

    get ProgressViewIOS() {
      return _$$_REQUIRE(_dependencyMap[22], "ProgressViewIOS");
    },

    get SafeAreaView() {
      return _$$_REQUIRE(_dependencyMap[23], "SafeAreaView");
    },

    get ScrollView() {
      return _$$_REQUIRE(_dependencyMap[24], "ScrollView");
    },

    get SectionList() {
      return _$$_REQUIRE(_dependencyMap[25], "SectionList");
    },

    get SegmentedControlIOS() {
      return _$$_REQUIRE(_dependencyMap[26], "SegmentedControlIOS");
    },

    get Slider() {
      return _$$_REQUIRE(_dependencyMap[27], "Slider");
    },

    get SnapshotViewIOS() {
      return _$$_REQUIRE(_dependencyMap[28], "SnapshotViewIOS");
    },

    get Switch() {
      return _$$_REQUIRE(_dependencyMap[29], "Switch");
    },

    get RefreshControl() {
      return _$$_REQUIRE(_dependencyMap[30], "RefreshControl");
    },

    get StatusBar() {
      return _$$_REQUIRE(_dependencyMap[31], "StatusBar");
    },

    get SwipeableFlatList() {
      return _$$_REQUIRE(_dependencyMap[32], "SwipeableFlatList");
    },

    get SwipeableListView() {
      if (!showedSwipeableListViewDeprecation) {
        console.warn('ListView and SwipeableListView are deprecated and will be removed in a future release. ' + 'See https://fb.me/nolistview for more information');
        showedSwipeableListViewDeprecation = true;
      }

      return _$$_REQUIRE(_dependencyMap[33], "SwipeableListView");
    },

    get TabBarIOS() {
      return _$$_REQUIRE(_dependencyMap[34], "TabBarIOS");
    },

    get Text() {
      return _$$_REQUIRE(_dependencyMap[35], "Text");
    },

    get TextInput() {
      return _$$_REQUIRE(_dependencyMap[36], "TextInput");
    },

    get ToastAndroid() {
      return _$$_REQUIRE(_dependencyMap[37], "ToastAndroid");
    },

    get ToolbarAndroid() {
      return _$$_REQUIRE(_dependencyMap[38], "ToolbarAndroid");
    },

    get Touchable() {
      return _$$_REQUIRE(_dependencyMap[39], "Touchable");
    },

    get TouchableHighlight() {
      return _$$_REQUIRE(_dependencyMap[40], "TouchableHighlight");
    },

    get TouchableNativeFeedback() {
      return _$$_REQUIRE(_dependencyMap[41], "TouchableNativeFeedback");
    },

    get TouchableOpacity() {
      return _$$_REQUIRE(_dependencyMap[42], "TouchableOpacity");
    },

    get TouchableWithoutFeedback() {
      return _$$_REQUIRE(_dependencyMap[43], "TouchableWithoutFeedback");
    },

    get View() {
      return _$$_REQUIRE(_dependencyMap[44], "View");
    },

    get ViewPagerAndroid() {
      return _$$_REQUIRE(_dependencyMap[45], "ViewPagerAndroid");
    },

    get VirtualizedList() {
      return _$$_REQUIRE(_dependencyMap[46], "VirtualizedList");
    },

    get WebView() {
      return _$$_REQUIRE(_dependencyMap[47], "WebView");
    },

    get ActionSheetIOS() {
      return _$$_REQUIRE(_dependencyMap[48], "ActionSheetIOS");
    },

    get Alert() {
      return _$$_REQUIRE(_dependencyMap[49], "Alert");
    },

    get AlertIOS() {
      return _$$_REQUIRE(_dependencyMap[50], "AlertIOS");
    },

    get Animated() {
      return _$$_REQUIRE(_dependencyMap[51], "Animated");
    },

    get AppRegistry() {
      return _$$_REQUIRE(_dependencyMap[52], "AppRegistry");
    },

    get AppState() {
      return _$$_REQUIRE(_dependencyMap[53], "AppState");
    },

    get AsyncStorage() {
      return _$$_REQUIRE(_dependencyMap[54], "AsyncStorage");
    },

    get BackAndroid() {
      return _$$_REQUIRE(_dependencyMap[55], "BackAndroid");
    },

    get BackHandler() {
      return _$$_REQUIRE(_dependencyMap[56], "BackHandler");
    },

    get CameraRoll() {
      return _$$_REQUIRE(_dependencyMap[57], "CameraRoll");
    },

    get Clipboard() {
      return _$$_REQUIRE(_dependencyMap[58], "Clipboard");
    },

    get DatePickerAndroid() {
      return _$$_REQUIRE(_dependencyMap[59], "DatePickerAndroid");
    },

    get DeviceInfo() {
      return _$$_REQUIRE(_dependencyMap[60], "DeviceInfo");
    },

    get Dimensions() {
      return _$$_REQUIRE(_dependencyMap[61], "Dimensions");
    },

    get Easing() {
      return _$$_REQUIRE(_dependencyMap[62], "Easing");
    },

    get findNodeHandle() {
      return _$$_REQUIRE(_dependencyMap[63], "ReactNative").findNodeHandle;
    },

    get I18nManager() {
      return _$$_REQUIRE(_dependencyMap[64], "I18nManager");
    },

    get ImagePickerIOS() {
      return _$$_REQUIRE(_dependencyMap[65], "ImagePickerIOS");
    },

    get InteractionManager() {
      return _$$_REQUIRE(_dependencyMap[66], "InteractionManager");
    },

    get Keyboard() {
      return _$$_REQUIRE(_dependencyMap[67], "Keyboard");
    },

    get LayoutAnimation() {
      return _$$_REQUIRE(_dependencyMap[68], "LayoutAnimation");
    },

    get Linking() {
      return _$$_REQUIRE(_dependencyMap[69], "Linking");
    },

    get NativeEventEmitter() {
      return _$$_REQUIRE(_dependencyMap[70], "NativeEventEmitter");
    },

    get NetInfo() {
      return _$$_REQUIRE(_dependencyMap[71], "NetInfo");
    },

    get PanResponder() {
      return _$$_REQUIRE(_dependencyMap[72], "PanResponder");
    },

    get PermissionsAndroid() {
      return _$$_REQUIRE(_dependencyMap[73], "PermissionsAndroid");
    },

    get PixelRatio() {
      return _$$_REQUIRE(_dependencyMap[74], "PixelRatio");
    },

    get PushNotificationIOS() {
      return _$$_REQUIRE(_dependencyMap[75], "PushNotificationIOS");
    },

    get Settings() {
      return _$$_REQUIRE(_dependencyMap[76], "Settings");
    },

    get Share() {
      return _$$_REQUIRE(_dependencyMap[77], "Share");
    },

    get StatusBarIOS() {
      return _$$_REQUIRE(_dependencyMap[78], "StatusBarIOS");
    },

    get StyleSheet() {
      return _$$_REQUIRE(_dependencyMap[79], "StyleSheet");
    },

    get Systrace() {
      return _$$_REQUIRE(_dependencyMap[80], "Systrace");
    },

    get TimePickerAndroid() {
      return _$$_REQUIRE(_dependencyMap[81], "TimePickerAndroid");
    },

    get TVEventHandler() {
      return _$$_REQUIRE(_dependencyMap[82], "TVEventHandler");
    },

    get UIManager() {
      return _$$_REQUIRE(_dependencyMap[83], "UIManager");
    },

    get unstable_batchedUpdates() {
      return _$$_REQUIRE(_dependencyMap[63], "ReactNative").unstable_batchedUpdates;
    },

    get Vibration() {
      return _$$_REQUIRE(_dependencyMap[84], "Vibration");
    },

    get VibrationIOS() {
      return _$$_REQUIRE(_dependencyMap[85], "VibrationIOS");
    },

    get YellowBox() {
      return _$$_REQUIRE(_dependencyMap[86], "YellowBox");
    },

    get DeviceEventEmitter() {
      return _$$_REQUIRE(_dependencyMap[87], "RCTDeviceEventEmitter");
    },

    get NativeAppEventEmitter() {
      return _$$_REQUIRE(_dependencyMap[88], "RCTNativeAppEventEmitter");
    },

    get NativeModules() {
      return _$$_REQUIRE(_dependencyMap[89], "NativeModules");
    },

    get Platform() {
      return _$$_REQUIRE(_dependencyMap[90], "Platform");
    },

    get processColor() {
      return _$$_REQUIRE(_dependencyMap[91], "processColor");
    },

    get requireNativeComponent() {
      return _$$_REQUIRE(_dependencyMap[92], "requireNativeComponent");
    },

    get takeSnapshot() {
      return _$$_REQUIRE(_dependencyMap[93], "takeSnapshot");
    },

    get ColorPropType() {
      return _$$_REQUIRE(_dependencyMap[94], "ColorPropType");
    },

    get EdgeInsetsPropType() {
      return _$$_REQUIRE(_dependencyMap[95], "EdgeInsetsPropType");
    },

    get PointPropType() {
      return _$$_REQUIRE(_dependencyMap[96], "PointPropType");
    },

    get ViewPropTypes() {
      return _$$_REQUIRE(_dependencyMap[97], "ViewPropTypes");
    },

    get Navigator() {
      invariant(false, 'Navigator is deprecated and has been removed from this package. It can now be installed ' + 'and imported from `react-native-deprecated-custom-components` instead of `react-native`. ' + 'Learn about alternative navigation solutions at http://facebook.github.io/react-native/docs/navigation.html');
    }

  };
  module.exports = ReactNative;
},116,[117,118,147,279,443,528,529,530,497,521,532,534,535,536,537,499,538,540,577,578,579,278,581,561,503,525,582,583,584,585,515,531,587,591,593,444,595,250,602,449,552,456,467,457,175,603,516,604,607,232,233,468,608,252,619,620,614,621,622,623,153,152,494,178,547,624,476,506,507,625,219,626,589,236,151,627,628,629,630,150,133,631,453,145,632,633,559,137,240,119,146,169,268,634,156,446,635,522],"node_modules\\react-native\\Libraries\\react-native\\react-native-implementation.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var validateFormat = process.env.NODE_ENV !== "production" ? function (format) {} : function (format) {
    if (format === undefined) {
      throw new Error('invariant(...): Second argument must be a string.');
    }
  };

  function invariant(condition, format) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    validateFormat(format);

    if (!condition) {
      var error;

      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return String(args[argIndex++]);
        }));
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1;
      throw error;
    }
  }

  module.exports = invariant;
},117,[],"node_modules\\fbjs\\lib\\invariant.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var NativeModules = _$$_REQUIRE(_dependencyMap[0], "NativeModules");

  var RCTDeviceEventEmitter = _$$_REQUIRE(_dependencyMap[1], "RCTDeviceEventEmitter");

  var UIManager = _$$_REQUIRE(_dependencyMap[2], "UIManager");

  var RCTAccessibilityInfo = NativeModules.AccessibilityInfo;
  var TOUCH_EXPLORATION_EVENT = 'touchExplorationDidChange';

  var _subscriptions = new Map();

  var AccessibilityInfo = {
    fetch: function fetch() {
      return new Promise(function (resolve, reject) {
        RCTAccessibilityInfo.isTouchExplorationEnabled(function (resp) {
          resolve(resp);
        });
      });
    },
    addEventListener: function addEventListener(eventName, handler) {
      var listener = RCTDeviceEventEmitter.addListener(TOUCH_EXPLORATION_EVENT, function (enabled) {
        handler(enabled);
      });

      _subscriptions.set(handler, listener);
    },
    removeEventListener: function removeEventListener(eventName, handler) {
      var listener = _subscriptions.get(handler);

      if (!listener) {
        return;
      }

      listener.remove();

      _subscriptions.delete(handler);
    },
    setAccessibilityFocus: function setAccessibilityFocus(reactTag) {
      UIManager.sendAccessibilityEvent(reactTag, UIManager.AccessibilityEventTypes.typeViewFocused);
    }
  };
  module.exports = AccessibilityInfo;
},118,[119,137,145],"node_modules\\react-native\\Libraries\\Components\\AccessibilityInfo\\AccessibilityInfo.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectWithoutProperties = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutProperties");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var _slicedToArray = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/slicedToArray");

  var BatchedBridge = _$$_REQUIRE(_dependencyMap[3], "BatchedBridge");

  var invariant = _$$_REQUIRE(_dependencyMap[4], "fbjs/lib/invariant");

  function genModule(config, moduleID) {
    if (!config) {
      return null;
    }

    var _config = _slicedToArray(config, 5),
        moduleName = _config[0],
        constants = _config[1],
        methods = _config[2],
        promiseMethods = _config[3],
        syncMethods = _config[4];

    invariant(!moduleName.startsWith('RCT') && !moduleName.startsWith('RK'), "Module name prefixes should've been stripped by the native side " + "but wasn't for " + moduleName);

    if (!constants && !methods) {
      return {
        name: moduleName
      };
    }

    var module = {};
    methods && methods.forEach(function (methodName, methodID) {
      var isPromise = promiseMethods && arrayContains(promiseMethods, methodID);
      var isSync = syncMethods && arrayContains(syncMethods, methodID);
      invariant(!isPromise || !isSync, 'Cannot have a method that is both async and a sync hook');
      var methodType = isPromise ? 'promise' : isSync ? 'sync' : 'async';
      module[methodName] = genMethod(moduleID, methodID, methodType);
    });

    _extends(module, constants);

    if (__DEV__) {
      BatchedBridge.createDebugLookup(moduleID, moduleName, methods);
    }

    return {
      name: moduleName,
      module: module
    };
  }

  global.__fbGenNativeModule = genModule;

  function loadModule(name, moduleID) {
    invariant(global.nativeRequireModuleConfig, "Can't lazily create module without nativeRequireModuleConfig");
    var config = global.nativeRequireModuleConfig(name);
    var info = genModule(config, moduleID);
    return info && info.module;
  }

  function genMethod(moduleID, methodID, type) {
    var fn = null;

    if (type === 'promise') {
      fn = function fn() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return new Promise(function (resolve, reject) {
          BatchedBridge.enqueueNativeCall(moduleID, methodID, args, function (data) {
            return resolve(data);
          }, function (errorData) {
            return reject(createErrorFromErrorData(errorData));
          });
        });
      };
    } else if (type === 'sync') {
      fn = function fn() {
        if (__DEV__) {
          invariant(global.nativeCallSyncHook, 'Calling synchronous methods on native ' + 'modules is not supported in Chrome.\n\n Consider providing alternative ' + 'methods to expose this method in debug mode, e.g. by exposing constants ' + 'ahead-of-time.');
        }

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return global.nativeCallSyncHook(moduleID, methodID, args);
      };
    } else {
      fn = function fn() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        var lastArg = args.length > 0 ? args[args.length - 1] : null;
        var secondLastArg = args.length > 1 ? args[args.length - 2] : null;
        var hasSuccessCallback = typeof lastArg === 'function';
        var hasErrorCallback = typeof secondLastArg === 'function';
        hasErrorCallback && invariant(hasSuccessCallback, 'Cannot have a non-function arg after a function arg.');
        var onSuccess = hasSuccessCallback ? lastArg : null;
        var onFail = hasErrorCallback ? secondLastArg : null;
        var callbackCount = hasSuccessCallback + hasErrorCallback;
        args = args.slice(0, args.length - callbackCount);
        BatchedBridge.enqueueNativeCall(moduleID, methodID, args, onFail, onSuccess);
      };
    }

    fn.type = type;
    return fn;
  }

  function arrayContains(array, value) {
    return array.indexOf(value) !== -1;
  }

  function createErrorFromErrorData(errorData) {
    var _ref = errorData || {},
        message = _ref.message,
        extraErrorInfo = _objectWithoutProperties(_ref, ["message"]);

    var error = new Error(message);
    error.framesToPop = 1;
    return _extends(error, extraErrorInfo);
  }

  var NativeModules = {};

  if (global.nativeModuleProxy) {
    NativeModules = global.nativeModuleProxy;
  } else if (!global.nativeExtensions) {
    var bridgeConfig = global.__fbBatchedBridgeConfig;
    invariant(bridgeConfig, '__fbBatchedBridgeConfig is not set, cannot invoke native modules');

    var defineLazyObjectProperty = _$$_REQUIRE(_dependencyMap[5], "defineLazyObjectProperty");

    (bridgeConfig.remoteModuleConfig || []).forEach(function (config, moduleID) {
      var info = genModule(config, moduleID);

      if (!info) {
        return;
      }

      if (info.module) {
        NativeModules[info.name] = info.module;
      } else {
          defineLazyObjectProperty(NativeModules, info.name, {
            get: function get() {
              return loadModule(info.name, moduleID);
            }
          });
        }
    });
  }

  module.exports = NativeModules;
},119,[120,112,122,126,117,136],"node_modules\\react-native\\Libraries\\BatchedBridge\\NativeModules.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var objectWithoutPropertiesLoose = _$$_REQUIRE(_dependencyMap[0], "./objectWithoutPropertiesLoose");

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  module.exports = _objectWithoutProperties;
},120,[121],"node_modules\\@babel\\runtime\\helpers\\objectWithoutProperties.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  module.exports = _objectWithoutPropertiesLoose;
},121,[],"node_modules\\@babel\\runtime\\helpers\\objectWithoutPropertiesLoose.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var arrayWithHoles = _$$_REQUIRE(_dependencyMap[0], "./arrayWithHoles");

  var iterableToArrayLimit = _$$_REQUIRE(_dependencyMap[1], "./iterableToArrayLimit");

  var nonIterableRest = _$$_REQUIRE(_dependencyMap[2], "./nonIterableRest");

  function _slicedToArray(arr, i) {
    return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
  }

  module.exports = _slicedToArray;
},122,[123,124,125],"node_modules\\@babel\\runtime\\helpers\\slicedToArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  module.exports = _arrayWithHoles;
},123,[],"node_modules\\@babel\\runtime\\helpers\\arrayWithHoles.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  module.exports = _iterableToArrayLimit;
},124,[],"node_modules\\@babel\\runtime\\helpers\\iterableToArrayLimit.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  module.exports = _nonIterableRest;
},125,[],"node_modules\\@babel\\runtime\\helpers\\nonIterableRest.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var MessageQueue = _$$_REQUIRE(_dependencyMap[0], "MessageQueue");

  var BatchedBridge = new MessageQueue();
  Object.defineProperty(global, '__fbBatchedBridge', {
    configurable: true,
    value: BatchedBridge
  });
  module.exports = BatchedBridge;
},126,[127],"node_modules\\react-native\\Libraries\\BatchedBridge\\BatchedBridge.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _toConsumableArray = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/toConsumableArray");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/defineProperty");

  var ErrorUtils = _$$_REQUIRE(_dependencyMap[4], "ErrorUtils");

  var Systrace = _$$_REQUIRE(_dependencyMap[5], "Systrace");

  var deepFreezeAndThrowOnMutationInDev = _$$_REQUIRE(_dependencyMap[6], "deepFreezeAndThrowOnMutationInDev");

  var invariant = _$$_REQUIRE(_dependencyMap[7], "fbjs/lib/invariant");

  var stringifySafe = _$$_REQUIRE(_dependencyMap[8], "stringifySafe");

  var TO_JS = 0;
  var TO_NATIVE = 1;
  var MODULE_IDS = 0;
  var METHOD_IDS = 1;
  var PARAMS = 2;
  var MIN_TIME_BETWEEN_FLUSHES_MS = 5;
  var TRACE_TAG_REACT_APPS = 1 << 17;
  var DEBUG_INFO_LIMIT = 32;

  var MessageQueue = function () {
    function MessageQueue() {
      _classCallCheck(this, MessageQueue);

      _defineProperty(this, "_lazyCallableModules", void 0);

      _defineProperty(this, "_queue", void 0);

      _defineProperty(this, "_successCallbacks", void 0);

      _defineProperty(this, "_failureCallbacks", void 0);

      _defineProperty(this, "_callID", void 0);

      _defineProperty(this, "_lastFlush", void 0);

      _defineProperty(this, "_eventLoopStartTime", void 0);

      _defineProperty(this, "_immediatesCallback", void 0);

      _defineProperty(this, "_debugInfo", void 0);

      _defineProperty(this, "_remoteModuleTable", void 0);

      _defineProperty(this, "_remoteMethodTable", void 0);

      _defineProperty(this, "__spy", void 0);

      this._lazyCallableModules = {};
      this._queue = [[], [], [], 0];
      this._successCallbacks = {};
      this._failureCallbacks = {};
      this._callID = 0;
      this._lastFlush = 0;
      this._eventLoopStartTime = Date.now();
      this._immediatesCallback = null;

      if (__DEV__) {
        this._debugInfo = {};
        this._remoteModuleTable = {};
        this._remoteMethodTable = {};
      }

      this.callFunctionReturnFlushedQueue = this.callFunctionReturnFlushedQueue.bind(this);
      this.callFunctionReturnResultAndFlushedQueue = this.callFunctionReturnResultAndFlushedQueue.bind(this);
      this.flushedQueue = this.flushedQueue.bind(this);
      this.invokeCallbackAndReturnFlushedQueue = this.invokeCallbackAndReturnFlushedQueue.bind(this);
    }

    _createClass(MessageQueue, [{
      key: "callFunctionReturnFlushedQueue",
      value: function callFunctionReturnFlushedQueue(module, method, args) {
        var _this = this;

        this.__guard(function () {
          _this.__callFunction(module, method, args);
        });

        return this.flushedQueue();
      }
    }, {
      key: "callFunctionReturnResultAndFlushedQueue",
      value: function callFunctionReturnResultAndFlushedQueue(module, method, args) {
        var _this2 = this;

        var result;

        this.__guard(function () {
          result = _this2.__callFunction(module, method, args);
        });

        return [result, this.flushedQueue()];
      }
    }, {
      key: "invokeCallbackAndReturnFlushedQueue",
      value: function invokeCallbackAndReturnFlushedQueue(cbID, args) {
        var _this3 = this;

        this.__guard(function () {
          _this3.__invokeCallback(cbID, args);
        });

        return this.flushedQueue();
      }
    }, {
      key: "flushedQueue",
      value: function flushedQueue() {
        var _this4 = this;

        this.__guard(function () {
          _this4.__callImmediates();
        });

        var queue = this._queue;
        this._queue = [[], [], [], this._callID];
        return queue[0].length ? queue : null;
      }
    }, {
      key: "getEventLoopRunningTime",
      value: function getEventLoopRunningTime() {
        return Date.now() - this._eventLoopStartTime;
      }
    }, {
      key: "registerCallableModule",
      value: function registerCallableModule(name, module) {
        this._lazyCallableModules[name] = function () {
          return module;
        };
      }
    }, {
      key: "registerLazyCallableModule",
      value: function registerLazyCallableModule(name, factory) {
        var module;
        var getValue = factory;

        this._lazyCallableModules[name] = function () {
          if (getValue) {
            module = getValue();
            getValue = null;
          }

          return module;
        };
      }
    }, {
      key: "getCallableModule",
      value: function getCallableModule(name) {
        var getValue = this._lazyCallableModules[name];
        return getValue ? getValue() : null;
      }
    }, {
      key: "enqueueNativeCall",
      value: function enqueueNativeCall(moduleID, methodID, params, onFail, onSucc) {
        if (onFail || onSucc) {
          if (__DEV__) {
            this._debugInfo[this._callID] = [moduleID, methodID];

            if (this._callID > DEBUG_INFO_LIMIT) {
              delete this._debugInfo[this._callID - DEBUG_INFO_LIMIT];
            }
          }

          onFail && params.push(this._callID << 1);
          onSucc && params.push(this._callID << 1 | 1);
          this._successCallbacks[this._callID] = onSucc;
          this._failureCallbacks[this._callID] = onFail;
        }

        if (__DEV__) {
          global.nativeTraceBeginAsyncFlow && global.nativeTraceBeginAsyncFlow(TRACE_TAG_REACT_APPS, 'native', this._callID);
        }

        this._callID++;

        this._queue[MODULE_IDS].push(moduleID);

        this._queue[METHOD_IDS].push(methodID);

        if (__DEV__) {
          var isValidArgument = function isValidArgument(val) {
            var t = typeof val;

            if (t === 'undefined' || t === 'null' || t === 'boolean' || t === 'number' || t === 'string') {
              return true;
            }

            if (t === 'function' || t !== 'object') {
              return false;
            }

            if (Array.isArray(val)) {
              return val.every(isValidArgument);
            }

            for (var k in val) {
              if (typeof val[k] !== 'function' && !isValidArgument(val[k])) {
                return false;
              }
            }

            return true;
          };

          invariant(isValidArgument(params), '%s is not usable as a native method argument', params);
          deepFreezeAndThrowOnMutationInDev(params);
        }

        this._queue[PARAMS].push(params);

        var now = Date.now();

        if (global.nativeFlushQueueImmediate && now - this._lastFlush >= MIN_TIME_BETWEEN_FLUSHES_MS) {
          var queue = this._queue;
          this._queue = [[], [], [], this._callID];
          this._lastFlush = now;
          global.nativeFlushQueueImmediate(queue);
        }

        Systrace.counterEvent('pending_js_to_native_queue', this._queue[0].length);

        if (__DEV__ && this.__spy && isFinite(moduleID)) {
          this.__spy({
            type: TO_NATIVE,
            module: this._remoteModuleTable[moduleID],
            method: this._remoteMethodTable[moduleID][methodID],
            args: params
          });
        } else if (this.__spy) {
          this.__spy({
            type: TO_NATIVE,
            module: moduleID + '',
            method: methodID,
            args: params
          });
        }
      }
    }, {
      key: "createDebugLookup",
      value: function createDebugLookup(moduleID, name, methods) {
        if (__DEV__) {
          this._remoteModuleTable[moduleID] = name;
          this._remoteMethodTable[moduleID] = methods;
        }
      }
    }, {
      key: "setImmediatesCallback",
      value: function setImmediatesCallback(fn) {
        this._immediatesCallback = fn;
      }
    }, {
      key: "__guard",
      value: function __guard(fn) {
        if (this.__shouldPauseOnThrow()) {
          fn();
        } else {
          try {
            fn();
          } catch (error) {
            ErrorUtils.reportFatalError(error);
          }
        }
      }
    }, {
      key: "__shouldPauseOnThrow",
      value: function __shouldPauseOnThrow() {
        return typeof DebuggerInternal !== 'undefined' && DebuggerInternal.shouldPauseOnThrow === true;
      }
    }, {
      key: "__callImmediates",
      value: function __callImmediates() {
        Systrace.beginEvent('JSTimers.callImmediates()');

        if (this._immediatesCallback != null) {
          this._immediatesCallback();
        }

        Systrace.endEvent();
      }
    }, {
      key: "__callFunction",
      value: function __callFunction(module, method, args) {
        this._lastFlush = Date.now();
        this._eventLoopStartTime = this._lastFlush;

        if (__DEV__ || this.__spy) {
          Systrace.beginEvent(module + "." + method + "(" + stringifySafe(args) + ")");
        } else {
          Systrace.beginEvent(module + "." + method + "(...)");
        }

        if (this.__spy) {
          this.__spy({
            type: TO_JS,
            module: module,
            method: method,
            args: args
          });
        }

        var moduleMethods = this.getCallableModule(module);
        invariant(!!moduleMethods, 'Module %s is not a registered callable module (calling %s)', module, method);
        invariant(!!moduleMethods[method], 'Method %s does not exist on module %s', method, module);
        var result = moduleMethods[method].apply(moduleMethods, args);
        Systrace.endEvent();
        return result;
      }
    }, {
      key: "__invokeCallback",
      value: function __invokeCallback(cbID, args) {
        this._lastFlush = Date.now();
        this._eventLoopStartTime = this._lastFlush;
        var callID = cbID >>> 1;
        var isSuccess = cbID & 1;
        var callback = isSuccess ? this._successCallbacks[callID] : this._failureCallbacks[callID];

        if (__DEV__) {
          var debug = this._debugInfo[callID];

          var _module = debug && this._remoteModuleTable[debug[0]];

          var method = debug && this._remoteMethodTable[debug[0]][debug[1]];

          if (!callback) {
            var errorMessage = "Callback with id " + cbID + ": " + _module + "." + method + "() not found";

            if (method) {
              errorMessage = "The callback " + method + "() exists in module " + _module + ", " + 'but only one callback may be registered to a function in a native module.';
            }

            invariant(callback, errorMessage);
          }

          var profileName = debug ? '<callback for ' + _module + '.' + method + '>' : cbID;

          if (callback && this.__spy) {
            this.__spy({
              type: TO_JS,
              module: null,
              method: profileName,
              args: args
            });
          }

          Systrace.beginEvent("MessageQueue.invokeCallback(" + profileName + ", " + stringifySafe(args) + ")");
        }

        if (!callback) {
          return;
        }

        delete this._successCallbacks[callID];
        delete this._failureCallbacks[callID];
        callback.apply(void 0, _toConsumableArray(args));

        if (__DEV__) {
          Systrace.endEvent();
        }
      }
    }], [{
      key: "spy",
      value: function spy(spyOrToggle) {
        if (spyOrToggle === true) {
          MessageQueue.prototype.__spy = function (info) {
            console.log((info.type === TO_JS ? 'N->JS' : 'JS->N') + " : " + ("" + (info.module ? info.module + '.' : '') + info.method) + ("(" + JSON.stringify(info.args) + ")"));
          };
        } else if (spyOrToggle === false) {
          MessageQueue.prototype.__spy = null;
        } else {
          MessageQueue.prototype.__spy = spyOrToggle;
        }
      }
    }]);

    return MessageQueue;
  }();

  module.exports = MessageQueue;
},127,[128,24,25,32,132,133,134,117,135],"node_modules\\react-native\\Libraries\\BatchedBridge\\MessageQueue.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var arrayWithoutHoles = _$$_REQUIRE(_dependencyMap[0], "./arrayWithoutHoles");

  var iterableToArray = _$$_REQUIRE(_dependencyMap[1], "./iterableToArray");

  var nonIterableSpread = _$$_REQUIRE(_dependencyMap[2], "./nonIterableSpread");

  function _toConsumableArray(arr) {
    return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
  }

  module.exports = _toConsumableArray;
},128,[129,130,131],"node_modules\\@babel\\runtime\\helpers\\toConsumableArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    }
  }

  module.exports = _arrayWithoutHoles;
},129,[],"node_modules\\@babel\\runtime\\helpers\\arrayWithoutHoles.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _iterableToArray(iter) {
    if ((typeof Symbol === "function" ? Symbol.iterator : "@@iterator") in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  module.exports = _iterableToArray;
},130,[],"node_modules\\@babel\\runtime\\helpers\\iterableToArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  module.exports = _nonIterableSpread;
},131,[],"node_modules\\@babel\\runtime\\helpers\\nonIterableSpread.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = global.ErrorUtils;
},132,[],"node_modules\\react-native\\Libraries\\vendor\\core\\ErrorUtils.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var invariant = _$$_REQUIRE(_dependencyMap[0], "fbjs/lib/invariant");

  var TRACE_TAG_REACT_APPS = 1 << 17;
  var TRACE_TAG_JS_VM_CALLS = 1 << 27;
  var _enabled = false;
  var _asyncCookie = 0;
  var _markStack = [];

  var _markStackIndex = -1;

  var _canInstallReactHook = false;
  var REACT_MARKER = "\u269B";
  var userTimingPolyfill = __DEV__ ? {
    mark: function mark(markName) {
      if (_enabled) {
        _markStackIndex++;
        _markStack[_markStackIndex] = markName;
        var systraceLabel = markName;

        if (markName[0] === REACT_MARKER) {
          var indexOfId = markName.lastIndexOf(' (#');
          var cutoffIndex = indexOfId !== -1 ? indexOfId : markName.length;
          systraceLabel = markName.slice(2, cutoffIndex);
        }

        Systrace.beginEvent(systraceLabel);
      }
    },
    measure: function measure(measureName, startMark, endMark) {
      if (_enabled) {
        invariant(typeof measureName === 'string' && typeof startMark === 'string' && typeof endMark === 'undefined', 'Only performance.measure(string, string) overload is supported.');
        var topMark = _markStack[_markStackIndex];
        invariant(startMark === topMark, 'There was a mismatching performance.measure() call. ' + 'Expected "%s" but got "%s."', topMark, startMark);
        _markStackIndex--;
        Systrace.endEvent();
      }
    },
    clearMarks: function clearMarks(markName) {
      if (_enabled) {
        if (_markStackIndex === -1) {
          return;
        }

        if (markName === _markStack[_markStackIndex]) {
          if (userTimingPolyfill != null) {
            userTimingPolyfill.measure(markName, markName);
          }
        }
      }
    },
    clearMeasures: function clearMeasures() {}
  } : null;
  var Systrace = {
    installReactHook: function installReactHook() {
      if (_enabled) {
        if (__DEV__) {
          global.performance = userTimingPolyfill;
        }
      }

      _canInstallReactHook = true;
    },
    setEnabled: function setEnabled(enabled) {
      if (_enabled !== enabled) {
        if (__DEV__) {
          if (enabled) {
            global.nativeTraceBeginLegacy && global.nativeTraceBeginLegacy(TRACE_TAG_JS_VM_CALLS);
          } else {
            global.nativeTraceEndLegacy && global.nativeTraceEndLegacy(TRACE_TAG_JS_VM_CALLS);
          }

          if (_canInstallReactHook) {
            if (enabled && global.performance === undefined) {
              global.performance = userTimingPolyfill;
            }
          }
        }

        _enabled = enabled;
      }
    },
    isEnabled: function isEnabled() {
      return _enabled;
    },
    beginEvent: function beginEvent(profileName, args) {
      if (_enabled) {
        profileName = typeof profileName === 'function' ? profileName() : profileName;
        global.nativeTraceBeginSection(TRACE_TAG_REACT_APPS, profileName, args);
      }
    },
    endEvent: function endEvent() {
      if (_enabled) {
        global.nativeTraceEndSection(TRACE_TAG_REACT_APPS);
      }
    },
    beginAsyncEvent: function beginAsyncEvent(profileName) {
      var cookie = _asyncCookie;

      if (_enabled) {
        _asyncCookie++;
        profileName = typeof profileName === 'function' ? profileName() : profileName;
        global.nativeTraceBeginAsyncSection(TRACE_TAG_REACT_APPS, profileName, cookie);
      }

      return cookie;
    },
    endAsyncEvent: function endAsyncEvent(profileName, cookie) {
      if (_enabled) {
        profileName = typeof profileName === 'function' ? profileName() : profileName;
        global.nativeTraceEndAsyncSection(TRACE_TAG_REACT_APPS, profileName, cookie);
      }
    },
    counterEvent: function counterEvent(profileName, value) {
      if (_enabled) {
        profileName = typeof profileName === 'function' ? profileName() : profileName;
        global.nativeTraceCounter && global.nativeTraceCounter(TRACE_TAG_REACT_APPS, profileName, value);
      }
    }
  };

  if (__DEV__) {
    _$$_REQUIRE.Systrace = Systrace;
  }

  module.exports = Systrace;
},133,[117],"node_modules\\react-native\\Libraries\\Performance\\Systrace.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function deepFreezeAndThrowOnMutationInDev(object) {
    if (__DEV__) {
      if (typeof object !== 'object' || object === null || Object.isFrozen(object) || Object.isSealed(object)) {
        return object;
      }

      var keys = Object.keys(object);
      var _hasOwnProperty = Object.prototype.hasOwnProperty;

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];

        if (_hasOwnProperty.call(object, key)) {
          Object.defineProperty(object, key, {
            get: identity.bind(null, object[key])
          });
          Object.defineProperty(object, key, {
            set: throwOnImmutableMutation.bind(null, key)
          });
        }
      }

      Object.freeze(object);
      Object.seal(object);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];

        if (_hasOwnProperty.call(object, key)) {
          deepFreezeAndThrowOnMutationInDev(object[key]);
        }
      }
    }

    return object;
  }

  function throwOnImmutableMutation(key, value) {
    throw Error('You attempted to set the key `' + key + '` with the value `' + JSON.stringify(value) + '` on an object that is meant to be immutable ' + 'and has been frozen.');
  }

  function identity(value) {
    return value;
  }

  module.exports = deepFreezeAndThrowOnMutationInDev;
},134,[],"node_modules\\react-native\\Libraries\\Utilities\\deepFreezeAndThrowOnMutationInDev.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function stringifySafe(arg) {
    var ret;
    var type = typeof arg;

    if (arg === undefined) {
      ret = 'undefined';
    } else if (arg === null) {
      ret = 'null';
    } else if (type === 'string') {
      ret = '"' + arg + '"';
    } else if (type === 'function') {
      try {
        ret = arg.toString();
      } catch (e) {
        ret = '[function unknown]';
      }
    } else {
      try {
        ret = JSON.stringify(arg);
      } catch (e) {
        if (typeof arg.toString === 'function') {
          try {
            ret = arg.toString();
          } catch (E) {}
        }
      }
    }

    return ret || '["' + type + '" failed to stringify]';
  }

  module.exports = stringifySafe;
},135,[],"node_modules\\react-native\\Libraries\\Utilities\\stringifySafe.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function defineLazyObjectProperty(object, name, descriptor) {
    var get = descriptor.get;
    var enumerable = descriptor.enumerable !== false;
    var writable = descriptor.writable !== false;
    var value;
    var valueSet = false;

    function getValue() {
      if (!valueSet) {
        valueSet = true;
        setValue(get());
      }

      return value;
    }

    function setValue(newValue) {
      value = newValue;
      valueSet = true;
      Object.defineProperty(object, name, {
        value: newValue,
        configurable: true,
        enumerable: enumerable,
        writable: writable
      });
    }

    Object.defineProperty(object, name, {
      get: getValue,
      set: setValue,
      configurable: true,
      enumerable: enumerable
    });
  }

  module.exports = defineLazyObjectProperty;
},136,[],"node_modules\\react-native\\Libraries\\Utilities\\defineLazyObjectProperty.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _get = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/get");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var EventEmitter = _$$_REQUIRE(_dependencyMap[8], "EventEmitter");

  var EventSubscriptionVendor = _$$_REQUIRE(_dependencyMap[9], "EventSubscriptionVendor");

  function checkNativeEventModule(eventType) {
    if (eventType) {
      if (eventType.lastIndexOf('statusBar', 0) === 0) {
        throw new Error('`' + eventType + '` event should be registered via the StatusBarIOS module');
      }

      if (eventType.lastIndexOf('keyboard', 0) === 0) {
        throw new Error('`' + eventType + '` event should be registered via the Keyboard module');
      }

      if (eventType === 'appStateDidChange' || eventType === 'memoryWarning') {
        throw new Error('`' + eventType + '` event should be registered via the AppState module');
      }
    }
  }

  var RCTDeviceEventEmitter = function (_EventEmitter) {
    _inherits(RCTDeviceEventEmitter, _EventEmitter);

    function RCTDeviceEventEmitter() {
      var _this;

      _classCallCheck(this, RCTDeviceEventEmitter);

      var sharedSubscriber = new EventSubscriptionVendor();
      _this = _possibleConstructorReturn(this, _getPrototypeOf(RCTDeviceEventEmitter).call(this, sharedSubscriber));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "sharedSubscriber", void 0);

      _this.sharedSubscriber = sharedSubscriber;
      return _this;
    }

    _createClass(RCTDeviceEventEmitter, [{
      key: "addListener",
      value: function addListener(eventType, listener, context) {
        if (__DEV__) {
          checkNativeEventModule(eventType);
        }

        return _get(_getPrototypeOf(RCTDeviceEventEmitter.prototype), "addListener", this).call(this, eventType, listener, context);
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners(eventType) {
        if (__DEV__) {
          checkNativeEventModule(eventType);
        }

        _get(_getPrototypeOf(RCTDeviceEventEmitter.prototype), "removeAllListeners", this).call(this, eventType);
      }
    }, {
      key: "removeSubscription",
      value: function removeSubscription(subscription) {
        if (subscription.emitter !== this) {
          subscription.emitter.removeSubscription(subscription);
        } else {
          _get(_getPrototypeOf(RCTDeviceEventEmitter.prototype), "removeSubscription", this).call(this, subscription);
        }
      }
    }]);

    return RCTDeviceEventEmitter;
  }(EventEmitter);

  module.exports = new RCTDeviceEventEmitter();
},137,[24,25,26,29,138,30,28,32,140,143],"node_modules\\react-native\\Libraries\\EventEmitter\\RCTDeviceEventEmitter.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var getPrototypeOf = _$$_REQUIRE(_dependencyMap[0], "./getPrototypeOf");

  var superPropBase = _$$_REQUIRE(_dependencyMap[1], "./superPropBase");

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      module.exports = _get = Reflect.get;
    } else {
      module.exports = _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  module.exports = _get;
},138,[29,139],"node_modules\\@babel\\runtime\\helpers\\get.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var getPrototypeOf = _$$_REQUIRE(_dependencyMap[0], "./getPrototypeOf");

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  module.exports = _superPropBase;
},139,[29],"node_modules\\@babel\\runtime\\helpers\\superPropBase.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/defineProperty");

  var EmitterSubscription = _$$_REQUIRE(_dependencyMap[3], "EmitterSubscription");

  var EventSubscriptionVendor = _$$_REQUIRE(_dependencyMap[4], "EventSubscriptionVendor");

  var emptyFunction = _$$_REQUIRE(_dependencyMap[5], "fbjs/lib/emptyFunction");

  var invariant = _$$_REQUIRE(_dependencyMap[6], "fbjs/lib/invariant");

  var EventEmitter = function () {
    function EventEmitter(subscriber) {
      _classCallCheck(this, EventEmitter);

      _defineProperty(this, "_subscriber", void 0);

      _defineProperty(this, "_currentSubscription", void 0);

      this._subscriber = subscriber || new EventSubscriptionVendor();
    }

    _createClass(EventEmitter, [{
      key: "addListener",
      value: function addListener(eventType, listener, context) {
        return this._subscriber.addSubscription(eventType, new EmitterSubscription(this, this._subscriber, listener, context));
      }
    }, {
      key: "once",
      value: function once(eventType, listener, context) {
        var _this = this;

        return this.addListener(eventType, function () {
          _this.removeCurrentListener();

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          listener.apply(context, args);
        });
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners(eventType) {
        this._subscriber.removeAllSubscriptions(eventType);
      }
    }, {
      key: "removeCurrentListener",
      value: function removeCurrentListener() {
        invariant(!!this._currentSubscription, 'Not in an emitting cycle; there is no current subscription');
        this.removeSubscription(this._currentSubscription);
      }
    }, {
      key: "removeSubscription",
      value: function removeSubscription(subscription) {
        invariant(subscription.emitter === this, 'Subscription does not belong to this emitter.');

        this._subscriber.removeSubscription(subscription);
      }
    }, {
      key: "listeners",
      value: function listeners(eventType) {
        var subscriptions = this._subscriber.getSubscriptionsForType(eventType);

        return subscriptions ? subscriptions.filter(emptyFunction.thatReturnsTrue).map(function (subscription) {
          return subscription.listener;
        }) : [];
      }
    }, {
      key: "emit",
      value: function emit(eventType) {
        var subscriptions = this._subscriber.getSubscriptionsForType(eventType);

        if (subscriptions) {
          for (var i = 0, l = subscriptions.length; i < l; i++) {
            var subscription = subscriptions[i];

            if (subscription) {
              this._currentSubscription = subscription;
              subscription.listener.apply(subscription.context, Array.prototype.slice.call(arguments, 1));
            }
          }

          this._currentSubscription = null;
        }
      }
    }, {
      key: "removeListener",
      value: function removeListener(eventType, listener) {
        var subscriptions = this._subscriber.getSubscriptionsForType(eventType);

        if (subscriptions) {
          for (var i = 0, l = subscriptions.length; i < l; i++) {
            var subscription = subscriptions[i];

            if (subscription && subscription.listener === listener) {
              subscription.remove();
            }
          }
        }
      }
    }]);

    return EventEmitter;
  }();

  module.exports = EventEmitter;
},140,[24,25,32,141,143,144,117],"node_modules\\react-native\\Libraries\\vendor\\emitter\\EventEmitter.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/defineProperty");

  var EventSubscription = _$$_REQUIRE(_dependencyMap[7], "EventSubscription");

  var EmitterSubscription = function (_EventSubscription) {
    _inherits(EmitterSubscription, _EventSubscription);

    function EmitterSubscription(emitter, subscriber, listener, context) {
      var _this;

      _classCallCheck(this, EmitterSubscription);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(EmitterSubscription).call(this, subscriber));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "emitter", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "listener", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "context", void 0);

      _this.emitter = emitter;
      _this.listener = listener;
      _this.context = context;
      return _this;
    }

    _createClass(EmitterSubscription, [{
      key: "remove",
      value: function remove() {
        this.emitter.removeSubscription(this);
      }
    }]);

    return EmitterSubscription;
  }(EventSubscription);

  module.exports = EmitterSubscription;
},141,[24,25,26,29,30,28,32,142],"node_modules\\react-native\\Libraries\\vendor\\emitter\\EmitterSubscription.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/defineProperty");

  var EventSubscription = function () {
    function EventSubscription(subscriber) {
      _classCallCheck(this, EventSubscription);

      _defineProperty(this, "eventType", void 0);

      _defineProperty(this, "key", void 0);

      _defineProperty(this, "subscriber", void 0);

      this.subscriber = subscriber;
    }

    _createClass(EventSubscription, [{
      key: "remove",
      value: function remove() {
        this.subscriber.removeSubscription(this);
      }
    }]);

    return EventSubscription;
  }();

  module.exports = EventSubscription;
},142,[24,25,32],"node_modules\\react-native\\Libraries\\vendor\\emitter\\EventSubscription.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/defineProperty");

  var invariant = _$$_REQUIRE(_dependencyMap[3], "fbjs/lib/invariant");

  var EventSubscriptionVendor = function () {
    function EventSubscriptionVendor() {
      _classCallCheck(this, EventSubscriptionVendor);

      _defineProperty(this, "_subscriptionsForType", void 0);

      _defineProperty(this, "_currentSubscription", void 0);

      this._subscriptionsForType = {};
      this._currentSubscription = null;
    }

    _createClass(EventSubscriptionVendor, [{
      key: "addSubscription",
      value: function addSubscription(eventType, subscription) {
        invariant(subscription.subscriber === this, 'The subscriber of the subscription is incorrectly set.');

        if (!this._subscriptionsForType[eventType]) {
          this._subscriptionsForType[eventType] = [];
        }

        var key = this._subscriptionsForType[eventType].length;

        this._subscriptionsForType[eventType].push(subscription);

        subscription.eventType = eventType;
        subscription.key = key;
        return subscription;
      }
    }, {
      key: "removeAllSubscriptions",
      value: function removeAllSubscriptions(eventType) {
        if (eventType === undefined) {
          this._subscriptionsForType = {};
        } else {
          delete this._subscriptionsForType[eventType];
        }
      }
    }, {
      key: "removeSubscription",
      value: function removeSubscription(subscription) {
        var eventType = subscription.eventType;
        var key = subscription.key;
        var subscriptionsForType = this._subscriptionsForType[eventType];

        if (subscriptionsForType) {
          delete subscriptionsForType[key];
        }
      }
    }, {
      key: "getSubscriptionsForType",
      value: function getSubscriptionsForType(eventType) {
        return this._subscriptionsForType[eventType];
      }
    }]);

    return EventSubscriptionVendor;
  }();

  module.exports = EventSubscriptionVendor;
},143,[24,25,32,117],"node_modules\\react-native\\Libraries\\vendor\\emitter\\EventSubscriptionVendor.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  function makeEmptyFunction(arg) {
    return function () {
      return arg;
    };
  }

  var emptyFunction = function emptyFunction() {};

  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);

  emptyFunction.thatReturnsThis = function () {
    return this;
  };

  emptyFunction.thatReturnsArgument = function (arg) {
    return arg;
  };

  module.exports = emptyFunction;
},144,[],"node_modules\\fbjs\\lib\\emptyFunction.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var NativeModules = _$$_REQUIRE(_dependencyMap[0], "NativeModules");

  var Platform = _$$_REQUIRE(_dependencyMap[1], "Platform");

  var defineLazyObjectProperty = _$$_REQUIRE(_dependencyMap[2], "defineLazyObjectProperty");

  var invariant = _$$_REQUIRE(_dependencyMap[3], "fbjs/lib/invariant");

  var UIManager = NativeModules.UIManager;
  invariant(UIManager, 'UIManager is undefined. The native module config is probably incorrect.');
  UIManager.__takeSnapshot = UIManager.takeSnapshot;

  UIManager.takeSnapshot = function () {
    invariant(false, 'UIManager.takeSnapshot should not be called directly. ' + 'Use ReactNative.takeSnapshot instead.');
  };

  if (Platform.OS === 'ios') {
    Object.keys(UIManager).forEach(function (viewName) {
      var viewConfig = UIManager[viewName];

      if (viewConfig.Manager) {
        defineLazyObjectProperty(viewConfig, 'Constants', {
          get: function get() {
            var viewManager = NativeModules[viewConfig.Manager];
            var constants = {};
            viewManager && Object.keys(viewManager).forEach(function (key) {
              var value = viewManager[key];

              if (typeof value !== 'function') {
                constants[key] = value;
              }
            });
            return constants;
          }
        });
        defineLazyObjectProperty(viewConfig, 'Commands', {
          get: function get() {
            var viewManager = NativeModules[viewConfig.Manager];
            var commands = {};
            var index = 0;
            viewManager && Object.keys(viewManager).forEach(function (key) {
              var value = viewManager[key];

              if (typeof value === 'function') {
                commands[key] = index++;
              }
            });
            return commands;
          }
        });
      }
    });
  } else if (UIManager.ViewManagerNames) {
    var residual = global.__residual ? global.__residual : function (_, f) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      return f.apply(undefined, args);
    };
    residual('void', function (UIManager, defineLazyObjectProperty) {
      UIManager.ViewManagerNames.forEach(function (viewManagerName) {
        defineLazyObjectProperty(UIManager, viewManagerName, {
          get: function get() {
            return UIManager.getConstantsForViewManager(viewManagerName);
          }
        });
      });
    }, UIManager, defineLazyObjectProperty);
    if (global.__makePartial) global.__makePartial(UIManager);
  }

  module.exports = UIManager;
},145,[119,146,136,117],"node_modules\\react-native\\Libraries\\ReactNative\\UIManager.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var NativeModules = _$$_REQUIRE(_dependencyMap[0], "NativeModules");

  var Platform = {
    OS: 'android',

    get Version() {
      var constants = NativeModules.PlatformConstants;
      return constants && constants.Version;
    },

    get isTesting() {
      var constants = NativeModules.PlatformConstants;
      return constants && constants.isTesting;
    },

    get isTV() {
      var constants = NativeModules.PlatformConstants;
      return constants && constants.uiMode === 'tv';
    },

    select: function select(obj) {
      return 'android' in obj ? obj.android : obj.default;
    }
  };
  module.exports = Platform;
},146,[119],"node_modules\\react-native\\Libraries\\Utilities\\Platform.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread");

  var _objectWithoutProperties = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutProperties");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\ActivityIndicator\\ActivityIndicator.js";

  var Platform = _$$_REQUIRE(_dependencyMap[3], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[4], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[5], "StyleSheet");

  var View = _$$_REQUIRE(_dependencyMap[6], "View");

  var requireNativeComponent = _$$_REQUIRE(_dependencyMap[7], "requireNativeComponent");

  var RCTActivityIndicator = Platform.OS === 'android' ? _$$_REQUIRE(_dependencyMap[8], "ProgressBarAndroid") : requireNativeComponent('RCTActivityIndicatorView');
  var GRAY = '#999999';

  var ActivityIndicator = function ActivityIndicator(props, forwardedRef) {
    var onLayout = props.onLayout,
        style = props.style,
        restProps = _objectWithoutProperties(props, ["onLayout", "style"]);

    var sizeStyle;

    switch (props.size) {
      case 'small':
        sizeStyle = styles.sizeSmall;
        break;

      case 'large':
        sizeStyle = styles.sizeLarge;
        break;

      default:
        sizeStyle = {
          height: props.size,
          width: props.size
        };
        break;
    }

    var nativeProps = _objectSpread({}, restProps, {
      ref: forwardedRef,
      style: sizeStyle,
      styleAttr: 'Normal',
      indeterminate: true
    });

    return React.createElement(View, {
      onLayout: onLayout,
      style: StyleSheet.compose(styles.container, style),
      __source: {
        fileName: _jsxFileName,
        lineNumber: 100
      }
    }, React.createElement(RCTActivityIndicator, _extends({}, nativeProps, {
      __source: {
        fileName: _jsxFileName,
        lineNumber: 108
      }
    })));
  };

  var ActivityIndicatorWithRef = React.forwardRef(ActivityIndicator);
  ActivityIndicatorWithRef.defaultProps = {
    animating: true,
    color: Platform.OS === 'ios' ? GRAY : null,
    hidesWhenStopped: true,
    size: 'small'
  };
  var styles = StyleSheet.create({
    container: {
      alignItems: 'center',
      justifyContent: 'center'
    },
    sizeSmall: {
      width: 20,
      height: 20
    },
    sizeLarge: {
      width: 36,
      height: 36
    }
  });
  module.exports = ActivityIndicatorWithRef;
},147,[112,148,120,146,149,150,175,268,278],"node_modules\\react-native\\Libraries\\Components\\ActivityIndicator\\ActivityIndicator.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var defineProperty = _$$_REQUIRE(_dependencyMap[0], "./defineProperty");

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  module.exports = _objectSpread;
},148,[32],"node_modules\\@babel\\runtime\\helpers\\objectSpread.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = _$$_REQUIRE(_dependencyMap[0], "react");
},149,[109],"node_modules\\react-native\\Libraries\\react-native\\React.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var PixelRatio = _$$_REQUIRE(_dependencyMap[1], "PixelRatio");

  var ReactNativeStyleAttributes = _$$_REQUIRE(_dependencyMap[2], "ReactNativeStyleAttributes");

  var StyleSheetValidation = _$$_REQUIRE(_dependencyMap[3], "StyleSheetValidation");

  var flatten = _$$_REQUIRE(_dependencyMap[4], "flattenStyle");

  var hairlineWidth = PixelRatio.roundToNearestPixel(0.4);

  if (hairlineWidth === 0) {
    hairlineWidth = 1 / PixelRatio.get();
  }

  var absoluteFill = {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  };

  if (__DEV__) {
    Object.freeze(absoluteFill);
  }

  module.exports = {
    hairlineWidth: hairlineWidth,
    absoluteFill: absoluteFill,
    absoluteFillObject: absoluteFill,
    compose: function compose(style1, style2) {
      if (style1 != null && style2 != null) {
        return [style1, style2];
      } else {
        return style1 != null ? style1 : style2;
      }
    },
    flatten: flatten,
    setStyleAttributePreprocessor: function setStyleAttributePreprocessor(property, process) {
      var value;

      if (typeof ReactNativeStyleAttributes[property] === 'string') {
        value = {};
      } else if (typeof ReactNativeStyleAttributes[property] === 'object') {
        value = ReactNativeStyleAttributes[property];
      } else {
        console.error(property + " is not a valid style attribute");
        return;
      }

      if (__DEV__ && typeof value.process === 'function') {
        console.warn("Overwriting " + property + " style attribute preprocessor");
      }

      ReactNativeStyleAttributes[property] = _objectSpread({}, value, {
        process: process
      });
    },
    create: function create(obj) {
      if (__DEV__) {
        for (var _key in obj) {
          StyleSheetValidation.validateStyle(_key, obj);

          if (obj[_key]) {
            Object.freeze(obj[_key]);
          }
        }
      }

      return obj;
    }
  };
},150,[148,151,154,173,174],"node_modules\\react-native\\Libraries\\StyleSheet\\StyleSheet.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var Dimensions = _$$_REQUIRE(_dependencyMap[2], "Dimensions");

  var PixelRatio = function () {
    function PixelRatio() {
      _classCallCheck(this, PixelRatio);
    }

    _createClass(PixelRatio, null, [{
      key: "get",
      value: function get() {
        return Dimensions.get('window').scale;
      }
    }, {
      key: "getFontScale",
      value: function getFontScale() {
        return Dimensions.get('window').fontScale || PixelRatio.get();
      }
    }, {
      key: "getPixelSizeForLayoutSize",
      value: function getPixelSizeForLayoutSize(layoutSize) {
        return Math.round(layoutSize * PixelRatio.get());
      }
    }, {
      key: "roundToNearestPixel",
      value: function roundToNearestPixel(layoutSize) {
        var ratio = PixelRatio.get();
        return Math.round(layoutSize * ratio) / ratio;
      }
    }, {
      key: "startDetecting",
      value: function startDetecting() {}
    }]);

    return PixelRatio;
  }();

  module.exports = PixelRatio;
},151,[24,25,152],"node_modules\\react-native\\Libraries\\Utilities\\PixelRatio.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var EventEmitter = _$$_REQUIRE(_dependencyMap[3], "EventEmitter");

  var Platform = _$$_REQUIRE(_dependencyMap[4], "Platform");

  var RCTDeviceEventEmitter = _$$_REQUIRE(_dependencyMap[5], "RCTDeviceEventEmitter");

  var invariant = _$$_REQUIRE(_dependencyMap[6], "fbjs/lib/invariant");

  var eventEmitter = new EventEmitter();
  var dimensionsInitialized = false;
  var dimensions = {};

  var Dimensions = function () {
    function Dimensions() {
      _classCallCheck(this, Dimensions);
    }

    _createClass(Dimensions, null, [{
      key: "set",
      value: function set(dims) {
        if (dims && dims.windowPhysicalPixels) {
          dims = JSON.parse(JSON.stringify(dims));
          var windowPhysicalPixels = dims.windowPhysicalPixels;
          dims.window = {
            width: windowPhysicalPixels.width / windowPhysicalPixels.scale,
            height: windowPhysicalPixels.height / windowPhysicalPixels.scale,
            scale: windowPhysicalPixels.scale,
            fontScale: windowPhysicalPixels.fontScale
          };

          if (Platform.OS === 'android') {
            var screenPhysicalPixels = dims.screenPhysicalPixels;
            dims.screen = {
              width: screenPhysicalPixels.width / screenPhysicalPixels.scale,
              height: screenPhysicalPixels.height / screenPhysicalPixels.scale,
              scale: screenPhysicalPixels.scale,
              fontScale: screenPhysicalPixels.fontScale
            };
            delete dims.screenPhysicalPixels;
          } else {
            dims.screen = dims.window;
          }

          delete dims.windowPhysicalPixels;
        }

        _extends(dimensions, dims);

        if (dimensionsInitialized) {
          eventEmitter.emit('change', {
            window: dimensions.window,
            screen: dimensions.screen
          });
        } else {
          dimensionsInitialized = true;
        }
      }
    }, {
      key: "get",
      value: function get(dim) {
        invariant(dimensions[dim], 'No dimension set for key ' + dim);
        return dimensions[dim];
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, handler) {
        invariant(type === 'change', 'Trying to subscribe to unknown event: "%s"', type);
        eventEmitter.addListener(type, handler);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, handler) {
        invariant(type === 'change', 'Trying to remove listener for unknown event: "%s"', type);
        eventEmitter.removeListener(type, handler);
      }
    }]);

    return Dimensions;
  }();

  var dims = global.nativeExtensions && global.nativeExtensions.DeviceInfo && global.nativeExtensions.DeviceInfo.Dimensions;
  var nativeExtensionsEnabled = true;

  if (!dims) {
    var DeviceInfo = _$$_REQUIRE(_dependencyMap[7], "DeviceInfo");

    dims = DeviceInfo.Dimensions;
    nativeExtensionsEnabled = false;
  }

  invariant(dims, 'Either DeviceInfo native extension or DeviceInfo Native Module must be registered');
  Dimensions.set(dims);

  if (!nativeExtensionsEnabled) {
    RCTDeviceEventEmitter.addListener('didUpdateDimensions', function (update) {
      Dimensions.set(update);
    });
  }

  module.exports = Dimensions;
},152,[112,24,25,140,146,137,117,153],"node_modules\\react-native\\Libraries\\Utilities\\Dimensions.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var DeviceInfo = _$$_REQUIRE(_dependencyMap[0], "NativeModules").DeviceInfo;

  var invariant = _$$_REQUIRE(_dependencyMap[1], "fbjs/lib/invariant");

  invariant(DeviceInfo, 'DeviceInfo native module is not installed correctly');
  module.exports = DeviceInfo;
},153,[119,117],"node_modules\\react-native\\Libraries\\Utilities\\DeviceInfo.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var ImageStylePropTypes = _$$_REQUIRE(_dependencyMap[1], "ImageStylePropTypes");

  var TextStylePropTypes = _$$_REQUIRE(_dependencyMap[2], "TextStylePropTypes");

  var ViewStylePropTypes = _$$_REQUIRE(_dependencyMap[3], "ViewStylePropTypes");

  var processColor = _$$_REQUIRE(_dependencyMap[4], "processColor");

  var processTransform = _$$_REQUIRE(_dependencyMap[5], "processTransform");

  var sizesDiffer = _$$_REQUIRE(_dependencyMap[6], "sizesDiffer");

  var ReactNativeStyleAttributes = {};

  var _arr = Object.keys(_objectSpread({}, ViewStylePropTypes, TextStylePropTypes, ImageStylePropTypes));

  for (var _i = 0; _i < _arr.length; _i++) {
    var attributeName = _arr[_i];
    ReactNativeStyleAttributes[attributeName] = true;
  }

  ReactNativeStyleAttributes.transform = {
    process: processTransform
  };
  ReactNativeStyleAttributes.shadowOffset = {
    diff: sizesDiffer
  };
  var colorAttributes = {
    process: processColor
  };
  ReactNativeStyleAttributes.backgroundColor = colorAttributes;
  ReactNativeStyleAttributes.borderBottomColor = colorAttributes;
  ReactNativeStyleAttributes.borderColor = colorAttributes;
  ReactNativeStyleAttributes.borderLeftColor = colorAttributes;
  ReactNativeStyleAttributes.borderRightColor = colorAttributes;
  ReactNativeStyleAttributes.borderTopColor = colorAttributes;
  ReactNativeStyleAttributes.borderStartColor = colorAttributes;
  ReactNativeStyleAttributes.borderEndColor = colorAttributes;
  ReactNativeStyleAttributes.color = colorAttributes;
  ReactNativeStyleAttributes.shadowColor = colorAttributes;
  ReactNativeStyleAttributes.textDecorationColor = colorAttributes;
  ReactNativeStyleAttributes.tintColor = colorAttributes;
  ReactNativeStyleAttributes.textShadowColor = colorAttributes;
  ReactNativeStyleAttributes.overlayColor = colorAttributes;
  module.exports = ReactNativeStyleAttributes;
},154,[148,155,167,168,169,170,172],"node_modules\\react-native\\Libraries\\Components\\View\\ReactNativeStyleAttributes.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var ColorPropType = _$$_REQUIRE(_dependencyMap[1], "ColorPropType");

  var ImageResizeMode = _$$_REQUIRE(_dependencyMap[2], "ImageResizeMode");

  var LayoutPropTypes = _$$_REQUIRE(_dependencyMap[3], "LayoutPropTypes");

  var ReactPropTypes = _$$_REQUIRE(_dependencyMap[4], "prop-types");

  var ShadowPropTypesIOS = _$$_REQUIRE(_dependencyMap[5], "ShadowPropTypesIOS");

  var TransformPropTypes = _$$_REQUIRE(_dependencyMap[6], "TransformPropTypes");

  var ImageStylePropTypes = _objectSpread({}, LayoutPropTypes, ShadowPropTypesIOS, TransformPropTypes, {
    resizeMode: ReactPropTypes.oneOf(Object.keys(ImageResizeMode)),
    backfaceVisibility: ReactPropTypes.oneOf(['visible', 'hidden']),
    backgroundColor: ColorPropType,
    borderColor: ColorPropType,
    borderWidth: ReactPropTypes.number,
    borderRadius: ReactPropTypes.number,
    overflow: ReactPropTypes.oneOf(['visible', 'hidden']),
    tintColor: ColorPropType,
    opacity: ReactPropTypes.number,
    overlayColor: ReactPropTypes.string,
    borderTopLeftRadius: ReactPropTypes.number,
    borderTopRightRadius: ReactPropTypes.number,
    borderBottomLeftRadius: ReactPropTypes.number,
    borderBottomRightRadius: ReactPropTypes.number
  });

  module.exports = ImageStylePropTypes;
},155,[148,156,158,160,161,164,165],"node_modules\\react-native\\Libraries\\Image\\ImageStylePropTypes.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var normalizeColor = _$$_REQUIRE(_dependencyMap[0], "normalizeColor");

  var colorPropType = function colorPropType(isRequired, props, propName, componentName, location, propFullName) {
    var color = props[propName];

    if (color === undefined || color === null) {
      if (isRequired) {
        return new Error('Required ' + location + ' `' + (propFullName || propName) + '` was not specified in `' + componentName + '`.');
      }

      return;
    }

    if (typeof color === 'number') {
      return;
    }

    if (normalizeColor(color) === null) {
      return new Error('Invalid ' + location + ' `' + (propFullName || propName) + '` supplied to `' + componentName + '`: ' + color + '\n' + "Valid color formats are\n  - '#f0f' (#rgb)\n  - '#f0fc' (#rgba)\n  - '#ff00ff' (#rrggbb)\n  - '#ff00ff00' (#rrggbbaa)\n  - 'rgb(255, 255, 255)'\n  - 'rgba(255, 255, 255, 1.0)'\n  - 'hsl(360, 100%, 100%)'\n  - 'hsla(360, 100%, 100%, 1.0)'\n  - 'transparent'\n  - 'red'\n  - 0xff00ff00 (0xrrggbbaa)\n");
    }
  };

  var ColorPropType = colorPropType.bind(null, false);
  ColorPropType.isRequired = colorPropType.bind(null, true);
  module.exports = ColorPropType;
},156,[157],"node_modules\\react-native\\Libraries\\StyleSheet\\ColorPropType.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function normalizeColor(color) {
    var matchers = getMatchers();
    var match;

    if (typeof color === 'number') {
      if (color >>> 0 === color && color >= 0 && color <= 0xffffffff) {
        return color;
      }

      return null;
    }

    if (match = matchers.hex6.exec(color)) {
      return parseInt(match[1] + 'ff', 16) >>> 0;
    }

    if (names.hasOwnProperty(color)) {
      return names[color];
    }

    if (match = matchers.rgb.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 0x000000ff) >>> 0;
    }

    if (match = matchers.rgba.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;
    }

    if (match = matchers.hex3.exec(color)) {
      return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + 'ff', 16) >>> 0;
    }

    if (match = matchers.hex8.exec(color)) {
      return parseInt(match[1], 16) >>> 0;
    }

    if (match = matchers.hex4.exec(color)) {
      return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;
    }

    if (match = matchers.hsl.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 0x000000ff) >>> 0;
    }

    if (match = matchers.hsla.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;
    }

    return null;
  }

  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }

    if (t > 1) {
      t -= 1;
    }

    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }

    if (t < 1 / 2) {
      return q;
    }

    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }

    return p;
  }

  function hslToRgb(h, s, l) {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    var r = hue2rgb(p, q, h + 1 / 3);
    var g = hue2rgb(p, q, h);
    var b = hue2rgb(p, q, h - 1 / 3);
    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
  }

  var NUMBER = '[-+]?\\d*\\.?\\d+';
  var PERCENTAGE = NUMBER + '%';

  function call() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return '\\(\\s*(' + args.join(')\\s*,\\s*(') + ')\\s*\\)';
  }

  var cachedMatchers;

  function getMatchers() {
    if (cachedMatchers === undefined) {
      cachedMatchers = {
        rgb: new RegExp('rgb' + call(NUMBER, NUMBER, NUMBER)),
        rgba: new RegExp('rgba' + call(NUMBER, NUMBER, NUMBER, NUMBER)),
        hsl: new RegExp('hsl' + call(NUMBER, PERCENTAGE, PERCENTAGE)),
        hsla: new RegExp('hsla' + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)),
        hex3: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex4: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#([0-9a-fA-F]{6})$/,
        hex8: /^#([0-9a-fA-F]{8})$/
      };
    }

    return cachedMatchers;
  }

  function parse255(str) {
    var int = parseInt(str, 10);

    if (int < 0) {
      return 0;
    }

    if (int > 255) {
      return 255;
    }

    return int;
  }

  function parse360(str) {
    var int = parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
  }

  function parse1(str) {
    var num = parseFloat(str);

    if (num < 0) {
      return 0;
    }

    if (num > 1) {
      return 255;
    }

    return Math.round(num * 255);
  }

  function parsePercentage(str) {
    var int = parseFloat(str);

    if (int < 0) {
      return 0;
    }

    if (int > 100) {
      return 1;
    }

    return int / 100;
  }

  var names = {
    transparent: 0x00000000,
    aliceblue: 0xf0f8ffff,
    antiquewhite: 0xfaebd7ff,
    aqua: 0x00ffffff,
    aquamarine: 0x7fffd4ff,
    azure: 0xf0ffffff,
    beige: 0xf5f5dcff,
    bisque: 0xffe4c4ff,
    black: 0x000000ff,
    blanchedalmond: 0xffebcdff,
    blue: 0x0000ffff,
    blueviolet: 0x8a2be2ff,
    brown: 0xa52a2aff,
    burlywood: 0xdeb887ff,
    burntsienna: 0xea7e5dff,
    cadetblue: 0x5f9ea0ff,
    chartreuse: 0x7fff00ff,
    chocolate: 0xd2691eff,
    coral: 0xff7f50ff,
    cornflowerblue: 0x6495edff,
    cornsilk: 0xfff8dcff,
    crimson: 0xdc143cff,
    cyan: 0x00ffffff,
    darkblue: 0x00008bff,
    darkcyan: 0x008b8bff,
    darkgoldenrod: 0xb8860bff,
    darkgray: 0xa9a9a9ff,
    darkgreen: 0x006400ff,
    darkgrey: 0xa9a9a9ff,
    darkkhaki: 0xbdb76bff,
    darkmagenta: 0x8b008bff,
    darkolivegreen: 0x556b2fff,
    darkorange: 0xff8c00ff,
    darkorchid: 0x9932ccff,
    darkred: 0x8b0000ff,
    darksalmon: 0xe9967aff,
    darkseagreen: 0x8fbc8fff,
    darkslateblue: 0x483d8bff,
    darkslategray: 0x2f4f4fff,
    darkslategrey: 0x2f4f4fff,
    darkturquoise: 0x00ced1ff,
    darkviolet: 0x9400d3ff,
    deeppink: 0xff1493ff,
    deepskyblue: 0x00bfffff,
    dimgray: 0x696969ff,
    dimgrey: 0x696969ff,
    dodgerblue: 0x1e90ffff,
    firebrick: 0xb22222ff,
    floralwhite: 0xfffaf0ff,
    forestgreen: 0x228b22ff,
    fuchsia: 0xff00ffff,
    gainsboro: 0xdcdcdcff,
    ghostwhite: 0xf8f8ffff,
    gold: 0xffd700ff,
    goldenrod: 0xdaa520ff,
    gray: 0x808080ff,
    green: 0x008000ff,
    greenyellow: 0xadff2fff,
    grey: 0x808080ff,
    honeydew: 0xf0fff0ff,
    hotpink: 0xff69b4ff,
    indianred: 0xcd5c5cff,
    indigo: 0x4b0082ff,
    ivory: 0xfffff0ff,
    khaki: 0xf0e68cff,
    lavender: 0xe6e6faff,
    lavenderblush: 0xfff0f5ff,
    lawngreen: 0x7cfc00ff,
    lemonchiffon: 0xfffacdff,
    lightblue: 0xadd8e6ff,
    lightcoral: 0xf08080ff,
    lightcyan: 0xe0ffffff,
    lightgoldenrodyellow: 0xfafad2ff,
    lightgray: 0xd3d3d3ff,
    lightgreen: 0x90ee90ff,
    lightgrey: 0xd3d3d3ff,
    lightpink: 0xffb6c1ff,
    lightsalmon: 0xffa07aff,
    lightseagreen: 0x20b2aaff,
    lightskyblue: 0x87cefaff,
    lightslategray: 0x778899ff,
    lightslategrey: 0x778899ff,
    lightsteelblue: 0xb0c4deff,
    lightyellow: 0xffffe0ff,
    lime: 0x00ff00ff,
    limegreen: 0x32cd32ff,
    linen: 0xfaf0e6ff,
    magenta: 0xff00ffff,
    maroon: 0x800000ff,
    mediumaquamarine: 0x66cdaaff,
    mediumblue: 0x0000cdff,
    mediumorchid: 0xba55d3ff,
    mediumpurple: 0x9370dbff,
    mediumseagreen: 0x3cb371ff,
    mediumslateblue: 0x7b68eeff,
    mediumspringgreen: 0x00fa9aff,
    mediumturquoise: 0x48d1ccff,
    mediumvioletred: 0xc71585ff,
    midnightblue: 0x191970ff,
    mintcream: 0xf5fffaff,
    mistyrose: 0xffe4e1ff,
    moccasin: 0xffe4b5ff,
    navajowhite: 0xffdeadff,
    navy: 0x000080ff,
    oldlace: 0xfdf5e6ff,
    olive: 0x808000ff,
    olivedrab: 0x6b8e23ff,
    orange: 0xffa500ff,
    orangered: 0xff4500ff,
    orchid: 0xda70d6ff,
    palegoldenrod: 0xeee8aaff,
    palegreen: 0x98fb98ff,
    paleturquoise: 0xafeeeeff,
    palevioletred: 0xdb7093ff,
    papayawhip: 0xffefd5ff,
    peachpuff: 0xffdab9ff,
    peru: 0xcd853fff,
    pink: 0xffc0cbff,
    plum: 0xdda0ddff,
    powderblue: 0xb0e0e6ff,
    purple: 0x800080ff,
    rebeccapurple: 0x663399ff,
    red: 0xff0000ff,
    rosybrown: 0xbc8f8fff,
    royalblue: 0x4169e1ff,
    saddlebrown: 0x8b4513ff,
    salmon: 0xfa8072ff,
    sandybrown: 0xf4a460ff,
    seagreen: 0x2e8b57ff,
    seashell: 0xfff5eeff,
    sienna: 0xa0522dff,
    silver: 0xc0c0c0ff,
    skyblue: 0x87ceebff,
    slateblue: 0x6a5acdff,
    slategray: 0x708090ff,
    slategrey: 0x708090ff,
    snow: 0xfffafaff,
    springgreen: 0x00ff7fff,
    steelblue: 0x4682b4ff,
    tan: 0xd2b48cff,
    teal: 0x008080ff,
    thistle: 0xd8bfd8ff,
    tomato: 0xff6347ff,
    turquoise: 0x40e0d0ff,
    violet: 0xee82eeff,
    wheat: 0xf5deb3ff,
    white: 0xffffffff,
    whitesmoke: 0xf5f5f5ff,
    yellow: 0xffff00ff,
    yellowgreen: 0x9acd32ff
  };
  module.exports = normalizeColor;
},157,[],"node_modules\\react-native\\Libraries\\Color\\normalizeColor.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var keyMirror = _$$_REQUIRE(_dependencyMap[0], "fbjs/lib/keyMirror");

  var ImageResizeMode = keyMirror({
    contain: null,
    cover: null,
    stretch: null,
    center: null,
    repeat: null
  });
  module.exports = ImageResizeMode;
},158,[159],"node_modules\\react-native\\Libraries\\Image\\ImageResizeMode.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var invariant = _$$_REQUIRE(_dependencyMap[0], "./invariant");

  var keyMirror = function keyMirror(obj) {
    var ret = {};
    var key;
    !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : void 0;

    for (key in obj) {
      if (!obj.hasOwnProperty(key)) {
        continue;
      }

      ret[key] = key;
    }

    return ret;
  };

  module.exports = keyMirror;
},159,[117],"node_modules\\fbjs\\lib\\keyMirror.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var ReactPropTypes = _$$_REQUIRE(_dependencyMap[0], "prop-types");

  var LayoutPropTypes = {
    display: ReactPropTypes.oneOf(['none', 'flex']),
    width: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    height: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    start: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    end: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    top: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    left: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    right: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    bottom: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    minWidth: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    maxWidth: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    minHeight: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    maxHeight: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    margin: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    marginVertical: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    marginHorizontal: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    marginTop: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    marginBottom: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    marginLeft: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    marginRight: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    marginStart: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    marginEnd: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    padding: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    paddingVertical: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    paddingHorizontal: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    paddingTop: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    paddingBottom: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    paddingLeft: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    paddingRight: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    paddingStart: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    paddingEnd: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    borderWidth: ReactPropTypes.number,
    borderTopWidth: ReactPropTypes.number,
    borderStartWidth: ReactPropTypes.number,
    borderEndWidth: ReactPropTypes.number,
    borderRightWidth: ReactPropTypes.number,
    borderBottomWidth: ReactPropTypes.number,
    borderLeftWidth: ReactPropTypes.number,
    position: ReactPropTypes.oneOf(['absolute', 'relative']),
    flexDirection: ReactPropTypes.oneOf(['row', 'row-reverse', 'column', 'column-reverse']),
    flexWrap: ReactPropTypes.oneOf(['wrap', 'nowrap', 'wrap-reverse']),
    justifyContent: ReactPropTypes.oneOf(['flex-start', 'flex-end', 'center', 'space-between', 'space-around', 'space-evenly']),
    alignItems: ReactPropTypes.oneOf(['flex-start', 'flex-end', 'center', 'stretch', 'baseline']),
    alignSelf: ReactPropTypes.oneOf(['auto', 'flex-start', 'flex-end', 'center', 'stretch', 'baseline']),
    alignContent: ReactPropTypes.oneOf(['flex-start', 'flex-end', 'center', 'stretch', 'space-between', 'space-around']),
    overflow: ReactPropTypes.oneOf(['visible', 'hidden', 'scroll']),
    flex: ReactPropTypes.number,
    flexGrow: ReactPropTypes.number,
    flexShrink: ReactPropTypes.number,
    flexBasis: ReactPropTypes.oneOfType([ReactPropTypes.number, ReactPropTypes.string]),
    aspectRatio: ReactPropTypes.number,
    zIndex: ReactPropTypes.number,
    direction: ReactPropTypes.oneOf(['inherit', 'ltr', 'rtl'])
  };
  module.exports = LayoutPropTypes;
},160,[161],"node_modules\\react-native\\Libraries\\StyleSheet\\LayoutPropTypes.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  if (process.env.NODE_ENV !== 'production') {
    var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && (typeof Symbol === "function" ? Symbol.for : "@@for") && (typeof Symbol === "function" ? Symbol.for : "@@for")('react.element') || 0xeac7;

    var isValidElement = function isValidElement(object) {
      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    };

    var throwOnDirectAccess = true;
    module.exports = _$$_REQUIRE(_dependencyMap[0], "./factoryWithTypeCheckers")(isValidElement, throwOnDirectAccess);
  } else {
    module.exports = _$$_REQUIRE(_dependencyMap[1], "./factoryWithThrowingShims")();
  }
},161,[162,163],"node_modules\\prop-types\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var assign = _$$_REQUIRE(_dependencyMap[0], "object-assign");

  var ReactPropTypesSecret = _$$_REQUIRE(_dependencyMap[1], "./lib/ReactPropTypesSecret");

  var checkPropTypes = _$$_REQUIRE(_dependencyMap[2], "./checkPropTypes");

  var printWarning = function printWarning() {};

  if (process.env.NODE_ENV !== 'production') {
    printWarning = function printWarning(text) {
      var message = 'Warning: ' + text;

      if (typeof console !== 'undefined') {
        console.error(message);
      }

      try {
        throw new Error(message);
      } catch (x) {}
    };
  }

  function emptyFunctionThatReturnsNull() {
    return null;
  }

  module.exports = function (isValidElement, throwOnDirectAccess) {
    var ITERATOR_SYMBOL = typeof Symbol === 'function' && (typeof Symbol === "function" ? Symbol.iterator : "@@iterator");
    var FAUX_ITERATOR_SYMBOL = '@@iterator';

    function getIteratorFn(maybeIterable) {
      var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);

      if (typeof iteratorFn === 'function') {
        return iteratorFn;
      }
    }

    var ANONYMOUS = '<<anonymous>>';
    var ReactPropTypes = {
      array: createPrimitiveTypeChecker('array'),
      bool: createPrimitiveTypeChecker('boolean'),
      func: createPrimitiveTypeChecker('function'),
      number: createPrimitiveTypeChecker('number'),
      object: createPrimitiveTypeChecker('object'),
      string: createPrimitiveTypeChecker('string'),
      symbol: createPrimitiveTypeChecker('symbol'),
      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker,
      exact: createStrictShapeTypeChecker
    };

    function is(x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }

    function PropTypeError(message) {
      this.message = message;
      this.stack = '';
    }

    PropTypeError.prototype = Error.prototype;

    function createChainableTypeChecker(validate) {
      if (process.env.NODE_ENV !== 'production') {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
      }

      function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;

        if (secret !== ReactPropTypesSecret) {
          if (throwOnDirectAccess) {
            var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
            err.name = 'Invariant Violation';
            throw err;
          } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
            var cacheKey = componentName + ':' + propName;

            if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
              printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
              manualPropTypeCallCache[cacheKey] = true;
              manualPropTypeWarningCount++;
            }
          }
        }

        if (props[propName] == null) {
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
            }

            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
          }

          return null;
        } else {
          return validate(props, propName, componentName, location, propFullName);
        }
      }

      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);
      return chainedCheckType;
    }

    function createPrimitiveTypeChecker(expectedType) {
      function validate(props, propName, componentName, location, propFullName, secret) {
        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== expectedType) {
          var preciseType = getPreciseType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }

    function createArrayOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
        }

        var propValue = props[propName];

        if (!Array.isArray(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
        }

        for (var i = 0; i < propValue.length; i++) {
          var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);

          if (error instanceof Error) {
            return error;
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createElementTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];

        if (!isValidElement(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createInstanceTypeChecker(expectedClass) {
      function validate(props, propName, componentName, location, propFullName) {
        if (!(props[propName] instanceof expectedClass)) {
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
        return emptyFunctionThatReturnsNull;
      }

      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];

        for (var i = 0; i < expectedValues.length; i++) {
          if (is(propValue, expectedValues[i])) {
            return null;
          }
        }

        var valuesString = JSON.stringify(expectedValues);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
      }

      return createChainableTypeChecker(validate);
    }

    function createObjectOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
        }

        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
        }

        for (var key in propValue) {
          if (propValue.hasOwnProperty(key)) {
            var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);

            if (error instanceof Error) {
              return error;
            }
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
        process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
        return emptyFunctionThatReturnsNull;
      }

      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];

        if (typeof checker !== 'function') {
          printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
          return emptyFunctionThatReturnsNull;
        }
      }

      function validate(props, propName, componentName, location, propFullName) {
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];

          if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
            return null;
          }
        }

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
      }

      return createChainableTypeChecker(validate);
    }

    function createNodeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        if (!isNode(props[propName])) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        }

        for (var key in shapeTypes) {
          var checker = shapeTypes[key];

          if (!checker) {
            continue;
          }

          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);

          if (error) {
            return error;
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createStrictShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        }

        var allKeys = assign({}, props[propName], shapeTypes);

        for (var key in allKeys) {
          var checker = shapeTypes[key];

          if (!checker) {
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
          }

          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);

          if (error) {
            return error;
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function isNode(propValue) {
      switch (typeof propValue) {
        case 'number':
        case 'string':
        case 'undefined':
          return true;

        case 'boolean':
          return !propValue;

        case 'object':
          if (Array.isArray(propValue)) {
            return propValue.every(isNode);
          }

          if (propValue === null || isValidElement(propValue)) {
            return true;
          }

          var iteratorFn = getIteratorFn(propValue);

          if (iteratorFn) {
            var iterator = iteratorFn.call(propValue);
            var step;

            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator.next()).done) {
                if (!isNode(step.value)) {
                  return false;
                }
              }
            } else {
              while (!(step = iterator.next()).done) {
                var entry = step.value;

                if (entry) {
                  if (!isNode(entry[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }

          return true;

        default:
          return false;
      }
    }

    function isSymbol(propType, propValue) {
      if (propType === 'symbol') {
        return true;
      }

      if (propValue['@@toStringTag'] === 'Symbol') {
        return true;
      }

      if (typeof Symbol === 'function' && propValue instanceof Symbol) {
        return true;
      }

      return false;
    }

    function getPropType(propValue) {
      var propType = typeof propValue;

      if (Array.isArray(propValue)) {
        return 'array';
      }

      if (propValue instanceof RegExp) {
        return 'object';
      }

      if (isSymbol(propType, propValue)) {
        return 'symbol';
      }

      return propType;
    }

    function getPreciseType(propValue) {
      if (typeof propValue === 'undefined' || propValue === null) {
        return '' + propValue;
      }

      var propType = getPropType(propValue);

      if (propType === 'object') {
        if (propValue instanceof Date) {
          return 'date';
        } else if (propValue instanceof RegExp) {
          return 'regexp';
        }
      }

      return propType;
    }

    function getPostfixForTypeWarning(value) {
      var type = getPreciseType(value);

      switch (type) {
        case 'array':
        case 'object':
          return 'an ' + type;

        case 'boolean':
        case 'date':
        case 'regexp':
          return 'a ' + type;

        default:
          return type;
      }
    }

    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }

      return propValue.constructor.name;
    }

    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
},162,[111,115,114],"node_modules\\prop-types\\factoryWithTypeCheckers.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var ReactPropTypesSecret = _$$_REQUIRE(_dependencyMap[0], "./lib/ReactPropTypesSecret");

  function emptyFunction() {}

  module.exports = function () {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        return;
      }

      var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
      err.name = 'Invariant Violation';
      throw err;
    }

    ;
    shim.isRequired = shim;

    function getShim() {
      return shim;
    }

    ;
    var ReactPropTypes = {
      array: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim
    };
    ReactPropTypes.checkPropTypes = emptyFunction;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
},163,[115],"node_modules\\prop-types\\factoryWithThrowingShims.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var ColorPropType = _$$_REQUIRE(_dependencyMap[0], "ColorPropType");

  var ReactPropTypes = _$$_REQUIRE(_dependencyMap[1], "prop-types");

  var ShadowPropTypesIOS = {
    shadowColor: ColorPropType,
    shadowOffset: ReactPropTypes.shape({
      width: ReactPropTypes.number,
      height: ReactPropTypes.number
    }),
    shadowOpacity: ReactPropTypes.number,
    shadowRadius: ReactPropTypes.number
  };
  module.exports = ShadowPropTypesIOS;
},164,[156,161],"node_modules\\react-native\\Libraries\\Components\\View\\ShadowPropTypesIOS.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var ReactPropTypes = _$$_REQUIRE(_dependencyMap[0], "prop-types");

  var deprecatedPropType = _$$_REQUIRE(_dependencyMap[1], "deprecatedPropType");

  var TransformMatrixPropType = function TransformMatrixPropType(props, propName, componentName) {
    if (props[propName]) {
      return new Error('The transformMatrix style property is deprecated. ' + 'Use `transform: [{ matrix: ... }]` instead.');
    }
  };

  var DecomposedMatrixPropType = function DecomposedMatrixPropType(props, propName, componentName) {
    if (props[propName]) {
      return new Error('The decomposedMatrix style property is deprecated. ' + 'Use `transform: [...]` instead.');
    }
  };

  var TransformPropTypes = {
    transform: ReactPropTypes.arrayOf(ReactPropTypes.oneOfType([ReactPropTypes.shape({
      perspective: ReactPropTypes.number
    }), ReactPropTypes.shape({
      rotate: ReactPropTypes.string
    }), ReactPropTypes.shape({
      rotateX: ReactPropTypes.string
    }), ReactPropTypes.shape({
      rotateY: ReactPropTypes.string
    }), ReactPropTypes.shape({
      rotateZ: ReactPropTypes.string
    }), ReactPropTypes.shape({
      scale: ReactPropTypes.number
    }), ReactPropTypes.shape({
      scaleX: ReactPropTypes.number
    }), ReactPropTypes.shape({
      scaleY: ReactPropTypes.number
    }), ReactPropTypes.shape({
      translateX: ReactPropTypes.number
    }), ReactPropTypes.shape({
      translateY: ReactPropTypes.number
    }), ReactPropTypes.shape({
      skewX: ReactPropTypes.string
    }), ReactPropTypes.shape({
      skewY: ReactPropTypes.string
    })])),
    transformMatrix: TransformMatrixPropType,
    decomposedMatrix: DecomposedMatrixPropType,
    scaleX: deprecatedPropType(ReactPropTypes.number, 'Use the transform prop instead.'),
    scaleY: deprecatedPropType(ReactPropTypes.number, 'Use the transform prop instead.'),
    rotation: deprecatedPropType(ReactPropTypes.number, 'Use the transform prop instead.'),
    translateX: deprecatedPropType(ReactPropTypes.number, 'Use the transform prop instead.'),
    translateY: deprecatedPropType(ReactPropTypes.number, 'Use the transform prop instead.')
  };
  module.exports = TransformPropTypes;
},165,[161,166],"node_modules\\react-native\\Libraries\\StyleSheet\\TransformPropTypes.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var UIManager = _$$_REQUIRE(_dependencyMap[0], "UIManager");

  function deprecatedPropType(propType, explanation) {
    return function validate(props, propName, componentName) {
      if (!UIManager[componentName] && props[propName] !== undefined) {
        console.warn("`" + propName + "` supplied to `" + componentName + "` has been deprecated. " + explanation);
      }

      for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        rest[_key - 3] = arguments[_key];
      }

      return propType.apply(void 0, [props, propName, componentName].concat(rest));
    };
  }

  module.exports = deprecatedPropType;
},166,[145],"node_modules\\react-native\\Libraries\\Utilities\\deprecatedPropType.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var ColorPropType = _$$_REQUIRE(_dependencyMap[1], "ColorPropType");

  var ReactPropTypes = _$$_REQUIRE(_dependencyMap[2], "prop-types");

  var ViewStylePropTypes = _$$_REQUIRE(_dependencyMap[3], "ViewStylePropTypes");

  var TextStylePropTypes = _objectSpread({}, ViewStylePropTypes, {
    color: ColorPropType,
    fontFamily: ReactPropTypes.string,
    fontSize: ReactPropTypes.number,
    fontStyle: ReactPropTypes.oneOf(['normal', 'italic']),
    fontWeight: ReactPropTypes.oneOf(['normal', 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900']),
    fontVariant: ReactPropTypes.arrayOf(ReactPropTypes.oneOf(['small-caps', 'oldstyle-nums', 'lining-nums', 'tabular-nums', 'proportional-nums'])),
    textShadowOffset: ReactPropTypes.shape({
      width: ReactPropTypes.number,
      height: ReactPropTypes.number
    }),
    textShadowRadius: ReactPropTypes.number,
    textShadowColor: ColorPropType,
    letterSpacing: ReactPropTypes.number,
    lineHeight: ReactPropTypes.number,
    textAlign: ReactPropTypes.oneOf(['auto', 'left', 'right', 'center', 'justify']),
    textAlignVertical: ReactPropTypes.oneOf(['auto', 'top', 'bottom', 'center']),
    includeFontPadding: ReactPropTypes.bool,
    textDecorationLine: ReactPropTypes.oneOf(['none', 'underline', 'line-through', 'underline line-through']),
    textDecorationStyle: ReactPropTypes.oneOf(['solid', 'double', 'dotted', 'dashed']),
    textDecorationColor: ColorPropType,
    textTransform: ReactPropTypes.oneOf(['none', 'capitalize', 'uppercase', 'lowercase']),
    writingDirection: ReactPropTypes.oneOf(['auto', 'ltr', 'rtl'])
  });

  module.exports = TextStylePropTypes;
},167,[148,156,161,168],"node_modules\\react-native\\Libraries\\Text\\TextStylePropTypes.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var ColorPropType = _$$_REQUIRE(_dependencyMap[1], "ColorPropType");

  var LayoutPropTypes = _$$_REQUIRE(_dependencyMap[2], "LayoutPropTypes");

  var ReactPropTypes = _$$_REQUIRE(_dependencyMap[3], "prop-types");

  var ShadowPropTypesIOS = _$$_REQUIRE(_dependencyMap[4], "ShadowPropTypesIOS");

  var TransformPropTypes = _$$_REQUIRE(_dependencyMap[5], "TransformPropTypes");

  var ViewStylePropTypes = _objectSpread({}, LayoutPropTypes, ShadowPropTypesIOS, TransformPropTypes, {
    backfaceVisibility: ReactPropTypes.oneOf(['visible', 'hidden']),
    backgroundColor: ColorPropType,
    borderColor: ColorPropType,
    borderTopColor: ColorPropType,
    borderRightColor: ColorPropType,
    borderBottomColor: ColorPropType,
    borderLeftColor: ColorPropType,
    borderStartColor: ColorPropType,
    borderEndColor: ColorPropType,
    borderRadius: ReactPropTypes.number,
    borderTopLeftRadius: ReactPropTypes.number,
    borderTopRightRadius: ReactPropTypes.number,
    borderTopStartRadius: ReactPropTypes.number,
    borderTopEndRadius: ReactPropTypes.number,
    borderBottomLeftRadius: ReactPropTypes.number,
    borderBottomRightRadius: ReactPropTypes.number,
    borderBottomStartRadius: ReactPropTypes.number,
    borderBottomEndRadius: ReactPropTypes.number,
    borderStyle: ReactPropTypes.oneOf(['solid', 'dotted', 'dashed']),
    borderWidth: ReactPropTypes.number,
    borderTopWidth: ReactPropTypes.number,
    borderRightWidth: ReactPropTypes.number,
    borderBottomWidth: ReactPropTypes.number,
    borderLeftWidth: ReactPropTypes.number,
    opacity: ReactPropTypes.number,
    elevation: ReactPropTypes.number
  });

  module.exports = ViewStylePropTypes;
},168,[148,156,160,161,164,165],"node_modules\\react-native\\Libraries\\Components\\View\\ViewStylePropTypes.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Platform = _$$_REQUIRE(_dependencyMap[0], "Platform");

  var normalizeColor = _$$_REQUIRE(_dependencyMap[1], "normalizeColor");

  function processColor(color) {
    if (color === undefined || color === null) {
      return color;
    }

    var int32Color = normalizeColor(color);

    if (int32Color === null || int32Color === undefined) {
      return undefined;
    }

    int32Color = (int32Color << 24 | int32Color >>> 8) >>> 0;

    if (Platform.OS === 'android') {
      int32Color = int32Color | 0x0;
    }

    return int32Color;
  }

  module.exports = processColor;
},169,[146,157],"node_modules\\react-native\\Libraries\\StyleSheet\\processColor.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var MatrixMath = _$$_REQUIRE(_dependencyMap[0], "MatrixMath");

  var Platform = _$$_REQUIRE(_dependencyMap[1], "Platform");

  var invariant = _$$_REQUIRE(_dependencyMap[2], "fbjs/lib/invariant");

  var stringifySafe = _$$_REQUIRE(_dependencyMap[3], "stringifySafe");

  function processTransform(transform) {
    if (__DEV__) {
      _validateTransforms(transform);
    }

    if (Platform.OS === 'android' || Platform.OS === 'ios') {
      return transform;
    }

    var result = MatrixMath.createIdentityMatrix();
    transform.forEach(function (transformation) {
      var key = Object.keys(transformation)[0];
      var value = transformation[key];

      switch (key) {
        case 'matrix':
          MatrixMath.multiplyInto(result, result, value);
          break;

        case 'perspective':
          _multiplyTransform(result, MatrixMath.reusePerspectiveCommand, [value]);

          break;

        case 'rotateX':
          _multiplyTransform(result, MatrixMath.reuseRotateXCommand, [_convertToRadians(value)]);

          break;

        case 'rotateY':
          _multiplyTransform(result, MatrixMath.reuseRotateYCommand, [_convertToRadians(value)]);

          break;

        case 'rotate':
        case 'rotateZ':
          _multiplyTransform(result, MatrixMath.reuseRotateZCommand, [_convertToRadians(value)]);

          break;

        case 'scale':
          _multiplyTransform(result, MatrixMath.reuseScaleCommand, [value]);

          break;

        case 'scaleX':
          _multiplyTransform(result, MatrixMath.reuseScaleXCommand, [value]);

          break;

        case 'scaleY':
          _multiplyTransform(result, MatrixMath.reuseScaleYCommand, [value]);

          break;

        case 'translate':
          _multiplyTransform(result, MatrixMath.reuseTranslate3dCommand, [value[0], value[1], value[2] || 0]);

          break;

        case 'translateX':
          _multiplyTransform(result, MatrixMath.reuseTranslate2dCommand, [value, 0]);

          break;

        case 'translateY':
          _multiplyTransform(result, MatrixMath.reuseTranslate2dCommand, [0, value]);

          break;

        case 'skewX':
          _multiplyTransform(result, MatrixMath.reuseSkewXCommand, [_convertToRadians(value)]);

          break;

        case 'skewY':
          _multiplyTransform(result, MatrixMath.reuseSkewYCommand, [_convertToRadians(value)]);

          break;

        default:
          throw new Error('Invalid transform name: ' + key);
      }
    });
    return result;
  }

  function _multiplyTransform(result, matrixMathFunction, args) {
    var matrixToApply = MatrixMath.createIdentityMatrix();
    var argsWithIdentity = [matrixToApply].concat(args);
    matrixMathFunction.apply(this, argsWithIdentity);
    MatrixMath.multiplyInto(result, result, matrixToApply);
  }

  function _convertToRadians(value) {
    var floatValue = parseFloat(value);
    return value.indexOf('rad') > -1 ? floatValue : floatValue * Math.PI / 180;
  }

  function _validateTransforms(transform) {
    transform.forEach(function (transformation) {
      var keys = Object.keys(transformation);
      invariant(keys.length === 1, 'You must specify exactly one property per transform object. Passed properties: %s', stringifySafe(transformation));
      var key = keys[0];
      var value = transformation[key];

      _validateTransform(key, value, transformation);
    });
  }

  function _validateTransform(key, value, transformation) {
    invariant(!value.getValue, 'You passed an Animated.Value to a normal component. ' + 'You need to wrap that component in an Animated. For example, ' + 'replace <View /> by <Animated.View />.');
    var multivalueTransforms = ['matrix', 'translate'];

    if (multivalueTransforms.indexOf(key) !== -1) {
      invariant(Array.isArray(value), 'Transform with key of %s must have an array as the value: %s', key, stringifySafe(transformation));
    }

    switch (key) {
      case 'matrix':
        invariant(value.length === 9 || value.length === 16, 'Matrix transform must have a length of 9 (2d) or 16 (3d). ' + 'Provided matrix has a length of %s: %s', value.length, stringifySafe(transformation));
        break;

      case 'translate':
        invariant(value.length === 2 || value.length === 3, 'Transform with key translate must be an array of length 2 or 3, found %s: %s', value.length, stringifySafe(transformation));
        break;

      case 'rotateX':
      case 'rotateY':
      case 'rotateZ':
      case 'rotate':
      case 'skewX':
      case 'skewY':
        invariant(typeof value === 'string', 'Transform with key of "%s" must be a string: %s', key, stringifySafe(transformation));
        invariant(value.indexOf('deg') > -1 || value.indexOf('rad') > -1, 'Rotate transform must be expressed in degrees (deg) or radians ' + '(rad): %s', stringifySafe(transformation));
        break;

      case 'perspective':
        invariant(typeof value === 'number', 'Transform with key of "%s" must be a number: %s', key, stringifySafe(transformation));
        invariant(value !== 0, 'Transform with key of "%s" cannot be zero: %s', key, stringifySafe(transformation));
        break;

      case 'translateX':
      case 'translateY':
      case 'scale':
      case 'scaleX':
      case 'scaleY':
        invariant(typeof value === 'number', 'Transform with key of "%s" must be a number: %s', key, stringifySafe(transformation));
        break;

      default:
        invariant(false, 'Invalid transform %s: %s', key, stringifySafe(transformation));
    }
  }

  module.exports = processTransform;
},170,[171,146,117,135],"node_modules\\react-native\\Libraries\\StyleSheet\\processTransform.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _slicedToArray = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/slicedToArray");

  var invariant = _$$_REQUIRE(_dependencyMap[1], "fbjs/lib/invariant");

  var MatrixMath = {
    createIdentityMatrix: function createIdentityMatrix() {
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    },
    createCopy: function createCopy(m) {
      return [m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]];
    },
    createOrthographic: function createOrthographic(left, right, bottom, top, near, far) {
      var a = 2 / (right - left);
      var b = 2 / (top - bottom);
      var c = -2 / (far - near);
      var tx = -(right + left) / (right - left);
      var ty = -(top + bottom) / (top - bottom);
      var tz = -(far + near) / (far - near);
      return [a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, tx, ty, tz, 1];
    },
    createFrustum: function createFrustum(left, right, bottom, top, near, far) {
      var r_width = 1 / (right - left);
      var r_height = 1 / (top - bottom);
      var r_depth = 1 / (near - far);
      var x = 2 * (near * r_width);
      var y = 2 * (near * r_height);
      var A = (right + left) * r_width;
      var B = (top + bottom) * r_height;
      var C = (far + near) * r_depth;
      var D = 2 * (far * near * r_depth);
      return [x, 0, 0, 0, 0, y, 0, 0, A, B, C, -1, 0, 0, D, 0];
    },
    createPerspective: function createPerspective(fovInRadians, aspect, near, far) {
      var h = 1 / Math.tan(fovInRadians / 2);
      var r_depth = 1 / (near - far);
      var C = (far + near) * r_depth;
      var D = 2 * (far * near * r_depth);
      return [h / aspect, 0, 0, 0, 0, h, 0, 0, 0, 0, C, -1, 0, 0, D, 0];
    },
    createTranslate2d: function createTranslate2d(x, y) {
      var mat = MatrixMath.createIdentityMatrix();
      MatrixMath.reuseTranslate2dCommand(mat, x, y);
      return mat;
    },
    reuseTranslate2dCommand: function reuseTranslate2dCommand(matrixCommand, x, y) {
      matrixCommand[12] = x;
      matrixCommand[13] = y;
    },
    reuseTranslate3dCommand: function reuseTranslate3dCommand(matrixCommand, x, y, z) {
      matrixCommand[12] = x;
      matrixCommand[13] = y;
      matrixCommand[14] = z;
    },
    createScale: function createScale(factor) {
      var mat = MatrixMath.createIdentityMatrix();
      MatrixMath.reuseScaleCommand(mat, factor);
      return mat;
    },
    reuseScaleCommand: function reuseScaleCommand(matrixCommand, factor) {
      matrixCommand[0] = factor;
      matrixCommand[5] = factor;
    },
    reuseScale3dCommand: function reuseScale3dCommand(matrixCommand, x, y, z) {
      matrixCommand[0] = x;
      matrixCommand[5] = y;
      matrixCommand[10] = z;
    },
    reusePerspectiveCommand: function reusePerspectiveCommand(matrixCommand, p) {
      matrixCommand[11] = -1 / p;
    },
    reuseScaleXCommand: function reuseScaleXCommand(matrixCommand, factor) {
      matrixCommand[0] = factor;
    },
    reuseScaleYCommand: function reuseScaleYCommand(matrixCommand, factor) {
      matrixCommand[5] = factor;
    },
    reuseScaleZCommand: function reuseScaleZCommand(matrixCommand, factor) {
      matrixCommand[10] = factor;
    },
    reuseRotateXCommand: function reuseRotateXCommand(matrixCommand, radians) {
      matrixCommand[5] = Math.cos(radians);
      matrixCommand[6] = Math.sin(radians);
      matrixCommand[9] = -Math.sin(radians);
      matrixCommand[10] = Math.cos(radians);
    },
    reuseRotateYCommand: function reuseRotateYCommand(matrixCommand, amount) {
      matrixCommand[0] = Math.cos(amount);
      matrixCommand[2] = -Math.sin(amount);
      matrixCommand[8] = Math.sin(amount);
      matrixCommand[10] = Math.cos(amount);
    },
    reuseRotateZCommand: function reuseRotateZCommand(matrixCommand, radians) {
      matrixCommand[0] = Math.cos(radians);
      matrixCommand[1] = Math.sin(radians);
      matrixCommand[4] = -Math.sin(radians);
      matrixCommand[5] = Math.cos(radians);
    },
    createRotateZ: function createRotateZ(radians) {
      var mat = MatrixMath.createIdentityMatrix();
      MatrixMath.reuseRotateZCommand(mat, radians);
      return mat;
    },
    reuseSkewXCommand: function reuseSkewXCommand(matrixCommand, radians) {
      matrixCommand[4] = Math.tan(radians);
    },
    reuseSkewYCommand: function reuseSkewYCommand(matrixCommand, radians) {
      matrixCommand[1] = Math.tan(radians);
    },
    multiplyInto: function multiplyInto(out, a, b) {
      var a00 = a[0],
          a01 = a[1],
          a02 = a[2],
          a03 = a[3],
          a10 = a[4],
          a11 = a[5],
          a12 = a[6],
          a13 = a[7],
          a20 = a[8],
          a21 = a[9],
          a22 = a[10],
          a23 = a[11],
          a30 = a[12],
          a31 = a[13],
          a32 = a[14],
          a33 = a[15];
      var b0 = b[0],
          b1 = b[1],
          b2 = b[2],
          b3 = b[3];
      out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[4];
      b1 = b[5];
      b2 = b[6];
      b3 = b[7];
      out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[8];
      b1 = b[9];
      b2 = b[10];
      b3 = b[11];
      out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[12];
      b1 = b[13];
      b2 = b[14];
      b3 = b[15];
      out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    },
    determinant: function determinant(matrix) {
      var _matrix = _slicedToArray(matrix, 16),
          m00 = _matrix[0],
          m01 = _matrix[1],
          m02 = _matrix[2],
          m03 = _matrix[3],
          m10 = _matrix[4],
          m11 = _matrix[5],
          m12 = _matrix[6],
          m13 = _matrix[7],
          m20 = _matrix[8],
          m21 = _matrix[9],
          m22 = _matrix[10],
          m23 = _matrix[11],
          m30 = _matrix[12],
          m31 = _matrix[13],
          m32 = _matrix[14],
          m33 = _matrix[15];

      return m03 * m12 * m21 * m30 - m02 * m13 * m21 * m30 - m03 * m11 * m22 * m30 + m01 * m13 * m22 * m30 + m02 * m11 * m23 * m30 - m01 * m12 * m23 * m30 - m03 * m12 * m20 * m31 + m02 * m13 * m20 * m31 + m03 * m10 * m22 * m31 - m00 * m13 * m22 * m31 - m02 * m10 * m23 * m31 + m00 * m12 * m23 * m31 + m03 * m11 * m20 * m32 - m01 * m13 * m20 * m32 - m03 * m10 * m21 * m32 + m00 * m13 * m21 * m32 + m01 * m10 * m23 * m32 - m00 * m11 * m23 * m32 - m02 * m11 * m20 * m33 + m01 * m12 * m20 * m33 + m02 * m10 * m21 * m33 - m00 * m12 * m21 * m33 - m01 * m10 * m22 * m33 + m00 * m11 * m22 * m33;
    },
    inverse: function inverse(matrix) {
      var det = MatrixMath.determinant(matrix);

      if (!det) {
        return matrix;
      }

      var _matrix2 = _slicedToArray(matrix, 16),
          m00 = _matrix2[0],
          m01 = _matrix2[1],
          m02 = _matrix2[2],
          m03 = _matrix2[3],
          m10 = _matrix2[4],
          m11 = _matrix2[5],
          m12 = _matrix2[6],
          m13 = _matrix2[7],
          m20 = _matrix2[8],
          m21 = _matrix2[9],
          m22 = _matrix2[10],
          m23 = _matrix2[11],
          m30 = _matrix2[12],
          m31 = _matrix2[13],
          m32 = _matrix2[14],
          m33 = _matrix2[15];

      return [(m12 * m23 * m31 - m13 * m22 * m31 + m13 * m21 * m32 - m11 * m23 * m32 - m12 * m21 * m33 + m11 * m22 * m33) / det, (m03 * m22 * m31 - m02 * m23 * m31 - m03 * m21 * m32 + m01 * m23 * m32 + m02 * m21 * m33 - m01 * m22 * m33) / det, (m02 * m13 * m31 - m03 * m12 * m31 + m03 * m11 * m32 - m01 * m13 * m32 - m02 * m11 * m33 + m01 * m12 * m33) / det, (m03 * m12 * m21 - m02 * m13 * m21 - m03 * m11 * m22 + m01 * m13 * m22 + m02 * m11 * m23 - m01 * m12 * m23) / det, (m13 * m22 * m30 - m12 * m23 * m30 - m13 * m20 * m32 + m10 * m23 * m32 + m12 * m20 * m33 - m10 * m22 * m33) / det, (m02 * m23 * m30 - m03 * m22 * m30 + m03 * m20 * m32 - m00 * m23 * m32 - m02 * m20 * m33 + m00 * m22 * m33) / det, (m03 * m12 * m30 - m02 * m13 * m30 - m03 * m10 * m32 + m00 * m13 * m32 + m02 * m10 * m33 - m00 * m12 * m33) / det, (m02 * m13 * m20 - m03 * m12 * m20 + m03 * m10 * m22 - m00 * m13 * m22 - m02 * m10 * m23 + m00 * m12 * m23) / det, (m11 * m23 * m30 - m13 * m21 * m30 + m13 * m20 * m31 - m10 * m23 * m31 - m11 * m20 * m33 + m10 * m21 * m33) / det, (m03 * m21 * m30 - m01 * m23 * m30 - m03 * m20 * m31 + m00 * m23 * m31 + m01 * m20 * m33 - m00 * m21 * m33) / det, (m01 * m13 * m30 - m03 * m11 * m30 + m03 * m10 * m31 - m00 * m13 * m31 - m01 * m10 * m33 + m00 * m11 * m33) / det, (m03 * m11 * m20 - m01 * m13 * m20 - m03 * m10 * m21 + m00 * m13 * m21 + m01 * m10 * m23 - m00 * m11 * m23) / det, (m12 * m21 * m30 - m11 * m22 * m30 - m12 * m20 * m31 + m10 * m22 * m31 + m11 * m20 * m32 - m10 * m21 * m32) / det, (m01 * m22 * m30 - m02 * m21 * m30 + m02 * m20 * m31 - m00 * m22 * m31 - m01 * m20 * m32 + m00 * m21 * m32) / det, (m02 * m11 * m30 - m01 * m12 * m30 - m02 * m10 * m31 + m00 * m12 * m31 + m01 * m10 * m32 - m00 * m11 * m32) / det, (m01 * m12 * m20 - m02 * m11 * m20 + m02 * m10 * m21 - m00 * m12 * m21 - m01 * m10 * m22 + m00 * m11 * m22) / det];
    },
    transpose: function transpose(m) {
      return [m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]];
    },
    multiplyVectorByMatrix: function multiplyVectorByMatrix(v, m) {
      var _v = _slicedToArray(v, 4),
          vx = _v[0],
          vy = _v[1],
          vz = _v[2],
          vw = _v[3];

      return [vx * m[0] + vy * m[4] + vz * m[8] + vw * m[12], vx * m[1] + vy * m[5] + vz * m[9] + vw * m[13], vx * m[2] + vy * m[6] + vz * m[10] + vw * m[14], vx * m[3] + vy * m[7] + vz * m[11] + vw * m[15]];
    },
    v3Length: function v3Length(a) {
      return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
    },
    v3Normalize: function v3Normalize(vector, v3Length) {
      var im = 1 / (v3Length || MatrixMath.v3Length(vector));
      return [vector[0] * im, vector[1] * im, vector[2] * im];
    },
    v3Dot: function v3Dot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    },
    v3Combine: function v3Combine(a, b, aScale, bScale) {
      return [aScale * a[0] + bScale * b[0], aScale * a[1] + bScale * b[1], aScale * a[2] + bScale * b[2]];
    },
    v3Cross: function v3Cross(a, b) {
      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    },
    quaternionToDegreesXYZ: function quaternionToDegreesXYZ(q, matrix, row) {
      var _q = _slicedToArray(q, 4),
          qx = _q[0],
          qy = _q[1],
          qz = _q[2],
          qw = _q[3];

      var qw2 = qw * qw;
      var qx2 = qx * qx;
      var qy2 = qy * qy;
      var qz2 = qz * qz;
      var test = qx * qy + qz * qw;
      var unit = qw2 + qx2 + qy2 + qz2;
      var conv = 180 / Math.PI;

      if (test > 0.49999 * unit) {
        return [0, 2 * Math.atan2(qx, qw) * conv, 90];
      }

      if (test < -0.49999 * unit) {
        return [0, -2 * Math.atan2(qx, qw) * conv, -90];
      }

      return [MatrixMath.roundTo3Places(Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx2 - 2 * qz2) * conv), MatrixMath.roundTo3Places(Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy2 - 2 * qz2) * conv), MatrixMath.roundTo3Places(Math.asin(2 * qx * qy + 2 * qz * qw) * conv)];
    },
    roundTo3Places: function roundTo3Places(n) {
      var arr = n.toString().split('e');
      return Math.round(arr[0] + 'e' + (arr[1] ? +arr[1] - 3 : 3)) * 0.001;
    },
    decomposeMatrix: function decomposeMatrix(transformMatrix) {
      invariant(transformMatrix.length === 16, 'Matrix decomposition needs a list of 3d matrix values, received %s', transformMatrix);
      var perspective = [];
      var quaternion = [];
      var scale = [];
      var skew = [];
      var translation = [];

      if (!transformMatrix[15]) {
        return;
      }

      var matrix = [];
      var perspectiveMatrix = [];

      for (var i = 0; i < 4; i++) {
        matrix.push([]);

        for (var j = 0; j < 4; j++) {
          var value = transformMatrix[i * 4 + j] / transformMatrix[15];
          matrix[i].push(value);
          perspectiveMatrix.push(j === 3 ? 0 : value);
        }
      }

      perspectiveMatrix[15] = 1;

      if (!MatrixMath.determinant(perspectiveMatrix)) {
        return;
      }

      if (matrix[0][3] !== 0 || matrix[1][3] !== 0 || matrix[2][3] !== 0) {
        var rightHandSide = [matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]];
        var inversePerspectiveMatrix = MatrixMath.inverse(perspectiveMatrix);
        var transposedInversePerspectiveMatrix = MatrixMath.transpose(inversePerspectiveMatrix);
        var perspective = MatrixMath.multiplyVectorByMatrix(rightHandSide, transposedInversePerspectiveMatrix);
      } else {
        perspective[0] = perspective[1] = perspective[2] = 0;
        perspective[3] = 1;
      }

      for (var i = 0; i < 3; i++) {
        translation[i] = matrix[3][i];
      }

      var row = [];

      for (i = 0; i < 3; i++) {
        row[i] = [matrix[i][0], matrix[i][1], matrix[i][2]];
      }

      scale[0] = MatrixMath.v3Length(row[0]);
      row[0] = MatrixMath.v3Normalize(row[0], scale[0]);
      skew[0] = MatrixMath.v3Dot(row[0], row[1]);
      row[1] = MatrixMath.v3Combine(row[1], row[0], 1.0, -skew[0]);
      skew[0] = MatrixMath.v3Dot(row[0], row[1]);
      row[1] = MatrixMath.v3Combine(row[1], row[0], 1.0, -skew[0]);
      scale[1] = MatrixMath.v3Length(row[1]);
      row[1] = MatrixMath.v3Normalize(row[1], scale[1]);
      skew[0] /= scale[1];
      skew[1] = MatrixMath.v3Dot(row[0], row[2]);
      row[2] = MatrixMath.v3Combine(row[2], row[0], 1.0, -skew[1]);
      skew[2] = MatrixMath.v3Dot(row[1], row[2]);
      row[2] = MatrixMath.v3Combine(row[2], row[1], 1.0, -skew[2]);
      scale[2] = MatrixMath.v3Length(row[2]);
      row[2] = MatrixMath.v3Normalize(row[2], scale[2]);
      skew[1] /= scale[2];
      skew[2] /= scale[2];
      var pdum3 = MatrixMath.v3Cross(row[1], row[2]);

      if (MatrixMath.v3Dot(row[0], pdum3) < 0) {
        for (i = 0; i < 3; i++) {
          scale[i] *= -1;
          row[i][0] *= -1;
          row[i][1] *= -1;
          row[i][2] *= -1;
        }
      }

      quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
      quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
      quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
      quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));

      if (row[2][1] > row[1][2]) {
        quaternion[0] = -quaternion[0];
      }

      if (row[0][2] > row[2][0]) {
        quaternion[1] = -quaternion[1];
      }

      if (row[1][0] > row[0][1]) {
        quaternion[2] = -quaternion[2];
      }

      var rotationDegrees;

      if (quaternion[0] < 0.001 && quaternion[0] >= 0 && quaternion[1] < 0.001 && quaternion[1] >= 0) {
        rotationDegrees = [0, 0, MatrixMath.roundTo3Places(Math.atan2(row[0][1], row[0][0]) * 180 / Math.PI)];
      } else {
        rotationDegrees = MatrixMath.quaternionToDegreesXYZ(quaternion, matrix, row);
      }

      return {
        rotationDegrees: rotationDegrees,
        perspective: perspective,
        quaternion: quaternion,
        scale: scale,
        skew: skew,
        translation: translation,
        rotate: rotationDegrees[2],
        rotateX: rotationDegrees[0],
        rotateY: rotationDegrees[1],
        scaleX: scale[0],
        scaleY: scale[1],
        translateX: translation[0],
        translateY: translation[1]
      };
    }
  };
  module.exports = MatrixMath;
},171,[122,117],"node_modules\\react-native\\Libraries\\Utilities\\MatrixMath.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var dummySize = {
    width: undefined,
    height: undefined
  };

  var sizesDiffer = function sizesDiffer(one, two) {
    one = one || dummySize;
    two = two || dummySize;
    return one !== two && (one.width !== two.width || one.height !== two.height);
  };

  module.exports = sizesDiffer;
},172,[],"node_modules\\react-native\\Libraries\\Utilities\\differ\\sizesDiffer.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var ImageStylePropTypes = _$$_REQUIRE(_dependencyMap[2], "ImageStylePropTypes");

  var TextStylePropTypes = _$$_REQUIRE(_dependencyMap[3], "TextStylePropTypes");

  var ViewStylePropTypes = _$$_REQUIRE(_dependencyMap[4], "ViewStylePropTypes");

  var invariant = _$$_REQUIRE(_dependencyMap[5], "fbjs/lib/invariant");

  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

  var StyleSheetValidation = function () {
    function StyleSheetValidation() {
      _classCallCheck(this, StyleSheetValidation);
    }

    _createClass(StyleSheetValidation, null, [{
      key: "validateStyleProp",
      value: function validateStyleProp(prop, style, caller) {
        if (!__DEV__) {
          return;
        }

        if (allStylePropTypes[prop] === undefined) {
          var message1 = '"' + prop + '" is not a valid style property.';
          var message2 = '\nValid style props: ' + JSON.stringify(Object.keys(allStylePropTypes).sort(), null, '  ');
          styleError(message1, style, caller, message2);
        }

        var error = allStylePropTypes[prop](style, prop, caller, 'prop', null, ReactPropTypesSecret);

        if (error) {
          styleError(error.message, style, caller);
        }
      }
    }, {
      key: "validateStyle",
      value: function validateStyle(name, styles) {
        if (!__DEV__) {
          return;
        }

        for (var prop in styles[name]) {
          StyleSheetValidation.validateStyleProp(prop, styles[name], 'StyleSheet ' + name);
        }
      }
    }, {
      key: "addValidStylePropTypes",
      value: function addValidStylePropTypes(stylePropTypes) {
        for (var key in stylePropTypes) {
          allStylePropTypes[key] = stylePropTypes[key];
        }
      }
    }]);

    return StyleSheetValidation;
  }();

  var styleError = function styleError(message1, style, caller, message2) {
    invariant(false, message1 + '\n' + (caller || '<<unknown>>') + ': ' + JSON.stringify(style, null, '  ') + (message2 || ''));
  };

  var allStylePropTypes = {};
  StyleSheetValidation.addValidStylePropTypes(ImageStylePropTypes);
  StyleSheetValidation.addValidStylePropTypes(TextStylePropTypes);
  StyleSheetValidation.addValidStylePropTypes(ViewStylePropTypes);
  module.exports = StyleSheetValidation;
},173,[24,25,155,167,168,117],"node_modules\\react-native\\Libraries\\StyleSheet\\StyleSheetValidation.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function flattenStyle(style) {
    if (style === null || typeof style !== 'object') {
      return undefined;
    }

    if (!Array.isArray(style)) {
      return style;
    }

    var result = {};

    for (var i = 0, styleLength = style.length; i < styleLength; ++i) {
      var computedStyle = flattenStyle(style[i]);

      if (computedStyle) {
        for (var key in computedStyle) {
          result[key] = computedStyle[key];
        }
      }
    }

    return result;
  }

  module.exports = flattenStyle;
},174,[],"node_modules\\react-native\\Libraries\\StyleSheet\\flattenStyle.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\View\\View.js";

  var React = _$$_REQUIRE(_dependencyMap[1], "React");

  var TextAncestor = _$$_REQUIRE(_dependencyMap[2], "TextAncestor");

  var ViewNativeComponent = _$$_REQUIRE(_dependencyMap[3], "ViewNativeComponent");

  var invariant = _$$_REQUIRE(_dependencyMap[4], "fbjs/lib/invariant");

  var ViewToExport = ViewNativeComponent;

  if (__DEV__) {
    if (!global.__RCTProfileIsProfiling) {
      var View = function View(props, forwardedRef) {
        return React.createElement(TextAncestor.Consumer, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 39
          }
        }, function (hasTextAncestor) {
          invariant(!hasTextAncestor, 'Nesting of <View> within <Text> is not currently supported.');
          return React.createElement(ViewNativeComponent, _extends({}, props, {
            ref: forwardedRef,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 45
            }
          }));
        });
      };

      ViewToExport = React.forwardRef(View);
      ViewToExport.displayName = 'View';
    }
  }

  module.exports = ViewToExport;
},175,[112,149,176,177,117],"node_modules\\react-native\\Libraries\\Components\\View\\View.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var React = _$$_REQUIRE(_dependencyMap[0], "React");

  module.exports = React.createContext(false);
},176,[149],"node_modules\\react-native\\Libraries\\Text\\TextAncestor.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var ReactNative = _$$_REQUIRE(_dependencyMap[0], "ReactNative");

  var requireNativeComponent = _$$_REQUIRE(_dependencyMap[1], "requireNativeComponent");

  var NativeViewComponent = requireNativeComponent('RCTView');
  module.exports = NativeViewComponent;
},177,[178,268],"node_modules\\react-native\\Libraries\\Components\\View\\ViewNativeComponent.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var ReactNative;

  if (__DEV__) {
    ReactNative = _$$_REQUIRE(_dependencyMap[0], "ReactNativeRenderer-dev");
  } else {
    ReactNative = _$$_REQUIRE(_dependencyMap[1], "ReactNativeRenderer-prod");
  }

  module.exports = ReactNative;
},178,[179,267],"node_modules\\react-native\\Libraries\\Renderer\\shims\\ReactNative.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  if (__DEV__) {
    (function () {
      "use strict";

      _$$_REQUIRE(_dependencyMap[1], "InitializeCore");

      var ReactNativeViewConfigRegistry = _$$_REQUIRE(_dependencyMap[2], "ReactNativeViewConfigRegistry");

      var UIManager = _$$_REQUIRE(_dependencyMap[3], "UIManager");

      var RCTEventEmitter = _$$_REQUIRE(_dependencyMap[4], "RCTEventEmitter");

      var React = _$$_REQUIRE(_dependencyMap[5], "react");

      var deepFreezeAndThrowOnMutationInDev = _$$_REQUIRE(_dependencyMap[6], "deepFreezeAndThrowOnMutationInDev");

      var deepDiffer = _$$_REQUIRE(_dependencyMap[7], "deepDiffer");

      var flattenStyle = _$$_REQUIRE(_dependencyMap[8], "flattenStyle");

      var TextInputState = _$$_REQUIRE(_dependencyMap[9], "TextInputState");

      var checkPropTypes = _$$_REQUIRE(_dependencyMap[10], "prop-types/checkPropTypes");

      var tracing = _$$_REQUIRE(_dependencyMap[11], "scheduler/tracing");

      var scheduler = _$$_REQUIRE(_dependencyMap[12], "scheduler");

      var ExceptionsManager = _$$_REQUIRE(_dependencyMap[13], "ExceptionsManager");

      var validateFormat = function validateFormat() {};

      {
        validateFormat = function validateFormat(format) {
          if (format === undefined) {
            throw new Error("invariant requires an error message argument");
          }
        };
      }

      function invariant(condition, format, a, b, c, d, e, f) {
        validateFormat(format);

        if (!condition) {
          var error = void 0;

          if (format === undefined) {
            error = new Error("Minified exception occurred; use the non-minified dev environment " + "for the full error message and additional helpful warnings.");
          } else {
            var args = [a, b, c, d, e, f];
            var argIndex = 0;
            error = new Error(format.replace(/%s/g, function () {
              return args[argIndex++];
            }));
            error.name = "Invariant Violation";
          }

          error.framesToPop = 1;
          throw error;
        }
      }

      var invokeGuardedCallbackImpl = function invokeGuardedCallbackImpl(name, func, context, a, b, c, d, e, f) {
        var funcArgs = Array.prototype.slice.call(arguments, 3);

        try {
          func.apply(context, funcArgs);
        } catch (error) {
          this.onError(error);
        }
      };

      {
        if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
          var fakeNode = document.createElement("react");

          var invokeGuardedCallbackDev = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
            invariant(typeof document !== "undefined", "The `document` global was defined when React was initialized, but is not " + "defined anymore. This can happen in a test environment if a component " + "schedules an update from an asynchronous callback, but the test has already " + "finished running. To solve this, you can either unmount the component at " + "the end of your test (and ensure that any asynchronous operations get " + "canceled in `componentWillUnmount`), or you can change the test itself " + "to be asynchronous.");
            var evt = document.createEvent("Event");
            var didError = true;
            var windowEvent = window.event;
            var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
            var funcArgs = Array.prototype.slice.call(arguments, 3);

            function callCallback() {
              fakeNode.removeEventListener(evtType, callCallback, false);

              if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                window.event = windowEvent;
              }

              func.apply(context, funcArgs);
              didError = false;
            }

            var error = void 0;
            var didSetError = false;
            var isCrossOriginError = false;

            function handleWindowError(event) {
              error = event.error;
              didSetError = true;

              if (error === null && event.colno === 0 && event.lineno === 0) {
                isCrossOriginError = true;
              }

              if (event.defaultPrevented) {
                if (error != null && typeof error === "object") {
                  try {
                    error._suppressLogging = true;
                  } catch (inner) {}
                }
              }
            }

            var evtType = "react-" + (name ? name : "invokeguardedcallback");
            window.addEventListener("error", handleWindowError);
            fakeNode.addEventListener(evtType, callCallback, false);
            evt.initEvent(evtType, false, false);
            fakeNode.dispatchEvent(evt);

            if (windowEventDescriptor) {
              Object.defineProperty(window, "event", windowEventDescriptor);
            }

            if (didError) {
              if (!didSetError) {
                error = new Error("An error was thrown inside one of your components, but React " + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + "your browser. Try triggering the error in production mode, " + "or switching to a modern browser. If you suspect that this is " + "actually an issue with React, please file an issue.");
              } else if (isCrossOriginError) {
                error = new Error("A cross-origin error was thrown. React doesn't have access to " + "the actual error object in development. " + "See https://fb.me/react-crossorigin-error for more information.");
              }

              this.onError(error);
            }

            window.removeEventListener("error", handleWindowError);
          };

          invokeGuardedCallbackImpl = invokeGuardedCallbackDev;
        }
      }
      var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
      var hasError = false;
      var caughtError = null;
      var hasRethrowError = false;
      var rethrowError = null;
      var reporter = {
        onError: function onError(error) {
          hasError = true;
          caughtError = error;
        }
      };

      function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
        hasError = false;
        caughtError = null;
        invokeGuardedCallbackImpl$1.apply(reporter, arguments);
      }

      function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
        invokeGuardedCallback.apply(this, arguments);

        if (hasError) {
          var error = clearCaughtError();

          if (!hasRethrowError) {
            hasRethrowError = true;
            rethrowError = error;
          }
        }
      }

      function rethrowCaughtError() {
        if (hasRethrowError) {
          var error = rethrowError;
          hasRethrowError = false;
          rethrowError = null;
          throw error;
        }
      }

      function hasCaughtError() {
        return hasError;
      }

      function clearCaughtError() {
        if (hasError) {
          var error = caughtError;
          hasError = false;
          caughtError = null;
          return error;
        } else {
          invariant(false, "clearCaughtError was called but no error was captured. This error " + "is likely caused by a bug in React. Please file an issue.");
        }
      }

      var eventPluginOrder = null;
      var namesToPlugins = {};

      function recomputePluginOrdering() {
        if (!eventPluginOrder) {
          return;
        }

        for (var pluginName in namesToPlugins) {
          var pluginModule = namesToPlugins[pluginName];
          var pluginIndex = eventPluginOrder.indexOf(pluginName);
          invariant(pluginIndex > -1, "EventPluginRegistry: Cannot inject event plugins that do not exist in " + "the plugin ordering, `%s`.", pluginName);

          if (plugins[pluginIndex]) {
            continue;
          }

          invariant(pluginModule.extractEvents, "EventPluginRegistry: Event plugins must implement an `extractEvents` " + "method, but `%s` does not.", pluginName);
          plugins[pluginIndex] = pluginModule;
          var publishedEvents = pluginModule.eventTypes;

          for (var eventName in publishedEvents) {
            invariant(publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName), "EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.", eventName, pluginName);
          }
        }
      }

      function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
        invariant(!eventNameDispatchConfigs.hasOwnProperty(eventName), "EventPluginHub: More than one plugin attempted to publish the same " + "event name, `%s`.", eventName);
        eventNameDispatchConfigs[eventName] = dispatchConfig;
        var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

        if (phasedRegistrationNames) {
          for (var phaseName in phasedRegistrationNames) {
            if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
              var phasedRegistrationName = phasedRegistrationNames[phaseName];
              publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
            }
          }

          return true;
        } else if (dispatchConfig.registrationName) {
          publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
          return true;
        }

        return false;
      }

      function publishRegistrationName(registrationName, pluginModule, eventName) {
        invariant(!registrationNameModules[registrationName], "EventPluginHub: More than one plugin attempted to publish the same " + "registration name, `%s`.", registrationName);
        registrationNameModules[registrationName] = pluginModule;
        registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;
        {
          var lowerCasedName = registrationName.toLowerCase();
        }
      }

      var plugins = [];
      var eventNameDispatchConfigs = {};
      var registrationNameModules = {};
      var registrationNameDependencies = {};

      function injectEventPluginOrder(injectedEventPluginOrder) {
        invariant(!eventPluginOrder, "EventPluginRegistry: Cannot inject event plugin ordering more than " + "once. You are likely trying to load more than one copy of React.");
        eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
        recomputePluginOrdering();
      }

      function injectEventPluginsByName(injectedNamesToPlugins) {
        var isOrderingDirty = false;

        for (var pluginName in injectedNamesToPlugins) {
          if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
            continue;
          }

          var pluginModule = injectedNamesToPlugins[pluginName];

          if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
            invariant(!namesToPlugins[pluginName], "EventPluginRegistry: Cannot inject two different event plugins " + "using the same name, `%s`.", pluginName);
            namesToPlugins[pluginName] = pluginModule;
            isOrderingDirty = true;
          }
        }

        if (isOrderingDirty) {
          recomputePluginOrdering();
        }
      }

      var warningWithoutStack = function warningWithoutStack() {};

      {
        warningWithoutStack = function warningWithoutStack(condition, format) {
          for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          if (format === undefined) {
            throw new Error("`warningWithoutStack(condition, format, ...args)` requires a warning " + "message argument");
          }

          if (args.length > 8) {
            throw new Error("warningWithoutStack() currently supports at most 8 arguments.");
          }

          if (condition) {
            return;
          }

          if (typeof console !== "undefined") {
            var argsWithFormat = args.map(function (item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console.error, console, argsWithFormat);
          }

          try {
            var argIndex = 0;
            var message = "Warning: " + format.replace(/%s/g, function () {
              return args[argIndex++];
            });
            throw new Error(message);
          } catch (x) {}
        };
      }
      var warningWithoutStack$1 = warningWithoutStack;
      var getFiberCurrentPropsFromNode = null;
      var getInstanceFromNode = null;
      var getNodeFromInstance = null;

      function setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {
        getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;
        getInstanceFromNode = getInstanceFromNodeImpl;
        getNodeFromInstance = getNodeFromInstanceImpl;
        {
          !(getNodeFromInstance && getInstanceFromNode) ? warningWithoutStack$1(false, "EventPluginUtils.setComponentTree(...): Injected " + "module is missing getNodeFromInstance or getInstanceFromNode.") : void 0;
        }
      }

      var validateEventDispatches = void 0;
      {
        validateEventDispatches = function validateEventDispatches(event) {
          var dispatchListeners = event._dispatchListeners;
          var dispatchInstances = event._dispatchInstances;
          var listenersIsArr = Array.isArray(dispatchListeners);
          var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
          var instancesIsArr = Array.isArray(dispatchInstances);
          var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
          !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warningWithoutStack$1(false, "EventPluginUtils: Invalid `event`.") : void 0;
        };
      }

      function executeDispatch(event, listener, inst) {
        var type = event.type || "unknown-event";
        event.currentTarget = getNodeFromInstance(inst);
        invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
        event.currentTarget = null;
      }

      function executeDispatchesInOrder(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchInstances = event._dispatchInstances;
        {
          validateEventDispatches(event);
        }

        if (Array.isArray(dispatchListeners)) {
          for (var i = 0; i < dispatchListeners.length; i++) {
            if (event.isPropagationStopped()) {
              break;
            }

            executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);
          }
        } else if (dispatchListeners) {
          executeDispatch(event, dispatchListeners, dispatchInstances);
        }

        event._dispatchListeners = null;
        event._dispatchInstances = null;
      }

      function executeDispatchesInOrderStopAtTrueImpl(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchInstances = event._dispatchInstances;
        {
          validateEventDispatches(event);
        }

        if (Array.isArray(dispatchListeners)) {
          for (var i = 0; i < dispatchListeners.length; i++) {
            if (event.isPropagationStopped()) {
              break;
            }

            if (dispatchListeners[i](event, dispatchInstances[i])) {
              return dispatchInstances[i];
            }
          }
        } else if (dispatchListeners) {
          if (dispatchListeners(event, dispatchInstances)) {
            return dispatchInstances;
          }
        }

        return null;
      }

      function executeDispatchesInOrderStopAtTrue(event) {
        var ret = executeDispatchesInOrderStopAtTrueImpl(event);
        event._dispatchInstances = null;
        event._dispatchListeners = null;
        return ret;
      }

      function executeDirectDispatch(event) {
        {
          validateEventDispatches(event);
        }
        var dispatchListener = event._dispatchListeners;
        var dispatchInstance = event._dispatchInstances;
        invariant(!Array.isArray(dispatchListener), "executeDirectDispatch(...): Invalid `event`.");
        event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;
        var res = dispatchListener ? dispatchListener(event) : null;
        event.currentTarget = null;
        event._dispatchListeners = null;
        event._dispatchInstances = null;
        return res;
      }

      function hasDispatches(event) {
        return !!event._dispatchListeners;
      }

      function accumulateInto(current, next) {
        invariant(next != null, "accumulateInto(...): Accumulated items must not be null or undefined.");

        if (current == null) {
          return next;
        }

        if (Array.isArray(current)) {
          if (Array.isArray(next)) {
            current.push.apply(current, next);
            return current;
          }

          current.push(next);
          return current;
        }

        if (Array.isArray(next)) {
          return [current].concat(next);
        }

        return [current, next];
      }

      function forEachAccumulated(arr, cb, scope) {
        if (Array.isArray(arr)) {
          arr.forEach(cb, scope);
        } else if (arr) {
          cb.call(scope, arr);
        }
      }

      var eventQueue = null;

      var executeDispatchesAndRelease = function executeDispatchesAndRelease(event) {
        if (event) {
          executeDispatchesInOrder(event);

          if (!event.isPersistent()) {
            event.constructor.release(event);
          }
        }
      };

      var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
        return executeDispatchesAndRelease(e);
      };

      function isInteractive(tag) {
        return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
      }

      function shouldPreventMouseEvent(name, type, props) {
        switch (name) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
            return !!(props.disabled && isInteractive(type));

          default:
            return false;
        }
      }

      var injection = {
        injectEventPluginOrder: injectEventPluginOrder,
        injectEventPluginsByName: injectEventPluginsByName
      };

      function getListener(inst, registrationName) {
        var listener = void 0;
        var stateNode = inst.stateNode;

        if (!stateNode) {
          return null;
        }

        var props = getFiberCurrentPropsFromNode(stateNode);

        if (!props) {
          return null;
        }

        listener = props[registrationName];

        if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
          return null;
        }

        invariant(!listener || typeof listener === "function", "Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
        return listener;
      }

      function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var events = null;

        for (var i = 0; i < plugins.length; i++) {
          var possiblePlugin = plugins[i];

          if (possiblePlugin) {
            var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);

            if (extractedEvents) {
              events = accumulateInto(events, extractedEvents);
            }
          }
        }

        return events;
      }

      function runEventsInBatch(events) {
        if (events !== null) {
          eventQueue = accumulateInto(eventQueue, events);
        }

        var processingEventQueue = eventQueue;
        eventQueue = null;

        if (!processingEventQueue) {
          return;
        }

        forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
        invariant(!eventQueue, "processEventQueue(): Additional events were enqueued while processing " + "an event queue. Support for this has not yet been implemented.");
        rethrowCaughtError();
      }

      function runExtractedEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        runEventsInBatch(events);
      }

      var FunctionComponent = 0;
      var ClassComponent = 1;
      var IndeterminateComponent = 2;
      var HostRoot = 3;
      var HostPortal = 4;
      var HostComponent = 5;
      var HostText = 6;
      var Fragment = 7;
      var Mode = 8;
      var ContextConsumer = 9;
      var ContextProvider = 10;
      var ForwardRef = 11;
      var Profiler = 12;
      var SuspenseComponent = 13;
      var MemoComponent = 14;
      var SimpleMemoComponent = 15;
      var LazyComponent = 16;
      var IncompleteClassComponent = 17;

      function getParent(inst) {
        do {
          inst = inst.return;
        } while (inst && inst.tag !== HostComponent);

        if (inst) {
          return inst;
        }

        return null;
      }

      function getLowestCommonAncestor(instA, instB) {
        var depthA = 0;

        for (var tempA = instA; tempA; tempA = getParent(tempA)) {
          depthA++;
        }

        var depthB = 0;

        for (var tempB = instB; tempB; tempB = getParent(tempB)) {
          depthB++;
        }

        while (depthA - depthB > 0) {
          instA = getParent(instA);
          depthA--;
        }

        while (depthB - depthA > 0) {
          instB = getParent(instB);
          depthB--;
        }

        var depth = depthA;

        while (depth--) {
          if (instA === instB || instA === instB.alternate) {
            return instA;
          }

          instA = getParent(instA);
          instB = getParent(instB);
        }

        return null;
      }

      function isAncestor(instA, instB) {
        while (instB) {
          if (instA === instB || instA === instB.alternate) {
            return true;
          }

          instB = getParent(instB);
        }

        return false;
      }

      function getParentInstance(inst) {
        return getParent(inst);
      }

      function traverseTwoPhase(inst, fn, arg) {
        var path = [];

        while (inst) {
          path.push(inst);
          inst = getParent(inst);
        }

        var i = void 0;

        for (i = path.length; i-- > 0;) {
          fn(path[i], "captured", arg);
        }

        for (i = 0; i < path.length; i++) {
          fn(path[i], "bubbled", arg);
        }
      }

      function listenerAtPhase(inst, event, propagationPhase) {
        var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
        return getListener(inst, registrationName);
      }

      function accumulateDirectionalDispatches(inst, phase, event) {
        {
          !inst ? warningWithoutStack$1(false, "Dispatching inst must not be null") : void 0;
        }
        var listener = listenerAtPhase(inst, event, phase);

        if (listener) {
          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
          event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
        }
      }

      function accumulateTwoPhaseDispatchesSingle(event) {
        if (event && event.dispatchConfig.phasedRegistrationNames) {
          traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
        }
      }

      function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
        if (event && event.dispatchConfig.phasedRegistrationNames) {
          var targetInst = event._targetInst;
          var parentInst = targetInst ? getParentInstance(targetInst) : null;
          traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
        }
      }

      function accumulateDispatches(inst, ignoredDirection, event) {
        if (inst && event && event.dispatchConfig.registrationName) {
          var registrationName = event.dispatchConfig.registrationName;
          var listener = getListener(inst, registrationName);

          if (listener) {
            event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
            event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
          }
        }
      }

      function accumulateDirectDispatchesSingle(event) {
        if (event && event.dispatchConfig.registrationName) {
          accumulateDispatches(event._targetInst, null, event);
        }
      }

      function accumulateTwoPhaseDispatches(events) {
        forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
      }

      function accumulateTwoPhaseDispatchesSkipTarget(events) {
        forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
      }

      function accumulateDirectDispatches(events) {
        forEachAccumulated(events, accumulateDirectDispatchesSingle);
      }

      var EVENT_POOL_SIZE = 10;
      var EventInterface = {
        type: null,
        target: null,
        currentTarget: function currentTarget() {
          return null;
        },
        eventPhase: null,
        bubbles: null,
        cancelable: null,
        timeStamp: function timeStamp(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: null,
        isTrusted: null
      };

      function functionThatReturnsTrue() {
        return true;
      }

      function functionThatReturnsFalse() {
        return false;
      }

      function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
        {
          delete this.nativeEvent;
          delete this.preventDefault;
          delete this.stopPropagation;
          delete this.isDefaultPrevented;
          delete this.isPropagationStopped;
        }
        this.dispatchConfig = dispatchConfig;
        this._targetInst = targetInst;
        this.nativeEvent = nativeEvent;
        var Interface = this.constructor.Interface;

        for (var propName in Interface) {
          if (!Interface.hasOwnProperty(propName)) {
            continue;
          }

          {
            delete this[propName];
          }
          var normalize = Interface[propName];

          if (normalize) {
            this[propName] = normalize(nativeEvent);
          } else {
            if (propName === "target") {
              this.target = nativeEventTarget;
            } else {
              this[propName] = nativeEvent[propName];
            }
          }
        }

        var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;

        if (defaultPrevented) {
          this.isDefaultPrevented = functionThatReturnsTrue;
        } else {
          this.isDefaultPrevented = functionThatReturnsFalse;
        }

        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }

      _extends(SyntheticEvent.prototype, {
        preventDefault: function preventDefault() {
          this.defaultPrevented = true;
          var event = this.nativeEvent;

          if (!event) {
            return;
          }

          if (event.preventDefault) {
            event.preventDefault();
          } else if (typeof event.returnValue !== "unknown") {
            event.returnValue = false;
          }

          this.isDefaultPrevented = functionThatReturnsTrue;
        },
        stopPropagation: function stopPropagation() {
          var event = this.nativeEvent;

          if (!event) {
            return;
          }

          if (event.stopPropagation) {
            event.stopPropagation();
          } else if (typeof event.cancelBubble !== "unknown") {
            event.cancelBubble = true;
          }

          this.isPropagationStopped = functionThatReturnsTrue;
        },
        persist: function persist() {
          this.isPersistent = functionThatReturnsTrue;
        },
        isPersistent: functionThatReturnsFalse,
        destructor: function destructor() {
          var Interface = this.constructor.Interface;

          for (var propName in Interface) {
            {
              Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
            }
          }

          this.dispatchConfig = null;
          this._targetInst = null;
          this.nativeEvent = null;
          this.isDefaultPrevented = functionThatReturnsFalse;
          this.isPropagationStopped = functionThatReturnsFalse;
          this._dispatchListeners = null;
          this._dispatchInstances = null;
          {
            Object.defineProperty(this, "nativeEvent", getPooledWarningPropertyDefinition("nativeEvent", null));
            Object.defineProperty(this, "isDefaultPrevented", getPooledWarningPropertyDefinition("isDefaultPrevented", functionThatReturnsFalse));
            Object.defineProperty(this, "isPropagationStopped", getPooledWarningPropertyDefinition("isPropagationStopped", functionThatReturnsFalse));
            Object.defineProperty(this, "preventDefault", getPooledWarningPropertyDefinition("preventDefault", function () {}));
            Object.defineProperty(this, "stopPropagation", getPooledWarningPropertyDefinition("stopPropagation", function () {}));
          }
        }
      });

      SyntheticEvent.Interface = EventInterface;

      SyntheticEvent.extend = function (Interface) {
        var Super = this;

        var E = function E() {};

        E.prototype = Super.prototype;
        var prototype = new E();

        function Class() {
          return Super.apply(this, arguments);
        }

        _extends(prototype, Class.prototype);

        Class.prototype = prototype;
        Class.prototype.constructor = Class;
        Class.Interface = _extends({}, Super.Interface, Interface);
        Class.extend = Super.extend;
        addEventPoolingTo(Class);
        return Class;
      };

      addEventPoolingTo(SyntheticEvent);

      function getPooledWarningPropertyDefinition(propName, getVal) {
        var isFunction = typeof getVal === "function";
        return {
          configurable: true,
          set: set,
          get: get$$1
        };

        function set(val) {
          var action = isFunction ? "setting the method" : "setting the property";
          warn(action, "This is effectively a no-op");
          return val;
        }

        function get$$1() {
          var action = isFunction ? "accessing the method" : "accessing the property";
          var result = isFunction ? "This is a no-op function" : "This is set to null";
          warn(action, result);
          return getVal;
        }

        function warn(action, result) {
          var warningCondition = false;
          !warningCondition ? warningWithoutStack$1(false, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + "If you must keep the original synthetic event around, use event.persist(). " + "See https://fb.me/react-event-pooling for more information.", action, propName, result) : void 0;
        }
      }

      function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
        var EventConstructor = this;

        if (EventConstructor.eventPool.length) {
          var instance = EventConstructor.eventPool.pop();
          EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
          return instance;
        }

        return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
      }

      function releasePooledEvent(event) {
        var EventConstructor = this;
        invariant(event instanceof EventConstructor, "Trying to release an event instance into a pool of a different type.");
        event.destructor();

        if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
          EventConstructor.eventPool.push(event);
        }
      }

      function addEventPoolingTo(EventConstructor) {
        EventConstructor.eventPool = [];
        EventConstructor.getPooled = getPooledEvent;
        EventConstructor.release = releasePooledEvent;
      }

      var ResponderSyntheticEvent = SyntheticEvent.extend({
        touchHistory: function touchHistory(nativeEvent) {
          return null;
        }
      });
      var TOP_TOUCH_START = "topTouchStart";
      var TOP_TOUCH_MOVE = "topTouchMove";
      var TOP_TOUCH_END = "topTouchEnd";
      var TOP_TOUCH_CANCEL = "topTouchCancel";
      var TOP_SCROLL = "topScroll";
      var TOP_SELECTION_CHANGE = "topSelectionChange";

      function isStartish(topLevelType) {
        return topLevelType === TOP_TOUCH_START;
      }

      function isMoveish(topLevelType) {
        return topLevelType === TOP_TOUCH_MOVE;
      }

      function isEndish(topLevelType) {
        return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL;
      }

      var startDependencies = [TOP_TOUCH_START];
      var moveDependencies = [TOP_TOUCH_MOVE];
      var endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END];
      var MAX_TOUCH_BANK = 20;
      var touchBank = [];
      var touchHistory = {
        touchBank: touchBank,
        numberActiveTouches: 0,
        indexOfSingleActiveTouch: -1,
        mostRecentTimeStamp: 0
      };

      function timestampForTouch(touch) {
        return touch.timeStamp || touch.timestamp;
      }

      function createTouchRecord(touch) {
        return {
          touchActive: true,
          startPageX: touch.pageX,
          startPageY: touch.pageY,
          startTimeStamp: timestampForTouch(touch),
          currentPageX: touch.pageX,
          currentPageY: touch.pageY,
          currentTimeStamp: timestampForTouch(touch),
          previousPageX: touch.pageX,
          previousPageY: touch.pageY,
          previousTimeStamp: timestampForTouch(touch)
        };
      }

      function resetTouchRecord(touchRecord, touch) {
        touchRecord.touchActive = true;
        touchRecord.startPageX = touch.pageX;
        touchRecord.startPageY = touch.pageY;
        touchRecord.startTimeStamp = timestampForTouch(touch);
        touchRecord.currentPageX = touch.pageX;
        touchRecord.currentPageY = touch.pageY;
        touchRecord.currentTimeStamp = timestampForTouch(touch);
        touchRecord.previousPageX = touch.pageX;
        touchRecord.previousPageY = touch.pageY;
        touchRecord.previousTimeStamp = timestampForTouch(touch);
      }

      function getTouchIdentifier(_ref) {
        var identifier = _ref.identifier;
        invariant(identifier != null, "Touch object is missing identifier.");
        {
          !(identifier <= MAX_TOUCH_BANK) ? warningWithoutStack$1(false, "Touch identifier %s is greater than maximum supported %s which causes " + "performance issues backfilling array locations for all of the indices.", identifier, MAX_TOUCH_BANK) : void 0;
        }
        return identifier;
      }

      function recordTouchStart(touch) {
        var identifier = getTouchIdentifier(touch);
        var touchRecord = touchBank[identifier];

        if (touchRecord) {
          resetTouchRecord(touchRecord, touch);
        } else {
          touchBank[identifier] = createTouchRecord(touch);
        }

        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
      }

      function recordTouchMove(touch) {
        var touchRecord = touchBank[getTouchIdentifier(touch)];

        if (touchRecord) {
          touchRecord.touchActive = true;
          touchRecord.previousPageX = touchRecord.currentPageX;
          touchRecord.previousPageY = touchRecord.currentPageY;
          touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
          touchRecord.currentPageX = touch.pageX;
          touchRecord.currentPageY = touch.pageY;
          touchRecord.currentTimeStamp = timestampForTouch(touch);
          touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
        } else {
          console.error("Cannot record touch move without a touch start.\n" + "Touch Move: %s\n", "Touch Bank: %s", printTouch(touch), printTouchBank());
        }
      }

      function recordTouchEnd(touch) {
        var touchRecord = touchBank[getTouchIdentifier(touch)];

        if (touchRecord) {
          touchRecord.touchActive = false;
          touchRecord.previousPageX = touchRecord.currentPageX;
          touchRecord.previousPageY = touchRecord.currentPageY;
          touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
          touchRecord.currentPageX = touch.pageX;
          touchRecord.currentPageY = touch.pageY;
          touchRecord.currentTimeStamp = timestampForTouch(touch);
          touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
        } else {
          console.error("Cannot record touch end without a touch start.\n" + "Touch End: %s\n", "Touch Bank: %s", printTouch(touch), printTouchBank());
        }
      }

      function printTouch(touch) {
        return JSON.stringify({
          identifier: touch.identifier,
          pageX: touch.pageX,
          pageY: touch.pageY,
          timestamp: timestampForTouch(touch)
        });
      }

      function printTouchBank() {
        var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));

        if (touchBank.length > MAX_TOUCH_BANK) {
          printed += " (original size: " + touchBank.length + ")";
        }

        return printed;
      }

      var ResponderTouchHistoryStore = {
        recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {
          if (isMoveish(topLevelType)) {
            nativeEvent.changedTouches.forEach(recordTouchMove);
          } else if (isStartish(topLevelType)) {
            nativeEvent.changedTouches.forEach(recordTouchStart);
            touchHistory.numberActiveTouches = nativeEvent.touches.length;

            if (touchHistory.numberActiveTouches === 1) {
              touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;
            }
          } else if (isEndish(topLevelType)) {
            nativeEvent.changedTouches.forEach(recordTouchEnd);
            touchHistory.numberActiveTouches = nativeEvent.touches.length;

            if (touchHistory.numberActiveTouches === 1) {
              for (var i = 0; i < touchBank.length; i++) {
                var touchTrackToCheck = touchBank[i];

                if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {
                  touchHistory.indexOfSingleActiveTouch = i;
                  break;
                }
              }

              {
                var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];
                !(activeRecord != null && activeRecord.touchActive) ? warningWithoutStack$1(false, "Cannot find single active touch.") : void 0;
              }
            }
          }
        },
        touchHistory: touchHistory
      };

      function accumulate(current, next) {
        invariant(next != null, "accumulate(...): Accumulated items must be not be null or undefined.");

        if (current == null) {
          return next;
        }

        if (Array.isArray(current)) {
          return current.concat(next);
        }

        if (Array.isArray(next)) {
          return [current].concat(next);
        }

        return [current, next];
      }

      var responderInst = null;
      var trackedTouchCount = 0;

      var changeResponder = function changeResponder(nextResponderInst, blockHostResponder) {
        var oldResponderInst = responderInst;
        responderInst = nextResponderInst;

        if (ResponderEventPlugin.GlobalResponderHandler !== null) {
          ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);
        }
      };

      var eventTypes$1 = {
        startShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onStartShouldSetResponder",
            captured: "onStartShouldSetResponderCapture"
          },
          dependencies: startDependencies
        },
        scrollShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onScrollShouldSetResponder",
            captured: "onScrollShouldSetResponderCapture"
          },
          dependencies: [TOP_SCROLL]
        },
        selectionChangeShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onSelectionChangeShouldSetResponder",
            captured: "onSelectionChangeShouldSetResponderCapture"
          },
          dependencies: [TOP_SELECTION_CHANGE]
        },
        moveShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onMoveShouldSetResponder",
            captured: "onMoveShouldSetResponderCapture"
          },
          dependencies: moveDependencies
        },
        responderStart: {
          registrationName: "onResponderStart",
          dependencies: startDependencies
        },
        responderMove: {
          registrationName: "onResponderMove",
          dependencies: moveDependencies
        },
        responderEnd: {
          registrationName: "onResponderEnd",
          dependencies: endDependencies
        },
        responderRelease: {
          registrationName: "onResponderRelease",
          dependencies: endDependencies
        },
        responderTerminationRequest: {
          registrationName: "onResponderTerminationRequest",
          dependencies: []
        },
        responderGrant: {
          registrationName: "onResponderGrant",
          dependencies: []
        },
        responderReject: {
          registrationName: "onResponderReject",
          dependencies: []
        },
        responderTerminate: {
          registrationName: "onResponderTerminate",
          dependencies: []
        }
      };

      function setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var shouldSetEventType = isStartish(topLevelType) ? eventTypes$1.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes$1.moveShouldSetResponder : topLevelType === TOP_SELECTION_CHANGE ? eventTypes$1.selectionChangeShouldSetResponder : eventTypes$1.scrollShouldSetResponder;
        var bubbleShouldSetFrom = !responderInst ? targetInst : getLowestCommonAncestor(responderInst, targetInst);
        var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;
        var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);
        shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;

        if (skipOverBubbleShouldSetFrom) {
          accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);
        } else {
          accumulateTwoPhaseDispatches(shouldSetEvent);
        }

        var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);

        if (!shouldSetEvent.isPersistent()) {
          shouldSetEvent.constructor.release(shouldSetEvent);
        }

        if (!wantsResponderInst || wantsResponderInst === responderInst) {
          return null;
        }

        var extracted = void 0;
        var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget);
        grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
        accumulateDirectDispatches(grantEvent);
        var blockHostResponder = executeDirectDispatch(grantEvent) === true;

        if (responderInst) {
          var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget);
          terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
          accumulateDirectDispatches(terminationRequestEvent);
          var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);

          if (!terminationRequestEvent.isPersistent()) {
            terminationRequestEvent.constructor.release(terminationRequestEvent);
          }

          if (shouldSwitch) {
            var terminateEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderTerminate, responderInst, nativeEvent, nativeEventTarget);
            terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(terminateEvent);
            extracted = accumulate(extracted, [grantEvent, terminateEvent]);
            changeResponder(wantsResponderInst, blockHostResponder);
          } else {
            var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderReject, wantsResponderInst, nativeEvent, nativeEventTarget);
            rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(rejectEvent);
            extracted = accumulate(extracted, rejectEvent);
          }
        } else {
          extracted = accumulate(extracted, grantEvent);
          changeResponder(wantsResponderInst, blockHostResponder);
        }

        return extracted;
      }

      function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {
        return topLevelInst && (topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE || isStartish(topLevelType) || isMoveish(topLevelType));
      }

      function noResponderTouches(nativeEvent) {
        var touches = nativeEvent.touches;

        if (!touches || touches.length === 0) {
          return true;
        }

        for (var i = 0; i < touches.length; i++) {
          var activeTouch = touches[i];
          var target = activeTouch.target;

          if (target !== null && target !== undefined && target !== 0) {
            var targetInst = getInstanceFromNode(target);

            if (isAncestor(responderInst, targetInst)) {
              return false;
            }
          }
        }

        return true;
      }

      var ResponderEventPlugin = {
        _getResponder: function _getResponder() {
          return responderInst;
        },
        eventTypes: eventTypes$1,
        extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
          if (isStartish(topLevelType)) {
            trackedTouchCount += 1;
          } else if (isEndish(topLevelType)) {
            if (trackedTouchCount >= 0) {
              trackedTouchCount -= 1;
            } else {
              console.error("Ended a touch event which was not counted in `trackedTouchCount`.");
              return null;
            }
          }

          ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);
          var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) : null;
          var isResponderTouchStart = responderInst && isStartish(topLevelType);
          var isResponderTouchMove = responderInst && isMoveish(topLevelType);
          var isResponderTouchEnd = responderInst && isEndish(topLevelType);
          var incrementalTouch = isResponderTouchStart ? eventTypes$1.responderStart : isResponderTouchMove ? eventTypes$1.responderMove : isResponderTouchEnd ? eventTypes$1.responderEnd : null;

          if (incrementalTouch) {
            var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);
            gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(gesture);
            extracted = accumulate(extracted, gesture);
          }

          var isResponderTerminate = responderInst && topLevelType === TOP_TOUCH_CANCEL;
          var isResponderRelease = responderInst && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);
          var finalTouch = isResponderTerminate ? eventTypes$1.responderTerminate : isResponderRelease ? eventTypes$1.responderRelease : null;

          if (finalTouch) {
            var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);
            finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(finalEvent);
            extracted = accumulate(extracted, finalEvent);
            changeResponder(null);
          }

          return extracted;
        },
        GlobalResponderHandler: null,
        injection: {
          injectGlobalResponderHandler: function injectGlobalResponderHandler(GlobalResponderHandler) {
            ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;
          }
        }
      };
      var customBubblingEventTypes$1 = ReactNativeViewConfigRegistry.customBubblingEventTypes;
      var customDirectEventTypes$1 = ReactNativeViewConfigRegistry.customDirectEventTypes;
      var eventTypes$2 = ReactNativeViewConfigRegistry.eventTypes;
      var ReactNativeBridgeEventPlugin = {
        eventTypes: eventTypes$2,
        extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
          if (targetInst == null) {
            return null;
          }

          var bubbleDispatchConfig = customBubblingEventTypes$1[topLevelType];
          var directDispatchConfig = customDirectEventTypes$1[topLevelType];
          invariant(bubbleDispatchConfig || directDispatchConfig, 'Unsupported top level event type "%s" dispatched', topLevelType);
          var event = SyntheticEvent.getPooled(bubbleDispatchConfig || directDispatchConfig, targetInst, nativeEvent, nativeEventTarget);

          if (bubbleDispatchConfig) {
            accumulateTwoPhaseDispatches(event);
          } else if (directDispatchConfig) {
            accumulateDirectDispatches(event);
          } else {
            return null;
          }

          return event;
        }
      };
      var ReactNativeEventPluginOrder = ["ResponderEventPlugin", "ReactNativeBridgeEventPlugin"];
      injection.injectEventPluginOrder(ReactNativeEventPluginOrder);
      injection.injectEventPluginsByName({
        ResponderEventPlugin: ResponderEventPlugin,
        ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin
      });
      var instanceCache = {};
      var instanceProps = {};

      function precacheFiberNode(hostInst, tag) {
        instanceCache[tag] = hostInst;
      }

      function uncacheFiberNode(tag) {
        delete instanceCache[tag];
        delete instanceProps[tag];
      }

      function getInstanceFromTag(tag) {
        return instanceCache[tag] || null;
      }

      function getTagFromInstance(inst) {
        var tag = inst.stateNode._nativeTag;

        if (tag === undefined) {
          tag = inst.stateNode.canonical._nativeTag;
        }

        invariant(tag, "All native instances should have a tag.");
        return tag;
      }

      function getFiberCurrentPropsFromNode$1(stateNode) {
        return instanceProps[stateNode._nativeTag] || null;
      }

      function updateFiberProps(tag, props) {
        instanceProps[tag] = props;
      }

      var restoreImpl = null;
      var restoreTarget = null;
      var restoreQueue = null;

      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);

        if (!internalInstance) {
          return;
        }

        invariant(typeof restoreImpl === "function", "setRestoreImplementation() needs to be called to handle a target for controlled " + "events. This error is likely caused by a bug in React. Please file an issue.");
        var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
        restoreImpl(internalInstance.stateNode, internalInstance.type, props);
      }

      function needsStateRestore() {
        return restoreTarget !== null || restoreQueue !== null;
      }

      function restoreStateIfNeeded() {
        if (!restoreTarget) {
          return;
        }

        var target = restoreTarget;
        var queuedTargets = restoreQueue;
        restoreTarget = null;
        restoreQueue = null;
        restoreStateOfTarget(target);

        if (queuedTargets) {
          for (var i = 0; i < queuedTargets.length; i++) {
            restoreStateOfTarget(queuedTargets[i]);
          }
        }
      }

      var _batchedUpdatesImpl = function _batchedUpdatesImpl(fn, bookkeeping) {
        return fn(bookkeeping);
      };

      var _flushInteractiveUpdatesImpl = function _flushInteractiveUpdatesImpl() {};

      var isBatching = false;

      function batchedUpdates(fn, bookkeeping) {
        if (isBatching) {
          return fn(bookkeeping);
        }

        isBatching = true;

        try {
          return _batchedUpdatesImpl(fn, bookkeeping);
        } finally {
          isBatching = false;
          var controlledComponentsHavePendingUpdates = needsStateRestore();

          if (controlledComponentsHavePendingUpdates) {
            _flushInteractiveUpdatesImpl();

            restoreStateIfNeeded();
          }
        }
      }

      function setBatchingImplementation(batchedUpdatesImpl, interactiveUpdatesImpl, flushInteractiveUpdatesImpl) {
        _batchedUpdatesImpl = batchedUpdatesImpl;
        _flushInteractiveUpdatesImpl = flushInteractiveUpdatesImpl;
      }

      var EMPTY_NATIVE_EVENT = {};

      var touchSubsequence = function touchSubsequence(touches, indices) {
        var ret = [];

        for (var i = 0; i < indices.length; i++) {
          ret.push(touches[indices[i]]);
        }

        return ret;
      };

      var removeTouchesAtIndices = function removeTouchesAtIndices(touches, indices) {
        var rippedOut = [];
        var temp = touches;

        for (var i = 0; i < indices.length; i++) {
          var index = indices[i];
          rippedOut.push(touches[index]);
          temp[index] = null;
        }

        var fillAt = 0;

        for (var j = 0; j < temp.length; j++) {
          var cur = temp[j];

          if (cur !== null) {
            temp[fillAt++] = cur;
          }
        }

        temp.length = fillAt;
        return rippedOut;
      };

      function _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {
        var nativeEvent = nativeEventParam || EMPTY_NATIVE_EVENT;
        var inst = getInstanceFromTag(rootNodeID);
        batchedUpdates(function () {
          runExtractedEventsInBatch(topLevelType, inst, nativeEvent, nativeEvent.target);
        });
      }

      function receiveEvent(rootNodeID, topLevelType, nativeEventParam) {
        _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam);
      }

      function receiveTouches(eventTopLevelType, touches, changedIndices) {
        var changedTouches = eventTopLevelType === "topTouchEnd" || eventTopLevelType === "topTouchCancel" ? removeTouchesAtIndices(touches, changedIndices) : touchSubsequence(touches, changedIndices);

        for (var jj = 0; jj < changedTouches.length; jj++) {
          var touch = changedTouches[jj];
          touch.changedTouches = changedTouches;
          touch.touches = touches;
          var nativeEvent = touch;
          var rootNodeID = null;
          var target = nativeEvent.target;

          if (target !== null && target !== undefined) {
            if (target < 1) {
              {
                warningWithoutStack$1(false, "A view is reporting that a touch occurred on tag zero.");
              }
            } else {
              rootNodeID = target;
            }
          }

          _receiveRootNodeIDEvent(rootNodeID, eventTopLevelType, nativeEvent);
        }
      }

      var ReactNativeEventEmitter = Object.freeze({
        getListener: getListener,
        registrationNames: registrationNameModules,
        _receiveRootNodeIDEvent: _receiveRootNodeIDEvent,
        receiveEvent: receiveEvent,
        receiveTouches: receiveTouches
      });
      var ReactNativeGlobalResponderHandler = {
        onChange: function onChange(from, to, blockNativeResponder) {
          if (to !== null) {
            var tag = to.stateNode._nativeTag;
            UIManager.setJSResponder(tag, blockNativeResponder);
          } else {
            UIManager.clearJSResponder();
          }
        }
      };
      RCTEventEmitter.register(ReactNativeEventEmitter);
      setComponentTree(getFiberCurrentPropsFromNode$1, getInstanceFromTag, getTagFromInstance);
      ResponderEventPlugin.injection.injectGlobalResponderHandler(ReactNativeGlobalResponderHandler);

      function get$1(key) {
        return key._reactInternalFiber;
      }

      function set(key, value) {
        key._reactInternalFiber = value;
      }

      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      var hasSymbol = typeof Symbol === "function" && (typeof Symbol === "function" ? Symbol.for : "@@for");
      var REACT_ELEMENT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.element") : 0xeac7;
      var REACT_PORTAL_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.portal") : 0xeaca;
      var REACT_FRAGMENT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.fragment") : 0xeacb;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.strict_mode") : 0xeacc;
      var REACT_PROFILER_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.profiler") : 0xead2;
      var REACT_PROVIDER_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.provider") : 0xeacd;
      var REACT_CONTEXT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.context") : 0xeace;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.concurrent_mode") : 0xeacf;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.forward_ref") : 0xead0;
      var REACT_SUSPENSE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.suspense") : 0xead1;
      var REACT_MEMO_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.memo") : 0xead3;
      var REACT_LAZY_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.lazy") : 0xead4;
      var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && (typeof Symbol === "function" ? Symbol.iterator : "@@iterator");
      var FAUX_ITERATOR_SYMBOL = "@@iterator";

      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }

        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }

        return null;
      }

      var Pending = 0;
      var Resolved = 1;
      var Rejected = 2;

      function refineResolvedLazyComponent(lazyComponent) {
        return lazyComponent._status === Resolved ? lazyComponent._result : null;
      }

      function getWrappedName(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || "";
        return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
      }

      function getComponentName(type) {
        if (type == null) {
          return null;
        }

        {
          if (typeof type.tag === "number") {
            warningWithoutStack$1(false, "Received an unexpected object in getComponentName(). " + "This is likely a bug in React. Please file an issue.");
          }
        }

        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }

        if (typeof type === "string") {
          return type;
        }

        switch (type) {
          case REACT_CONCURRENT_MODE_TYPE:
            return "ConcurrentMode";

          case REACT_FRAGMENT_TYPE:
            return "Fragment";

          case REACT_PORTAL_TYPE:
            return "Portal";

          case REACT_PROFILER_TYPE:
            return "Profiler";

          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";

          case REACT_SUSPENSE_TYPE:
            return "Suspense";
        }

        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              return "Context.Consumer";

            case REACT_PROVIDER_TYPE:
              return "Context.Provider";

            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");

            case REACT_MEMO_TYPE:
              return getComponentName(type.type);

            case REACT_LAZY_TYPE:
              {
                var thenable = type;
                var resolvedThenable = refineResolvedLazyComponent(thenable);

                if (resolvedThenable) {
                  return getComponentName(resolvedThenable);
                }
              }
          }
        }

        return null;
      }

      var NoEffect = 0;
      var PerformedWork = 1;
      var Placement = 2;
      var Update = 4;
      var PlacementAndUpdate = 6;
      var Deletion = 8;
      var ContentReset = 16;
      var Callback = 32;
      var DidCapture = 64;
      var Ref = 128;
      var Snapshot = 256;
      var Passive = 512;
      var LifecycleEffectMask = 932;
      var HostEffectMask = 1023;
      var Incomplete = 1024;
      var ShouldCapture = 2048;
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var MOUNTING = 1;
      var MOUNTED = 2;
      var UNMOUNTED = 3;

      function isFiberMountedImpl(fiber) {
        var node = fiber;

        if (!fiber.alternate) {
          if ((node.effectTag & Placement) !== NoEffect) {
            return MOUNTING;
          }

          while (node.return) {
            node = node.return;

            if ((node.effectTag & Placement) !== NoEffect) {
              return MOUNTING;
            }
          }
        } else {
          while (node.return) {
            node = node.return;
          }
        }

        if (node.tag === HostRoot) {
          return MOUNTED;
        }

        return UNMOUNTED;
      }

      function isFiberMounted(fiber) {
        return isFiberMountedImpl(fiber) === MOUNTED;
      }

      function isMounted(component) {
        {
          var owner = ReactCurrentOwner$1.current;

          if (owner !== null && owner.tag === ClassComponent) {
            var ownerFiber = owner;
            var instance = ownerFiber.stateNode;
            !instance._warnedAboutRefsInRender ? warningWithoutStack$1(false, "%s is accessing isMounted inside its render() function. " + "render() should be a pure function of props and state. It should " + "never access something that requires stale data from the previous " + "render, such as refs. Move this logic to componentDidMount and " + "componentDidUpdate instead.", getComponentName(ownerFiber.type) || "A component") : void 0;
            instance._warnedAboutRefsInRender = true;
          }
        }
        var fiber = get$1(component);

        if (!fiber) {
          return false;
        }

        return isFiberMountedImpl(fiber) === MOUNTED;
      }

      function assertIsMounted(fiber) {
        invariant(isFiberMountedImpl(fiber) === MOUNTED, "Unable to find node on an unmounted component.");
      }

      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;

        if (!alternate) {
          var state = isFiberMountedImpl(fiber);
          invariant(state !== UNMOUNTED, "Unable to find node on an unmounted component.");

          if (state === MOUNTING) {
            return null;
          }

          return fiber;
        }

        var a = fiber;
        var b = alternate;

        while (true) {
          var parentA = a.return;
          var parentB = parentA ? parentA.alternate : null;

          if (!parentA || !parentB) {
            break;
          }

          if (parentA.child === parentB.child) {
            var child = parentA.child;

            while (child) {
              if (child === a) {
                assertIsMounted(parentA);
                return fiber;
              }

              if (child === b) {
                assertIsMounted(parentA);
                return alternate;
              }

              child = child.sibling;
            }

            invariant(false, "Unable to find node on an unmounted component.");
          }

          if (a.return !== b.return) {
            a = parentA;
            b = parentB;
          } else {
            var didFindChild = false;
            var _child = parentA.child;

            while (_child) {
              if (_child === a) {
                didFindChild = true;
                a = parentA;
                b = parentB;
                break;
              }

              if (_child === b) {
                didFindChild = true;
                b = parentA;
                a = parentB;
                break;
              }

              _child = _child.sibling;
            }

            if (!didFindChild) {
              _child = parentB.child;

              while (_child) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentB;
                  b = parentA;
                  break;
                }

                if (_child === b) {
                  didFindChild = true;
                  b = parentB;
                  a = parentA;
                  break;
                }

                _child = _child.sibling;
              }

              invariant(didFindChild, "Child was not found in either parent set. This indicates a bug " + "in React related to the return pointer. Please file an issue.");
            }
          }

          invariant(a.alternate === b, "Return fibers should always be each others' alternates. " + "This error is likely caused by a bug in React. Please file an issue.");
        }

        invariant(a.tag === HostRoot, "Unable to find node on an unmounted component.");

        if (a.stateNode.current === a) {
          return fiber;
        }

        return alternate;
      }

      function findCurrentHostFiber(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);

        if (!currentParent) {
          return null;
        }

        var node = currentParent;

        while (true) {
          if (node.tag === HostComponent || node.tag === HostText) {
            return node;
          } else if (node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }

          if (node === currentParent) {
            return null;
          }

          while (!node.sibling) {
            if (!node.return || node.return === currentParent) {
              return null;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }

        return null;
      }

      var emptyObject = {};
      var removedKeys = null;
      var removedKeyCount = 0;

      function defaultDiffer(prevProp, nextProp) {
        if (typeof nextProp !== "object" || nextProp === null) {
          return true;
        } else {
          return deepDiffer(prevProp, nextProp);
        }
      }

      function restoreDeletedValuesInNestedArray(updatePayload, node, validAttributes) {
        if (Array.isArray(node)) {
          var i = node.length;

          while (i-- && removedKeyCount > 0) {
            restoreDeletedValuesInNestedArray(updatePayload, node[i], validAttributes);
          }
        } else if (node && removedKeyCount > 0) {
          var obj = node;

          for (var propKey in removedKeys) {
            if (!removedKeys[propKey]) {
              continue;
            }

            var nextProp = obj[propKey];

            if (nextProp === undefined) {
              continue;
            }

            var attributeConfig = validAttributes[propKey];

            if (!attributeConfig) {
              continue;
            }

            if (typeof nextProp === "function") {
              nextProp = true;
            }

            if (typeof nextProp === "undefined") {
              nextProp = null;
            }

            if (typeof attributeConfig !== "object") {
              updatePayload[propKey] = nextProp;
            } else if (typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
              var nextValue = typeof attributeConfig.process === "function" ? attributeConfig.process(nextProp) : nextProp;
              updatePayload[propKey] = nextValue;
            }

            removedKeys[propKey] = false;
            removedKeyCount--;
          }
        }
      }

      function diffNestedArrayProperty(updatePayload, prevArray, nextArray, validAttributes) {
        var minLength = prevArray.length < nextArray.length ? prevArray.length : nextArray.length;
        var i = void 0;

        for (i = 0; i < minLength; i++) {
          updatePayload = diffNestedProperty(updatePayload, prevArray[i], nextArray[i], validAttributes);
        }

        for (; i < prevArray.length; i++) {
          updatePayload = clearNestedProperty(updatePayload, prevArray[i], validAttributes);
        }

        for (; i < nextArray.length; i++) {
          updatePayload = addNestedProperty(updatePayload, nextArray[i], validAttributes);
        }

        return updatePayload;
      }

      function diffNestedProperty(updatePayload, prevProp, nextProp, validAttributes) {
        if (!updatePayload && prevProp === nextProp) {
          return updatePayload;
        }

        if (!prevProp || !nextProp) {
          if (nextProp) {
            return addNestedProperty(updatePayload, nextProp, validAttributes);
          }

          if (prevProp) {
            return clearNestedProperty(updatePayload, prevProp, validAttributes);
          }

          return updatePayload;
        }

        if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) {
          return diffProperties(updatePayload, prevProp, nextProp, validAttributes);
        }

        if (Array.isArray(prevProp) && Array.isArray(nextProp)) {
          return diffNestedArrayProperty(updatePayload, prevProp, nextProp, validAttributes);
        }

        if (Array.isArray(prevProp)) {
          return diffProperties(updatePayload, flattenStyle(prevProp), nextProp, validAttributes);
        }

        return diffProperties(updatePayload, prevProp, flattenStyle(nextProp), validAttributes);
      }

      function addNestedProperty(updatePayload, nextProp, validAttributes) {
        if (!nextProp) {
          return updatePayload;
        }

        if (!Array.isArray(nextProp)) {
          return addProperties(updatePayload, nextProp, validAttributes);
        }

        for (var i = 0; i < nextProp.length; i++) {
          updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);
        }

        return updatePayload;
      }

      function clearNestedProperty(updatePayload, prevProp, validAttributes) {
        if (!prevProp) {
          return updatePayload;
        }

        if (!Array.isArray(prevProp)) {
          return clearProperties(updatePayload, prevProp, validAttributes);
        }

        for (var i = 0; i < prevProp.length; i++) {
          updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);
        }

        return updatePayload;
      }

      function diffProperties(updatePayload, prevProps, nextProps, validAttributes) {
        var attributeConfig = void 0;
        var nextProp = void 0;
        var prevProp = void 0;

        for (var propKey in nextProps) {
          attributeConfig = validAttributes[propKey];

          if (!attributeConfig) {
            continue;
          }

          prevProp = prevProps[propKey];
          nextProp = nextProps[propKey];

          if (typeof nextProp === "function") {
            nextProp = true;

            if (typeof prevProp === "function") {
              prevProp = true;
            }
          }

          if (typeof nextProp === "undefined") {
            nextProp = null;

            if (typeof prevProp === "undefined") {
              prevProp = null;
            }
          }

          if (removedKeys) {
            removedKeys[propKey] = false;
          }

          if (updatePayload && updatePayload[propKey] !== undefined) {
            if (typeof attributeConfig !== "object") {
              updatePayload[propKey] = nextProp;
            } else if (typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
              var nextValue = typeof attributeConfig.process === "function" ? attributeConfig.process(nextProp) : nextProp;
              updatePayload[propKey] = nextValue;
            }

            continue;
          }

          if (prevProp === nextProp) {
            continue;
          }

          if (typeof attributeConfig !== "object") {
            if (defaultDiffer(prevProp, nextProp)) {
              (updatePayload || (updatePayload = {}))[propKey] = nextProp;
            }
          } else if (typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
            var shouldUpdate = prevProp === undefined || (typeof attributeConfig.diff === "function" ? attributeConfig.diff(prevProp, nextProp) : defaultDiffer(prevProp, nextProp));

            if (shouldUpdate) {
              var _nextValue = typeof attributeConfig.process === "function" ? attributeConfig.process(nextProp) : nextProp;

              (updatePayload || (updatePayload = {}))[propKey] = _nextValue;
            }
          } else {
            removedKeys = null;
            removedKeyCount = 0;
            updatePayload = diffNestedProperty(updatePayload, prevProp, nextProp, attributeConfig);

            if (removedKeyCount > 0 && updatePayload) {
              restoreDeletedValuesInNestedArray(updatePayload, nextProp, attributeConfig);
              removedKeys = null;
            }
          }
        }

        for (var _propKey in prevProps) {
          if (nextProps[_propKey] !== undefined) {
            continue;
          }

          attributeConfig = validAttributes[_propKey];

          if (!attributeConfig) {
            continue;
          }

          if (updatePayload && updatePayload[_propKey] !== undefined) {
            continue;
          }

          prevProp = prevProps[_propKey];

          if (prevProp === undefined) {
            continue;
          }

          if (typeof attributeConfig !== "object" || typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
            (updatePayload || (updatePayload = {}))[_propKey] = null;

            if (!removedKeys) {
              removedKeys = {};
            }

            if (!removedKeys[_propKey]) {
              removedKeys[_propKey] = true;
              removedKeyCount++;
            }
          } else {
            updatePayload = clearNestedProperty(updatePayload, prevProp, attributeConfig);
          }
        }

        return updatePayload;
      }

      function addProperties(updatePayload, props, validAttributes) {
        return diffProperties(updatePayload, emptyObject, props, validAttributes);
      }

      function clearProperties(updatePayload, prevProps, validAttributes) {
        return diffProperties(updatePayload, prevProps, emptyObject, validAttributes);
      }

      function create(props, validAttributes) {
        return addProperties(null, props, validAttributes);
      }

      function diff(prevProps, nextProps, validAttributes) {
        return diffProperties(null, prevProps, nextProps, validAttributes);
      }

      function mountSafeCallback_NOT_REALLY_SAFE(context, callback) {
        return function () {
          if (!callback) {
            return undefined;
          }

          if (typeof context.__isMounted === "boolean") {
            if (!context.__isMounted) {
              return undefined;
            }
          }

          return callback.apply(context, arguments);
        };
      }

      function throwOnStylesProp(component, props) {
        if (props.styles !== undefined) {
          var owner = component._owner || null;
          var name = component.constructor.displayName;
          var msg = "`styles` is not a supported property of `" + name + "`, did " + "you mean `style` (singular)?";

          if (owner && owner.constructor && owner.constructor.displayName) {
            msg += "\n\nCheck the `" + owner.constructor.displayName + "` parent " + " component.";
          }

          throw new Error(msg);
        }
      }

      function warnForStyleProps(props, validAttributes) {
        for (var key in validAttributes.style) {
          if (!(validAttributes[key] || props[key] === undefined)) {
            console.error("You are setting the style `{ " + key + ": ... }` as a prop. You " + "should nest it in a style object. " + "E.g. `{ style: { " + key + ": ... } }`");
          }
        }
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var ReactNativeFiberHostComponent = function () {
        function ReactNativeFiberHostComponent(tag, viewConfig) {
          _classCallCheck(this, ReactNativeFiberHostComponent);

          this._nativeTag = tag;
          this._children = [];
          this.viewConfig = viewConfig;
        }

        ReactNativeFiberHostComponent.prototype.blur = function blur() {
          TextInputState.blurTextInput(this._nativeTag);
        };

        ReactNativeFiberHostComponent.prototype.focus = function focus() {
          TextInputState.focusTextInput(this._nativeTag);
        };

        ReactNativeFiberHostComponent.prototype.measure = function measure(callback) {
          UIManager.measure(this._nativeTag, mountSafeCallback_NOT_REALLY_SAFE(this, callback));
        };

        ReactNativeFiberHostComponent.prototype.measureInWindow = function measureInWindow(callback) {
          UIManager.measureInWindow(this._nativeTag, mountSafeCallback_NOT_REALLY_SAFE(this, callback));
        };

        ReactNativeFiberHostComponent.prototype.measureLayout = function measureLayout(relativeToNativeNode, onSuccess, onFail) {
          UIManager.measureLayout(this._nativeTag, relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
        };

        ReactNativeFiberHostComponent.prototype.setNativeProps = function setNativeProps(nativeProps) {
          {
            warnForStyleProps(nativeProps, this.viewConfig.validAttributes);
          }
          var updatePayload = create(nativeProps, this.viewConfig.validAttributes);

          if (updatePayload != null) {
            UIManager.updateView(this._nativeTag, this.viewConfig.uiViewClassName, updatePayload);
          }
        };

        return ReactNativeFiberHostComponent;
      }();

      var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
      var now$1 = hasNativePerformanceNow ? function () {
        return performance.now();
      } : function () {
        return Date.now();
      };
      var scheduledCallback = null;
      var frameDeadline = 0;

      function setTimeoutCallback() {
        frameDeadline = now$1() + 5;
        var callback = scheduledCallback;
        scheduledCallback = null;

        if (callback !== null) {
          callback();
        }
      }

      function scheduleDeferredCallback$1(callback, options) {
        scheduledCallback = callback;
        var timeoutId = setTimeout(setTimeoutCallback, 1);
        return timeoutId;
      }

      function cancelDeferredCallback$1(callbackID) {
        scheduledCallback = null;
        clearTimeout(callbackID);
      }

      function shouldYield$1() {
        return frameDeadline <= now$1();
      }

      function shim() {
        invariant(false, "The current renderer does not support persistence. " + "This error is likely caused by a bug in React. " + "Please file an issue.");
      }

      var supportsPersistence = false;
      var cloneInstance = shim;
      var createContainerChildSet = shim;
      var appendChildToContainerChildSet = shim;
      var finalizeContainerChildren = shim;
      var replaceContainerChildren = shim;
      var cloneHiddenInstance = shim;
      var cloneUnhiddenInstance = shim;
      var createHiddenTextInstance = shim;

      function shim$1() {
        invariant(false, "The current renderer does not support hyration. " + "This error is likely caused by a bug in React. " + "Please file an issue.");
      }

      var supportsHydration = false;
      var canHydrateInstance = shim$1;
      var canHydrateTextInstance = shim$1;
      var getNextHydratableSibling = shim$1;
      var getFirstHydratableChild = shim$1;
      var hydrateInstance = shim$1;
      var hydrateTextInstance = shim$1;
      var didNotMatchHydratedContainerTextInstance = shim$1;
      var didNotMatchHydratedTextInstance = shim$1;
      var didNotHydrateContainerInstance = shim$1;
      var didNotHydrateInstance = shim$1;
      var didNotFindHydratableContainerInstance = shim$1;
      var didNotFindHydratableContainerTextInstance = shim$1;
      var didNotFindHydratableInstance = shim$1;
      var didNotFindHydratableTextInstance = shim$1;
      var UPDATE_SIGNAL = {};
      {
        Object.freeze(UPDATE_SIGNAL);
      }
      var nextReactTag = 3;

      function allocateTag() {
        var tag = nextReactTag;

        if (tag % 10 === 1) {
          tag += 2;
        }

        nextReactTag = tag + 2;
        return tag;
      }

      function recursivelyUncacheFiberNode(node) {
        if (typeof node === "number") {
          uncacheFiberNode(node);
        } else {
          uncacheFiberNode(node._nativeTag);

          node._children.forEach(recursivelyUncacheFiberNode);
        }
      }

      function appendInitialChild(parentInstance, child) {
        parentInstance._children.push(child);
      }

      function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
        var tag = allocateTag();
        var viewConfig = ReactNativeViewConfigRegistry.get(type);
        {
          for (var key in viewConfig.validAttributes) {
            if (props.hasOwnProperty(key)) {
              deepFreezeAndThrowOnMutationInDev(props[key]);
            }
          }
        }
        invariant(type !== "RCTView" || !hostContext.isInAParentText, "Nesting of <View> within <Text> is not currently supported.");
        var updatePayload = create(props, viewConfig.validAttributes);
        UIManager.createView(tag, viewConfig.uiViewClassName, rootContainerInstance, updatePayload);
        var component = new ReactNativeFiberHostComponent(tag, viewConfig);
        precacheFiberNode(internalInstanceHandle, tag);
        updateFiberProps(tag, props);
        return component;
      }

      function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
        invariant(hostContext.isInAParentText, "Text strings must be rendered within a <Text> component.");
        var tag = allocateTag();
        UIManager.createView(tag, "RCTRawText", rootContainerInstance, {
          text: text
        });
        precacheFiberNode(internalInstanceHandle, tag);
        return tag;
      }

      function finalizeInitialChildren(parentInstance, type, props, rootContainerInstance, hostContext) {
        if (parentInstance._children.length === 0) {
          return false;
        }

        var nativeTags = parentInstance._children.map(function (child) {
          return typeof child === "number" ? child : child._nativeTag;
        });

        UIManager.setChildren(parentInstance._nativeTag, nativeTags);
        return false;
      }

      function getRootHostContext(rootContainerInstance) {
        return {
          isInAParentText: false
        };
      }

      function getChildHostContext(parentHostContext, type, rootContainerInstance) {
        var prevIsInAParentText = parentHostContext.isInAParentText;
        var isInAParentText = type === "AndroidTextInput" || type === "RCTMultilineTextInputView" || type === "RCTSinglelineTextInputView" || type === "RCTText" || type === "RCTVirtualText";

        if (prevIsInAParentText !== isInAParentText) {
          return {
            isInAParentText: isInAParentText
          };
        } else {
          return parentHostContext;
        }
      }

      function getPublicInstance(instance) {
        return instance;
      }

      function prepareForCommit(containerInfo) {}

      function prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, hostContext) {
        return UPDATE_SIGNAL;
      }

      function resetAfterCommit(containerInfo) {}

      var now = now$1;
      var isPrimaryRenderer = true;
      var scheduleDeferredCallback = scheduleDeferredCallback$1;
      var cancelDeferredCallback = cancelDeferredCallback$1;
      var shouldYield = shouldYield$1;
      var scheduleTimeout = setTimeout;
      var cancelTimeout = clearTimeout;
      var noTimeout = -1;

      function shouldDeprioritizeSubtree(type, props) {
        return false;
      }

      function shouldSetTextContent(type, props) {
        return false;
      }

      var supportsMutation = true;

      function appendChild(parentInstance, child) {
        var childTag = typeof child === "number" ? child : child._nativeTag;
        var children = parentInstance._children;
        var index = children.indexOf(child);

        if (index >= 0) {
          children.splice(index, 1);
          children.push(child);
          UIManager.manageChildren(parentInstance._nativeTag, [index], [children.length - 1], [], [], []);
        } else {
          children.push(child);
          UIManager.manageChildren(parentInstance._nativeTag, [], [], [childTag], [children.length - 1], []);
        }
      }

      function appendChildToContainer(parentInstance, child) {
        var childTag = typeof child === "number" ? child : child._nativeTag;
        UIManager.setChildren(parentInstance, [childTag]);
      }

      function commitTextUpdate(textInstance, oldText, newText) {
        UIManager.updateView(textInstance, "RCTRawText", {
          text: newText
        });
      }

      function commitUpdate(instance, updatePayloadTODO, type, oldProps, newProps, internalInstanceHandle) {
        var viewConfig = instance.viewConfig;
        updateFiberProps(instance._nativeTag, newProps);
        var updatePayload = diff(oldProps, newProps, viewConfig.validAttributes);

        if (updatePayload != null) {
          UIManager.updateView(instance._nativeTag, viewConfig.uiViewClassName, updatePayload);
        }
      }

      function insertBefore(parentInstance, child, beforeChild) {
        var children = parentInstance._children;
        var index = children.indexOf(child);

        if (index >= 0) {
          children.splice(index, 1);
          var beforeChildIndex = children.indexOf(beforeChild);
          children.splice(beforeChildIndex, 0, child);
          UIManager.manageChildren(parentInstance._nativeTag, [index], [beforeChildIndex], [], [], []);
        } else {
          var _beforeChildIndex = children.indexOf(beforeChild);

          children.splice(_beforeChildIndex, 0, child);
          var childTag = typeof child === "number" ? child : child._nativeTag;
          UIManager.manageChildren(parentInstance._nativeTag, [], [], [childTag], [_beforeChildIndex], []);
        }
      }

      function insertInContainerBefore(parentInstance, child, beforeChild) {
        invariant(typeof parentInstance !== "number", "Container does not support insertBefore operation");
      }

      function removeChild(parentInstance, child) {
        recursivelyUncacheFiberNode(child);
        var children = parentInstance._children;
        var index = children.indexOf(child);
        children.splice(index, 1);
        UIManager.manageChildren(parentInstance._nativeTag, [], [], [], [], [index]);
      }

      function removeChildFromContainer(parentInstance, child) {
        recursivelyUncacheFiberNode(child);
        UIManager.manageChildren(parentInstance, [], [], [], [], [0]);
      }

      function resetTextContent(instance) {}

      function hideInstance(instance) {
        var viewConfig = instance.viewConfig;
        var updatePayload = create({
          style: {
            display: "none"
          }
        }, viewConfig.validAttributes);
        UIManager.updateView(instance._nativeTag, viewConfig.uiViewClassName, updatePayload);
      }

      function hideTextInstance(textInstance) {
        throw new Error("Not yet implemented.");
      }

      function unhideInstance(instance, props) {
        var viewConfig = instance.viewConfig;
        var updatePayload = diff(_extends({}, props, {
          style: [props.style, {
            display: "none"
          }]
        }), props, viewConfig.validAttributes);
        UIManager.updateView(instance._nativeTag, viewConfig.uiViewClassName, updatePayload);
      }

      function unhideTextInstance(textInstance, text) {
        throw new Error("Not yet implemented.");
      }

      var BEFORE_SLASH_RE = /^(.*)[\\\/]/;

      var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
        var sourceInfo = "";

        if (source) {
          var path = source.fileName;
          var fileName = path.replace(BEFORE_SLASH_RE, "");
          {
            if (/^index\./.test(fileName)) {
              var match = path.match(BEFORE_SLASH_RE);

              if (match) {
                var pathBeforeSlash = match[1];

                if (pathBeforeSlash) {
                  var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, "");
                  fileName = folderName + "/" + fileName;
                }
              }
            }
          }
          sourceInfo = " (at " + fileName + ":" + source.lineNumber + ")";
        } else if (ownerName) {
          sourceInfo = " (created by " + ownerName + ")";
        }

        return "\n    in " + (name || "Unknown") + sourceInfo;
      };

      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

      function describeFiber(fiber) {
        switch (fiber.tag) {
          case IndeterminateComponent:
          case LazyComponent:
          case FunctionComponent:
          case ClassComponent:
          case HostComponent:
          case Mode:
          case SuspenseComponent:
            var owner = fiber._debugOwner;
            var source = fiber._debugSource;
            var name = getComponentName(fiber.type);
            var ownerName = null;

            if (owner) {
              ownerName = getComponentName(owner.type);
            }

            return describeComponentFrame(name, source, ownerName);

          default:
            return "";
        }
      }

      function getStackByFiberInDevAndProd(workInProgress) {
        var info = "";
        var node = workInProgress;

        do {
          info += describeFiber(node);
          node = node.return;
        } while (node);

        return info;
      }

      var current = null;
      var phase = null;

      function getCurrentFiberOwnerNameInDevOrNull() {
        {
          if (current === null) {
            return null;
          }

          var owner = current._debugOwner;

          if (owner !== null && typeof owner !== "undefined") {
            return getComponentName(owner.type);
          }
        }
        return null;
      }

      function getCurrentFiberStackInDev() {
        {
          if (current === null) {
            return "";
          }

          return getStackByFiberInDevAndProd(current);
        }
        return "";
      }

      function resetCurrentFiber() {
        {
          ReactDebugCurrentFrame.getCurrentStack = null;
          current = null;
          phase = null;
        }
      }

      function setCurrentFiber(fiber) {
        {
          ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
          current = fiber;
          phase = null;
        }
      }

      function setCurrentPhase(lifeCyclePhase) {
        {
          phase = lifeCyclePhase;
        }
      }

      var debugRenderPhaseSideEffects = false;
      var debugRenderPhaseSideEffectsForStrictMode = false;
      var enableHooks = false;
      var enableUserTimingAPI = true;
      var replayFailedUnitOfWorkWithInvokeGuardedCallback = true;
      var warnAboutDeprecatedLifecycles = false;
      var enableProfilerTimer = true;
      var enableSchedulerTracing = true;
      var reactEmoji = "\u269B";
      var warningEmoji = "\u26D4";
      var supportsUserTiming = typeof performance !== "undefined" && typeof performance.mark === "function" && typeof performance.clearMarks === "function" && typeof performance.measure === "function" && typeof performance.clearMeasures === "function";
      var currentFiber = null;
      var currentPhase = null;
      var currentPhaseFiber = null;
      var isCommitting = false;
      var hasScheduledUpdateInCurrentCommit = false;
      var hasScheduledUpdateInCurrentPhase = false;
      var commitCountInCurrentWorkLoop = 0;
      var effectCountInCurrentCommit = 0;
      var isWaitingForCallback = false;
      var labelsInCurrentCommit = new Set();

      var formatMarkName = function formatMarkName(markName) {
        return reactEmoji + " " + markName;
      };

      var formatLabel = function formatLabel(label, warning) {
        var prefix = warning ? warningEmoji + " " : reactEmoji + " ";
        var suffix = warning ? " Warning: " + warning : "";
        return "" + prefix + label + suffix;
      };

      var beginMark = function beginMark(markName) {
        performance.mark(formatMarkName(markName));
      };

      var clearMark = function clearMark(markName) {
        performance.clearMarks(formatMarkName(markName));
      };

      var endMark = function endMark(label, markName, warning) {
        var formattedMarkName = formatMarkName(markName);
        var formattedLabel = formatLabel(label, warning);

        try {
          performance.measure(formattedLabel, formattedMarkName);
        } catch (err) {}

        performance.clearMarks(formattedMarkName);
        performance.clearMeasures(formattedLabel);
      };

      var getFiberMarkName = function getFiberMarkName(label, debugID) {
        return label + " (#" + debugID + ")";
      };

      var getFiberLabel = function getFiberLabel(componentName, isMounted, phase) {
        if (phase === null) {
          return componentName + " [" + (isMounted ? "update" : "mount") + "]";
        } else {
          return componentName + "." + phase;
        }
      };

      var beginFiberMark = function beginFiberMark(fiber, phase) {
        var componentName = getComponentName(fiber.type) || "Unknown";
        var debugID = fiber._debugID;
        var isMounted = fiber.alternate !== null;
        var label = getFiberLabel(componentName, isMounted, phase);

        if (isCommitting && labelsInCurrentCommit.has(label)) {
          return false;
        }

        labelsInCurrentCommit.add(label);
        var markName = getFiberMarkName(label, debugID);
        beginMark(markName);
        return true;
      };

      var clearFiberMark = function clearFiberMark(fiber, phase) {
        var componentName = getComponentName(fiber.type) || "Unknown";
        var debugID = fiber._debugID;
        var isMounted = fiber.alternate !== null;
        var label = getFiberLabel(componentName, isMounted, phase);
        var markName = getFiberMarkName(label, debugID);
        clearMark(markName);
      };

      var endFiberMark = function endFiberMark(fiber, phase, warning) {
        var componentName = getComponentName(fiber.type) || "Unknown";
        var debugID = fiber._debugID;
        var isMounted = fiber.alternate !== null;
        var label = getFiberLabel(componentName, isMounted, phase);
        var markName = getFiberMarkName(label, debugID);
        endMark(label, markName, warning);
      };

      var shouldIgnoreFiber = function shouldIgnoreFiber(fiber) {
        switch (fiber.tag) {
          case HostRoot:
          case HostComponent:
          case HostText:
          case HostPortal:
          case Fragment:
          case ContextProvider:
          case ContextConsumer:
          case Mode:
            return true;

          default:
            return false;
        }
      };

      var clearPendingPhaseMeasurement = function clearPendingPhaseMeasurement() {
        if (currentPhase !== null && currentPhaseFiber !== null) {
          clearFiberMark(currentPhaseFiber, currentPhase);
        }

        currentPhaseFiber = null;
        currentPhase = null;
        hasScheduledUpdateInCurrentPhase = false;
      };

      var pauseTimers = function pauseTimers() {
        var fiber = currentFiber;

        while (fiber) {
          if (fiber._debugIsCurrentlyTiming) {
            endFiberMark(fiber, null, null);
          }

          fiber = fiber.return;
        }
      };

      var resumeTimersRecursively = function resumeTimersRecursively(fiber) {
        if (fiber.return !== null) {
          resumeTimersRecursively(fiber.return);
        }

        if (fiber._debugIsCurrentlyTiming) {
          beginFiberMark(fiber, null);
        }
      };

      var resumeTimers = function resumeTimers() {
        if (currentFiber !== null) {
          resumeTimersRecursively(currentFiber);
        }
      };

      function recordEffect() {
        if (enableUserTimingAPI) {
          effectCountInCurrentCommit++;
        }
      }

      function recordScheduleUpdate() {
        if (enableUserTimingAPI) {
          if (isCommitting) {
            hasScheduledUpdateInCurrentCommit = true;
          }

          if (currentPhase !== null && currentPhase !== "componentWillMount" && currentPhase !== "componentWillReceiveProps") {
            hasScheduledUpdateInCurrentPhase = true;
          }
        }
      }

      function startRequestCallbackTimer() {
        if (enableUserTimingAPI) {
          if (supportsUserTiming && !isWaitingForCallback) {
            isWaitingForCallback = true;
            beginMark("(Waiting for async callback...)");
          }
        }
      }

      function stopRequestCallbackTimer(didExpire, expirationTime) {
        if (enableUserTimingAPI) {
          if (supportsUserTiming) {
            isWaitingForCallback = false;
            var warning = didExpire ? "React was blocked by main thread" : null;
            endMark("(Waiting for async callback... will force flush in " + expirationTime + " ms)", "(Waiting for async callback...)", warning);
          }
        }
      }

      function startWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          currentFiber = fiber;

          if (!beginFiberMark(fiber, null)) {
            return;
          }

          fiber._debugIsCurrentlyTiming = true;
        }
      }

      function cancelWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          fiber._debugIsCurrentlyTiming = false;
          clearFiberMark(fiber, null);
        }
      }

      function stopWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          currentFiber = fiber.return;

          if (!fiber._debugIsCurrentlyTiming) {
            return;
          }

          fiber._debugIsCurrentlyTiming = false;
          endFiberMark(fiber, null, null);
        }
      }

      function stopFailedWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          currentFiber = fiber.return;

          if (!fiber._debugIsCurrentlyTiming) {
            return;
          }

          fiber._debugIsCurrentlyTiming = false;
          var warning = fiber.tag === SuspenseComponent ? "Rendering was suspended" : "An error was thrown inside this error boundary";
          endFiberMark(fiber, null, warning);
        }
      }

      function startPhaseTimer(fiber, phase) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          clearPendingPhaseMeasurement();

          if (!beginFiberMark(fiber, phase)) {
            return;
          }

          currentPhaseFiber = fiber;
          currentPhase = phase;
        }
      }

      function stopPhaseTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          if (currentPhase !== null && currentPhaseFiber !== null) {
            var warning = hasScheduledUpdateInCurrentPhase ? "Scheduled a cascading update" : null;
            endFiberMark(currentPhaseFiber, currentPhase, warning);
          }

          currentPhase = null;
          currentPhaseFiber = null;
        }
      }

      function startWorkLoopTimer(nextUnitOfWork) {
        if (enableUserTimingAPI) {
          currentFiber = nextUnitOfWork;

          if (!supportsUserTiming) {
            return;
          }

          commitCountInCurrentWorkLoop = 0;
          beginMark("(React Tree Reconciliation)");
          resumeTimers();
        }
      }

      function stopWorkLoopTimer(interruptedBy, didCompleteRoot) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var warning = null;

          if (interruptedBy !== null) {
            if (interruptedBy.tag === HostRoot) {
              warning = "A top-level update interrupted the previous render";
            } else {
              var componentName = getComponentName(interruptedBy.type) || "Unknown";
              warning = "An update to " + componentName + " interrupted the previous render";
            }
          } else if (commitCountInCurrentWorkLoop > 1) {
            warning = "There were cascading updates";
          }

          commitCountInCurrentWorkLoop = 0;
          var label = didCompleteRoot ? "(React Tree Reconciliation: Completed Root)" : "(React Tree Reconciliation: Yielded)";
          pauseTimers();
          endMark(label, "(React Tree Reconciliation)", warning);
        }
      }

      function startCommitTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          isCommitting = true;
          hasScheduledUpdateInCurrentCommit = false;
          labelsInCurrentCommit.clear();
          beginMark("(Committing Changes)");
        }
      }

      function stopCommitTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var warning = null;

          if (hasScheduledUpdateInCurrentCommit) {
            warning = "Lifecycle hook scheduled a cascading update";
          } else if (commitCountInCurrentWorkLoop > 0) {
            warning = "Caused by a cascading update in earlier commit";
          }

          hasScheduledUpdateInCurrentCommit = false;
          commitCountInCurrentWorkLoop++;
          isCommitting = false;
          labelsInCurrentCommit.clear();
          endMark("(Committing Changes)", "(Committing Changes)", warning);
        }
      }

      function startCommitSnapshotEffectsTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          effectCountInCurrentCommit = 0;
          beginMark("(Committing Snapshot Effects)");
        }
      }

      function stopCommitSnapshotEffectsTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var count = effectCountInCurrentCommit;
          effectCountInCurrentCommit = 0;
          endMark("(Committing Snapshot Effects: " + count + " Total)", "(Committing Snapshot Effects)", null);
        }
      }

      function startCommitHostEffectsTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          effectCountInCurrentCommit = 0;
          beginMark("(Committing Host Effects)");
        }
      }

      function stopCommitHostEffectsTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var count = effectCountInCurrentCommit;
          effectCountInCurrentCommit = 0;
          endMark("(Committing Host Effects: " + count + " Total)", "(Committing Host Effects)", null);
        }
      }

      function startCommitLifeCyclesTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          effectCountInCurrentCommit = 0;
          beginMark("(Calling Lifecycle Methods)");
        }
      }

      function stopCommitLifeCyclesTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var count = effectCountInCurrentCommit;
          effectCountInCurrentCommit = 0;
          endMark("(Calling Lifecycle Methods: " + count + " Total)", "(Calling Lifecycle Methods)", null);
        }
      }

      var valueStack = [];
      var fiberStack = void 0;
      {
        fiberStack = [];
      }
      var index = -1;

      function createCursor(defaultValue) {
        return {
          current: defaultValue
        };
      }

      function pop(cursor, fiber) {
        if (index < 0) {
          {
            warningWithoutStack$1(false, "Unexpected pop.");
          }
          return;
        }

        {
          if (fiber !== fiberStack[index]) {
            warningWithoutStack$1(false, "Unexpected Fiber popped.");
          }
        }
        cursor.current = valueStack[index];
        valueStack[index] = null;
        {
          fiberStack[index] = null;
        }
        index--;
      }

      function push(cursor, value, fiber) {
        index++;
        valueStack[index] = cursor.current;
        {
          fiberStack[index] = fiber;
        }
        cursor.current = value;
      }

      function checkThatStackIsEmpty() {
        {
          if (index !== -1) {
            warningWithoutStack$1(false, "Expected an empty stack. Something was not reset properly.");
          }
        }
      }

      function resetStackAfterFatalErrorInDev() {
        {
          index = -1;
          valueStack.length = 0;
          fiberStack.length = 0;
        }
      }

      var warnedAboutMissingGetChildContext = void 0;
      {
        warnedAboutMissingGetChildContext = {};
      }
      var emptyContextObject = {};
      {
        Object.freeze(emptyContextObject);
      }
      var contextStackCursor = createCursor(emptyContextObject);
      var didPerformWorkStackCursor = createCursor(false);
      var previousContext = emptyContextObject;

      function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {
        if (didPushOwnContextIfProvider && isContextProvider(Component)) {
          return previousContext;
        }

        return contextStackCursor.current;
      }

      function cacheContext(workInProgress, unmaskedContext, maskedContext) {
        var instance = workInProgress.stateNode;
        instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
        instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
      }

      function getMaskedContext(workInProgress, unmaskedContext) {
        var type = workInProgress.type;
        var contextTypes = type.contextTypes;

        if (!contextTypes) {
          return emptyContextObject;
        }

        var instance = workInProgress.stateNode;

        if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
          return instance.__reactInternalMemoizedMaskedChildContext;
        }

        var context = {};

        for (var key in contextTypes) {
          context[key] = unmaskedContext[key];
        }

        {
          var name = getComponentName(type) || "Unknown";
          checkPropTypes(contextTypes, context, "context", name, getCurrentFiberStackInDev);
        }

        if (instance) {
          cacheContext(workInProgress, unmaskedContext, context);
        }

        return context;
      }

      function hasContextChanged() {
        return didPerformWorkStackCursor.current;
      }

      function isContextProvider(type) {
        var childContextTypes = type.childContextTypes;
        return childContextTypes !== null && childContextTypes !== undefined;
      }

      function popContext(fiber) {
        pop(didPerformWorkStackCursor, fiber);
        pop(contextStackCursor, fiber);
      }

      function popTopLevelContextObject(fiber) {
        pop(didPerformWorkStackCursor, fiber);
        pop(contextStackCursor, fiber);
      }

      function pushTopLevelContextObject(fiber, context, didChange) {
        invariant(contextStackCursor.current === emptyContextObject, "Unexpected context found on stack. " + "This error is likely caused by a bug in React. Please file an issue.");
        push(contextStackCursor, context, fiber);
        push(didPerformWorkStackCursor, didChange, fiber);
      }

      function processChildContext(fiber, type, parentContext) {
        var instance = fiber.stateNode;
        var childContextTypes = type.childContextTypes;

        if (typeof instance.getChildContext !== "function") {
          {
            var componentName = getComponentName(type) || "Unknown";

            if (!warnedAboutMissingGetChildContext[componentName]) {
              warnedAboutMissingGetChildContext[componentName] = true;
              warningWithoutStack$1(false, "%s.childContextTypes is specified but there is no getChildContext() method " + "on the instance. You can either define getChildContext() on %s or remove " + "childContextTypes from it.", componentName, componentName);
            }
          }
          return parentContext;
        }

        var childContext = void 0;
        {
          setCurrentPhase("getChildContext");
        }
        startPhaseTimer(fiber, "getChildContext");
        childContext = instance.getChildContext();
        stopPhaseTimer();
        {
          setCurrentPhase(null);
        }

        for (var contextKey in childContext) {
          invariant(contextKey in childContextTypes, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(type) || "Unknown", contextKey);
        }

        {
          var name = getComponentName(type) || "Unknown";
          checkPropTypes(childContextTypes, childContext, "child context", name, getCurrentFiberStackInDev);
        }
        return _extends({}, parentContext, childContext);
      }

      function pushContextProvider(workInProgress) {
        var instance = workInProgress.stateNode;
        var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
        previousContext = contextStackCursor.current;
        push(contextStackCursor, memoizedMergedChildContext, workInProgress);
        push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
        return true;
      }

      function invalidateContextProvider(workInProgress, type, didChange) {
        var instance = workInProgress.stateNode;
        invariant(instance, "Expected to have an instance by this point. " + "This error is likely caused by a bug in React. Please file an issue.");

        if (didChange) {
          var mergedContext = processChildContext(workInProgress, type, previousContext);
          instance.__reactInternalMemoizedMergedChildContext = mergedContext;
          pop(didPerformWorkStackCursor, workInProgress);
          pop(contextStackCursor, workInProgress);
          push(contextStackCursor, mergedContext, workInProgress);
          push(didPerformWorkStackCursor, didChange, workInProgress);
        } else {
          pop(didPerformWorkStackCursor, workInProgress);
          push(didPerformWorkStackCursor, didChange, workInProgress);
        }
      }

      function findCurrentUnmaskedContext(fiber) {
        invariant(isFiberMounted(fiber) && fiber.tag === ClassComponent, "Expected subtree parent to be a mounted class component. " + "This error is likely caused by a bug in React. Please file an issue.");
        var node = fiber;

        do {
          switch (node.tag) {
            case HostRoot:
              return node.stateNode.context;

            case ClassComponent:
              {
                var Component = node.type;

                if (isContextProvider(Component)) {
                  return node.stateNode.__reactInternalMemoizedMergedChildContext;
                }

                break;
              }
          }

          node = node.return;
        } while (node !== null);

        invariant(false, "Found unexpected detached subtree parent. " + "This error is likely caused by a bug in React. Please file an issue.");
      }

      var onCommitFiberRoot = null;
      var onCommitFiberUnmount = null;
      var hasLoggedError = false;

      function catchErrors(fn) {
        return function (arg) {
          try {
            return fn(arg);
          } catch (err) {
            if (true && !hasLoggedError) {
              hasLoggedError = true;
              warningWithoutStack$1(false, "React DevTools encountered an error: %s", err);
            }
          }
        };
      }

      var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";

      function injectInternals(internals) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
          return false;
        }

        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;

        if (hook.isDisabled) {
          return true;
        }

        if (!hook.supportsFiber) {
          {
            warningWithoutStack$1(false, "The installed version of React DevTools is too old and will not work " + "with the current version of React. Please update React DevTools. " + "https://fb.me/react-devtools");
          }
          return true;
        }

        try {
          var rendererID = hook.inject(internals);
          onCommitFiberRoot = catchErrors(function (root) {
            return hook.onCommitFiberRoot(rendererID, root);
          });
          onCommitFiberUnmount = catchErrors(function (fiber) {
            return hook.onCommitFiberUnmount(rendererID, fiber);
          });
        } catch (err) {
          {
            warningWithoutStack$1(false, "React DevTools encountered an error: %s.", err);
          }
        }

        return true;
      }

      function onCommitRoot(root) {
        if (typeof onCommitFiberRoot === "function") {
          onCommitFiberRoot(root);
        }
      }

      function onCommitUnmount(fiber) {
        if (typeof onCommitFiberUnmount === "function") {
          onCommitFiberUnmount(fiber);
        }
      }

      var maxSigned31BitInt = 1073741823;
      var NoWork = 0;
      var Never = 1;
      var Sync = maxSigned31BitInt;
      var UNIT_SIZE = 10;
      var MAGIC_NUMBER_OFFSET = maxSigned31BitInt - 1;

      function msToExpirationTime(ms) {
        return MAGIC_NUMBER_OFFSET - (ms / UNIT_SIZE | 0);
      }

      function expirationTimeToMs(expirationTime) {
        return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;
      }

      function ceiling(num, precision) {
        return ((num / precision | 0) + 1) * precision;
      }

      function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
        return MAGIC_NUMBER_OFFSET - ceiling(MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
      }

      var LOW_PRIORITY_EXPIRATION = 5000;
      var LOW_PRIORITY_BATCH_SIZE = 250;

      function computeAsyncExpiration(currentTime) {
        return computeExpirationBucket(currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE);
      }

      var HIGH_PRIORITY_EXPIRATION = 500;
      var HIGH_PRIORITY_BATCH_SIZE = 100;

      function computeInteractiveExpiration(currentTime) {
        return computeExpirationBucket(currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE);
      }

      var NoContext = 0;
      var ConcurrentMode = 1;
      var StrictMode = 2;
      var ProfileMode = 4;
      var hasBadMapPolyfill = void 0;
      {
        hasBadMapPolyfill = false;

        try {
          var nonExtensibleObject = Object.preventExtensions({});
          var testMap = new Map([[nonExtensibleObject, null]]);
          var testSet = new Set([nonExtensibleObject]);
          testMap.set(0, 0);
          testSet.add(0);
        } catch (e) {
          hasBadMapPolyfill = true;
        }
      }
      var debugCounter = void 0;
      {
        debugCounter = 1;
      }

      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.elementType = null;
        this.type = null;
        this.stateNode = null;
        this.return = null;
        this.child = null;
        this.sibling = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = pendingProps;
        this.memoizedProps = null;
        this.updateQueue = null;
        this.memoizedState = null;
        this.firstContextDependency = null;
        this.mode = mode;
        this.effectTag = NoEffect;
        this.nextEffect = null;
        this.firstEffect = null;
        this.lastEffect = null;
        this.expirationTime = NoWork;
        this.childExpirationTime = NoWork;
        this.alternate = null;

        if (enableProfilerTimer) {
          this.actualDuration = 0;
          this.actualStartTime = -1;
          this.selfBaseDuration = 0;
          this.treeBaseDuration = 0;
        }

        {
          this._debugID = debugCounter++;
          this._debugSource = null;
          this._debugOwner = null;
          this._debugIsCurrentlyTiming = false;

          if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
            Object.preventExtensions(this);
          }
        }
      }

      var createFiber = function createFiber(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      };

      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }

      function isSimpleFunctionComponent(type) {
        return typeof type === "function" && !shouldConstruct(type) && type.defaultProps === undefined;
      }

      function resolveLazyComponentTag(Component) {
        if (typeof Component === "function") {
          return shouldConstruct(Component) ? ClassComponent : FunctionComponent;
        } else if (Component !== undefined && Component !== null) {
          var $$typeof = Component.$$typeof;

          if ($$typeof === REACT_FORWARD_REF_TYPE) {
            return ForwardRef;
          }

          if ($$typeof === REACT_MEMO_TYPE) {
            return MemoComponent;
          }
        }

        return IndeterminateComponent;
      }

      function createWorkInProgress(current, pendingProps, expirationTime) {
        var workInProgress = current.alternate;

        if (workInProgress === null) {
          workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);
          workInProgress.elementType = current.elementType;
          workInProgress.type = current.type;
          workInProgress.stateNode = current.stateNode;
          {
            workInProgress._debugID = current._debugID;
            workInProgress._debugSource = current._debugSource;
            workInProgress._debugOwner = current._debugOwner;
          }
          workInProgress.alternate = current;
          current.alternate = workInProgress;
        } else {
          workInProgress.pendingProps = pendingProps;
          workInProgress.effectTag = NoEffect;
          workInProgress.nextEffect = null;
          workInProgress.firstEffect = null;
          workInProgress.lastEffect = null;

          if (enableProfilerTimer) {
            workInProgress.actualDuration = 0;
            workInProgress.actualStartTime = -1;
          }
        }

        workInProgress.childExpirationTime = current.childExpirationTime;
        workInProgress.expirationTime = current.expirationTime;
        workInProgress.child = current.child;
        workInProgress.memoizedProps = current.memoizedProps;
        workInProgress.memoizedState = current.memoizedState;
        workInProgress.updateQueue = current.updateQueue;
        workInProgress.firstContextDependency = current.firstContextDependency;
        workInProgress.sibling = current.sibling;
        workInProgress.index = current.index;
        workInProgress.ref = current.ref;

        if (enableProfilerTimer) {
          workInProgress.selfBaseDuration = current.selfBaseDuration;
          workInProgress.treeBaseDuration = current.treeBaseDuration;
        }

        return workInProgress;
      }

      function createHostRootFiber(isConcurrent) {
        var mode = isConcurrent ? ConcurrentMode | StrictMode : NoContext;

        if (enableProfilerTimer && isDevToolsPresent) {
          mode |= ProfileMode;
        }

        return createFiber(HostRoot, null, null, mode);
      }

      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime) {
        var fiber = void 0;
        var fiberTag = IndeterminateComponent;
        var resolvedType = type;

        if (typeof type === "function") {
          if (shouldConstruct(type)) {
            fiberTag = ClassComponent;
          }
        } else if (typeof type === "string") {
          fiberTag = HostComponent;
        } else {
          getTag: switch (type) {
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);

            case REACT_CONCURRENT_MODE_TYPE:
              return createFiberFromMode(pendingProps, mode | ConcurrentMode | StrictMode, expirationTime, key);

            case REACT_STRICT_MODE_TYPE:
              return createFiberFromMode(pendingProps, mode | StrictMode, expirationTime, key);

            case REACT_PROFILER_TYPE:
              return createFiberFromProfiler(pendingProps, mode, expirationTime, key);

            case REACT_SUSPENSE_TYPE:
              return createFiberFromSuspense(pendingProps, mode, expirationTime, key);

            default:
              {
                if (typeof type === "object" && type !== null) {
                  switch (type.$$typeof) {
                    case REACT_PROVIDER_TYPE:
                      fiberTag = ContextProvider;
                      break getTag;

                    case REACT_CONTEXT_TYPE:
                      fiberTag = ContextConsumer;
                      break getTag;

                    case REACT_FORWARD_REF_TYPE:
                      fiberTag = ForwardRef;
                      break getTag;

                    case REACT_MEMO_TYPE:
                      fiberTag = MemoComponent;
                      break getTag;

                    case REACT_LAZY_TYPE:
                      fiberTag = LazyComponent;
                      resolvedType = null;
                      break getTag;
                  }
                }

                var info = "";
                {
                  if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                    info += " You likely forgot to export your component from the file " + "it's defined in, or you might have mixed up default and " + "named imports.";
                  }

                  var ownerName = owner ? getComponentName(owner.type) : null;

                  if (ownerName) {
                    info += "\n\nCheck the render method of `" + ownerName + "`.";
                  }
                }
                invariant(false, "Element type is invalid: expected a string (for built-in " + "components) or a class/function (for composite components) " + "but got: %s.%s", type == null ? type : typeof type, info);
              }
          }
        }

        fiber = createFiber(fiberTag, pendingProps, key, mode);
        fiber.elementType = type;
        fiber.type = resolvedType;
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromElement(element, mode, expirationTime) {
        var owner = null;
        {
          owner = element._owner;
        }
        var type = element.type;
        var key = element.key;
        var pendingProps = element.props;
        var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime);
        {
          fiber._debugSource = element._source;
          fiber._debugOwner = element._owner;
        }
        return fiber;
      }

      function createFiberFromFragment(elements, mode, expirationTime, key) {
        var fiber = createFiber(Fragment, elements, key, mode);
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
        {
          if (typeof pendingProps.id !== "string" || typeof pendingProps.onRender !== "function") {
            warningWithoutStack$1(false, 'Profiler must specify an "id" string and "onRender" function as props');
          }
        }
        var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
        fiber.elementType = REACT_PROFILER_TYPE;
        fiber.type = REACT_PROFILER_TYPE;
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromMode(pendingProps, mode, expirationTime, key) {
        var fiber = createFiber(Mode, pendingProps, key, mode);
        var type = (mode & ConcurrentMode) === NoContext ? REACT_STRICT_MODE_TYPE : REACT_CONCURRENT_MODE_TYPE;
        fiber.elementType = type;
        fiber.type = type;
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromSuspense(pendingProps, mode, expirationTime, key) {
        var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
        var type = REACT_SUSPENSE_TYPE;
        fiber.elementType = type;
        fiber.type = type;
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromText(content, mode, expirationTime) {
        var fiber = createFiber(HostText, content, null, mode);
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromHostInstanceForDeletion() {
        var fiber = createFiber(HostComponent, null, null, NoContext);
        fiber.elementType = "DELETED";
        fiber.type = "DELETED";
        return fiber;
      }

      function createFiberFromPortal(portal, mode, expirationTime) {
        var pendingProps = portal.children !== null ? portal.children : [];
        var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
        fiber.expirationTime = expirationTime;
        fiber.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return fiber;
      }

      function assignFiberPropertiesInDEV(target, source) {
        if (target === null) {
          target = createFiber(IndeterminateComponent, null, null, NoContext);
        }

        target.tag = source.tag;
        target.key = source.key;
        target.elementType = source.elementType;
        target.type = source.type;
        target.stateNode = source.stateNode;
        target.return = source.return;
        target.child = source.child;
        target.sibling = source.sibling;
        target.index = source.index;
        target.ref = source.ref;
        target.pendingProps = source.pendingProps;
        target.memoizedProps = source.memoizedProps;
        target.updateQueue = source.updateQueue;
        target.memoizedState = source.memoizedState;
        target.firstContextDependency = source.firstContextDependency;
        target.mode = source.mode;
        target.effectTag = source.effectTag;
        target.nextEffect = source.nextEffect;
        target.firstEffect = source.firstEffect;
        target.lastEffect = source.lastEffect;
        target.expirationTime = source.expirationTime;
        target.childExpirationTime = source.childExpirationTime;
        target.alternate = source.alternate;

        if (enableProfilerTimer) {
          target.actualDuration = source.actualDuration;
          target.actualStartTime = source.actualStartTime;
          target.selfBaseDuration = source.selfBaseDuration;
          target.treeBaseDuration = source.treeBaseDuration;
        }

        target._debugID = source._debugID;
        target._debugSource = source._debugSource;
        target._debugOwner = source._debugOwner;
        target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;
        return target;
      }

      function createFiberRoot(containerInfo, isConcurrent, hydrate) {
        var uninitializedFiber = createHostRootFiber(isConcurrent);
        var root = void 0;

        if (enableSchedulerTracing) {
          root = {
            current: uninitializedFiber,
            containerInfo: containerInfo,
            pendingChildren: null,
            earliestPendingTime: NoWork,
            latestPendingTime: NoWork,
            earliestSuspendedTime: NoWork,
            latestSuspendedTime: NoWork,
            latestPingedTime: NoWork,
            didError: false,
            pendingCommitExpirationTime: NoWork,
            finishedWork: null,
            timeoutHandle: noTimeout,
            context: null,
            pendingContext: null,
            hydrate: hydrate,
            nextExpirationTimeToWorkOn: NoWork,
            expirationTime: NoWork,
            firstBatch: null,
            nextScheduledRoot: null,
            interactionThreadID: tracing.unstable_getThreadID(),
            memoizedInteractions: new Set(),
            pendingInteractionMap: new Map()
          };
        } else {
          root = {
            current: uninitializedFiber,
            containerInfo: containerInfo,
            pendingChildren: null,
            earliestPendingTime: NoWork,
            latestPendingTime: NoWork,
            earliestSuspendedTime: NoWork,
            latestSuspendedTime: NoWork,
            latestPingedTime: NoWork,
            didError: false,
            pendingCommitExpirationTime: NoWork,
            finishedWork: null,
            timeoutHandle: noTimeout,
            context: null,
            pendingContext: null,
            hydrate: hydrate,
            nextExpirationTimeToWorkOn: NoWork,
            expirationTime: NoWork,
            firstBatch: null,
            nextScheduledRoot: null
          };
        }

        uninitializedFiber.stateNode = root;
        return root;
      }

      var lowPriorityWarning = function lowPriorityWarning() {};

      {
        var printWarning = function printWarning(format) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          var argIndex = 0;
          var message = "Warning: " + format.replace(/%s/g, function () {
            return args[argIndex++];
          });

          if (typeof console !== "undefined") {
            console.warn(message);
          }

          try {
            throw new Error(message);
          } catch (x) {}
        };

        lowPriorityWarning = function lowPriorityWarning(condition, format) {
          if (format === undefined) {
            throw new Error("`lowPriorityWarning(condition, format, ...args)` requires a warning " + "message argument");
          }

          if (!condition) {
            for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
              args[_key2 - 2] = arguments[_key2];
            }

            printWarning.apply(undefined, [format].concat(args));
          }
        };
      }
      var lowPriorityWarning$1 = lowPriorityWarning;
      var ReactStrictModeWarnings = {
        discardPendingWarnings: function discardPendingWarnings() {},
        flushPendingDeprecationWarnings: function flushPendingDeprecationWarnings() {},
        flushPendingUnsafeLifecycleWarnings: function flushPendingUnsafeLifecycleWarnings() {},
        recordDeprecationWarnings: function recordDeprecationWarnings(fiber, instance) {},
        recordUnsafeLifecycleWarnings: function recordUnsafeLifecycleWarnings(fiber, instance) {},
        recordLegacyContextWarning: function recordLegacyContextWarning(fiber, instance) {},
        flushLegacyContextWarning: function flushLegacyContextWarning() {}
      };
      {
        var LIFECYCLE_SUGGESTIONS = {
          UNSAFE_componentWillMount: "componentDidMount",
          UNSAFE_componentWillReceiveProps: "static getDerivedStateFromProps",
          UNSAFE_componentWillUpdate: "componentDidUpdate"
        };
        var pendingComponentWillMountWarnings = [];
        var pendingComponentWillReceivePropsWarnings = [];
        var pendingComponentWillUpdateWarnings = [];
        var pendingUnsafeLifecycleWarnings = new Map();
        var pendingLegacyContextWarning = new Map();
        var didWarnAboutDeprecatedLifecycles = new Set();
        var didWarnAboutUnsafeLifecycles = new Set();
        var didWarnAboutLegacyContext = new Set();

        var setToSortedString = function setToSortedString(set) {
          var array = [];
          set.forEach(function (value) {
            array.push(value);
          });
          return array.sort().join(", ");
        };

        ReactStrictModeWarnings.discardPendingWarnings = function () {
          pendingComponentWillMountWarnings = [];
          pendingComponentWillReceivePropsWarnings = [];
          pendingComponentWillUpdateWarnings = [];
          pendingUnsafeLifecycleWarnings = new Map();
          pendingLegacyContextWarning = new Map();
        };

        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
          pendingUnsafeLifecycleWarnings.forEach(function (lifecycleWarningsMap, strictRoot) {
            var lifecyclesWarningMesages = [];
            Object.keys(lifecycleWarningsMap).forEach(function (lifecycle) {
              var lifecycleWarnings = lifecycleWarningsMap[lifecycle];

              if (lifecycleWarnings.length > 0) {
                var componentNames = new Set();
                lifecycleWarnings.forEach(function (fiber) {
                  componentNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                var formatted = lifecycle.replace("UNSAFE_", "");
                var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];
                var sortedComponentNames = setToSortedString(componentNames);
                lifecyclesWarningMesages.push(formatted + ": Please update the following components to use " + (suggestion + " instead: " + sortedComponentNames));
              }
            });

            if (lifecyclesWarningMesages.length > 0) {
              var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);
              warningWithoutStack$1(false, "Unsafe lifecycle methods were found within a strict-mode tree:%s" + "\n\n%s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-strict-mode-warnings", strictRootComponentStack, lifecyclesWarningMesages.join("\n\n"));
            }
          });
          pendingUnsafeLifecycleWarnings = new Map();
        };

        var findStrictRoot = function findStrictRoot(fiber) {
          var maybeStrictRoot = null;
          var node = fiber;

          while (node !== null) {
            if (node.mode & StrictMode) {
              maybeStrictRoot = node;
            }

            node = node.return;
          }

          return maybeStrictRoot;
        };

        ReactStrictModeWarnings.flushPendingDeprecationWarnings = function () {
          if (pendingComponentWillMountWarnings.length > 0) {
            var uniqueNames = new Set();
            pendingComponentWillMountWarnings.forEach(function (fiber) {
              uniqueNames.add(getComponentName(fiber.type) || "Component");
              didWarnAboutDeprecatedLifecycles.add(fiber.type);
            });
            var sortedNames = setToSortedString(uniqueNames);
            lowPriorityWarning$1(false, "componentWillMount is deprecated and will be removed in the next major version. " + "Use componentDidMount instead. As a temporary workaround, " + "you can rename to UNSAFE_componentWillMount." + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-async-component-lifecycle-hooks", sortedNames);
            pendingComponentWillMountWarnings = [];
          }

          if (pendingComponentWillReceivePropsWarnings.length > 0) {
            var _uniqueNames = new Set();

            pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
              _uniqueNames.add(getComponentName(fiber.type) || "Component");

              didWarnAboutDeprecatedLifecycles.add(fiber.type);
            });

            var _sortedNames = setToSortedString(_uniqueNames);

            lowPriorityWarning$1(false, "componentWillReceiveProps is deprecated and will be removed in the next major version. " + "Use static getDerivedStateFromProps instead." + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-async-component-lifecycle-hooks", _sortedNames);
            pendingComponentWillReceivePropsWarnings = [];
          }

          if (pendingComponentWillUpdateWarnings.length > 0) {
            var _uniqueNames2 = new Set();

            pendingComponentWillUpdateWarnings.forEach(function (fiber) {
              _uniqueNames2.add(getComponentName(fiber.type) || "Component");

              didWarnAboutDeprecatedLifecycles.add(fiber.type);
            });

            var _sortedNames2 = setToSortedString(_uniqueNames2);

            lowPriorityWarning$1(false, "componentWillUpdate is deprecated and will be removed in the next major version. " + "Use componentDidUpdate instead. As a temporary workaround, " + "you can rename to UNSAFE_componentWillUpdate." + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-async-component-lifecycle-hooks", _sortedNames2);
            pendingComponentWillUpdateWarnings = [];
          }
        };

        ReactStrictModeWarnings.recordDeprecationWarnings = function (fiber, instance) {
          if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {
            return;
          }

          if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
            pendingComponentWillMountWarnings.push(fiber);
          }

          if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
            pendingComponentWillReceivePropsWarnings.push(fiber);
          }

          if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
            pendingComponentWillUpdateWarnings.push(fiber);
          }
        };

        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {
          var strictRoot = findStrictRoot(fiber);

          if (strictRoot === null) {
            warningWithoutStack$1(false, "Expected to find a StrictMode component in a strict mode tree. " + "This error is likely caused by a bug in React. Please file an issue.");
            return;
          }

          if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
            return;
          }

          var warningsForRoot = void 0;

          if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {
            warningsForRoot = {
              UNSAFE_componentWillMount: [],
              UNSAFE_componentWillReceiveProps: [],
              UNSAFE_componentWillUpdate: []
            };
            pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);
          } else {
            warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);
          }

          var unsafeLifecycles = [];

          if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillMount === "function") {
            unsafeLifecycles.push("UNSAFE_componentWillMount");
          }

          if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillReceiveProps === "function") {
            unsafeLifecycles.push("UNSAFE_componentWillReceiveProps");
          }

          if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillUpdate === "function") {
            unsafeLifecycles.push("UNSAFE_componentWillUpdate");
          }

          if (unsafeLifecycles.length > 0) {
            unsafeLifecycles.forEach(function (lifecycle) {
              warningsForRoot[lifecycle].push(fiber);
            });
          }
        };

        ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {
          var strictRoot = findStrictRoot(fiber);

          if (strictRoot === null) {
            warningWithoutStack$1(false, "Expected to find a StrictMode component in a strict mode tree. " + "This error is likely caused by a bug in React. Please file an issue.");
            return;
          }

          if (didWarnAboutLegacyContext.has(fiber.type)) {
            return;
          }

          var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);

          if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
            if (warningsForRoot === undefined) {
              warningsForRoot = [];
              pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
            }

            warningsForRoot.push(fiber);
          }
        };

        ReactStrictModeWarnings.flushLegacyContextWarning = function () {
          pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {
            var uniqueNames = new Set();
            fiberArray.forEach(function (fiber) {
              uniqueNames.add(getComponentName(fiber.type) || "Component");
              didWarnAboutLegacyContext.add(fiber.type);
            });
            var sortedNames = setToSortedString(uniqueNames);
            var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);
            warningWithoutStack$1(false, "Legacy context API has been detected within a strict-mode tree: %s" + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-strict-mode-warnings", strictRootComponentStack, sortedNames);
          });
        };
      }
      var ReactFiberInstrumentation = {
        debugTool: null
      };
      var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;

      function markPendingPriorityLevel(root, expirationTime) {
        root.didError = false;
        var earliestPendingTime = root.earliestPendingTime;

        if (earliestPendingTime === NoWork) {
          root.earliestPendingTime = root.latestPendingTime = expirationTime;
        } else {
          if (earliestPendingTime < expirationTime) {
            root.earliestPendingTime = expirationTime;
          } else {
            var latestPendingTime = root.latestPendingTime;

            if (latestPendingTime > expirationTime) {
              root.latestPendingTime = expirationTime;
            }
          }
        }

        findNextExpirationTimeToWorkOn(expirationTime, root);
      }

      function markCommittedPriorityLevels(root, earliestRemainingTime) {
        root.didError = false;

        if (earliestRemainingTime === NoWork) {
          root.earliestPendingTime = NoWork;
          root.latestPendingTime = NoWork;
          root.earliestSuspendedTime = NoWork;
          root.latestSuspendedTime = NoWork;
          root.latestPingedTime = NoWork;
          findNextExpirationTimeToWorkOn(NoWork, root);
          return;
        }

        var latestPendingTime = root.latestPendingTime;

        if (latestPendingTime !== NoWork) {
          if (latestPendingTime > earliestRemainingTime) {
            root.earliestPendingTime = root.latestPendingTime = NoWork;
          } else {
            var earliestPendingTime = root.earliestPendingTime;

            if (earliestPendingTime > earliestRemainingTime) {
              root.earliestPendingTime = root.latestPendingTime;
            }
          }
        }

        var earliestSuspendedTime = root.earliestSuspendedTime;

        if (earliestSuspendedTime === NoWork) {
          markPendingPriorityLevel(root, earliestRemainingTime);
          findNextExpirationTimeToWorkOn(NoWork, root);
          return;
        }

        var latestSuspendedTime = root.latestSuspendedTime;

        if (earliestRemainingTime < latestSuspendedTime) {
          root.earliestSuspendedTime = NoWork;
          root.latestSuspendedTime = NoWork;
          root.latestPingedTime = NoWork;
          markPendingPriorityLevel(root, earliestRemainingTime);
          findNextExpirationTimeToWorkOn(NoWork, root);
          return;
        }

        if (earliestRemainingTime > earliestSuspendedTime) {
          markPendingPriorityLevel(root, earliestRemainingTime);
          findNextExpirationTimeToWorkOn(NoWork, root);
          return;
        }

        findNextExpirationTimeToWorkOn(NoWork, root);
      }

      function hasLowerPriorityWork(root, erroredExpirationTime) {
        var latestPendingTime = root.latestPendingTime;
        var latestSuspendedTime = root.latestSuspendedTime;
        var latestPingedTime = root.latestPingedTime;
        return latestPendingTime !== NoWork && latestPendingTime < erroredExpirationTime || latestSuspendedTime !== NoWork && latestSuspendedTime < erroredExpirationTime || latestPingedTime !== NoWork && latestPingedTime < erroredExpirationTime;
      }

      function isPriorityLevelSuspended(root, expirationTime) {
        var earliestSuspendedTime = root.earliestSuspendedTime;
        var latestSuspendedTime = root.latestSuspendedTime;
        return earliestSuspendedTime !== NoWork && expirationTime <= earliestSuspendedTime && expirationTime >= latestSuspendedTime;
      }

      function markSuspendedPriorityLevel(root, suspendedTime) {
        root.didError = false;
        clearPing(root, suspendedTime);
        var earliestPendingTime = root.earliestPendingTime;
        var latestPendingTime = root.latestPendingTime;

        if (earliestPendingTime === suspendedTime) {
          if (latestPendingTime === suspendedTime) {
            root.earliestPendingTime = root.latestPendingTime = NoWork;
          } else {
            root.earliestPendingTime = latestPendingTime;
          }
        } else if (latestPendingTime === suspendedTime) {
          root.latestPendingTime = earliestPendingTime;
        }

        var earliestSuspendedTime = root.earliestSuspendedTime;
        var latestSuspendedTime = root.latestSuspendedTime;

        if (earliestSuspendedTime === NoWork) {
          root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;
        } else {
          if (earliestSuspendedTime < suspendedTime) {
            root.earliestSuspendedTime = suspendedTime;
          } else if (latestSuspendedTime > suspendedTime) {
            root.latestSuspendedTime = suspendedTime;
          }
        }

        findNextExpirationTimeToWorkOn(suspendedTime, root);
      }

      function markPingedPriorityLevel(root, pingedTime) {
        root.didError = false;
        var latestPingedTime = root.latestPingedTime;

        if (latestPingedTime === NoWork || latestPingedTime > pingedTime) {
          root.latestPingedTime = pingedTime;
        }

        findNextExpirationTimeToWorkOn(pingedTime, root);
      }

      function clearPing(root, completedTime) {
        var latestPingedTime = root.latestPingedTime;

        if (latestPingedTime !== NoWork && latestPingedTime >= completedTime) {
          root.latestPingedTime = NoWork;
        }
      }

      function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
        var earliestExpirationTime = renderExpirationTime;
        var earliestPendingTime = root.earliestPendingTime;
        var earliestSuspendedTime = root.earliestSuspendedTime;

        if (earliestPendingTime > earliestExpirationTime) {
          earliestExpirationTime = earliestPendingTime;
        }

        if (earliestSuspendedTime > earliestExpirationTime) {
          earliestExpirationTime = earliestSuspendedTime;
        }

        return earliestExpirationTime;
      }

      function didExpireAtExpirationTime(root, currentTime) {
        var expirationTime = root.expirationTime;

        if (expirationTime !== NoWork && currentTime <= expirationTime) {
          root.nextExpirationTimeToWorkOn = currentTime;
        }
      }

      function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
        var earliestSuspendedTime = root.earliestSuspendedTime;
        var latestSuspendedTime = root.latestSuspendedTime;
        var earliestPendingTime = root.earliestPendingTime;
        var latestPingedTime = root.latestPingedTime;
        var nextExpirationTimeToWorkOn = earliestPendingTime !== NoWork ? earliestPendingTime : latestPingedTime;

        if (nextExpirationTimeToWorkOn === NoWork && (completedExpirationTime === NoWork || latestSuspendedTime < completedExpirationTime)) {
          nextExpirationTimeToWorkOn = latestSuspendedTime;
        }

        var expirationTime = nextExpirationTimeToWorkOn;

        if (expirationTime !== NoWork && earliestSuspendedTime > expirationTime) {
          expirationTime = earliestSuspendedTime;
        }

        root.nextExpirationTimeToWorkOn = nextExpirationTimeToWorkOn;
        root.expirationTime = expirationTime;
      }

      var UpdateState = 0;
      var ReplaceState = 1;
      var ForceUpdate = 2;
      var CaptureUpdate = 3;
      var hasForceUpdate = false;
      var didWarnUpdateInsideUpdate = void 0;
      var currentlyProcessingQueue = void 0;
      var resetCurrentlyProcessingQueue = void 0;
      {
        didWarnUpdateInsideUpdate = false;
        currentlyProcessingQueue = null;

        resetCurrentlyProcessingQueue = function resetCurrentlyProcessingQueue() {
          currentlyProcessingQueue = null;
        };
      }

      function createUpdateQueue(baseState) {
        var queue = {
          baseState: baseState,
          firstUpdate: null,
          lastUpdate: null,
          firstCapturedUpdate: null,
          lastCapturedUpdate: null,
          firstEffect: null,
          lastEffect: null,
          firstCapturedEffect: null,
          lastCapturedEffect: null
        };
        return queue;
      }

      function cloneUpdateQueue(currentQueue) {
        var queue = {
          baseState: currentQueue.baseState,
          firstUpdate: currentQueue.firstUpdate,
          lastUpdate: currentQueue.lastUpdate,
          firstCapturedUpdate: null,
          lastCapturedUpdate: null,
          firstEffect: null,
          lastEffect: null,
          firstCapturedEffect: null,
          lastCapturedEffect: null
        };
        return queue;
      }

      function createUpdate(expirationTime) {
        return {
          expirationTime: expirationTime,
          tag: UpdateState,
          payload: null,
          callback: null,
          next: null,
          nextEffect: null
        };
      }

      function appendUpdateToQueue(queue, update) {
        if (queue.lastUpdate === null) {
          queue.firstUpdate = queue.lastUpdate = update;
        } else {
          queue.lastUpdate.next = update;
          queue.lastUpdate = update;
        }
      }

      function enqueueUpdate(fiber, update) {
        var alternate = fiber.alternate;
        var queue1 = void 0;
        var queue2 = void 0;

        if (alternate === null) {
          queue1 = fiber.updateQueue;
          queue2 = null;

          if (queue1 === null) {
            queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
          }
        } else {
          queue1 = fiber.updateQueue;
          queue2 = alternate.updateQueue;

          if (queue1 === null) {
            if (queue2 === null) {
              queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
              queue2 = alternate.updateQueue = createUpdateQueue(alternate.memoizedState);
            } else {
              queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);
            }
          } else {
            if (queue2 === null) {
              queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);
            } else {}
          }
        }

        if (queue2 === null || queue1 === queue2) {
          appendUpdateToQueue(queue1, update);
        } else {
          if (queue1.lastUpdate === null || queue2.lastUpdate === null) {
            appendUpdateToQueue(queue1, update);
            appendUpdateToQueue(queue2, update);
          } else {
            appendUpdateToQueue(queue1, update);
            queue2.lastUpdate = update;
          }
        }

        {
          if (fiber.tag === ClassComponent && (currentlyProcessingQueue === queue1 || queue2 !== null && currentlyProcessingQueue === queue2) && !didWarnUpdateInsideUpdate) {
            warningWithoutStack$1(false, "An update (setState, replaceState, or forceUpdate) was scheduled " + "from inside an update function. Update functions should be pure, " + "with zero side-effects. Consider using componentDidUpdate or a " + "callback.");
            didWarnUpdateInsideUpdate = true;
          }
        }
      }

      function enqueueCapturedUpdate(workInProgress, update) {
        var workInProgressQueue = workInProgress.updateQueue;

        if (workInProgressQueue === null) {
          workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(workInProgress.memoizedState);
        } else {
          workInProgressQueue = ensureWorkInProgressQueueIsAClone(workInProgress, workInProgressQueue);
        }

        if (workInProgressQueue.lastCapturedUpdate === null) {
          workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;
        } else {
          workInProgressQueue.lastCapturedUpdate.next = update;
          workInProgressQueue.lastCapturedUpdate = update;
        }
      }

      function ensureWorkInProgressQueueIsAClone(workInProgress, queue) {
        var current = workInProgress.alternate;

        if (current !== null) {
          if (queue === current.updateQueue) {
            queue = workInProgress.updateQueue = cloneUpdateQueue(queue);
          }
        }

        return queue;
      }

      function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
        switch (update.tag) {
          case ReplaceState:
            {
              var _payload = update.payload;

              if (typeof _payload === "function") {
                {
                  if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
                    _payload.call(instance, prevState, nextProps);
                  }
                }
                return _payload.call(instance, prevState, nextProps);
              }

              return _payload;
            }

          case CaptureUpdate:
            {
              workInProgress.effectTag = workInProgress.effectTag & ~ShouldCapture | DidCapture;
            }

          case UpdateState:
            {
              var _payload2 = update.payload;
              var partialState = void 0;

              if (typeof _payload2 === "function") {
                {
                  if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
                    _payload2.call(instance, prevState, nextProps);
                  }
                }
                partialState = _payload2.call(instance, prevState, nextProps);
              } else {
                partialState = _payload2;
              }

              if (partialState === null || partialState === undefined) {
                return prevState;
              }

              return _extends({}, prevState, partialState);
            }

          case ForceUpdate:
            {
              hasForceUpdate = true;
              return prevState;
            }
        }

        return prevState;
      }

      function processUpdateQueue(workInProgress, queue, props, instance, renderExpirationTime) {
        hasForceUpdate = false;
        queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);
        {
          currentlyProcessingQueue = queue;
        }
        var newBaseState = queue.baseState;
        var newFirstUpdate = null;
        var newExpirationTime = NoWork;
        var update = queue.firstUpdate;
        var resultState = newBaseState;

        while (update !== null) {
          var updateExpirationTime = update.expirationTime;

          if (updateExpirationTime < renderExpirationTime) {
            if (newFirstUpdate === null) {
              newFirstUpdate = update;
              newBaseState = resultState;
            }

            if (newExpirationTime < updateExpirationTime) {
              newExpirationTime = updateExpirationTime;
            }
          } else {
            resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);
            var _callback = update.callback;

            if (_callback !== null) {
              workInProgress.effectTag |= Callback;
              update.nextEffect = null;

              if (queue.lastEffect === null) {
                queue.firstEffect = queue.lastEffect = update;
              } else {
                queue.lastEffect.nextEffect = update;
                queue.lastEffect = update;
              }
            }
          }

          update = update.next;
        }

        var newFirstCapturedUpdate = null;
        update = queue.firstCapturedUpdate;

        while (update !== null) {
          var _updateExpirationTime = update.expirationTime;

          if (_updateExpirationTime < renderExpirationTime) {
            if (newFirstCapturedUpdate === null) {
              newFirstCapturedUpdate = update;

              if (newFirstUpdate === null) {
                newBaseState = resultState;
              }
            }

            if (newExpirationTime < _updateExpirationTime) {
              newExpirationTime = _updateExpirationTime;
            }
          } else {
            resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);
            var _callback2 = update.callback;

            if (_callback2 !== null) {
              workInProgress.effectTag |= Callback;
              update.nextEffect = null;

              if (queue.lastCapturedEffect === null) {
                queue.firstCapturedEffect = queue.lastCapturedEffect = update;
              } else {
                queue.lastCapturedEffect.nextEffect = update;
                queue.lastCapturedEffect = update;
              }
            }
          }

          update = update.next;
        }

        if (newFirstUpdate === null) {
          queue.lastUpdate = null;
        }

        if (newFirstCapturedUpdate === null) {
          queue.lastCapturedUpdate = null;
        } else {
          workInProgress.effectTag |= Callback;
        }

        if (newFirstUpdate === null && newFirstCapturedUpdate === null) {
          newBaseState = resultState;
        }

        queue.baseState = newBaseState;
        queue.firstUpdate = newFirstUpdate;
        queue.firstCapturedUpdate = newFirstCapturedUpdate;
        workInProgress.expirationTime = newExpirationTime;
        workInProgress.memoizedState = resultState;
        {
          currentlyProcessingQueue = null;
        }
      }

      function callCallback(callback, context) {
        invariant(typeof callback === "function", "Invalid argument passed as callback. Expected a function. Instead " + "received: %s", callback);
        callback.call(context);
      }

      function resetHasForceUpdateBeforeProcessing() {
        hasForceUpdate = false;
      }

      function checkHasForceUpdateAfterProcessing() {
        return hasForceUpdate;
      }

      function commitUpdateQueue(finishedWork, finishedQueue, instance, renderExpirationTime) {
        if (finishedQueue.firstCapturedUpdate !== null) {
          if (finishedQueue.lastUpdate !== null) {
            finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;
            finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;
          }

          finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;
        }

        commitUpdateEffects(finishedQueue.firstEffect, instance);
        finishedQueue.firstEffect = finishedQueue.lastEffect = null;
        commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);
        finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;
      }

      function commitUpdateEffects(effect, instance) {
        while (effect !== null) {
          var _callback3 = effect.callback;

          if (_callback3 !== null) {
            effect.callback = null;
            callCallback(_callback3, instance);
          }

          effect = effect.nextEffect;
        }
      }

      function createCapturedValue(value, source) {
        return {
          value: value,
          source: source,
          stack: getStackByFiberInDevAndProd(source)
        };
      }

      var warning = warningWithoutStack$1;
      {
        warning = function warning(condition, format) {
          if (condition) {
            return;
          }

          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame.getStackAddendum();

          for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          warningWithoutStack$1.apply(undefined, [false, format + "%s"].concat(args, [stack]));
        };
      }
      var warning$1 = warning;
      var valueCursor = createCursor(null);
      var rendererSigil = void 0;
      {
        rendererSigil = {};
      }
      var currentlyRenderingFiber = null;
      var lastContextDependency = null;
      var lastContextWithAllBitsObserved = null;

      function resetContextDependences() {
        currentlyRenderingFiber = null;
        lastContextDependency = null;
        lastContextWithAllBitsObserved = null;
      }

      function pushProvider(providerFiber, nextValue) {
        var context = providerFiber.type._context;

        if (isPrimaryRenderer) {
          push(valueCursor, context._currentValue, providerFiber);
          context._currentValue = nextValue;
          {
            !(context._currentRenderer === undefined || context._currentRenderer === null || context._currentRenderer === rendererSigil) ? warningWithoutStack$1(false, "Detected multiple renderers concurrently rendering the " + "same context provider. This is currently unsupported.") : void 0;
            context._currentRenderer = rendererSigil;
          }
        } else {
          push(valueCursor, context._currentValue2, providerFiber);
          context._currentValue2 = nextValue;
          {
            !(context._currentRenderer2 === undefined || context._currentRenderer2 === null || context._currentRenderer2 === rendererSigil) ? warningWithoutStack$1(false, "Detected multiple renderers concurrently rendering the " + "same context provider. This is currently unsupported.") : void 0;
            context._currentRenderer2 = rendererSigil;
          }
        }
      }

      function popProvider(providerFiber) {
        var currentValue = valueCursor.current;
        pop(valueCursor, providerFiber);
        var context = providerFiber.type._context;

        if (isPrimaryRenderer) {
          context._currentValue = currentValue;
        } else {
          context._currentValue2 = currentValue;
        }
      }

      function calculateChangedBits(context, newValue, oldValue) {
        if (oldValue === newValue && (oldValue !== 0 || 1 / oldValue === 1 / newValue) || oldValue !== oldValue && newValue !== newValue) {
            return 0;
          } else {
          var changedBits = typeof context._calculateChangedBits === "function" ? context._calculateChangedBits(oldValue, newValue) : maxSigned31BitInt;
          {
            !((changedBits & maxSigned31BitInt) === changedBits) ? warning$1(false, "calculateChangedBits: Expected the return value to be a " + "31-bit integer. Instead received: %s", changedBits) : void 0;
          }
          return changedBits | 0;
        }
      }

      function propagateContextChange(workInProgress, context, changedBits, renderExpirationTime) {
        var fiber = workInProgress.child;

        if (fiber !== null) {
          fiber.return = workInProgress;
        }

        while (fiber !== null) {
          var nextFiber = void 0;
          var dependency = fiber.firstContextDependency;

          if (dependency !== null) {
            do {
              if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {
                if (fiber.tag === ClassComponent) {
                  var update = createUpdate(renderExpirationTime);
                  update.tag = ForceUpdate;
                  enqueueUpdate(fiber, update);
                }

                if (fiber.expirationTime < renderExpirationTime) {
                  fiber.expirationTime = renderExpirationTime;
                }

                var alternate = fiber.alternate;

                if (alternate !== null && alternate.expirationTime < renderExpirationTime) {
                  alternate.expirationTime = renderExpirationTime;
                }

                var node = fiber.return;

                while (node !== null) {
                  alternate = node.alternate;

                  if (node.childExpirationTime < renderExpirationTime) {
                    node.childExpirationTime = renderExpirationTime;

                    if (alternate !== null && alternate.childExpirationTime < renderExpirationTime) {
                      alternate.childExpirationTime = renderExpirationTime;
                    }
                  } else if (alternate !== null && alternate.childExpirationTime < renderExpirationTime) {
                    alternate.childExpirationTime = renderExpirationTime;
                  } else {
                    break;
                  }

                  node = node.return;
                }
              }

              nextFiber = fiber.child;
              dependency = dependency.next;
            } while (dependency !== null);
          } else if (fiber.tag === ContextProvider) {
            nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
          } else {
            nextFiber = fiber.child;
          }

          if (nextFiber !== null) {
            nextFiber.return = fiber;
          } else {
            nextFiber = fiber;

            while (nextFiber !== null) {
              if (nextFiber === workInProgress) {
                nextFiber = null;
                break;
              }

              var sibling = nextFiber.sibling;

              if (sibling !== null) {
                sibling.return = nextFiber.return;
                nextFiber = sibling;
                break;
              }

              nextFiber = nextFiber.return;
            }
          }

          fiber = nextFiber;
        }
      }

      function prepareToReadContext(workInProgress, renderExpirationTime) {
        currentlyRenderingFiber = workInProgress;
        lastContextDependency = null;
        lastContextWithAllBitsObserved = null;
        workInProgress.firstContextDependency = null;
      }

      function readContext(context, observedBits) {
        if (lastContextWithAllBitsObserved === context) {} else if (observedBits === false || observedBits === 0) {} else {
          var resolvedObservedBits = void 0;

          if (typeof observedBits !== "number" || observedBits === maxSigned31BitInt) {
            lastContextWithAllBitsObserved = context;
            resolvedObservedBits = maxSigned31BitInt;
          } else {
            resolvedObservedBits = observedBits;
          }

          var contextItem = {
            context: context,
            observedBits: resolvedObservedBits,
            next: null
          };

          if (lastContextDependency === null) {
            invariant(currentlyRenderingFiber !== null, "Context can only be read while React is " + "rendering, e.g. inside the render method or getDerivedStateFromProps.");
            currentlyRenderingFiber.firstContextDependency = lastContextDependency = contextItem;
          } else {
            lastContextDependency = lastContextDependency.next = contextItem;
          }
        }

        return isPrimaryRenderer ? context._currentValue : context._currentValue2;
      }

      var NoEffect$1 = 0;
      var UnmountSnapshot = 2;
      var UnmountMutation = 4;
      var MountMutation = 8;
      var UnmountLayout = 16;
      var MountLayout = 32;
      var MountPassive = 64;
      var UnmountPassive = 128;

      function areHookInputsEqual(arr1, arr2) {
        {
          !(arr1.length === arr2.length) ? warning$1(false, "Detected a variable number of hook dependencies. The length of the " + "dependencies array should be constant between renders.\n\n" + "Previous: %s\n" + "Incoming: %s", arr1.join(", "), arr2.join(", ")) : void 0;
        }

        for (var i = 0; i < arr1.length; i++) {
          var val1 = arr1[i];
          var val2 = arr2[i];

          if (val1 === val2 && (val1 !== 0 || 1 / val1 === 1 / val2) || val1 !== val1 && val2 !== val2) {
              continue;
            }

          return false;
        }

        return true;
      }

      var renderExpirationTime = NoWork;
      var currentlyRenderingFiber$1 = null;
      var firstCurrentHook = null;
      var currentHook = null;
      var firstWorkInProgressHook = null;
      var workInProgressHook = null;
      var remainingExpirationTime = NoWork;
      var componentUpdateQueue = null;
      var isReRender = false;
      var didScheduleRenderPhaseUpdate = false;
      var renderPhaseUpdates = null;
      var numberOfReRenders = 0;
      var RE_RENDER_LIMIT = 25;

      function resolveCurrentlyRenderingFiber() {
        invariant(currentlyRenderingFiber$1 !== null, "Hooks can only be called inside the body of a function component.");
        return currentlyRenderingFiber$1;
      }

      function prepareToUseHooks(current, workInProgress, nextRenderExpirationTime) {
        if (!enableHooks) {
          return;
        }

        renderExpirationTime = nextRenderExpirationTime;
        currentlyRenderingFiber$1 = workInProgress;
        firstCurrentHook = current !== null ? current.memoizedState : null;
      }

      function finishHooks(Component, props, children, refOrContext) {
        if (!enableHooks) {
          return children;
        }

        while (didScheduleRenderPhaseUpdate) {
          didScheduleRenderPhaseUpdate = false;
          numberOfReRenders += 1;
          currentHook = null;
          workInProgressHook = null;
          componentUpdateQueue = null;
          children = Component(props, refOrContext);
        }

        renderPhaseUpdates = null;
        numberOfReRenders = 0;
        var renderedWork = currentlyRenderingFiber$1;
        renderedWork.memoizedState = firstWorkInProgressHook;
        renderedWork.expirationTime = remainingExpirationTime;
        renderedWork.updateQueue = componentUpdateQueue;
        var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
        renderExpirationTime = NoWork;
        currentlyRenderingFiber$1 = null;
        firstCurrentHook = null;
        currentHook = null;
        firstWorkInProgressHook = null;
        workInProgressHook = null;
        remainingExpirationTime = NoWork;
        componentUpdateQueue = null;
        invariant(!didRenderTooFewHooks, "Rendered fewer hooks than expected. This may be caused by an accidental " + "early return statement.");
        return children;
      }

      function resetHooks() {
        if (!enableHooks) {
          return;
        }

        renderExpirationTime = NoWork;
        currentlyRenderingFiber$1 = null;
        firstCurrentHook = null;
        currentHook = null;
        firstWorkInProgressHook = null;
        workInProgressHook = null;
        remainingExpirationTime = NoWork;
        componentUpdateQueue = null;
        didScheduleRenderPhaseUpdate = false;
        renderPhaseUpdates = null;
        numberOfReRenders = 0;
      }

      function createHook() {
        return {
          memoizedState: null,
          baseState: null,
          queue: null,
          baseUpdate: null,
          next: null
        };
      }

      function cloneHook(hook) {
        return {
          memoizedState: hook.memoizedState,
          baseState: hook.memoizedState,
          queue: hook.queue,
          baseUpdate: hook.baseUpdate,
          next: null
        };
      }

      function createWorkInProgressHook() {
        if (workInProgressHook === null) {
          if (firstWorkInProgressHook === null) {
            isReRender = false;
            currentHook = firstCurrentHook;

            if (currentHook === null) {
              workInProgressHook = createHook();
            } else {
              workInProgressHook = cloneHook(currentHook);
            }

            firstWorkInProgressHook = workInProgressHook;
          } else {
            isReRender = true;
            currentHook = firstCurrentHook;
            workInProgressHook = firstWorkInProgressHook;
          }
        } else {
          if (workInProgressHook.next === null) {
            isReRender = false;
            var hook = void 0;

            if (currentHook === null) {
              hook = createHook();
            } else {
              currentHook = currentHook.next;

              if (currentHook === null) {
                hook = createHook();
              } else {
                hook = cloneHook(currentHook);
              }
            }

            workInProgressHook = workInProgressHook.next = hook;
          } else {
            isReRender = true;
            workInProgressHook = workInProgressHook.next;
            currentHook = currentHook !== null ? currentHook.next : null;
          }
        }

        return workInProgressHook;
      }

      function createFunctionComponentUpdateQueue() {
        return {
          lastEffect: null
        };
      }

      function basicStateReducer(state, action) {
        return typeof action === "function" ? action(state) : action;
      }

      function useContext(context, observedBits) {
        resolveCurrentlyRenderingFiber();
        return readContext(context, observedBits);
      }

      function useState(initialState) {
        return useReducer(basicStateReducer, initialState);
      }

      function useReducer(reducer, initialState, initialAction) {
        currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
        workInProgressHook = createWorkInProgressHook();
        var queue = workInProgressHook.queue;

        if (queue !== null) {
          if (isReRender) {
            var _dispatch2 = queue.dispatch;

            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);

              if (firstRenderPhaseUpdate !== undefined) {
                renderPhaseUpdates.delete(queue);
                var newState = workInProgressHook.memoizedState;
                var update = firstRenderPhaseUpdate;

                do {
                  var _action = update.action;
                  newState = reducer(newState, _action);
                  update = update.next;
                } while (update !== null);

                workInProgressHook.memoizedState = newState;

                if (workInProgressHook.baseUpdate === queue.last) {
                  workInProgressHook.baseState = newState;
                }

                return [newState, _dispatch2];
              }
            }

            return [workInProgressHook.memoizedState, _dispatch2];
          }

          var _last = queue.last;
          var _baseUpdate = workInProgressHook.baseUpdate;
          var first = void 0;

          if (_baseUpdate !== null) {
            if (_last !== null) {
              _last.next = null;
            }

            first = _baseUpdate.next;
          } else {
            first = _last !== null ? _last.next : null;
          }

          if (first !== null) {
            var _newState = workInProgressHook.baseState;
            var newBaseState = null;
            var newBaseUpdate = null;
            var prevUpdate = _baseUpdate;
            var _update = first;
            var didSkip = false;

            do {
              var updateExpirationTime = _update.expirationTime;

              if (updateExpirationTime < renderExpirationTime) {
                if (!didSkip) {
                  didSkip = true;
                  newBaseUpdate = prevUpdate;
                  newBaseState = _newState;
                }

                if (updateExpirationTime > remainingExpirationTime) {
                  remainingExpirationTime = updateExpirationTime;
                }
              } else {
                var _action2 = _update.action;
                _newState = reducer(_newState, _action2);
              }

              prevUpdate = _update;
              _update = _update.next;
            } while (_update !== null && _update !== first);

            if (!didSkip) {
              newBaseUpdate = prevUpdate;
              newBaseState = _newState;
            }

            workInProgressHook.memoizedState = _newState;
            workInProgressHook.baseUpdate = newBaseUpdate;
            workInProgressHook.baseState = newBaseState;
          }

          var _dispatch = queue.dispatch;
          return [workInProgressHook.memoizedState, _dispatch];
        }

        if (reducer === basicStateReducer) {
          if (typeof initialState === "function") {
            initialState = initialState();
          }
        } else if (initialAction !== undefined && initialAction !== null) {
          initialState = reducer(initialState, initialAction);
        }

        workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;
        queue = workInProgressHook.queue = {
          last: null,
          dispatch: null
        };
        var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
        return [workInProgressHook.memoizedState, dispatch];
      }

      function pushEffect(tag, create, destroy, inputs) {
        var effect = {
          tag: tag,
          create: create,
          destroy: destroy,
          inputs: inputs,
          next: null
        };

        if (componentUpdateQueue === null) {
          componentUpdateQueue = createFunctionComponentUpdateQueue();
          componentUpdateQueue.lastEffect = effect.next = effect;
        } else {
          var _lastEffect = componentUpdateQueue.lastEffect;

          if (_lastEffect === null) {
            componentUpdateQueue.lastEffect = effect.next = effect;
          } else {
            var firstEffect = _lastEffect.next;
            _lastEffect.next = effect;
            effect.next = firstEffect;
            componentUpdateQueue.lastEffect = effect;
          }
        }

        return effect;
      }

      function useRef(initialValue) {
        currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
        workInProgressHook = createWorkInProgressHook();
        var ref = void 0;

        if (workInProgressHook.memoizedState === null) {
          ref = {
            current: initialValue
          };
          {
            Object.seal(ref);
          }
          workInProgressHook.memoizedState = ref;
        } else {
          ref = workInProgressHook.memoizedState;
        }

        return ref;
      }

      function useMutationEffect(create, inputs) {
        useEffectImpl(Snapshot | Update, UnmountSnapshot | MountMutation, create, inputs);
      }

      function useLayoutEffect(create, inputs) {
        useEffectImpl(Update, UnmountMutation | MountLayout, create, inputs);
      }

      function useEffect(create, inputs) {
        useEffectImpl(Update | Passive, UnmountPassive | MountPassive, create, inputs);
      }

      function useEffectImpl(fiberEffectTag, hookEffectTag, create, inputs) {
        currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
        workInProgressHook = createWorkInProgressHook();
        var nextInputs = inputs !== undefined && inputs !== null ? inputs : [create];
        var destroy = null;

        if (currentHook !== null) {
          var prevEffect = currentHook.memoizedState;
          destroy = prevEffect.destroy;

          if (areHookInputsEqual(nextInputs, prevEffect.inputs)) {
            pushEffect(NoEffect$1, create, destroy, nextInputs);
            return;
          }
        }

        currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
        workInProgressHook.memoizedState = pushEffect(hookEffectTag, create, destroy, nextInputs);
      }

      function useImperativeMethods(ref, create, inputs) {
        var nextInputs = inputs !== null && inputs !== undefined ? inputs.concat([ref]) : [ref, create];
        useEffectImpl(Update, UnmountMutation | MountLayout, function () {
          if (typeof ref === "function") {
            var refCallback = ref;

            var _inst = create();

            refCallback(_inst);
            return function () {
              return refCallback(null);
            };
          } else if (ref !== null && ref !== undefined) {
            var refObject = ref;

            var _inst2 = create();

            refObject.current = _inst2;
            return function () {
              refObject.current = null;
            };
          }
        }, nextInputs);
      }

      function useCallback(callback, inputs) {
        currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
        workInProgressHook = createWorkInProgressHook();
        var nextInputs = inputs !== undefined && inputs !== null ? inputs : [callback];
        var prevState = workInProgressHook.memoizedState;

        if (prevState !== null) {
          var prevInputs = prevState[1];

          if (areHookInputsEqual(nextInputs, prevInputs)) {
            return prevState[0];
          }
        }

        workInProgressHook.memoizedState = [callback, nextInputs];
        return callback;
      }

      function useMemo(nextCreate, inputs) {
        currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
        workInProgressHook = createWorkInProgressHook();
        var nextInputs = inputs !== undefined && inputs !== null ? inputs : [nextCreate];
        var prevState = workInProgressHook.memoizedState;

        if (prevState !== null) {
          var prevInputs = prevState[1];

          if (areHookInputsEqual(nextInputs, prevInputs)) {
            return prevState[0];
          }
        }

        var nextValue = nextCreate();
        workInProgressHook.memoizedState = [nextValue, nextInputs];
        return nextValue;
      }

      function dispatchAction(fiber, queue, action) {
        invariant(numberOfReRenders < RE_RENDER_LIMIT, "Too many re-renders. React limits the number of renders to prevent " + "an infinite loop.");
        var alternate = fiber.alternate;

        if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) {
          didScheduleRenderPhaseUpdate = true;
          var update = {
            expirationTime: renderExpirationTime,
            action: action,
            next: null
          };

          if (renderPhaseUpdates === null) {
            renderPhaseUpdates = new Map();
          }

          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);

          if (firstRenderPhaseUpdate === undefined) {
            renderPhaseUpdates.set(queue, update);
          } else {
            var lastRenderPhaseUpdate = firstRenderPhaseUpdate;

            while (lastRenderPhaseUpdate.next !== null) {
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            }

            lastRenderPhaseUpdate.next = update;
          }
        } else {
          var currentTime = requestCurrentTime();

          var _expirationTime = computeExpirationForFiber(currentTime, fiber);

          var _update2 = {
            expirationTime: _expirationTime,
            action: action,
            next: null
          };
          flushPassiveEffects();
          var _last2 = queue.last;

          if (_last2 === null) {
            _update2.next = _update2;
          } else {
            var first = _last2.next;

            if (first !== null) {
              _update2.next = first;
            }

            _last2.next = _update2;
          }

          queue.last = _update2;
          scheduleWork(fiber, _expirationTime);
        }
      }

      var NO_CONTEXT = {};
      var contextStackCursor$1 = createCursor(NO_CONTEXT);
      var contextFiberStackCursor = createCursor(NO_CONTEXT);
      var rootInstanceStackCursor = createCursor(NO_CONTEXT);

      function requiredContext(c) {
        invariant(c !== NO_CONTEXT, "Expected host context to exist. This error is likely caused by a bug " + "in React. Please file an issue.");
        return c;
      }

      function getRootHostContainer() {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        return rootInstance;
      }

      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance, fiber);
        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor$1, NO_CONTEXT, fiber);
        var nextRootContext = getRootHostContext(nextRootInstance);
        pop(contextStackCursor$1, fiber);
        push(contextStackCursor$1, nextRootContext, fiber);
      }

      function popHostContainer(fiber) {
        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
        pop(rootInstanceStackCursor, fiber);
      }

      function getHostContext() {
        var context = requiredContext(contextStackCursor$1.current);
        return context;
      }

      function pushHostContext(fiber) {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        var context = requiredContext(contextStackCursor$1.current);
        var nextContext = getChildHostContext(context, fiber.type, rootInstance);

        if (context === nextContext) {
          return;
        }

        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor$1, nextContext, fiber);
      }

      function popHostContext(fiber) {
        if (contextFiberStackCursor.current !== fiber) {
          return;
        }

        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
      }

      var commitTime = 0;
      var profilerStartTime = -1;

      function getCommitTime() {
        return commitTime;
      }

      function recordCommitTime() {
        if (!enableProfilerTimer) {
          return;
        }

        commitTime = now();
      }

      function startProfilerTimer(fiber) {
        if (!enableProfilerTimer) {
          return;
        }

        profilerStartTime = now();

        if (fiber.actualStartTime < 0) {
          fiber.actualStartTime = now();
        }
      }

      function stopProfilerTimerIfRunning(fiber) {
        if (!enableProfilerTimer) {
          return;
        }

        profilerStartTime = -1;
      }

      function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
        if (!enableProfilerTimer) {
          return;
        }

        if (profilerStartTime >= 0) {
          var elapsedTime = now() - profilerStartTime;
          fiber.actualDuration += elapsedTime;

          if (overrideBaseTime) {
            fiber.selfBaseDuration = elapsedTime;
          }

          profilerStartTime = -1;
        }
      }

      var hasOwnProperty = Object.prototype.hasOwnProperty;

      function is(x, y) {
        if (x === y) {
          return x !== 0 || y !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }

      function shallowEqual(objA, objB) {
        if (is(objA, objB)) {
          return true;
        }

        if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
          return false;
        }

        var keysA = Object.keys(objA);
        var keysB = Object.keys(objB);

        if (keysA.length !== keysB.length) {
          return false;
        }

        for (var i = 0; i < keysA.length; i++) {
          if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
            return false;
          }
        }

        return true;
      }

      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = _extends({}, baseProps);

          var defaultProps = Component.defaultProps;

          for (var propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }

          return props;
        }

        return baseProps;
      }

      function readLazyComponentType(lazyComponent) {
        var status = lazyComponent._status;
        var result = lazyComponent._result;

        switch (status) {
          case Resolved:
            {
              var Component = result;
              return Component;
            }

          case Rejected:
            {
              var error = result;
              throw error;
            }

          case Pending:
            {
              var thenable = result;
              throw thenable;
            }

          default:
            {
              lazyComponent._status = Pending;
              var ctor = lazyComponent._ctor;

              var _thenable = ctor();

              _thenable.then(function (moduleObject) {
                if (lazyComponent._status === Pending) {
                  var defaultExport = moduleObject.default;
                  {
                    if (defaultExport === undefined) {
                      warning$1(false, "lazy: Expected the result of a dynamic import() call. " + "Instead received: %s\n\nYour code should look like: \n  " + "const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                    }
                  }
                  lazyComponent._status = Resolved;
                  lazyComponent._result = defaultExport;
                }
              }, function (error) {
                if (lazyComponent._status === Pending) {
                  lazyComponent._status = Rejected;
                  lazyComponent._result = error;
                }
              });

              lazyComponent._result = _thenable;
              throw _thenable;
            }
        }
      }

      var ReactCurrentOwner$4 = ReactSharedInternals.ReactCurrentOwner;

      function readContext$1(contextType) {
        var dispatcher = ReactCurrentOwner$4.currentDispatcher;
        return dispatcher.readContext(contextType);
      }

      var fakeInternalInstance = {};
      var isArray$1 = Array.isArray;
      var emptyRefsObject = new React.Component().refs;
      var didWarnAboutStateAssignmentForComponent = void 0;
      var didWarnAboutUninitializedState = void 0;
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;
      var didWarnAboutLegacyLifecyclesAndDerivedState = void 0;
      var didWarnAboutUndefinedDerivedState = void 0;
      var warnOnUndefinedDerivedState = void 0;
      var warnOnInvalidCallback = void 0;
      var didWarnAboutDirectlyAssigningPropsToState = void 0;
      var didWarnAboutContextTypeAndContextTypes = void 0;
      var didWarnAboutInvalidateContextType = void 0;
      {
        didWarnAboutStateAssignmentForComponent = new Set();
        didWarnAboutUninitializedState = new Set();
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
        didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
        didWarnAboutDirectlyAssigningPropsToState = new Set();
        didWarnAboutUndefinedDerivedState = new Set();
        didWarnAboutContextTypeAndContextTypes = new Set();
        didWarnAboutInvalidateContextType = new Set();
        var didWarnOnInvalidCallback = new Set();

        warnOnInvalidCallback = function warnOnInvalidCallback(callback, callerName) {
          if (callback === null || typeof callback === "function") {
            return;
          }

          var key = callerName + "_" + callback;

          if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            warningWithoutStack$1(false, "%s(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callerName, callback);
          }
        };

        warnOnUndefinedDerivedState = function warnOnUndefinedDerivedState(type, partialState) {
          if (partialState === undefined) {
            var componentName = getComponentName(type) || "Component";

            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
              didWarnAboutUndefinedDerivedState.add(componentName);
              warningWithoutStack$1(false, "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. " + "You have returned undefined.", componentName);
            }
          }
        };

        Object.defineProperty(fakeInternalInstance, "_processChildContext", {
          enumerable: false,
          value: function value() {
            invariant(false, "_processChildContext is not available in React 16+. This likely " + "means you have multiple copies of React and are attempting to nest " + "a React 15 tree inside a React 16 tree using " + "unstable_renderSubtreeIntoContainer, which isn't supported. Try " + "to make sure you have only one copy of React (and ideally, switch " + "to ReactDOM.createPortal).");
          }
        });
        Object.freeze(fakeInternalInstance);
      }

      function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
        var prevState = workInProgress.memoizedState;
        {
          if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
            getDerivedStateFromProps(nextProps, prevState);
          }
        }
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        {
          warnOnUndefinedDerivedState(ctor, partialState);
        }
        var memoizedState = partialState === null || partialState === undefined ? prevState : _extends({}, prevState, partialState);
        workInProgress.memoizedState = memoizedState;
        var updateQueue = workInProgress.updateQueue;

        if (updateQueue !== null && workInProgress.expirationTime === NoWork) {
          updateQueue.baseState = memoizedState;
        }
      }

      var classComponentUpdater = {
        isMounted: isMounted,
        enqueueSetState: function enqueueSetState(inst, payload, callback) {
          var fiber = get$1(inst);
          var currentTime = requestCurrentTime();
          var expirationTime = computeExpirationForFiber(currentTime, fiber);
          var update = createUpdate(expirationTime);
          update.payload = payload;

          if (callback !== undefined && callback !== null) {
            {
              warnOnInvalidCallback(callback, "setState");
            }
            update.callback = callback;
          }

          flushPassiveEffects();
          enqueueUpdate(fiber, update);
          scheduleWork(fiber, expirationTime);
        },
        enqueueReplaceState: function enqueueReplaceState(inst, payload, callback) {
          var fiber = get$1(inst);
          var currentTime = requestCurrentTime();
          var expirationTime = computeExpirationForFiber(currentTime, fiber);
          var update = createUpdate(expirationTime);
          update.tag = ReplaceState;
          update.payload = payload;

          if (callback !== undefined && callback !== null) {
            {
              warnOnInvalidCallback(callback, "replaceState");
            }
            update.callback = callback;
          }

          flushPassiveEffects();
          enqueueUpdate(fiber, update);
          scheduleWork(fiber, expirationTime);
        },
        enqueueForceUpdate: function enqueueForceUpdate(inst, callback) {
          var fiber = get$1(inst);
          var currentTime = requestCurrentTime();
          var expirationTime = computeExpirationForFiber(currentTime, fiber);
          var update = createUpdate(expirationTime);
          update.tag = ForceUpdate;

          if (callback !== undefined && callback !== null) {
            {
              warnOnInvalidCallback(callback, "forceUpdate");
            }
            update.callback = callback;
          }

          flushPassiveEffects();
          enqueueUpdate(fiber, update);
          scheduleWork(fiber, expirationTime);
        }
      };

      function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
        var instance = workInProgress.stateNode;

        if (typeof instance.shouldComponentUpdate === "function") {
          startPhaseTimer(workInProgress, "shouldComponentUpdate");
          var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
          stopPhaseTimer();
          {
            !(shouldUpdate !== undefined) ? warningWithoutStack$1(false, "%s.shouldComponentUpdate(): Returned undefined instead of a " + "boolean value. Make sure to return true or false.", getComponentName(ctor) || "Component") : void 0;
          }
          return shouldUpdate;
        }

        if (ctor.prototype && ctor.prototype.isPureReactComponent) {
          return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
        }

        return true;
      }

      function checkClassInstance(workInProgress, ctor, newProps) {
        var instance = workInProgress.stateNode;
        {
          var name = getComponentName(ctor) || "Component";
          var renderPresent = instance.render;

          if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === "function") {
              warningWithoutStack$1(false, "%s(...): No `render` method found on the returned component " + "instance: did you accidentally return an object from the constructor?", name);
            } else {
              warningWithoutStack$1(false, "%s(...): No `render` method found on the returned component " + "instance: you may have forgotten to define `render`.", name);
            }
          }

          var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
          !noGetInitialStateOnES6 ? warningWithoutStack$1(false, "getInitialState was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Did you mean to define a state property instead?", name) : void 0;
          var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
          !noGetDefaultPropsOnES6 ? warningWithoutStack$1(false, "getDefaultProps was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Use a static property to define defaultProps instead.", name) : void 0;
          var noInstancePropTypes = !instance.propTypes;
          !noInstancePropTypes ? warningWithoutStack$1(false, "propTypes was defined as an instance property on %s. Use a static " + "property to define propTypes instead.", name) : void 0;
          var noInstanceContextType = !instance.contextType;
          !noInstanceContextType ? warningWithoutStack$1(false, "contextType was defined as an instance property on %s. Use a static " + "property to define contextType instead.", name) : void 0;
          var noInstanceContextTypes = !instance.contextTypes;
          !noInstanceContextTypes ? warningWithoutStack$1(false, "contextTypes was defined as an instance property on %s. Use a static " + "property to define contextTypes instead.", name) : void 0;

          if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
            didWarnAboutContextTypeAndContextTypes.add(ctor);
            warningWithoutStack$1(false, "%s declares both contextTypes and contextType static properties. " + "The legacy contextTypes property will be ignored.", name);
          }

          var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== "function";
          !noComponentShouldUpdate ? warningWithoutStack$1(false, "%s has a method called " + "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " + "The name is phrased as a question because the function is " + "expected to return a value.", name) : void 0;

          if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
            warningWithoutStack$1(false, "%s has a method called shouldComponentUpdate(). " + "shouldComponentUpdate should not be used when extending React.PureComponent. " + "Please extend React.Component if shouldComponentUpdate is used.", getComponentName(ctor) || "A pure component");
          }

          var noComponentDidUnmount = typeof instance.componentDidUnmount !== "function";
          !noComponentDidUnmount ? warningWithoutStack$1(false, "%s has a method called " + "componentDidUnmount(). But there is no such lifecycle method. " + "Did you mean componentWillUnmount()?", name) : void 0;
          var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== "function";
          !noComponentDidReceiveProps ? warningWithoutStack$1(false, "%s has a method called " + "componentDidReceiveProps(). But there is no such lifecycle method. " + "If you meant to update the state in response to changing props, " + "use componentWillReceiveProps(). If you meant to fetch data or " + "run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name) : void 0;
          var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== "function";
          !noComponentWillRecieveProps ? warningWithoutStack$1(false, "%s has a method called " + "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name) : void 0;
          var noUnsafeComponentWillRecieveProps = typeof instance.UNSAFE_componentWillRecieveProps !== "function";
          !noUnsafeComponentWillRecieveProps ? warningWithoutStack$1(false, "%s has a method called " + "UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name) : void 0;
          var hasMutatedProps = instance.props !== newProps;
          !(instance.props === undefined || !hasMutatedProps) ? warningWithoutStack$1(false, "%s(...): When calling super() in `%s`, make sure to pass " + "up the same props that your component's constructor was passed.", name, name) : void 0;
          var noInstanceDefaultProps = !instance.defaultProps;
          !noInstanceDefaultProps ? warningWithoutStack$1(false, "Setting defaultProps as an instance property on %s is not supported and will be ignored." + " Instead, define defaultProps as a static property on %s.", name, name) : void 0;

          if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            warningWithoutStack$1(false, "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). " + "This component defines getSnapshotBeforeUpdate() only.", getComponentName(ctor));
          }

          var noInstanceGetDerivedStateFromProps = typeof instance.getDerivedStateFromProps !== "function";
          !noInstanceGetDerivedStateFromProps ? warningWithoutStack$1(false, "%s: getDerivedStateFromProps() is defined as an instance method " + "and will be ignored. Instead, declare it as a static method.", name) : void 0;
          var noInstanceGetDerivedStateFromCatch = typeof instance.getDerivedStateFromError !== "function";
          !noInstanceGetDerivedStateFromCatch ? warningWithoutStack$1(false, "%s: getDerivedStateFromError() is defined as an instance method " + "and will be ignored. Instead, declare it as a static method.", name) : void 0;
          var noStaticGetSnapshotBeforeUpdate = typeof ctor.getSnapshotBeforeUpdate !== "function";
          !noStaticGetSnapshotBeforeUpdate ? warningWithoutStack$1(false, "%s: getSnapshotBeforeUpdate() is defined as a static method " + "and will be ignored. Instead, declare it as an instance method.", name) : void 0;
          var _state = instance.state;

          if (_state && (typeof _state !== "object" || isArray$1(_state))) {
            warningWithoutStack$1(false, "%s.state: must be set to an object or null", name);
          }

          if (typeof instance.getChildContext === "function") {
            !(typeof ctor.childContextTypes === "object") ? warningWithoutStack$1(false, "%s.getChildContext(): childContextTypes must be defined in order to " + "use getChildContext().", name) : void 0;
          }
        }
      }

      function adoptClassInstance(workInProgress, instance) {
        instance.updater = classComponentUpdater;
        workInProgress.stateNode = instance;
        set(instance, workInProgress);
        {
          instance._reactInternalInstance = fakeInternalInstance;
        }
      }

      function constructClassInstance(workInProgress, ctor, props, renderExpirationTime) {
        var isLegacyContextConsumer = false;
        var unmaskedContext = emptyContextObject;
        var context = null;
        var contextType = ctor.contextType;

        if (typeof contextType === "object" && contextType !== null) {
          {
            if (contextType.$$typeof !== REACT_CONTEXT_TYPE && !didWarnAboutInvalidateContextType.has(ctor)) {
              didWarnAboutInvalidateContextType.add(ctor);
              warningWithoutStack$1(false, "%s defines an invalid contextType. " + "contextType should point to the Context object returned by React.createContext(). " + "Did you accidentally pass the Context.Provider instead?", getComponentName(ctor) || "Component");
            }
          }
          context = readContext$1(contextType);
        } else {
          unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
          var contextTypes = ctor.contextTypes;
          isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;
          context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;
        }

        {
          if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
            new ctor(props, context);
          }
        }
        var instance = new ctor(props, context);
        var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;
        adoptClassInstance(workInProgress, instance);
        {
          if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
            var componentName = getComponentName(ctor) || "Component";

            if (!didWarnAboutUninitializedState.has(componentName)) {
              didWarnAboutUninitializedState.add(componentName);
              warningWithoutStack$1(false, "`%s` uses `getDerivedStateFromProps` but its initial state is " + "%s. This is not recommended. Instead, define the initial state by " + "assigning an object to `this.state` in the constructor of `%s`. " + "This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
            }
          }

          if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;

            if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
              foundWillMountName = "componentWillMount";
            } else if (typeof instance.UNSAFE_componentWillMount === "function") {
              foundWillMountName = "UNSAFE_componentWillMount";
            }

            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              foundWillReceivePropsName = "componentWillReceiveProps";
            } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
            }

            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              foundWillUpdateName = "componentWillUpdate";
            } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              foundWillUpdateName = "UNSAFE_componentWillUpdate";
            }

            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentName(ctor) || "Component";

              var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";

              if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                warningWithoutStack$1(false, "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + "%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n" + "The above lifecycles should be removed. Learn more about this warning here:\n" + "https://fb.me/react-async-component-lifecycle-hooks", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
              }
            }
          }
        }

        if (isLegacyContextConsumer) {
          cacheContext(workInProgress, unmaskedContext, context);
        }

        return instance;
      }

      function callComponentWillMount(workInProgress, instance) {
        startPhaseTimer(workInProgress, "componentWillMount");
        var oldState = instance.state;

        if (typeof instance.componentWillMount === "function") {
          instance.componentWillMount();
        }

        if (typeof instance.UNSAFE_componentWillMount === "function") {
          instance.UNSAFE_componentWillMount();
        }

        stopPhaseTimer();

        if (oldState !== instance.state) {
          {
            warningWithoutStack$1(false, "%s.componentWillMount(): Assigning directly to this.state is " + "deprecated (except inside a component's " + "constructor). Use setState instead.", getComponentName(workInProgress.type) || "Component");
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }

      function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
        var oldState = instance.state;
        startPhaseTimer(workInProgress, "componentWillReceiveProps");

        if (typeof instance.componentWillReceiveProps === "function") {
          instance.componentWillReceiveProps(newProps, nextContext);
        }

        if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
          instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        }

        stopPhaseTimer();

        if (instance.state !== oldState) {
          {
            var componentName = getComponentName(workInProgress.type) || "Component";

            if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
              didWarnAboutStateAssignmentForComponent.add(componentName);
              warningWithoutStack$1(false, "%s.componentWillReceiveProps(): Assigning directly to " + "this.state is deprecated (except inside a component's " + "constructor). Use setState instead.", componentName);
            }
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }

      function mountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
        {
          checkClassInstance(workInProgress, ctor, newProps);
        }
        var instance = workInProgress.stateNode;
        instance.props = newProps;
        instance.state = workInProgress.memoizedState;
        instance.refs = emptyRefsObject;
        var contextType = ctor.contextType;

        if (typeof contextType === "object" && contextType !== null) {
          instance.context = readContext$1(contextType);
        } else {
          var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
          instance.context = getMaskedContext(workInProgress, unmaskedContext);
        }

        {
          if (instance.state === newProps) {
            var componentName = getComponentName(ctor) || "Component";

            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
              didWarnAboutDirectlyAssigningPropsToState.add(componentName);
              warningWithoutStack$1(false, "%s: It is not recommended to assign props directly to state " + "because updates to props won't be reflected in state. " + "In most cases, it is better to use props directly.", componentName);
            }
          }

          if (workInProgress.mode & StrictMode) {
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);
            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);
          }

          if (warnAboutDeprecatedLifecycles) {
            ReactStrictModeWarnings.recordDeprecationWarnings(workInProgress, instance);
          }
        }
        var updateQueue = workInProgress.updateQueue;

        if (updateQueue !== null) {
          processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
          instance.state = workInProgress.memoizedState;
        }

        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;

        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
          instance.state = workInProgress.memoizedState;
        }

        if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
          callComponentWillMount(workInProgress, instance);
          updateQueue = workInProgress.updateQueue;

          if (updateQueue !== null) {
            processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
            instance.state = workInProgress.memoizedState;
          }
        }

        if (typeof instance.componentDidMount === "function") {
          workInProgress.effectTag |= Update;
        }
      }

      function resumeMountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
        var instance = workInProgress.stateNode;
        var oldProps = workInProgress.memoizedProps;
        instance.props = oldProps;
        var oldContext = instance.context;
        var contextType = ctor.contextType;
        var nextContext = void 0;

        if (typeof contextType === "object" && contextType !== null) {
          nextContext = readContext$1(contextType);
        } else {
          var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
          nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
        }

        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";

        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
          if (oldProps !== newProps || oldContext !== nextContext) {
            callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
          }
        }

        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress.memoizedState;
        var newState = instance.state = oldState;
        var updateQueue = workInProgress.updateQueue;

        if (updateQueue !== null) {
          processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
          newState = workInProgress.memoizedState;
        }

        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
          if (typeof instance.componentDidMount === "function") {
            workInProgress.effectTag |= Update;
          }

          return false;
        }

        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
          newState = workInProgress.memoizedState;
        }

        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

        if (shouldUpdate) {
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            startPhaseTimer(workInProgress, "componentWillMount");

            if (typeof instance.componentWillMount === "function") {
              instance.componentWillMount();
            }

            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }

            stopPhaseTimer();
          }

          if (typeof instance.componentDidMount === "function") {
            workInProgress.effectTag |= Update;
          }
        } else {
          if (typeof instance.componentDidMount === "function") {
            workInProgress.effectTag |= Update;
          }

          workInProgress.memoizedProps = newProps;
          workInProgress.memoizedState = newState;
        }

        instance.props = newProps;
        instance.state = newState;
        instance.context = nextContext;
        return shouldUpdate;
      }

      function updateClassInstance(current, workInProgress, ctor, newProps, renderExpirationTime) {
        var instance = workInProgress.stateNode;
        var oldProps = workInProgress.memoizedProps;
        instance.props = workInProgress.type === workInProgress.elementType ? oldProps : resolveDefaultProps(workInProgress.type, oldProps);
        var oldContext = instance.context;
        var contextType = ctor.contextType;
        var nextContext = void 0;

        if (typeof contextType === "object" && contextType !== null) {
          nextContext = readContext$1(contextType);
        } else {
          var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
          nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
        }

        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";

        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
          if (oldProps !== newProps || oldContext !== nextContext) {
            callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
          }
        }

        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress.memoizedState;
        var newState = instance.state = oldState;
        var updateQueue = workInProgress.updateQueue;

        if (updateQueue !== null) {
          processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
          newState = workInProgress.memoizedState;
        }

        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
          if (typeof instance.componentDidUpdate === "function") {
            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
              workInProgress.effectTag |= Update;
            }
          }

          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
              workInProgress.effectTag |= Snapshot;
            }
          }

          return false;
        }

        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
          newState = workInProgress.memoizedState;
        }

        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

        if (shouldUpdate) {
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
            startPhaseTimer(workInProgress, "componentWillUpdate");

            if (typeof instance.componentWillUpdate === "function") {
              instance.componentWillUpdate(newProps, newState, nextContext);
            }

            if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
            }

            stopPhaseTimer();
          }

          if (typeof instance.componentDidUpdate === "function") {
            workInProgress.effectTag |= Update;
          }

          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            workInProgress.effectTag |= Snapshot;
          }
        } else {
          if (typeof instance.componentDidUpdate === "function") {
            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
              workInProgress.effectTag |= Update;
            }
          }

          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
              workInProgress.effectTag |= Snapshot;
            }
          }

          workInProgress.memoizedProps = newProps;
          workInProgress.memoizedState = newState;
        }

        instance.props = newProps;
        instance.state = newState;
        instance.context = nextContext;
        return shouldUpdate;
      }

      var didWarnAboutMaps = void 0;
      var didWarnAboutGenerators = void 0;
      var didWarnAboutStringRefInStrictMode = void 0;
      var ownerHasKeyUseWarning = void 0;
      var ownerHasFunctionTypeWarning = void 0;

      var warnForMissingKey = function warnForMissingKey(child) {};

      {
        didWarnAboutMaps = false;
        didWarnAboutGenerators = false;
        didWarnAboutStringRefInStrictMode = {};
        ownerHasKeyUseWarning = {};
        ownerHasFunctionTypeWarning = {};

        warnForMissingKey = function warnForMissingKey(child) {
          if (child === null || typeof child !== "object") {
            return;
          }

          if (!child._store || child._store.validated || child.key != null) {
            return;
          }

          invariant(typeof child._store === "object", "React Component in warnForMissingKey should have a _store. " + "This error is likely caused by a bug in React. Please file an issue.");
          child._store.validated = true;
          var currentComponentErrorInfo = "Each child in an array or iterator should have a unique " + '"key" prop. See https://fb.me/react-warning-keys for ' + "more information." + getCurrentFiberStackInDev();

          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }

          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          warning$1(false, "Each child in an array or iterator should have a unique " + '"key" prop. See https://fb.me/react-warning-keys for ' + "more information.");
        };
      }
      var isArray = Array.isArray;

      function coerceRef(returnFiber, current$$1, element) {
        var mixedRef = element.ref;

        if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
          {
            if (returnFiber.mode & StrictMode) {
              var componentName = getComponentName(returnFiber.type) || "Component";

              if (!didWarnAboutStringRefInStrictMode[componentName]) {
                warningWithoutStack$1(false, 'A string ref, "%s", has been found within a strict mode tree. ' + "String refs are a source of potential bugs and should be avoided. " + "We recommend using createRef() instead." + "\n%s" + "\n\nLearn more about using refs safely here:" + "\nhttps://fb.me/react-strict-mode-string-ref", mixedRef, getStackByFiberInDevAndProd(returnFiber));
                didWarnAboutStringRefInStrictMode[componentName] = true;
              }
            }
          }

          if (element._owner) {
            var owner = element._owner;
            var inst = void 0;

            if (owner) {
              var ownerFiber = owner;
              invariant(ownerFiber.tag === ClassComponent, "Function components cannot have refs.");
              inst = ownerFiber.stateNode;
            }

            invariant(inst, "Missing owner for string ref %s. This error is likely caused by a " + "bug in React. Please file an issue.", mixedRef);
            var stringRef = "" + mixedRef;

            if (current$$1 !== null && current$$1.ref !== null && typeof current$$1.ref === "function" && current$$1.ref._stringRef === stringRef) {
              return current$$1.ref;
            }

            var ref = function ref(value) {
              var refs = inst.refs;

              if (refs === emptyRefsObject) {
                refs = inst.refs = {};
              }

              if (value === null) {
                delete refs[stringRef];
              } else {
                refs[stringRef] = value;
              }
            };

            ref._stringRef = stringRef;
            return ref;
          } else {
            invariant(typeof mixedRef === "string", "Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
            invariant(element._owner, "Element ref was specified as a string (%s) but no owner was set. This could happen for one of" + " the following reasons:\n" + "1. You may be adding a ref to a function component\n" + "2. You may be adding a ref to a component that was not created inside a component's render method\n" + "3. You have multiple copies of React loaded\n" + "See https://fb.me/react-refs-must-have-owner for more information.", mixedRef);
          }
        }

        return mixedRef;
      }

      function throwOnInvalidObjectType(returnFiber, newChild) {
        if (returnFiber.type !== "textarea") {
          var addendum = "";
          {
            addendum = " If you meant to render a collection of children, use an array " + "instead." + getCurrentFiberStackInDev();
          }
          invariant(false, "Objects are not valid as a React child (found: %s).%s", Object.prototype.toString.call(newChild) === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : newChild, addendum);
        }
      }

      function warnOnFunctionType() {
        var currentComponentErrorInfo = "Functions are not valid as a React child. This may happen if " + "you return a Component instead of <Component /> from render. " + "Or maybe you meant to call this function rather than return it." + getCurrentFiberStackInDev();

        if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
          return;
        }

        ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;
        warning$1(false, "Functions are not valid as a React child. This may happen if " + "you return a Component instead of <Component /> from render. " + "Or maybe you meant to call this function rather than return it.");
      }

      function ChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (!shouldTrackSideEffects) {
            return;
          }

          var last = returnFiber.lastEffect;

          if (last !== null) {
            last.nextEffect = childToDelete;
            returnFiber.lastEffect = childToDelete;
          } else {
            returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
          }

          childToDelete.nextEffect = null;
          childToDelete.effectTag = Deletion;
        }

        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) {
            return null;
          }

          var childToDelete = currentFirstChild;

          while (childToDelete !== null) {
            deleteChild(returnFiber, childToDelete);
            childToDelete = childToDelete.sibling;
          }

          return null;
        }

        function mapRemainingChildren(returnFiber, currentFirstChild) {
          var existingChildren = new Map();
          var existingChild = currentFirstChild;

          while (existingChild !== null) {
            if (existingChild.key !== null) {
              existingChildren.set(existingChild.key, existingChild);
            } else {
              existingChildren.set(existingChild.index, existingChild);
            }

            existingChild = existingChild.sibling;
          }

          return existingChildren;
        }

        function useFiber(fiber, pendingProps, expirationTime) {
          var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
          clone.index = 0;
          clone.sibling = null;
          return clone;
        }

        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;

          if (!shouldTrackSideEffects) {
            return lastPlacedIndex;
          }

          var current$$1 = newFiber.alternate;

          if (current$$1 !== null) {
            var oldIndex = current$$1.index;

            if (oldIndex < lastPlacedIndex) {
              newFiber.effectTag = Placement;
              return lastPlacedIndex;
            } else {
              return oldIndex;
            }
          } else {
            newFiber.effectTag = Placement;
            return lastPlacedIndex;
          }
        }

        function placeSingleChild(newFiber) {
          if (shouldTrackSideEffects && newFiber.alternate === null) {
            newFiber.effectTag = Placement;
          }

          return newFiber;
        }

        function updateTextNode(returnFiber, current$$1, textContent, expirationTime) {
          if (current$$1 === null || current$$1.tag !== HostText) {
            var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current$$1, textContent, expirationTime);
            existing.return = returnFiber;
            return existing;
          }
        }

        function updateElement(returnFiber, current$$1, element, expirationTime) {
          if (current$$1 !== null && current$$1.elementType === element.type) {
            var existing = useFiber(current$$1, element.props, expirationTime);
            existing.ref = coerceRef(returnFiber, current$$1, element);
            existing.return = returnFiber;
            {
              existing._debugSource = element._source;
              existing._debugOwner = element._owner;
            }
            return existing;
          } else {
            var created = createFiberFromElement(element, returnFiber.mode, expirationTime);
            created.ref = coerceRef(returnFiber, current$$1, element);
            created.return = returnFiber;
            return created;
          }
        }

        function updatePortal(returnFiber, current$$1, portal, expirationTime) {
          if (current$$1 === null || current$$1.tag !== HostPortal || current$$1.stateNode.containerInfo !== portal.containerInfo || current$$1.stateNode.implementation !== portal.implementation) {
            var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current$$1, portal.children || [], expirationTime);
            existing.return = returnFiber;
            return existing;
          }
        }

        function updateFragment(returnFiber, current$$1, fragment, expirationTime, key) {
          if (current$$1 === null || current$$1.tag !== Fragment) {
            var created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current$$1, fragment, expirationTime);
            existing.return = returnFiber;
            return existing;
          }
        }

        function createChild(returnFiber, newChild, expirationTime) {
          if (typeof newChild === "string" || typeof newChild === "number") {
            var created = createFiberFromText("" + newChild, returnFiber.mode, expirationTime);
            created.return = returnFiber;
            return created;
          }

          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                {
                  var _created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);

                  _created.ref = coerceRef(returnFiber, null, newChild);
                  _created.return = returnFiber;
                  return _created;
                }

              case REACT_PORTAL_TYPE:
                {
                  var _created2 = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);

                  _created2.return = returnFiber;
                  return _created2;
                }
            }

            if (isArray(newChild) || getIteratorFn(newChild)) {
              var _created3 = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null);

              _created3.return = returnFiber;
              return _created3;
            }

            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }
          return null;
        }

        function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
          var key = oldFiber !== null ? oldFiber.key : null;

          if (typeof newChild === "string" || typeof newChild === "number") {
            if (key !== null) {
              return null;
            }

            return updateTextNode(returnFiber, oldFiber, "" + newChild, expirationTime);
          }

          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                {
                  if (newChild.key === key) {
                    if (newChild.type === REACT_FRAGMENT_TYPE) {
                      return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
                    }

                    return updateElement(returnFiber, oldFiber, newChild, expirationTime);
                  } else {
                    return null;
                  }
                }

              case REACT_PORTAL_TYPE:
                {
                  if (newChild.key === key) {
                    return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
                  } else {
                    return null;
                  }
                }
            }

            if (isArray(newChild) || getIteratorFn(newChild)) {
              if (key !== null) {
                return null;
              }

              return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
            }

            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }
          return null;
        }

        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
          if (typeof newChild === "string" || typeof newChild === "number") {
            var matchedFiber = existingChildren.get(newIdx) || null;
            return updateTextNode(returnFiber, matchedFiber, "" + newChild, expirationTime);
          }

          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                {
                  var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

                  if (newChild.type === REACT_FRAGMENT_TYPE) {
                    return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
                  }

                  return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
                }

              case REACT_PORTAL_TYPE:
                {
                  var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

                  return updatePortal(returnFiber, _matchedFiber2, newChild, expirationTime);
                }
            }

            if (isArray(newChild) || getIteratorFn(newChild)) {
              var _matchedFiber3 = existingChildren.get(newIdx) || null;

              return updateFragment(returnFiber, _matchedFiber3, newChild, expirationTime, null);
            }

            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }
          return null;
        }

        function warnOnInvalidKey(child, knownKeys) {
          {
            if (typeof child !== "object" || child === null) {
              return knownKeys;
            }

            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(child);
                var key = child.key;

                if (typeof key !== "string") {
                  break;
                }

                if (knownKeys === null) {
                  knownKeys = new Set();
                  knownKeys.add(key);
                  break;
                }

                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }

                warning$1(false, "Encountered two children with the same key, `%s`. " + "Keys should be unique so that components maintain their identity " + "across updates. Non-unique keys may cause children to be " + "duplicated and/or omitted — the behavior is unsupported and " + "could change in a future version.", key);
                break;

              default:
                break;
            }
          }
          return knownKeys;
        }

        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
          {
            var knownKeys = null;

            for (var i = 0; i < newChildren.length; i++) {
              var child = newChildren[i];
              knownKeys = warnOnInvalidKey(child, knownKeys);
            }
          }
          var resultingFirstChild = null;
          var previousNewFiber = null;
          var oldFiber = currentFirstChild;
          var lastPlacedIndex = 0;
          var newIdx = 0;
          var nextOldFiber = null;

          for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
            if (oldFiber.index > newIdx) {
              nextOldFiber = oldFiber;
              oldFiber = null;
            } else {
              nextOldFiber = oldFiber.sibling;
            }

            var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);

            if (newFiber === null) {
              if (oldFiber === null) {
                oldFiber = nextOldFiber;
              }

              break;
            }

            if (shouldTrackSideEffects) {
              if (oldFiber && newFiber.alternate === null) {
                deleteChild(returnFiber, oldFiber);
              }
            }

            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

            if (previousNewFiber === null) {
              resultingFirstChild = newFiber;
            } else {
              previousNewFiber.sibling = newFiber;
            }

            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }

          if (newIdx === newChildren.length) {
            deleteRemainingChildren(returnFiber, oldFiber);
            return resultingFirstChild;
          }

          if (oldFiber === null) {
            for (; newIdx < newChildren.length; newIdx++) {
              var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);

              if (!_newFiber) {
                continue;
              }

              lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber;
              } else {
                previousNewFiber.sibling = _newFiber;
              }

              previousNewFiber = _newFiber;
            }

            return resultingFirstChild;
          }

          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

          for (; newIdx < newChildren.length; newIdx++) {
            var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);

            if (_newFiber2) {
              if (shouldTrackSideEffects) {
                if (_newFiber2.alternate !== null) {
                  existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                }
              }

              lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber2;
              } else {
                previousNewFiber.sibling = _newFiber2;
              }

              previousNewFiber = _newFiber2;
            }
          }

          if (shouldTrackSideEffects) {
            existingChildren.forEach(function (child) {
              return deleteChild(returnFiber, child);
            });
          }

          return resultingFirstChild;
        }

        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
          var iteratorFn = getIteratorFn(newChildrenIterable);
          invariant(typeof iteratorFn === "function", "An object is not an iterable. This error is likely caused by a bug in " + "React. Please file an issue.");
          {
            if (typeof Symbol === "function" && newChildrenIterable[typeof Symbol === "function" ? Symbol.toStringTag : "@@toStringTag"] === "Generator") {
              !didWarnAboutGenerators ? warning$1(false, "Using Generators as children is unsupported and will likely yield " + "unexpected results because enumerating a generator mutates it. " + "You may convert it to an array with `Array.from()` or the " + "`[...spread]` operator before rendering. Keep in mind " + "you might need to polyfill these features for older browsers.") : void 0;
              didWarnAboutGenerators = true;
            }

            if (newChildrenIterable.entries === iteratorFn) {
              !didWarnAboutMaps ? warning$1(false, "Using Maps as children is unsupported and will likely yield " + "unexpected results. Convert it to a sequence/iterable of keyed " + "ReactElements instead.") : void 0;
              didWarnAboutMaps = true;
            }

            var _newChildren = iteratorFn.call(newChildrenIterable);

            if (_newChildren) {
              var knownKeys = null;

              var _step = _newChildren.next();

              for (; !_step.done; _step = _newChildren.next()) {
                var child = _step.value;
                knownKeys = warnOnInvalidKey(child, knownKeys);
              }
            }
          }
          var newChildren = iteratorFn.call(newChildrenIterable);
          invariant(newChildren != null, "An iterable object provided no iterator.");
          var resultingFirstChild = null;
          var previousNewFiber = null;
          var oldFiber = currentFirstChild;
          var lastPlacedIndex = 0;
          var newIdx = 0;
          var nextOldFiber = null;
          var step = newChildren.next();

          for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
            if (oldFiber.index > newIdx) {
              nextOldFiber = oldFiber;
              oldFiber = null;
            } else {
              nextOldFiber = oldFiber.sibling;
            }

            var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);

            if (newFiber === null) {
              if (!oldFiber) {
                oldFiber = nextOldFiber;
              }

              break;
            }

            if (shouldTrackSideEffects) {
              if (oldFiber && newFiber.alternate === null) {
                deleteChild(returnFiber, oldFiber);
              }
            }

            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

            if (previousNewFiber === null) {
              resultingFirstChild = newFiber;
            } else {
              previousNewFiber.sibling = newFiber;
            }

            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }

          if (step.done) {
            deleteRemainingChildren(returnFiber, oldFiber);
            return resultingFirstChild;
          }

          if (oldFiber === null) {
            for (; !step.done; newIdx++, step = newChildren.next()) {
              var _newFiber3 = createChild(returnFiber, step.value, expirationTime);

              if (_newFiber3 === null) {
                continue;
              }

              lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber3;
              } else {
                previousNewFiber.sibling = _newFiber3;
              }

              previousNewFiber = _newFiber3;
            }

            return resultingFirstChild;
          }

          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

          for (; !step.done; newIdx++, step = newChildren.next()) {
            var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);

            if (_newFiber4 !== null) {
              if (shouldTrackSideEffects) {
                if (_newFiber4.alternate !== null) {
                  existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                }
              }

              lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber4;
              } else {
                previousNewFiber.sibling = _newFiber4;
              }

              previousNewFiber = _newFiber4;
            }
          }

          if (shouldTrackSideEffects) {
            existingChildren.forEach(function (child) {
              return deleteChild(returnFiber, child);
            });
          }

          return resultingFirstChild;
        }

        function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
          if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
            var existing = useFiber(currentFirstChild, textContent, expirationTime);
            existing.return = returnFiber;
            return existing;
          }

          deleteRemainingChildren(returnFiber, currentFirstChild);
          var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
          created.return = returnFiber;
          return created;
        }

        function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
          var key = element.key;
          var child = currentFirstChild;

          while (child !== null) {
            if (child.key === key) {
              if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.elementType === element.type) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
                existing.ref = coerceRef(returnFiber, child, element);
                existing.return = returnFiber;
                {
                  existing._debugSource = element._source;
                  existing._debugOwner = element._owner;
                }
                return existing;
              } else {
                deleteRemainingChildren(returnFiber, child);
                break;
              }
            } else {
              deleteChild(returnFiber, child);
            }

            child = child.sibling;
          }

          if (element.type === REACT_FRAGMENT_TYPE) {
            var created = createFiberFromFragment(element.props.children, returnFiber.mode, expirationTime, element.key);
            created.return = returnFiber;
            return created;
          } else {
            var _created4 = createFiberFromElement(element, returnFiber.mode, expirationTime);

            _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
            _created4.return = returnFiber;
            return _created4;
          }
        }

        function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
          var key = portal.key;
          var child = currentFirstChild;

          while (child !== null) {
            if (child.key === key) {
              if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, portal.children || [], expirationTime);
                existing.return = returnFiber;
                return existing;
              } else {
                deleteRemainingChildren(returnFiber, child);
                break;
              }
            } else {
              deleteChild(returnFiber, child);
            }

            child = child.sibling;
          }

          var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);
          created.return = returnFiber;
          return created;
        }

        function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
          var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;

          if (isUnkeyedTopLevelFragment) {
            newChild = newChild.props.children;
          }

          var isObject = typeof newChild === "object" && newChild !== null;

          if (isObject) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));

              case REACT_PORTAL_TYPE:
                return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
            }
          }

          if (typeof newChild === "string" || typeof newChild === "number") {
            return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, expirationTime));
          }

          if (isArray(newChild)) {
            return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
          }

          if (getIteratorFn(newChild)) {
            return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
          }

          if (isObject) {
            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }

          if (typeof newChild === "undefined" && !isUnkeyedTopLevelFragment) {
            switch (returnFiber.tag) {
              case ClassComponent:
                {
                  {
                    var instance = returnFiber.stateNode;

                    if (instance.render._isMockFunction) {
                      break;
                    }
                  }
                }

              case FunctionComponent:
                {
                  var Component = returnFiber.type;
                  invariant(false, "%s(...): Nothing was returned from render. This usually means a " + "return statement is missing. Or, to render nothing, " + "return null.", Component.displayName || Component.name || "Component");
                }
            }
          }

          return deleteRemainingChildren(returnFiber, currentFirstChild);
        }

        return reconcileChildFibers;
      }

      var reconcileChildFibers = ChildReconciler(true);
      var mountChildFibers = ChildReconciler(false);

      function cloneChildFibers(current$$1, workInProgress) {
        invariant(current$$1 === null || workInProgress.child === current$$1.child, "Resuming work not yet implemented.");

        if (workInProgress.child === null) {
          return;
        }

        var currentChild = workInProgress.child;
        var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
        workInProgress.child = newChild;
        newChild.return = workInProgress;

        while (currentChild.sibling !== null) {
          currentChild = currentChild.sibling;
          newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
          newChild.return = workInProgress;
        }

        newChild.sibling = null;
      }

      var hydrationParentFiber = null;
      var nextHydratableInstance = null;
      var isHydrating = false;

      function enterHydrationState(fiber) {
        if (!supportsHydration) {
          return false;
        }

        var parentInstance = fiber.stateNode.containerInfo;
        nextHydratableInstance = getFirstHydratableChild(parentInstance);
        hydrationParentFiber = fiber;
        isHydrating = true;
        return true;
      }

      function deleteHydratableInstance(returnFiber, instance) {
        {
          switch (returnFiber.tag) {
            case HostRoot:
              didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
              break;

            case HostComponent:
              didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
              break;
          }
        }
        var childToDelete = createFiberFromHostInstanceForDeletion();
        childToDelete.stateNode = instance;
        childToDelete.return = returnFiber;
        childToDelete.effectTag = Deletion;

        if (returnFiber.lastEffect !== null) {
          returnFiber.lastEffect.nextEffect = childToDelete;
          returnFiber.lastEffect = childToDelete;
        } else {
          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
        }
      }

      function insertNonHydratedInstance(returnFiber, fiber) {
        fiber.effectTag |= Placement;
        {
          switch (returnFiber.tag) {
            case HostRoot:
              {
                var parentContainer = returnFiber.stateNode.containerInfo;

                switch (fiber.tag) {
                  case HostComponent:
                    var type = fiber.type;
                    var props = fiber.pendingProps;
                    didNotFindHydratableContainerInstance(parentContainer, type, props);
                    break;

                  case HostText:
                    var text = fiber.pendingProps;
                    didNotFindHydratableContainerTextInstance(parentContainer, text);
                    break;
                }

                break;
              }

            case HostComponent:
              {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;

                switch (fiber.tag) {
                  case HostComponent:
                    var _type = fiber.type;
                    var _props = fiber.pendingProps;
                    didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
                    break;

                  case HostText:
                    var _text = fiber.pendingProps;
                    didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                    break;
                }

                break;
              }

            default:
              return;
          }
        }
      }

      function tryHydrate(fiber, nextInstance) {
        switch (fiber.tag) {
          case HostComponent:
            {
              var type = fiber.type;
              var props = fiber.pendingProps;
              var instance = canHydrateInstance(nextInstance, type, props);

              if (instance !== null) {
                fiber.stateNode = instance;
                return true;
              }

              return false;
            }

          case HostText:
            {
              var text = fiber.pendingProps;
              var textInstance = canHydrateTextInstance(nextInstance, text);

              if (textInstance !== null) {
                fiber.stateNode = textInstance;
                return true;
              }

              return false;
            }

          default:
            return false;
        }
      }

      function tryToClaimNextHydratableInstance(fiber) {
        if (!isHydrating) {
          return;
        }

        var nextInstance = nextHydratableInstance;

        if (!nextInstance) {
          insertNonHydratedInstance(hydrationParentFiber, fiber);
          isHydrating = false;
          hydrationParentFiber = fiber;
          return;
        }

        var firstAttemptedInstance = nextInstance;

        if (!tryHydrate(fiber, nextInstance)) {
          nextInstance = getNextHydratableSibling(firstAttemptedInstance);

          if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
          }

          deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
        }

        hydrationParentFiber = fiber;
        nextHydratableInstance = getFirstHydratableChild(nextInstance);
      }

      function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
        if (!supportsHydration) {
          invariant(false, "Expected prepareToHydrateHostInstance() to never be called. " + "This error is likely caused by a bug in React. Please file an issue.");
        }

        var instance = fiber.stateNode;
        var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
        fiber.updateQueue = updatePayload;

        if (updatePayload !== null) {
          return true;
        }

        return false;
      }

      function prepareToHydrateHostTextInstance(fiber) {
        if (!supportsHydration) {
          invariant(false, "Expected prepareToHydrateHostTextInstance() to never be called. " + "This error is likely caused by a bug in React. Please file an issue.");
        }

        var textInstance = fiber.stateNode;
        var textContent = fiber.memoizedProps;
        var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
        {
          if (shouldUpdate) {
            var returnFiber = hydrationParentFiber;

            if (returnFiber !== null) {
              switch (returnFiber.tag) {
                case HostRoot:
                  {
                    var parentContainer = returnFiber.stateNode.containerInfo;
                    didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                    break;
                  }

                case HostComponent:
                  {
                    var parentType = returnFiber.type;
                    var parentProps = returnFiber.memoizedProps;
                    var parentInstance = returnFiber.stateNode;
                    didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                    break;
                  }
              }
            }
          }
        }
        return shouldUpdate;
      }

      function popToNextHostParent(fiber) {
        var parent = fiber.return;

        while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {
          parent = parent.return;
        }

        hydrationParentFiber = parent;
      }

      function popHydrationState(fiber) {
        if (!supportsHydration) {
          return false;
        }

        if (fiber !== hydrationParentFiber) {
          return false;
        }

        if (!isHydrating) {
          popToNextHostParent(fiber);
          isHydrating = true;
          return false;
        }

        var type = fiber.type;

        if (fiber.tag !== HostComponent || type !== "head" && type !== "body" && !shouldSetTextContent(type, fiber.memoizedProps)) {
          var nextInstance = nextHydratableInstance;

          while (nextInstance) {
            deleteHydratableInstance(fiber, nextInstance);
            nextInstance = getNextHydratableSibling(nextInstance);
          }
        }

        popToNextHostParent(fiber);
        nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
        return true;
      }

      function resetHydrationState() {
        if (!supportsHydration) {
          return;
        }

        hydrationParentFiber = null;
        nextHydratableInstance = null;
        isHydrating = false;
      }

      var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
      var didWarnAboutBadClass = void 0;
      var didWarnAboutContextTypeOnFunctionComponent = void 0;
      var didWarnAboutGetDerivedStateOnFunctionComponent = void 0;
      var didWarnAboutFunctionRefs = void 0;
      {
        didWarnAboutBadClass = {};
        didWarnAboutContextTypeOnFunctionComponent = {};
        didWarnAboutGetDerivedStateOnFunctionComponent = {};
        didWarnAboutFunctionRefs = {};
      }

      function reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime) {
        if (current$$1 === null) {
          workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
        } else {
          workInProgress.child = reconcileChildFibers(workInProgress, current$$1.child, nextChildren, renderExpirationTime);
        }
      }

      function forceUnmountCurrentAndReconcile(current$$1, workInProgress, nextChildren, renderExpirationTime) {
        workInProgress.child = reconcileChildFibers(workInProgress, current$$1.child, null, renderExpirationTime);
        workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
      }

      function updateForwardRef(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
        var render = Component.render;
        var ref = workInProgress.ref;
        var nextChildren = void 0;
        prepareToReadContext(workInProgress, renderExpirationTime);
        prepareToUseHooks(current$$1, workInProgress, renderExpirationTime);
        {
          ReactCurrentOwner$3.current = workInProgress;
          setCurrentPhase("render");
          nextChildren = render(nextProps, ref);
          setCurrentPhase(null);
        }
        nextChildren = finishHooks(render, nextProps, nextChildren, ref);
        workInProgress.effectTag |= PerformedWork;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateMemoComponent(current$$1, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {
        if (current$$1 === null) {
          var type = Component.type;

          if (isSimpleFunctionComponent(type) && Component.compare === null) {
            workInProgress.tag = SimpleMemoComponent;
            workInProgress.type = type;
            return updateSimpleMemoComponent(current$$1, workInProgress, type, nextProps, updateExpirationTime, renderExpirationTime);
          }

          var child = createFiberFromTypeAndProps(Component.type, null, nextProps, null, workInProgress.mode, renderExpirationTime);
          child.ref = workInProgress.ref;
          child.return = workInProgress;
          workInProgress.child = child;
          return child;
        }

        var currentChild = current$$1.child;

        if (updateExpirationTime < renderExpirationTime) {
          var prevProps = currentChild.memoizedProps;
          var compare = Component.compare;
          compare = compare !== null ? compare : shallowEqual;

          if (compare(prevProps, nextProps) && current$$1.ref === workInProgress.ref) {
            return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
          }
        }

        workInProgress.effectTag |= PerformedWork;
        var newChild = createWorkInProgress(currentChild, nextProps, renderExpirationTime);
        newChild.ref = workInProgress.ref;
        newChild.return = workInProgress;
        workInProgress.child = newChild;
        return newChild;
      }

      function updateSimpleMemoComponent(current$$1, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {
        if (current$$1 !== null && updateExpirationTime < renderExpirationTime) {
          var prevProps = current$$1.memoizedProps;

          if (shallowEqual(prevProps, nextProps) && current$$1.ref === workInProgress.ref) {
            return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
          }
        }

        return updateFunctionComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime);
      }

      function updateFragment(current$$1, workInProgress, renderExpirationTime) {
        var nextChildren = workInProgress.pendingProps;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateMode(current$$1, workInProgress, renderExpirationTime) {
        var nextChildren = workInProgress.pendingProps.children;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateProfiler(current$$1, workInProgress, renderExpirationTime) {
        if (enableProfilerTimer) {
          workInProgress.effectTag |= Update;
        }

        var nextProps = workInProgress.pendingProps;
        var nextChildren = nextProps.children;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function markRef(current$$1, workInProgress) {
        var ref = workInProgress.ref;

        if (current$$1 === null && ref !== null || current$$1 !== null && current$$1.ref !== ref) {
          workInProgress.effectTag |= Ref;
        }
      }

      function updateFunctionComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
        var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
        var context = getMaskedContext(workInProgress, unmaskedContext);
        var nextChildren = void 0;
        prepareToReadContext(workInProgress, renderExpirationTime);
        prepareToUseHooks(current$$1, workInProgress, renderExpirationTime);
        {
          ReactCurrentOwner$3.current = workInProgress;
          setCurrentPhase("render");
          nextChildren = Component(nextProps, context);
          setCurrentPhase(null);
        }
        nextChildren = finishHooks(Component, nextProps, nextChildren, context);
        workInProgress.effectTag |= PerformedWork;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateClassComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
        var hasContext = void 0;

        if (isContextProvider(Component)) {
          hasContext = true;
          pushContextProvider(workInProgress);
        } else {
          hasContext = false;
        }

        prepareToReadContext(workInProgress, renderExpirationTime);
        var instance = workInProgress.stateNode;
        var shouldUpdate = void 0;

        if (instance === null) {
          if (current$$1 !== null) {
            current$$1.alternate = null;
            workInProgress.alternate = null;
            workInProgress.effectTag |= Placement;
          }

          constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
          mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
          shouldUpdate = true;
        } else if (current$$1 === null) {
          shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
        } else {
          shouldUpdate = updateClassInstance(current$$1, workInProgress, Component, nextProps, renderExpirationTime);
        }

        return finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime);
      }

      function finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime) {
        markRef(current$$1, workInProgress);
        var didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;

        if (!shouldUpdate && !didCaptureError) {
          if (hasContext) {
            invalidateContextProvider(workInProgress, Component, false);
          }

          return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
        }

        var instance = workInProgress.stateNode;
        ReactCurrentOwner$3.current = workInProgress;
        var nextChildren = void 0;

        if (didCaptureError && typeof Component.getDerivedStateFromError !== "function") {
          nextChildren = null;

          if (enableProfilerTimer) {
            stopProfilerTimerIfRunning(workInProgress);
          }
        } else {
          {
            setCurrentPhase("render");
            nextChildren = instance.render();

            if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
              instance.render();
            }

            setCurrentPhase(null);
          }
        }

        workInProgress.effectTag |= PerformedWork;

        if (current$$1 !== null && didCaptureError) {
          forceUnmountCurrentAndReconcile(current$$1, workInProgress, nextChildren, renderExpirationTime);
        } else {
          reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        }

        workInProgress.memoizedState = instance.state;

        if (hasContext) {
          invalidateContextProvider(workInProgress, Component, true);
        }

        return workInProgress.child;
      }

      function pushHostRootContext(workInProgress) {
        var root = workInProgress.stateNode;

        if (root.pendingContext) {
          pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
        } else if (root.context) {
          pushTopLevelContextObject(workInProgress, root.context, false);
        }

        pushHostContainer(workInProgress, root.containerInfo);
      }

      function updateHostRoot(current$$1, workInProgress, renderExpirationTime) {
        pushHostRootContext(workInProgress);
        var updateQueue = workInProgress.updateQueue;
        invariant(updateQueue !== null, "If the root does not have an updateQueue, we should have already " + "bailed out. This error is likely caused by a bug in React. Please " + "file an issue.");
        var nextProps = workInProgress.pendingProps;
        var prevState = workInProgress.memoizedState;
        var prevChildren = prevState !== null ? prevState.element : null;
        processUpdateQueue(workInProgress, updateQueue, nextProps, null, renderExpirationTime);
        var nextState = workInProgress.memoizedState;
        var nextChildren = nextState.element;

        if (nextChildren === prevChildren) {
          resetHydrationState();
          return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
        }

        var root = workInProgress.stateNode;

        if ((current$$1 === null || current$$1.child === null) && root.hydrate && enterHydrationState(workInProgress)) {
          workInProgress.effectTag |= Placement;
          workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
        } else {
          reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
          resetHydrationState();
        }

        return workInProgress.child;
      }

      function updateHostComponent(current$$1, workInProgress, renderExpirationTime) {
        pushHostContext(workInProgress);

        if (current$$1 === null) {
          tryToClaimNextHydratableInstance(workInProgress);
        }

        var type = workInProgress.type;
        var nextProps = workInProgress.pendingProps;
        var prevProps = current$$1 !== null ? current$$1.memoizedProps : null;
        var nextChildren = nextProps.children;
        var isDirectTextChild = shouldSetTextContent(type, nextProps);

        if (isDirectTextChild) {
          nextChildren = null;
        } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
          workInProgress.effectTag |= ContentReset;
        }

        markRef(current$$1, workInProgress);

        if (renderExpirationTime !== Never && workInProgress.mode & ConcurrentMode && shouldDeprioritizeSubtree(type, nextProps)) {
          workInProgress.expirationTime = Never;
          return null;
        }

        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateHostText(current$$1, workInProgress) {
        if (current$$1 === null) {
          tryToClaimNextHydratableInstance(workInProgress);
        }

        return null;
      }

      function mountLazyComponent(_current, workInProgress, elementType, updateExpirationTime, renderExpirationTime) {
        if (_current !== null) {
          _current.alternate = null;
          workInProgress.alternate = null;
          workInProgress.effectTag |= Placement;
        }

        var props = workInProgress.pendingProps;
        cancelWorkTimer(workInProgress);
        var Component = readLazyComponentType(elementType);
        workInProgress.type = Component;
        var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);
        startWorkTimer(workInProgress);
        var resolvedProps = resolveDefaultProps(Component, props);
        var child = void 0;

        switch (resolvedTag) {
          case FunctionComponent:
            {
              child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderExpirationTime);
              break;
            }

          case ClassComponent:
            {
              child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderExpirationTime);
              break;
            }

          case ForwardRef:
            {
              child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderExpirationTime);
              break;
            }

          case MemoComponent:
            {
              child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), updateExpirationTime, renderExpirationTime);
              break;
            }

          default:
            {
              invariant(false, "Element type is invalid. Received a promise that resolves to: %s. " + "Promise elements must resolve to a class or function.", Component);
            }
        }

        return child;
      }

      function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderExpirationTime) {
        if (_current !== null) {
          _current.alternate = null;
          workInProgress.alternate = null;
          workInProgress.effectTag |= Placement;
        }

        workInProgress.tag = ClassComponent;
        var hasContext = void 0;

        if (isContextProvider(Component)) {
          hasContext = true;
          pushContextProvider(workInProgress);
        } else {
          hasContext = false;
        }

        prepareToReadContext(workInProgress, renderExpirationTime);
        constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
        mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
        return finishClassComponent(null, workInProgress, Component, true, hasContext, renderExpirationTime);
      }

      function mountIndeterminateComponent(_current, workInProgress, Component, renderExpirationTime) {
        if (_current !== null) {
          _current.alternate = null;
          workInProgress.alternate = null;
          workInProgress.effectTag |= Placement;
        }

        var props = workInProgress.pendingProps;
        var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);
        var context = getMaskedContext(workInProgress, unmaskedContext);
        prepareToReadContext(workInProgress, renderExpirationTime);
        prepareToUseHooks(null, workInProgress, renderExpirationTime);
        var value = void 0;
        {
          if (Component.prototype && typeof Component.prototype.render === "function") {
            var componentName = getComponentName(Component) || "Unknown";

            if (!didWarnAboutBadClass[componentName]) {
              warningWithoutStack$1(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + "This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
              didWarnAboutBadClass[componentName] = true;
            }
          }

          if (workInProgress.mode & StrictMode) {
            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
          }

          ReactCurrentOwner$3.current = workInProgress;
          value = Component(props, context);
        }
        workInProgress.effectTag |= PerformedWork;

        if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === undefined) {
          workInProgress.tag = ClassComponent;
          resetHooks();
          var hasContext = false;

          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress);
          } else {
            hasContext = false;
          }

          workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;
          var getDerivedStateFromProps = Component.getDerivedStateFromProps;

          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);
          }

          adoptClassInstance(workInProgress, value);
          mountClassInstance(workInProgress, Component, props, renderExpirationTime);
          return finishClassComponent(null, workInProgress, Component, true, hasContext, renderExpirationTime);
        } else {
          workInProgress.tag = FunctionComponent;
          value = finishHooks(Component, props, value, context);
          {
            if (Component) {
              !!Component.childContextTypes ? warningWithoutStack$1(false, "%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component") : void 0;
            }

            if (workInProgress.ref !== null) {
              var info = "";
              var ownerName = getCurrentFiberOwnerNameInDevOrNull();

              if (ownerName) {
                info += "\n\nCheck the render method of `" + ownerName + "`.";
              }

              var warningKey = ownerName || workInProgress._debugID || "";
              var debugSource = workInProgress._debugSource;

              if (debugSource) {
                warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
              }

              if (!didWarnAboutFunctionRefs[warningKey]) {
                didWarnAboutFunctionRefs[warningKey] = true;
                warning$1(false, "Function components cannot be given refs. " + "Attempts to access this ref will fail.%s", info);
              }
            }

            if (typeof Component.getDerivedStateFromProps === "function") {
              var _componentName = getComponentName(Component) || "Unknown";

              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName]) {
                warningWithoutStack$1(false, "%s: Function components do not support getDerivedStateFromProps.", _componentName);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName] = true;
              }
            }

            if (typeof Component.contextType === "object" && Component.contextType !== null) {
              var _componentName2 = getComponentName(Component) || "Unknown";

              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName2]) {
                warningWithoutStack$1(false, "%s: Function components do not support contextType.", _componentName2);
                didWarnAboutContextTypeOnFunctionComponent[_componentName2] = true;
              }
            }
          }
          reconcileChildren(null, workInProgress, value, renderExpirationTime);
          return workInProgress.child;
        }
      }

      function updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime) {
        var mode = workInProgress.mode;
        var nextProps = workInProgress.pendingProps;
        var nextState = workInProgress.memoizedState;
        var nextDidTimeout = void 0;

        if ((workInProgress.effectTag & DidCapture) === NoEffect) {
          nextState = null;
          nextDidTimeout = false;
        } else {
          nextState = {
            timedOutAt: nextState !== null ? nextState.timedOutAt : NoWork
          };
          nextDidTimeout = true;
          workInProgress.effectTag &= ~DidCapture;
        }

        var child = void 0;
        var next = void 0;

        if (current$$1 === null) {
          if (nextDidTimeout) {
            var nextFallbackChildren = nextProps.fallback;
            var primaryChildFragment = createFiberFromFragment(null, mode, NoWork, null);

            if ((workInProgress.mode & ConcurrentMode) === NoContext) {
              var progressedState = workInProgress.memoizedState;
              var progressedPrimaryChild = progressedState !== null ? workInProgress.child.child : workInProgress.child;
              primaryChildFragment.child = progressedPrimaryChild;
            }

            var fallbackChildFragment = createFiberFromFragment(nextFallbackChildren, mode, renderExpirationTime, null);
            primaryChildFragment.sibling = fallbackChildFragment;
            child = primaryChildFragment;
            next = fallbackChildFragment;
            child.return = next.return = workInProgress;
          } else {
            var nextPrimaryChildren = nextProps.children;
            child = next = mountChildFibers(workInProgress, null, nextPrimaryChildren, renderExpirationTime);
          }
        } else {
          var prevState = current$$1.memoizedState;
          var prevDidTimeout = prevState !== null;

          if (prevDidTimeout) {
            var currentPrimaryChildFragment = current$$1.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;

            if (nextDidTimeout) {
              var _nextFallbackChildren = nextProps.fallback;

              var _primaryChildFragment = createWorkInProgress(currentPrimaryChildFragment, currentPrimaryChildFragment.pendingProps, NoWork);

              _primaryChildFragment.effectTag |= Placement;

              if ((workInProgress.mode & ConcurrentMode) === NoContext) {
                var _progressedState = workInProgress.memoizedState;

                var _progressedPrimaryChild = _progressedState !== null ? workInProgress.child.child : workInProgress.child;

                if (_progressedPrimaryChild !== currentPrimaryChildFragment.child) {
                  _primaryChildFragment.child = _progressedPrimaryChild;
                }
              }

              if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
                var treeBaseDuration = 0;
                var hiddenChild = _primaryChildFragment.child;

                while (hiddenChild !== null) {
                  treeBaseDuration += hiddenChild.treeBaseDuration;
                  hiddenChild = hiddenChild.sibling;
                }

                _primaryChildFragment.treeBaseDuration = treeBaseDuration;
              }

              var _fallbackChildFragment = _primaryChildFragment.sibling = createWorkInProgress(currentFallbackChildFragment, _nextFallbackChildren, currentFallbackChildFragment.expirationTime);

              _fallbackChildFragment.effectTag |= Placement;
              child = _primaryChildFragment;
              _primaryChildFragment.childExpirationTime = NoWork;
              next = _fallbackChildFragment;
              child.return = next.return = workInProgress;
            } else {
              var _nextPrimaryChildren = nextProps.children;
              var currentPrimaryChild = currentPrimaryChildFragment.child;
              var primaryChild = reconcileChildFibers(workInProgress, currentPrimaryChild, _nextPrimaryChildren, renderExpirationTime);
              child = next = primaryChild;
            }
          } else {
            var _currentPrimaryChild = current$$1.child;

            if (nextDidTimeout) {
              var _nextFallbackChildren2 = nextProps.fallback;

              var _primaryChildFragment2 = createFiberFromFragment(null, mode, NoWork, null);

              _primaryChildFragment2.effectTag |= Placement;
              _primaryChildFragment2.child = _currentPrimaryChild;
              _currentPrimaryChild.return = _primaryChildFragment2;

              if ((workInProgress.mode & ConcurrentMode) === NoContext) {
                var _progressedState2 = workInProgress.memoizedState;

                var _progressedPrimaryChild2 = _progressedState2 !== null ? workInProgress.child.child : workInProgress.child;

                _primaryChildFragment2.child = _progressedPrimaryChild2;
              }

              if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
                var _treeBaseDuration = 0;
                var _hiddenChild = _primaryChildFragment2.child;

                while (_hiddenChild !== null) {
                  _treeBaseDuration += _hiddenChild.treeBaseDuration;
                  _hiddenChild = _hiddenChild.sibling;
                }

                _primaryChildFragment2.treeBaseDuration = _treeBaseDuration;
              }

              var _fallbackChildFragment2 = _primaryChildFragment2.sibling = createFiberFromFragment(_nextFallbackChildren2, mode, renderExpirationTime, null);

              _fallbackChildFragment2.effectTag |= Placement;
              child = _primaryChildFragment2;
              _primaryChildFragment2.childExpirationTime = NoWork;
              next = _fallbackChildFragment2;
              child.return = next.return = workInProgress;
            } else {
              var _nextPrimaryChildren2 = nextProps.children;
              next = child = reconcileChildFibers(workInProgress, _currentPrimaryChild, _nextPrimaryChildren2, renderExpirationTime);
            }
          }
        }

        workInProgress.memoizedState = nextState;
        workInProgress.child = child;
        return next;
      }

      function updatePortalComponent(current$$1, workInProgress, renderExpirationTime) {
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        var nextChildren = workInProgress.pendingProps;

        if (current$$1 === null) {
          workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
        } else {
          reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        }

        return workInProgress.child;
      }

      function updateContextProvider(current$$1, workInProgress, renderExpirationTime) {
        var providerType = workInProgress.type;
        var context = providerType._context;
        var newProps = workInProgress.pendingProps;
        var oldProps = workInProgress.memoizedProps;
        var newValue = newProps.value;
        {
          var providerPropTypes = workInProgress.type.propTypes;

          if (providerPropTypes) {
            checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider", getCurrentFiberStackInDev);
          }
        }
        pushProvider(workInProgress, newValue);

        if (oldProps !== null) {
          var oldValue = oldProps.value;
          var changedBits = calculateChangedBits(context, newValue, oldValue);

          if (changedBits === 0) {
            if (oldProps.children === newProps.children && !hasContextChanged()) {
              return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
            }
          } else {
            propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);
          }
        }

        var newChildren = newProps.children;
        reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);
        return workInProgress.child;
      }

      var hasWarnedAboutUsingContextAsConsumer = false;

      function updateContextConsumer(current$$1, workInProgress, renderExpirationTime) {
        var context = workInProgress.type;
        {
          if (context._context === undefined) {
            if (context !== context.Consumer) {
              if (!hasWarnedAboutUsingContextAsConsumer) {
                hasWarnedAboutUsingContextAsConsumer = true;
                warning$1(false, "Rendering <Context> directly is not supported and will be removed in " + "a future major release. Did you mean to render <Context.Consumer> instead?");
              }
            }
          } else {
            context = context._context;
          }
        }
        var newProps = workInProgress.pendingProps;
        var render = newProps.children;
        {
          !(typeof render === "function") ? warningWithoutStack$1(false, "A context consumer was rendered with multiple children, or a child " + "that isn't a function. A context consumer expects a single child " + "that is a function. If you did pass a function, make sure there " + "is no trailing or leading whitespace around it.") : void 0;
        }
        prepareToReadContext(workInProgress, renderExpirationTime);
        var newValue = readContext(context, newProps.unstable_observedBits);
        var newChildren = void 0;
        {
          ReactCurrentOwner$3.current = workInProgress;
          setCurrentPhase("render");
          newChildren = render(newValue);
          setCurrentPhase(null);
        }
        workInProgress.effectTag |= PerformedWork;
        reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime) {
        cancelWorkTimer(workInProgress);

        if (current$$1 !== null) {
          workInProgress.firstContextDependency = current$$1.firstContextDependency;
        }

        if (enableProfilerTimer) {
          stopProfilerTimerIfRunning(workInProgress);
        }

        var childExpirationTime = workInProgress.childExpirationTime;

        if (childExpirationTime < renderExpirationTime) {
          return null;
        } else {
          cloneChildFibers(current$$1, workInProgress);
          return workInProgress.child;
        }
      }

      function beginWork(current$$1, workInProgress, renderExpirationTime) {
        var updateExpirationTime = workInProgress.expirationTime;

        if (current$$1 !== null) {
          var oldProps = current$$1.memoizedProps;
          var newProps = workInProgress.pendingProps;

          if (oldProps === newProps && !hasContextChanged() && updateExpirationTime < renderExpirationTime) {
            switch (workInProgress.tag) {
              case HostRoot:
                pushHostRootContext(workInProgress);
                resetHydrationState();
                break;

              case HostComponent:
                pushHostContext(workInProgress);
                break;

              case ClassComponent:
                {
                  var Component = workInProgress.type;

                  if (isContextProvider(Component)) {
                    pushContextProvider(workInProgress);
                  }

                  break;
                }

              case HostPortal:
                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                break;

              case ContextProvider:
                {
                  var newValue = workInProgress.memoizedProps.value;
                  pushProvider(workInProgress, newValue);
                  break;
                }

              case Profiler:
                if (enableProfilerTimer) {
                  workInProgress.effectTag |= Update;
                }

                break;

              case SuspenseComponent:
                {
                  var state = workInProgress.memoizedState;
                  var didTimeout = state !== null;

                  if (didTimeout) {
                    var primaryChildFragment = workInProgress.child;
                    var primaryChildExpirationTime = primaryChildFragment.childExpirationTime;

                    if (primaryChildExpirationTime !== NoWork && primaryChildExpirationTime >= renderExpirationTime) {
                      return updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime);
                    } else {
                      var child = bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);

                      if (child !== null) {
                        return child.sibling;
                      } else {
                        return null;
                      }
                    }
                  }

                  break;
                }
            }

            return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
          }
        }

        workInProgress.expirationTime = NoWork;

        switch (workInProgress.tag) {
          case IndeterminateComponent:
            {
              var elementType = workInProgress.elementType;
              return mountIndeterminateComponent(current$$1, workInProgress, elementType, renderExpirationTime);
            }

          case LazyComponent:
            {
              var _elementType = workInProgress.elementType;
              return mountLazyComponent(current$$1, workInProgress, _elementType, updateExpirationTime, renderExpirationTime);
            }

          case FunctionComponent:
            {
              var _Component = workInProgress.type;
              var unresolvedProps = workInProgress.pendingProps;
              var resolvedProps = workInProgress.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);
              return updateFunctionComponent(current$$1, workInProgress, _Component, resolvedProps, renderExpirationTime);
            }

          case ClassComponent:
            {
              var _Component2 = workInProgress.type;
              var _unresolvedProps = workInProgress.pendingProps;

              var _resolvedProps = workInProgress.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);

              return updateClassComponent(current$$1, workInProgress, _Component2, _resolvedProps, renderExpirationTime);
            }

          case HostRoot:
            return updateHostRoot(current$$1, workInProgress, renderExpirationTime);

          case HostComponent:
            return updateHostComponent(current$$1, workInProgress, renderExpirationTime);

          case HostText:
            return updateHostText(current$$1, workInProgress);

          case SuspenseComponent:
            return updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime);

          case HostPortal:
            return updatePortalComponent(current$$1, workInProgress, renderExpirationTime);

          case ForwardRef:
            {
              var type = workInProgress.type;
              var _unresolvedProps2 = workInProgress.pendingProps;

              var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);

              return updateForwardRef(current$$1, workInProgress, type, _resolvedProps2, renderExpirationTime);
            }

          case Fragment:
            return updateFragment(current$$1, workInProgress, renderExpirationTime);

          case Mode:
            return updateMode(current$$1, workInProgress, renderExpirationTime);

          case Profiler:
            return updateProfiler(current$$1, workInProgress, renderExpirationTime);

          case ContextProvider:
            return updateContextProvider(current$$1, workInProgress, renderExpirationTime);

          case ContextConsumer:
            return updateContextConsumer(current$$1, workInProgress, renderExpirationTime);

          case MemoComponent:
            {
              var _type = workInProgress.type;
              var _unresolvedProps3 = workInProgress.pendingProps;

              var _resolvedProps3 = resolveDefaultProps(_type.type, _unresolvedProps3);

              return updateMemoComponent(current$$1, workInProgress, _type, _resolvedProps3, updateExpirationTime, renderExpirationTime);
            }

          case SimpleMemoComponent:
            {
              return updateSimpleMemoComponent(current$$1, workInProgress, workInProgress.type, workInProgress.pendingProps, updateExpirationTime, renderExpirationTime);
            }

          case IncompleteClassComponent:
            {
              var _Component3 = workInProgress.type;
              var _unresolvedProps4 = workInProgress.pendingProps;

              var _resolvedProps4 = workInProgress.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);

              return mountIncompleteClassComponent(current$$1, workInProgress, _Component3, _resolvedProps4, renderExpirationTime);
            }

          default:
            invariant(false, "Unknown unit of work tag. This error is likely caused by a bug in " + "React. Please file an issue.");
        }
      }

      function markUpdate(workInProgress) {
        workInProgress.effectTag |= Update;
      }

      function markRef$1(workInProgress) {
        workInProgress.effectTag |= Ref;
      }

      var _appendAllChildren = void 0;

      var updateHostContainer = void 0;
      var updateHostComponent$1 = void 0;
      var updateHostText$1 = void 0;

      if (supportsMutation) {
        _appendAllChildren = function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {
          var node = workInProgress.child;

          while (node !== null) {
            if (node.tag === HostComponent || node.tag === HostText) {
              appendInitialChild(parent, node.stateNode);
            } else if (node.tag === HostPortal) {} else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }

            if (node === workInProgress) {
              return;
            }

            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress) {
                return;
              }

              node = node.return;
            }

            node.sibling.return = node.return;
            node = node.sibling;
          }
        };

        updateHostContainer = function updateHostContainer(workInProgress) {};

        updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {
          var oldProps = current.memoizedProps;

          if (oldProps === newProps) {
            return;
          }

          var instance = workInProgress.stateNode;
          var currentHostContext = getHostContext();
          var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
          workInProgress.updateQueue = updatePayload;

          if (updatePayload) {
            markUpdate(workInProgress);
          }
        };

        updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {
          if (oldText !== newText) {
            markUpdate(workInProgress);
          }
        };
      } else if (supportsPersistence) {
        _appendAllChildren = function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {
          var node = workInProgress.child;

          while (node !== null) {
            branches: if (node.tag === HostComponent) {
              var instance = node.stateNode;

              if (needsVisibilityToggle) {
                var props = node.memoizedProps;
                var type = node.type;

                if (isHidden) {
                  instance = cloneHiddenInstance(instance, type, props, node);
                } else {
                  instance = cloneUnhiddenInstance(instance, type, props, node);
                }

                node.stateNode = instance;
              }

              appendInitialChild(parent, instance);
            } else if (node.tag === HostText) {
              var _instance = node.stateNode;

              if (needsVisibilityToggle) {
                var text = node.memoizedProps;
                var rootContainerInstance = getRootHostContainer();
                var currentHostContext = getHostContext();

                if (isHidden) {
                  _instance = createHiddenTextInstance(text, rootContainerInstance, currentHostContext, workInProgress);
                } else {
                  _instance = createTextInstance(text, rootContainerInstance, currentHostContext, workInProgress);
                }

                node.stateNode = _instance;
              }

              appendInitialChild(parent, _instance);
            } else if (node.tag === HostPortal) {} else if (node.tag === SuspenseComponent) {
              var current = node.alternate;

              if (current !== null) {
                var oldState = current.memoizedState;
                var newState = node.memoizedState;
                var oldIsHidden = oldState !== null;
                var newIsHidden = newState !== null;

                if (oldIsHidden !== newIsHidden) {
                  var primaryChildParent = newIsHidden ? node.child : node;

                  if (primaryChildParent !== null) {
                    _appendAllChildren(parent, primaryChildParent, true, newIsHidden);
                  }

                  break branches;
                }
              }

              if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }

            node = node;

            if (node === workInProgress) {
              return;
            }

            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress) {
                return;
              }

              node = node.return;
            }

            node.sibling.return = node.return;
            node = node.sibling;
          }
        };

        var appendAllChildrenToContainer = function appendAllChildrenToContainer(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {
          var node = workInProgress.child;

          while (node !== null) {
            branches: if (node.tag === HostComponent) {
              var instance = node.stateNode;

              if (needsVisibilityToggle) {
                var props = node.memoizedProps;
                var type = node.type;

                if (isHidden) {
                  instance = cloneHiddenInstance(instance, type, props, node);
                } else {
                  instance = cloneUnhiddenInstance(instance, type, props, node);
                }

                node.stateNode = instance;
              }

              appendChildToContainerChildSet(containerChildSet, instance);
            } else if (node.tag === HostText) {
              var _instance2 = node.stateNode;

              if (needsVisibilityToggle) {
                var text = node.memoizedProps;
                var rootContainerInstance = getRootHostContainer();
                var currentHostContext = getHostContext();

                if (isHidden) {
                  _instance2 = createHiddenTextInstance(text, rootContainerInstance, currentHostContext, workInProgress);
                } else {
                  _instance2 = createTextInstance(text, rootContainerInstance, currentHostContext, workInProgress);
                }

                node.stateNode = _instance2;
              }

              appendChildToContainerChildSet(containerChildSet, _instance2);
            } else if (node.tag === HostPortal) {} else if (node.tag === SuspenseComponent) {
              var current = node.alternate;

              if (current !== null) {
                var oldState = current.memoizedState;
                var newState = node.memoizedState;
                var oldIsHidden = oldState !== null;
                var newIsHidden = newState !== null;

                if (oldIsHidden !== newIsHidden) {
                  var primaryChildParent = newIsHidden ? node.child : node;

                  if (primaryChildParent !== null) {
                    appendAllChildrenToContainer(containerChildSet, primaryChildParent, true, newIsHidden);
                  }

                  break branches;
                }
              }

              if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }

            node = node;

            if (node === workInProgress) {
              return;
            }

            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress) {
                return;
              }

              node = node.return;
            }

            node.sibling.return = node.return;
            node = node.sibling;
          }
        };

        updateHostContainer = function updateHostContainer(workInProgress) {
          var portalOrRoot = workInProgress.stateNode;
          var childrenUnchanged = workInProgress.firstEffect === null;

          if (childrenUnchanged) {} else {
            var container = portalOrRoot.containerInfo;
            var newChildSet = createContainerChildSet(container);
            appendAllChildrenToContainer(newChildSet, workInProgress, false, false);
            portalOrRoot.pendingChildren = newChildSet;
            markUpdate(workInProgress);
            finalizeContainerChildren(container, newChildSet);
          }
        };

        updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {
          var currentInstance = current.stateNode;
          var oldProps = current.memoizedProps;
          var childrenUnchanged = workInProgress.firstEffect === null;

          if (childrenUnchanged && oldProps === newProps) {
            workInProgress.stateNode = currentInstance;
            return;
          }

          var recyclableInstance = workInProgress.stateNode;
          var currentHostContext = getHostContext();
          var updatePayload = null;

          if (oldProps !== newProps) {
            updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
          }

          if (childrenUnchanged && updatePayload === null) {
            workInProgress.stateNode = currentInstance;
            return;
          }

          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);

          if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {
            markUpdate(workInProgress);
          }

          workInProgress.stateNode = newInstance;

          if (childrenUnchanged) {
            markUpdate(workInProgress);
          } else {
            _appendAllChildren(newInstance, workInProgress, false, false);
          }
        };

        updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {
          if (oldText !== newText) {
            var rootContainerInstance = getRootHostContainer();
            var currentHostContext = getHostContext();
            workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);
            markUpdate(workInProgress);
          }
        };
      } else {
        updateHostContainer = function updateHostContainer(workInProgress) {};

        updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {};

        updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {};
      }

      function completeWork(current, workInProgress, renderExpirationTime) {
        var newProps = workInProgress.pendingProps;

        switch (workInProgress.tag) {
          case IndeterminateComponent:
            break;

          case LazyComponent:
            break;

          case SimpleMemoComponent:
          case FunctionComponent:
            break;

          case ClassComponent:
            {
              var Component = workInProgress.type;

              if (isContextProvider(Component)) {
                popContext(workInProgress);
              }

              break;
            }

          case HostRoot:
            {
              popHostContainer(workInProgress);
              popTopLevelContextObject(workInProgress);
              var fiberRoot = workInProgress.stateNode;

              if (fiberRoot.pendingContext) {
                fiberRoot.context = fiberRoot.pendingContext;
                fiberRoot.pendingContext = null;
              }

              if (current === null || current.child === null) {
                popHydrationState(workInProgress);
                workInProgress.effectTag &= ~Placement;
              }

              updateHostContainer(workInProgress);
              break;
            }

          case HostComponent:
            {
              popHostContext(workInProgress);
              var rootContainerInstance = getRootHostContainer();
              var type = workInProgress.type;

              if (current !== null && workInProgress.stateNode != null) {
                updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);

                if (current.ref !== workInProgress.ref) {
                  markRef$1(workInProgress);
                }
              } else {
                if (!newProps) {
                  invariant(workInProgress.stateNode !== null, "We must have new props for new mounts. This error is likely " + "caused by a bug in React. Please file an issue.");
                  break;
                }

                var currentHostContext = getHostContext();
                var wasHydrated = popHydrationState(workInProgress);

                if (wasHydrated) {
                  if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {
                    markUpdate(workInProgress);
                  }
                } else {
                  var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);

                  _appendAllChildren(instance, workInProgress, false, false);

                  if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {
                    markUpdate(workInProgress);
                  }

                  workInProgress.stateNode = instance;
                }

                if (workInProgress.ref !== null) {
                  markRef$1(workInProgress);
                }
              }

              break;
            }

          case HostText:
            {
              var newText = newProps;

              if (current && workInProgress.stateNode != null) {
                var oldText = current.memoizedProps;
                updateHostText$1(current, workInProgress, oldText, newText);
              } else {
                if (typeof newText !== "string") {
                  invariant(workInProgress.stateNode !== null, "We must have new props for new mounts. This error is likely " + "caused by a bug in React. Please file an issue.");
                }

                var _rootContainerInstance = getRootHostContainer();

                var _currentHostContext = getHostContext();

                var _wasHydrated = popHydrationState(workInProgress);

                if (_wasHydrated) {
                  if (prepareToHydrateHostTextInstance(workInProgress)) {
                    markUpdate(workInProgress);
                  }
                } else {
                  workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);
                }
              }

              break;
            }

          case ForwardRef:
            break;

          case SuspenseComponent:
            {
              var nextState = workInProgress.memoizedState;

              if ((workInProgress.effectTag & DidCapture) !== NoEffect) {
                workInProgress.expirationTime = renderExpirationTime;
                return workInProgress;
              }

              var nextDidTimeout = nextState !== null;
              var prevDidTimeout = current !== null && current.memoizedState !== null;

              if (current !== null && !nextDidTimeout && prevDidTimeout) {
                var currentFallbackChild = current.child.sibling;

                if (currentFallbackChild !== null) {
                  reconcileChildFibers(workInProgress, currentFallbackChild, null, renderExpirationTime);
                }
              }

              if (nextDidTimeout !== prevDidTimeout || (workInProgress.effectTag & ConcurrentMode) === NoContext && nextDidTimeout) {
                workInProgress.effectTag |= Update;
              }

              break;
            }

          case Fragment:
            break;

          case Mode:
            break;

          case Profiler:
            break;

          case HostPortal:
            popHostContainer(workInProgress);
            updateHostContainer(workInProgress);
            break;

          case ContextProvider:
            popProvider(workInProgress);
            break;

          case ContextConsumer:
            break;

          case MemoComponent:
            break;

          case IncompleteClassComponent:
            {
              var _Component = workInProgress.type;

              if (isContextProvider(_Component)) {
                popContext(workInProgress);
              }

              break;
            }

          default:
            invariant(false, "Unknown unit of work tag. This error is likely caused by a bug in " + "React. Please file an issue.");
        }

        return null;
      }

      function shouldCaptureSuspense(current, workInProgress) {
        if (workInProgress.memoizedProps.fallback === undefined) {
          return false;
        }

        var nextState = workInProgress.memoizedState;
        return nextState === null;
      }

      function showErrorDialog(capturedError) {
        var componentStack = capturedError.componentStack,
            error = capturedError.error;
        var errorToHandle = void 0;

        if (error instanceof Error) {
          var message = error.message,
              name = error.name;
          var summary = message ? name + ": " + message : name;
          errorToHandle = error;

          try {
            errorToHandle.message = summary + "\n\nThis error is located at:" + componentStack;
          } catch (e) {}
        } else if (typeof error === "string") {
          errorToHandle = new Error(error + "\n\nThis error is located at:" + componentStack);
        } else {
          errorToHandle = new Error("Unspecified error at:" + componentStack);
        }

        ExceptionsManager.handleException(errorToHandle, false);
        return false;
      }

      function logCapturedError(capturedError) {
        var logError = showErrorDialog(capturedError);

        if (logError === false) {
          return;
        }

        var error = capturedError.error;
        {
          var componentName = capturedError.componentName,
              componentStack = capturedError.componentStack,
              errorBoundaryName = capturedError.errorBoundaryName,
              errorBoundaryFound = capturedError.errorBoundaryFound,
              willRetry = capturedError.willRetry;

          if (error != null && error._suppressLogging) {
            if (errorBoundaryFound && willRetry) {
              return;
            }

            console.error(error);
          }

          var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
          var errorBoundaryMessage = void 0;

          if (errorBoundaryFound && errorBoundaryName) {
            if (willRetry) {
              errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
            } else {
              errorBoundaryMessage = "This error was initially handled by the error boundary " + errorBoundaryName + ".\n" + "Recreating the tree from scratch failed so React will unmount the tree.";
            }
          } else {
            errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\n" + "Visit https://fb.me/react-error-boundaries to learn more about error boundaries.";
          }

          var combinedMessage = "" + componentNameMessage + componentStack + "\n\n" + ("" + errorBoundaryMessage);
          console.error(combinedMessage);
        }
      }

      var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
      {
        didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
      }

      function logError(boundary, errorInfo) {
        var source = errorInfo.source;
        var stack = errorInfo.stack;

        if (stack === null && source !== null) {
          stack = getStackByFiberInDevAndProd(source);
        }

        var capturedError = {
          componentName: source !== null ? getComponentName(source.type) : null,
          componentStack: stack !== null ? stack : "",
          error: errorInfo.value,
          errorBoundary: null,
          errorBoundaryName: null,
          errorBoundaryFound: false,
          willRetry: false
        };

        if (boundary !== null && boundary.tag === ClassComponent) {
          capturedError.errorBoundary = boundary.stateNode;
          capturedError.errorBoundaryName = getComponentName(boundary.type);
          capturedError.errorBoundaryFound = true;
          capturedError.willRetry = true;
        }

        try {
          logCapturedError(capturedError);
        } catch (e) {
          setTimeout(function () {
            throw e;
          });
        }
      }

      var callComponentWillUnmountWithTimer = function callComponentWillUnmountWithTimer(current$$1, instance) {
        startPhaseTimer(current$$1, "componentWillUnmount");
        instance.props = current$$1.memoizedProps;
        instance.state = current$$1.memoizedState;
        instance.componentWillUnmount();
        stopPhaseTimer();
      };

      function safelyCallComponentWillUnmount(current$$1, instance) {
        {
          invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current$$1, instance);

          if (hasCaughtError()) {
            var unmountError = clearCaughtError();
            captureCommitPhaseError(current$$1, unmountError);
          }
        }
      }

      function safelyDetachRef(current$$1) {
        var ref = current$$1.ref;

        if (ref !== null) {
          if (typeof ref === "function") {
            {
              invokeGuardedCallback(null, ref, null, null);

              if (hasCaughtError()) {
                var refError = clearCaughtError();
                captureCommitPhaseError(current$$1, refError);
              }
            }
          } else {
            ref.current = null;
          }
        }
      }

      function safelyCallDestroy(current$$1, destroy) {
        {
          invokeGuardedCallback(null, destroy, null);

          if (hasCaughtError()) {
            var error = clearCaughtError();
            captureCommitPhaseError(current$$1, error);
          }
        }
      }

      function commitBeforeMutationLifeCycles(current$$1, finishedWork) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent:
            {
              commitHookEffectList(UnmountSnapshot, NoEffect$1, finishedWork);
              return;
            }

          case ClassComponent:
            {
              if (finishedWork.effectTag & Snapshot) {
                if (current$$1 !== null) {
                  var prevProps = current$$1.memoizedProps;
                  var prevState = current$$1.memoizedState;
                  startPhaseTimer(finishedWork, "getSnapshotBeforeUpdate");
                  var instance = finishedWork.stateNode;
                  {
                    if (finishedWork.type === finishedWork.elementType) {
                      !(instance.props === finishedWork.memoizedProps) ? warning$1(false, "Expected instance props to match memoized props before " + "getSnapshotBeforeUpdate. This is likely due to a bug in React. " + "Please file an issue.") : void 0;
                      !(instance.state === finishedWork.memoizedState) ? warning$1(false, "Expected instance state to match memoized state before " + "getSnapshotBeforeUpdate. This is likely due to a bug in React. " + "Please file an issue.") : void 0;
                    }
                  }
                  var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                  {
                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;

                    if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
                      didWarnSet.add(finishedWork.type);
                      warningWithoutStack$1(false, "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) " + "must be returned. You have returned undefined.", getComponentName(finishedWork.type));
                    }
                  }
                  instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                  stopPhaseTimer();
                }
              }

              return;
            }

          case HostRoot:
          case HostComponent:
          case HostText:
          case HostPortal:
          case IncompleteClassComponent:
            return;

          default:
            {
              invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
            }
        }
      }

      function commitHookEffectList(unmountTag, mountTag, finishedWork) {
        if (!enableHooks) {
          return;
        }

        var updateQueue = finishedWork.updateQueue;
        var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

        if (lastEffect !== null) {
          var firstEffect = lastEffect.next;
          var effect = firstEffect;

          do {
            if ((effect.tag & unmountTag) !== NoEffect$1) {
              var destroy = effect.destroy;
              effect.destroy = null;

              if (destroy !== null) {
                destroy();
              }
            }

            if ((effect.tag & mountTag) !== NoEffect$1) {
              var create = effect.create;

              var _destroy = create();

              if (typeof _destroy !== "function") {
                {
                  if (_destroy !== null && _destroy !== undefined) {
                    warningWithoutStack$1(false, "useEffect function must return a cleanup function or " + "nothing.%s%s", typeof _destroy.then === "function" ? " Promises and useEffect(async () => ...) are not " + "supported, but you can call an async function inside an " + "effect." : "", getStackByFiberInDevAndProd(finishedWork));
                  }
                }
                _destroy = null;
              }

              effect.destroy = _destroy;
            }

            effect = effect.next;
          } while (effect !== firstEffect);
        }
      }

      function commitPassiveHookEffects(finishedWork) {
        commitHookEffectList(UnmountPassive, NoEffect$1, finishedWork);
        commitHookEffectList(NoEffect$1, MountPassive, finishedWork);
      }

      function commitLifeCycles(finishedRoot, current$$1, finishedWork, committedExpirationTime) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent:
            {
              commitHookEffectList(UnmountLayout, MountLayout, finishedWork);
              break;
            }

          case ClassComponent:
            {
              var instance = finishedWork.stateNode;

              if (finishedWork.effectTag & Update) {
                if (current$$1 === null) {
                  startPhaseTimer(finishedWork, "componentDidMount");
                  {
                    if (finishedWork.type === finishedWork.elementType) {
                      !(instance.props === finishedWork.memoizedProps) ? warning$1(false, "Expected instance props to match memoized props before " + "componentDidMount. This is likely due to a bug in React. " + "Please file an issue.") : void 0;
                      !(instance.state === finishedWork.memoizedState) ? warning$1(false, "Expected instance state to match memoized state before " + "componentDidMount. This is likely due to a bug in React. " + "Please file an issue.") : void 0;
                    }
                  }
                  instance.componentDidMount();
                  stopPhaseTimer();
                } else {
                  var prevProps = finishedWork.elementType === finishedWork.type ? current$$1.memoizedProps : resolveDefaultProps(finishedWork.type, current$$1.memoizedProps);
                  var prevState = current$$1.memoizedState;
                  startPhaseTimer(finishedWork, "componentDidUpdate");
                  {
                    if (finishedWork.type === finishedWork.elementType) {
                      !(instance.props === finishedWork.memoizedProps) ? warning$1(false, "Expected instance props to match memoized props before " + "componentDidUpdate. This is likely due to a bug in React. " + "Please file an issue.") : void 0;
                      !(instance.state === finishedWork.memoizedState) ? warning$1(false, "Expected instance state to match memoized state before " + "componentDidUpdate. This is likely due to a bug in React. " + "Please file an issue.") : void 0;
                    }
                  }
                  instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                  stopPhaseTimer();
                }
              }

              var updateQueue = finishedWork.updateQueue;

              if (updateQueue !== null) {
                {
                  if (finishedWork.type === finishedWork.elementType) {
                    !(instance.props === finishedWork.memoizedProps) ? warning$1(false, "Expected instance props to match memoized props before " + "processing the update queue. This is likely due to a bug in React. " + "Please file an issue.") : void 0;
                    !(instance.state === finishedWork.memoizedState) ? warning$1(false, "Expected instance state to match memoized state before " + "processing the update queue. This is likely due to a bug in React. " + "Please file an issue.") : void 0;
                  }
                }
                commitUpdateQueue(finishedWork, updateQueue, instance, committedExpirationTime);
              }

              return;
            }

          case HostRoot:
            {
              var _updateQueue = finishedWork.updateQueue;

              if (_updateQueue !== null) {
                var _instance = null;

                if (finishedWork.child !== null) {
                  switch (finishedWork.child.tag) {
                    case HostComponent:
                      _instance = getPublicInstance(finishedWork.child.stateNode);
                      break;

                    case ClassComponent:
                      _instance = finishedWork.child.stateNode;
                      break;
                  }
                }

                commitUpdateQueue(finishedWork, _updateQueue, _instance, committedExpirationTime);
              }

              return;
            }

          case HostComponent:
            {
              var _instance2 = finishedWork.stateNode;

              if (current$$1 === null && finishedWork.effectTag & Update) {
                var type = finishedWork.type;
                var props = finishedWork.memoizedProps;
              }

              return;
            }

          case HostText:
            {
              return;
            }

          case HostPortal:
            {
              return;
            }

          case Profiler:
            {
              if (enableProfilerTimer) {
                var onRender = finishedWork.memoizedProps.onRender;

                if (enableSchedulerTracing) {
                  onRender(finishedWork.memoizedProps.id, current$$1 === null ? "mount" : "update", finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime(), finishedRoot.memoizedInteractions);
                } else {
                  onRender(finishedWork.memoizedProps.id, current$$1 === null ? "mount" : "update", finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime());
                }
              }

              return;
            }

          case SuspenseComponent:
            break;

          case IncompleteClassComponent:
            break;

          default:
            {
              invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
            }
        }
      }

      function hideOrUnhideAllChildren(finishedWork, isHidden) {
        if (supportsMutation) {
          var node = finishedWork;

          while (true) {
            if (node.tag === HostComponent) {
              var instance = node.stateNode;

              if (isHidden) {
                hideInstance(instance);
              } else {
                unhideInstance(node.stateNode, node.memoizedProps);
              }
            } else if (node.tag === HostText) {
              var _instance3 = node.stateNode;

              if (isHidden) {
                hideTextInstance(_instance3);
              } else {
                unhideTextInstance(_instance3, node.memoizedProps);
              }
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }

            if (node === finishedWork) {
              return;
            }

            while (node.sibling === null) {
              if (node.return === null || node.return === finishedWork) {
                return;
              }

              node = node.return;
            }

            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
      }

      function commitAttachRef(finishedWork) {
        var ref = finishedWork.ref;

        if (ref !== null) {
          var instance = finishedWork.stateNode;
          var instanceToUse = void 0;

          switch (finishedWork.tag) {
            case HostComponent:
              instanceToUse = getPublicInstance(instance);
              break;

            default:
              instanceToUse = instance;
          }

          if (typeof ref === "function") {
            ref(instanceToUse);
          } else {
            {
              if (!ref.hasOwnProperty("current")) {
                warningWithoutStack$1(false, "Unexpected ref object provided for %s. " + "Use either a ref-setter function or React.createRef().%s", getComponentName(finishedWork.type), getStackByFiberInDevAndProd(finishedWork));
              }
            }
            ref.current = instanceToUse;
          }
        }
      }

      function commitDetachRef(current$$1) {
        var currentRef = current$$1.ref;

        if (currentRef !== null) {
          if (typeof currentRef === "function") {
            currentRef(null);
          } else {
            currentRef.current = null;
          }
        }
      }

      function commitUnmount(current$$1) {
        onCommitUnmount(current$$1);

        switch (current$$1.tag) {
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent:
            {
              var updateQueue = current$$1.updateQueue;

              if (updateQueue !== null) {
                var lastEffect = updateQueue.lastEffect;

                if (lastEffect !== null) {
                  var firstEffect = lastEffect.next;
                  var effect = firstEffect;

                  do {
                    var destroy = effect.destroy;

                    if (destroy !== null) {
                      safelyCallDestroy(current$$1, destroy);
                    }

                    effect = effect.next;
                  } while (effect !== firstEffect);
                }
              }

              break;
            }

          case ClassComponent:
            {
              safelyDetachRef(current$$1);
              var instance = current$$1.stateNode;

              if (typeof instance.componentWillUnmount === "function") {
                safelyCallComponentWillUnmount(current$$1, instance);
              }

              return;
            }

          case HostComponent:
            {
              safelyDetachRef(current$$1);
              return;
            }

          case HostPortal:
            {
              if (supportsMutation) {
                unmountHostComponents(current$$1);
              } else if (supportsPersistence) {
                emptyPortalContainer(current$$1);
              }

              return;
            }
        }
      }

      function commitNestedUnmounts(root) {
        var node = root;

        while (true) {
          commitUnmount(node);

          if (node.child !== null && (!supportsMutation || node.tag !== HostPortal)) {
            node.child.return = node;
            node = node.child;
            continue;
          }

          if (node === root) {
            return;
          }

          while (node.sibling === null) {
            if (node.return === null || node.return === root) {
              return;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }
      }

      function detachFiber(current$$1) {
        current$$1.return = null;
        current$$1.child = null;

        if (current$$1.alternate) {
          current$$1.alternate.child = null;
          current$$1.alternate.return = null;
        }
      }

      function emptyPortalContainer(current$$1) {
        if (!supportsPersistence) {
          return;
        }

        var portal = current$$1.stateNode;
        var containerInfo = portal.containerInfo;
        var emptyChildSet = createContainerChildSet(containerInfo);
        replaceContainerChildren(containerInfo, emptyChildSet);
      }

      function commitContainer(finishedWork) {
        if (!supportsPersistence) {
          return;
        }

        switch (finishedWork.tag) {
          case ClassComponent:
            {
              return;
            }

          case HostComponent:
            {
              return;
            }

          case HostText:
            {
              return;
            }

          case HostRoot:
          case HostPortal:
            {
              var portalOrRoot = finishedWork.stateNode;
              var containerInfo = portalOrRoot.containerInfo,
                  _pendingChildren = portalOrRoot.pendingChildren;
              replaceContainerChildren(containerInfo, _pendingChildren);
              return;
            }

          default:
            {
              invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
            }
        }
      }

      function getHostParentFiber(fiber) {
        var parent = fiber.return;

        while (parent !== null) {
          if (isHostParent(parent)) {
            return parent;
          }

          parent = parent.return;
        }

        invariant(false, "Expected to find a host parent. This error is likely caused by a bug " + "in React. Please file an issue.");
      }

      function isHostParent(fiber) {
        return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
      }

      function getHostSibling(fiber) {
        var node = fiber;

        siblings: while (true) {
          while (node.sibling === null) {
            if (node.return === null || isHostParent(node.return)) {
              return null;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;

          while (node.tag !== HostComponent && node.tag !== HostText) {
            if (node.effectTag & Placement) {
              continue siblings;
            }

            if (node.child === null || node.tag === HostPortal) {
              continue siblings;
            } else {
              node.child.return = node;
              node = node.child;
            }
          }

          if (!(node.effectTag & Placement)) {
            return node.stateNode;
          }
        }
      }

      function commitPlacement(finishedWork) {
        if (!supportsMutation) {
          return;
        }

        var parentFiber = getHostParentFiber(finishedWork);
        var parent = void 0;
        var isContainer = void 0;

        switch (parentFiber.tag) {
          case HostComponent:
            parent = parentFiber.stateNode;
            isContainer = false;
            break;

          case HostRoot:
            parent = parentFiber.stateNode.containerInfo;
            isContainer = true;
            break;

          case HostPortal:
            parent = parentFiber.stateNode.containerInfo;
            isContainer = true;
            break;

          default:
            invariant(false, "Invalid host parent fiber. This error is likely caused by a bug " + "in React. Please file an issue.");
        }

        if (parentFiber.effectTag & ContentReset) {
          parentFiber.effectTag &= ~ContentReset;
        }

        var before = getHostSibling(finishedWork);
        var node = finishedWork;

        while (true) {
          if (node.tag === HostComponent || node.tag === HostText) {
            if (before) {
              if (isContainer) {
                insertInContainerBefore(parent, node.stateNode, before);
              } else {
                insertBefore(parent, node.stateNode, before);
              }
            } else {
              if (isContainer) {
                appendChildToContainer(parent, node.stateNode);
              } else {
                appendChild(parent, node.stateNode);
              }
            }
          } else if (node.tag === HostPortal) {} else if (node.child !== null) {
            node.child.return = node;
            node = node.child;
            continue;
          }

          if (node === finishedWork) {
            return;
          }

          while (node.sibling === null) {
            if (node.return === null || node.return === finishedWork) {
              return;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }
      }

      function unmountHostComponents(current$$1) {
        var node = current$$1;
        var currentParentIsValid = false;
        var currentParent = void 0;
        var currentParentIsContainer = void 0;

        while (true) {
          if (!currentParentIsValid) {
            var parent = node.return;

            findParent: while (true) {
              invariant(parent !== null, "Expected to find a host parent. This error is likely caused by " + "a bug in React. Please file an issue.");

              switch (parent.tag) {
                case HostComponent:
                  currentParent = parent.stateNode;
                  currentParentIsContainer = false;
                  break findParent;

                case HostRoot:
                  currentParent = parent.stateNode.containerInfo;
                  currentParentIsContainer = true;
                  break findParent;

                case HostPortal:
                  currentParent = parent.stateNode.containerInfo;
                  currentParentIsContainer = true;
                  break findParent;
              }

              parent = parent.return;
            }

            currentParentIsValid = true;
          }

          if (node.tag === HostComponent || node.tag === HostText) {
            commitNestedUnmounts(node);

            if (currentParentIsContainer) {
              removeChildFromContainer(currentParent, node.stateNode);
            } else {
              removeChild(currentParent, node.stateNode);
            }
          } else if (node.tag === HostPortal) {
            currentParent = node.stateNode.containerInfo;
            currentParentIsContainer = true;

            if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
          } else {
            commitUnmount(node);

            if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
          }

          if (node === current$$1) {
            return;
          }

          while (node.sibling === null) {
            if (node.return === null || node.return === current$$1) {
              return;
            }

            node = node.return;

            if (node.tag === HostPortal) {
              currentParentIsValid = false;
            }
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }
      }

      function commitDeletion(current$$1) {
        if (supportsMutation) {
          unmountHostComponents(current$$1);
        } else {
          commitNestedUnmounts(current$$1);
        }

        detachFiber(current$$1);
      }

      function commitWork(current$$1, finishedWork) {
        if (!supportsMutation) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent:
              {
                commitHookEffectList(UnmountMutation, MountMutation, finishedWork);
                return;
              }
          }

          commitContainer(finishedWork);
          return;
        }

        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent:
            {
              commitHookEffectList(UnmountMutation, MountMutation, finishedWork);
              return;
            }

          case ClassComponent:
            {
              return;
            }

          case HostComponent:
            {
              var instance = finishedWork.stateNode;

              if (instance != null) {
                var newProps = finishedWork.memoizedProps;
                var oldProps = current$$1 !== null ? current$$1.memoizedProps : newProps;
                var type = finishedWork.type;
                var updatePayload = finishedWork.updateQueue;
                finishedWork.updateQueue = null;

                if (updatePayload !== null) {
                  commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
                }
              }

              return;
            }

          case HostText:
            {
              invariant(finishedWork.stateNode !== null, "This should have a text node initialized. This error is likely " + "caused by a bug in React. Please file an issue.");
              var textInstance = finishedWork.stateNode;
              var newText = finishedWork.memoizedProps;
              var oldText = current$$1 !== null ? current$$1.memoizedProps : newText;
              commitTextUpdate(textInstance, oldText, newText);
              return;
            }

          case HostRoot:
            {
              return;
            }

          case Profiler:
            {
              return;
            }

          case SuspenseComponent:
            {
              var newState = finishedWork.memoizedState;
              var newDidTimeout = void 0;
              var primaryChildParent = finishedWork;

              if (newState === null) {
                newDidTimeout = false;
              } else {
                newDidTimeout = true;
                primaryChildParent = finishedWork.child;

                if (newState.timedOutAt === NoWork) {
                  newState.timedOutAt = requestCurrentTime();
                }
              }

              if (primaryChildParent !== null) {
                hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);
              }

              return;
            }

          case IncompleteClassComponent:
            {
              return;
            }

          default:
            {
              invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
            }
        }
      }

      function commitResetTextContent(current$$1) {
        if (!supportsMutation) {
          return;
        }

        resetTextContent(current$$1.stateNode);
      }

      function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
        var update = createUpdate(expirationTime);
        update.tag = CaptureUpdate;
        update.payload = {
          element: null
        };
        var error = errorInfo.value;

        update.callback = function () {
          onUncaughtError(error);
          logError(fiber, errorInfo);
        };

        return update;
      }

      function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
        var update = createUpdate(expirationTime);
        update.tag = CaptureUpdate;
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;

        if (typeof getDerivedStateFromError === "function") {
          var error = errorInfo.value;

          update.payload = function () {
            return getDerivedStateFromError(error);
          };
        }

        var inst = fiber.stateNode;

        if (inst !== null && typeof inst.componentDidCatch === "function") {
          update.callback = function callback() {
            if (typeof getDerivedStateFromError !== "function") {
              markLegacyErrorBoundaryAsFailed(this);
            }

            var error = errorInfo.value;
            var stack = errorInfo.stack;
            logError(fiber, errorInfo);
            this.componentDidCatch(error, {
              componentStack: stack !== null ? stack : ""
            });
            {
              if (typeof getDerivedStateFromError !== "function") {
                !(fiber.expirationTime === Sync) ? warningWithoutStack$1(false, "%s: Error boundaries should implement getDerivedStateFromError(). " + "In that method, return a state update to display an error message or fallback UI.", getComponentName(fiber.type) || "Unknown") : void 0;
              }
            }
          };
        }

        return update;
      }

      function throwException(root, returnFiber, sourceFiber, value, renderExpirationTime) {
        sourceFiber.effectTag |= Incomplete;
        sourceFiber.firstEffect = sourceFiber.lastEffect = null;

        if (value !== null && typeof value === "object" && typeof value.then === "function") {
          var thenable = value;
          var _workInProgress = returnFiber;
          var earliestTimeoutMs = -1;
          var startTimeMs = -1;

          do {
            if (_workInProgress.tag === SuspenseComponent) {
              var current$$1 = _workInProgress.alternate;

              if (current$$1 !== null) {
                var currentState = current$$1.memoizedState;

                if (currentState !== null) {
                  var timedOutAt = currentState.timedOutAt;
                  startTimeMs = expirationTimeToMs(timedOutAt);
                  break;
                }
              }

              var timeoutPropMs = _workInProgress.pendingProps.maxDuration;

              if (typeof timeoutPropMs === "number") {
                if (timeoutPropMs <= 0) {
                  earliestTimeoutMs = 0;
                } else if (earliestTimeoutMs === -1 || timeoutPropMs < earliestTimeoutMs) {
                  earliestTimeoutMs = timeoutPropMs;
                }
              }
            }

            _workInProgress = _workInProgress.return;
          } while (_workInProgress !== null);

          _workInProgress = returnFiber;

          do {
            if (_workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(_workInProgress.alternate, _workInProgress)) {
              var pingTime = (_workInProgress.mode & ConcurrentMode) === NoEffect ? Sync : renderExpirationTime;
              var onResolveOrReject = retrySuspendedRoot.bind(null, root, _workInProgress, sourceFiber, pingTime);

              if (enableSchedulerTracing) {
                onResolveOrReject = tracing.unstable_wrap(onResolveOrReject);
              }

              thenable.then(onResolveOrReject, onResolveOrReject);

              if ((_workInProgress.mode & ConcurrentMode) === NoEffect) {
                _workInProgress.effectTag |= DidCapture;
                var nextChildren = null;
                reconcileChildren(sourceFiber.alternate, sourceFiber, nextChildren, renderExpirationTime);
                sourceFiber.effectTag &= ~Incomplete;
                sourceFiber.effectTag &= ~LifecycleEffectMask;

                if (sourceFiber.tag === ClassComponent) {
                  var _current = sourceFiber.alternate;

                  if (_current === null) {
                    sourceFiber.tag = IncompleteClassComponent;
                  }
                }

                sourceFiber.expirationTime = renderExpirationTime;
                return;
              }

              var absoluteTimeoutMs = void 0;

              if (earliestTimeoutMs === -1) {
                absoluteTimeoutMs = maxSigned31BitInt;
              } else {
                if (startTimeMs === -1) {
                  var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, renderExpirationTime);
                  var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);
                  startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
                }

                absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
              }

              renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);
              _workInProgress.effectTag |= ShouldCapture;
              _workInProgress.expirationTime = renderExpirationTime;
              return;
            }

            _workInProgress = _workInProgress.return;
          } while (_workInProgress !== null);

          value = new Error((getComponentName(sourceFiber.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n" + "\n" + "Add a <Suspense fallback=...> component higher in the tree to " + "provide a loading indicator or placeholder to display." + getStackByFiberInDevAndProd(sourceFiber));
        }

        renderDidError();
        value = createCapturedValue(value, sourceFiber);
        var workInProgress = returnFiber;

        do {
          switch (workInProgress.tag) {
            case HostRoot:
              {
                var _errorInfo = value;
                workInProgress.effectTag |= ShouldCapture;
                workInProgress.expirationTime = renderExpirationTime;
                var update = createRootErrorUpdate(workInProgress, _errorInfo, renderExpirationTime);
                enqueueCapturedUpdate(workInProgress, update);
                return;
              }

            case ClassComponent:
              var errorInfo = value;
              var ctor = workInProgress.type;
              var instance = workInProgress.stateNode;

              if ((workInProgress.effectTag & DidCapture) === NoEffect && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                workInProgress.effectTag |= ShouldCapture;
                workInProgress.expirationTime = renderExpirationTime;

                var _update = createClassErrorUpdate(workInProgress, errorInfo, renderExpirationTime);

                enqueueCapturedUpdate(workInProgress, _update);
                return;
              }

              break;

            default:
              break;
          }

          workInProgress = workInProgress.return;
        } while (workInProgress !== null);
      }

      function unwindWork(workInProgress, renderExpirationTime) {
        switch (workInProgress.tag) {
          case ClassComponent:
            {
              var Component = workInProgress.type;

              if (isContextProvider(Component)) {
                popContext(workInProgress);
              }

              var effectTag = workInProgress.effectTag;

              if (effectTag & ShouldCapture) {
                workInProgress.effectTag = effectTag & ~ShouldCapture | DidCapture;
                return workInProgress;
              }

              return null;
            }

          case HostRoot:
            {
              popHostContainer(workInProgress);
              popTopLevelContextObject(workInProgress);
              var _effectTag = workInProgress.effectTag;
              invariant((_effectTag & DidCapture) === NoEffect, "The root failed to unmount after an error. This is likely a bug in " + "React. Please file an issue.");
              workInProgress.effectTag = _effectTag & ~ShouldCapture | DidCapture;
              return workInProgress;
            }

          case HostComponent:
            {
              popHostContext(workInProgress);
              return null;
            }

          case SuspenseComponent:
            {
              var _effectTag2 = workInProgress.effectTag;

              if (_effectTag2 & ShouldCapture) {
                workInProgress.effectTag = _effectTag2 & ~ShouldCapture | DidCapture;
                return workInProgress;
              }

              return null;
            }

          case HostPortal:
            popHostContainer(workInProgress);
            return null;

          case ContextProvider:
            popProvider(workInProgress);
            return null;

          default:
            return null;
        }
      }

      function unwindInterruptedWork(interruptedWork) {
        switch (interruptedWork.tag) {
          case ClassComponent:
            {
              var childContextTypes = interruptedWork.type.childContextTypes;

              if (childContextTypes !== null && childContextTypes !== undefined) {
                popContext(interruptedWork);
              }

              break;
            }

          case HostRoot:
            {
              popHostContainer(interruptedWork);
              popTopLevelContextObject(interruptedWork);
              break;
            }

          case HostComponent:
            {
              popHostContext(interruptedWork);
              break;
            }

          case HostPortal:
            popHostContainer(interruptedWork);
            break;

          case ContextProvider:
            popProvider(interruptedWork);
            break;

          default:
            break;
        }
      }

      var Dispatcher = {
        readContext: readContext,
        useCallback: useCallback,
        useContext: useContext,
        useEffect: useEffect,
        useImperativeMethods: useImperativeMethods,
        useLayoutEffect: useLayoutEffect,
        useMemo: useMemo,
        useMutationEffect: useMutationEffect,
        useReducer: useReducer,
        useRef: useRef,
        useState: useState
      };
      var DispatcherWithoutHooks = {
        readContext: readContext
      };
      var ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;
      var didWarnAboutStateTransition = void 0;
      var didWarnSetStateChildContext = void 0;
      var warnAboutUpdateOnUnmounted = void 0;
      var warnAboutInvalidUpdates = void 0;

      if (enableSchedulerTracing) {
        invariant(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null, "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) " + "without also replacing the `schedule/tracing` module with `schedule/tracing-profiling`. " + "Your bundler might have a setting for aliasing both modules. " + "Learn more at http://fb.me/react-profiling");
      }

      {
        didWarnAboutStateTransition = false;
        didWarnSetStateChildContext = false;
        var didWarnStateUpdateForUnmountedComponent = {};

        warnAboutUpdateOnUnmounted = function warnAboutUpdateOnUnmounted(fiber, isClass) {
          var componentName = getComponentName(fiber.type) || "ReactComponent";

          if (didWarnStateUpdateForUnmountedComponent[componentName]) {
            return;
          }

          warningWithoutStack$1(false, "Can't perform a React state update on an unmounted component. This " + "is a no-op, but it indicates a memory leak in your application. To " + "fix, cancel all subscriptions and asynchronous tasks in %s.%s", isClass ? "the componentWillUnmount method" : "a useEffect cleanup function", getStackByFiberInDevAndProd(fiber));
          didWarnStateUpdateForUnmountedComponent[componentName] = true;
        };

        warnAboutInvalidUpdates = function warnAboutInvalidUpdates(instance) {
          switch (phase) {
            case "getChildContext":
              if (didWarnSetStateChildContext) {
                return;
              }

              warningWithoutStack$1(false, "setState(...): Cannot call setState() inside getChildContext()");
              didWarnSetStateChildContext = true;
              break;

            case "render":
              if (didWarnAboutStateTransition) {
                return;
              }

              warningWithoutStack$1(false, "Cannot update during an existing state transition (such as within " + "`render`). Render methods should be a pure function of props and state.");
              didWarnAboutStateTransition = true;
              break;
          }
        };
      }
      var expirationContext = NoWork;
      var isWorking = false;
      var nextUnitOfWork = null;
      var nextRoot = null;
      var nextRenderExpirationTime = NoWork;
      var nextLatestAbsoluteTimeoutMs = -1;
      var nextRenderDidError = false;
      var nextEffect = null;
      var isCommitting$1 = false;
      var rootWithPendingPassiveEffects = null;
      var passiveEffectCallbackHandle = null;
      var passiveEffectCallback = null;
      var legacyErrorBoundariesThatAlreadyFailed = null;
      var interruptedBy = null;
      var stashedWorkInProgressProperties = void 0;
      var replayUnitOfWork = void 0;
      var mayReplayFailedUnitOfWork = void 0;
      var isReplayingFailedUnitOfWork = void 0;
      var originalReplayError = void 0;
      var rethrowOriginalError = void 0;

      if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
        stashedWorkInProgressProperties = null;
        mayReplayFailedUnitOfWork = true;
        isReplayingFailedUnitOfWork = false;
        originalReplayError = null;

        replayUnitOfWork = function replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy) {
          if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
            return;
          }

          if (stashedWorkInProgressProperties === null) {
            warningWithoutStack$1(false, "Could not replay rendering after an error. This is likely a bug in React. " + "Please file an issue.");
            return;
          }

          assignFiberPropertiesInDEV(failedUnitOfWork, stashedWorkInProgressProperties);

          switch (failedUnitOfWork.tag) {
            case HostRoot:
              popHostContainer(failedUnitOfWork);
              popTopLevelContextObject(failedUnitOfWork);
              break;

            case HostComponent:
              popHostContext(failedUnitOfWork);
              break;

            case ClassComponent:
              {
                var Component = failedUnitOfWork.type;

                if (isContextProvider(Component)) {
                  popContext(failedUnitOfWork);
                }

                break;
              }

            case HostPortal:
              popHostContainer(failedUnitOfWork);
              break;

            case ContextProvider:
              popProvider(failedUnitOfWork);
              break;
          }

          isReplayingFailedUnitOfWork = true;
          originalReplayError = thrownValue;
          invokeGuardedCallback(null, workLoop, null, isYieldy);
          isReplayingFailedUnitOfWork = false;
          originalReplayError = null;

          if (hasCaughtError()) {
            var replayError = clearCaughtError();

            if (replayError != null && thrownValue != null) {
              try {
                if (replayError._suppressLogging) {
                  thrownValue._suppressLogging = true;
                }
              } catch (inner) {}
            }
          } else {
            nextUnitOfWork = failedUnitOfWork;
          }
        };

        rethrowOriginalError = function rethrowOriginalError() {
          throw originalReplayError;
        };
      }

      function resetStack() {
        if (nextUnitOfWork !== null) {
          var interruptedWork = nextUnitOfWork.return;

          while (interruptedWork !== null) {
            unwindInterruptedWork(interruptedWork);
            interruptedWork = interruptedWork.return;
          }
        }

        {
          ReactStrictModeWarnings.discardPendingWarnings();
          checkThatStackIsEmpty();
        }
        nextRoot = null;
        nextRenderExpirationTime = NoWork;
        nextLatestAbsoluteTimeoutMs = -1;
        nextRenderDidError = false;
        nextUnitOfWork = null;
      }

      function commitAllHostEffects() {
        while (nextEffect !== null) {
          {
            setCurrentFiber(nextEffect);
          }
          recordEffect();
          var effectTag = nextEffect.effectTag;

          if (effectTag & ContentReset) {
            commitResetTextContent(nextEffect);
          }

          if (effectTag & Ref) {
            var current$$1 = nextEffect.alternate;

            if (current$$1 !== null) {
              commitDetachRef(current$$1);
            }
          }

          var primaryEffectTag = effectTag & (Placement | Update | Deletion);

          switch (primaryEffectTag) {
            case Placement:
              {
                commitPlacement(nextEffect);
                nextEffect.effectTag &= ~Placement;
                break;
              }

            case PlacementAndUpdate:
              {
                commitPlacement(nextEffect);
                nextEffect.effectTag &= ~Placement;
                var _current = nextEffect.alternate;
                commitWork(_current, nextEffect);
                break;
              }

            case Update:
              {
                var _current2 = nextEffect.alternate;
                commitWork(_current2, nextEffect);
                break;
              }

            case Deletion:
              {
                commitDeletion(nextEffect);
                break;
              }
          }

          nextEffect = nextEffect.nextEffect;
        }

        {
          resetCurrentFiber();
        }
      }

      function commitBeforeMutationLifecycles() {
        while (nextEffect !== null) {
          {
            setCurrentFiber(nextEffect);
          }
          var effectTag = nextEffect.effectTag;

          if (effectTag & Snapshot) {
            recordEffect();
            var current$$1 = nextEffect.alternate;
            commitBeforeMutationLifeCycles(current$$1, nextEffect);
          }

          nextEffect = nextEffect.nextEffect;
        }

        {
          resetCurrentFiber();
        }
      }

      function commitAllLifeCycles(finishedRoot, committedExpirationTime) {
        {
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
          ReactStrictModeWarnings.flushLegacyContextWarning();

          if (warnAboutDeprecatedLifecycles) {
            ReactStrictModeWarnings.flushPendingDeprecationWarnings();
          }
        }

        while (nextEffect !== null) {
          var effectTag = nextEffect.effectTag;

          if (effectTag & (Update | Callback)) {
            recordEffect();
            var current$$1 = nextEffect.alternate;
            commitLifeCycles(finishedRoot, current$$1, nextEffect, committedExpirationTime);
          }

          if (effectTag & Ref) {
            recordEffect();
            commitAttachRef(nextEffect);
          }

          if (enableHooks && effectTag & Passive) {
            rootWithPendingPassiveEffects = finishedRoot;
          }

          nextEffect = nextEffect.nextEffect;
        }
      }

      function commitPassiveEffects(root, firstEffect) {
        rootWithPendingPassiveEffects = null;
        passiveEffectCallbackHandle = null;
        passiveEffectCallback = null;
        var previousIsRendering = isRendering;
        isRendering = true;
        var effect = firstEffect;

        do {
          if (effect.effectTag & Passive) {
            var didError = false;
            var error = void 0;
            {
              invokeGuardedCallback(null, commitPassiveHookEffects, null, effect);

              if (hasCaughtError()) {
                didError = true;
                error = clearCaughtError();
              }
            }

            if (didError) {
              captureCommitPhaseError(effect, error);
            }
          }

          effect = effect.nextEffect;
        } while (effect !== null);

        isRendering = previousIsRendering;
        var rootExpirationTime = root.expirationTime;

        if (rootExpirationTime !== NoWork) {
          requestWork(root, rootExpirationTime);
        }
      }

      function isAlreadyFailedLegacyErrorBoundary(instance) {
        return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
      }

      function markLegacyErrorBoundaryAsFailed(instance) {
        if (legacyErrorBoundariesThatAlreadyFailed === null) {
          legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
        } else {
          legacyErrorBoundariesThatAlreadyFailed.add(instance);
        }
      }

      function flushPassiveEffects() {
        if (passiveEffectCallback !== null) {
          scheduler.unstable_cancelCallback(passiveEffectCallbackHandle);
          passiveEffectCallback();
        }
      }

      function commitRoot(root, finishedWork) {
        isWorking = true;
        isCommitting$1 = true;
        startCommitTimer();
        invariant(root.current !== finishedWork, "Cannot commit the same tree as before. This is probably a bug " + "related to the return field. This error is likely caused by a bug " + "in React. Please file an issue.");
        var committedExpirationTime = root.pendingCommitExpirationTime;
        invariant(committedExpirationTime !== NoWork, "Cannot commit an incomplete root. This error is likely caused by a " + "bug in React. Please file an issue.");
        root.pendingCommitExpirationTime = NoWork;
        var updateExpirationTimeBeforeCommit = finishedWork.expirationTime;
        var childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;
        var earliestRemainingTimeBeforeCommit = childExpirationTimeBeforeCommit > updateExpirationTimeBeforeCommit ? childExpirationTimeBeforeCommit : updateExpirationTimeBeforeCommit;
        markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);
        var prevInteractions = null;

        if (enableSchedulerTracing) {
          prevInteractions = tracing.__interactionsRef.current;
          tracing.__interactionsRef.current = root.memoizedInteractions;
        }

        ReactCurrentOwner$2.current = null;
        var firstEffect = void 0;

        if (finishedWork.effectTag > PerformedWork) {
          if (finishedWork.lastEffect !== null) {
            finishedWork.lastEffect.nextEffect = finishedWork;
            firstEffect = finishedWork.firstEffect;
          } else {
            firstEffect = finishedWork;
          }
        } else {
          firstEffect = finishedWork.firstEffect;
        }

        prepareForCommit(root.containerInfo);
        nextEffect = firstEffect;
        startCommitSnapshotEffectsTimer();

        while (nextEffect !== null) {
          var didError = false;
          var error = void 0;
          {
            invokeGuardedCallback(null, commitBeforeMutationLifecycles, null);

            if (hasCaughtError()) {
              didError = true;
              error = clearCaughtError();
            }
          }

          if (didError) {
            invariant(nextEffect !== null, "Should have next effect. This error is likely caused by a bug " + "in React. Please file an issue.");
            captureCommitPhaseError(nextEffect, error);

            if (nextEffect !== null) {
              nextEffect = nextEffect.nextEffect;
            }
          }
        }

        stopCommitSnapshotEffectsTimer();

        if (enableProfilerTimer) {
          recordCommitTime();
        }

        nextEffect = firstEffect;
        startCommitHostEffectsTimer();

        while (nextEffect !== null) {
          var _didError = false;

          var _error = void 0;

          {
            invokeGuardedCallback(null, commitAllHostEffects, null);

            if (hasCaughtError()) {
              _didError = true;
              _error = clearCaughtError();
            }
          }

          if (_didError) {
            invariant(nextEffect !== null, "Should have next effect. This error is likely caused by a bug " + "in React. Please file an issue.");
            captureCommitPhaseError(nextEffect, _error);

            if (nextEffect !== null) {
              nextEffect = nextEffect.nextEffect;
            }
          }
        }

        stopCommitHostEffectsTimer();
        resetAfterCommit(root.containerInfo);
        root.current = finishedWork;
        nextEffect = firstEffect;
        startCommitLifeCyclesTimer();

        while (nextEffect !== null) {
          var _didError2 = false;

          var _error2 = void 0;

          {
            invokeGuardedCallback(null, commitAllLifeCycles, null, root, committedExpirationTime);

            if (hasCaughtError()) {
              _didError2 = true;
              _error2 = clearCaughtError();
            }
          }

          if (_didError2) {
            invariant(nextEffect !== null, "Should have next effect. This error is likely caused by a bug " + "in React. Please file an issue.");
            captureCommitPhaseError(nextEffect, _error2);

            if (nextEffect !== null) {
              nextEffect = nextEffect.nextEffect;
            }
          }
        }

        if (enableHooks && firstEffect !== null && rootWithPendingPassiveEffects !== null) {
          var callback = commitPassiveEffects.bind(null, root, firstEffect);

          if (enableSchedulerTracing) {
            callback = tracing.unstable_wrap(callback);
          }

          passiveEffectCallbackHandle = scheduler.unstable_scheduleCallback(callback);
          passiveEffectCallback = callback;
        }

        isCommitting$1 = false;
        isWorking = false;
        stopCommitLifeCyclesTimer();
        stopCommitTimer();
        onCommitRoot(finishedWork.stateNode);

        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);
        }

        var updateExpirationTimeAfterCommit = finishedWork.expirationTime;
        var childExpirationTimeAfterCommit = finishedWork.childExpirationTime;
        var earliestRemainingTimeAfterCommit = childExpirationTimeAfterCommit > updateExpirationTimeAfterCommit ? childExpirationTimeAfterCommit : updateExpirationTimeAfterCommit;

        if (earliestRemainingTimeAfterCommit === NoWork) {
          legacyErrorBoundariesThatAlreadyFailed = null;
        }

        onCommit(root, earliestRemainingTimeAfterCommit);

        if (enableSchedulerTracing) {
          tracing.__interactionsRef.current = prevInteractions;
          var subscriber = void 0;

          try {
            subscriber = tracing.__subscriberRef.current;

            if (subscriber !== null && root.memoizedInteractions.size > 0) {
              var threadID = computeThreadID(committedExpirationTime, root.interactionThreadID);
              subscriber.onWorkStopped(root.memoizedInteractions, threadID);
            }
          } catch (error) {
            if (!hasUnhandledError) {
              hasUnhandledError = true;
              unhandledError = error;
            }
          } finally {
            var pendingInteractionMap = root.pendingInteractionMap;
            pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {
              if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {
                pendingInteractionMap.delete(scheduledExpirationTime);
                scheduledInteractions.forEach(function (interaction) {
                  interaction.__count--;

                  if (subscriber !== null && interaction.__count === 0) {
                    try {
                      subscriber.onInteractionScheduledWorkCompleted(interaction);
                    } catch (error) {
                      if (!hasUnhandledError) {
                        hasUnhandledError = true;
                        unhandledError = error;
                      }
                    }
                  }
                });
              }
            });
          }
        }
      }

      function resetChildExpirationTime(workInProgress, renderTime) {
        if (renderTime !== Never && workInProgress.childExpirationTime === Never) {
          return;
        }

        var newChildExpirationTime = NoWork;

        if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
          var actualDuration = workInProgress.actualDuration;
          var treeBaseDuration = workInProgress.selfBaseDuration;
          var shouldBubbleActualDurations = workInProgress.alternate === null || workInProgress.child !== workInProgress.alternate.child;
          var child = workInProgress.child;

          while (child !== null) {
            var childUpdateExpirationTime = child.expirationTime;
            var childChildExpirationTime = child.childExpirationTime;

            if (childUpdateExpirationTime > newChildExpirationTime) {
              newChildExpirationTime = childUpdateExpirationTime;
            }

            if (childChildExpirationTime > newChildExpirationTime) {
              newChildExpirationTime = childChildExpirationTime;
            }

            if (shouldBubbleActualDurations) {
              actualDuration += child.actualDuration;
            }

            treeBaseDuration += child.treeBaseDuration;
            child = child.sibling;
          }

          workInProgress.actualDuration = actualDuration;
          workInProgress.treeBaseDuration = treeBaseDuration;
        } else {
          var _child = workInProgress.child;

          while (_child !== null) {
            var _childUpdateExpirationTime = _child.expirationTime;
            var _childChildExpirationTime = _child.childExpirationTime;

            if (_childUpdateExpirationTime > newChildExpirationTime) {
              newChildExpirationTime = _childUpdateExpirationTime;
            }

            if (_childChildExpirationTime > newChildExpirationTime) {
              newChildExpirationTime = _childChildExpirationTime;
            }

            _child = _child.sibling;
          }
        }

        workInProgress.childExpirationTime = newChildExpirationTime;
      }

      function completeUnitOfWork(workInProgress) {
        while (true) {
          var current$$1 = workInProgress.alternate;
          {
            setCurrentFiber(workInProgress);
          }
          var returnFiber = workInProgress.return;
          var siblingFiber = workInProgress.sibling;

          if ((workInProgress.effectTag & Incomplete) === NoEffect) {
            if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
              mayReplayFailedUnitOfWork = false;
            }

            nextUnitOfWork = workInProgress;

            if (enableProfilerTimer) {
              if (workInProgress.mode & ProfileMode) {
                startProfilerTimer(workInProgress);
              }

              nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);

              if (workInProgress.mode & ProfileMode) {
                stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
              }
            } else {
              nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);
            }

            if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
              mayReplayFailedUnitOfWork = true;
            }

            stopWorkTimer(workInProgress);
            resetChildExpirationTime(workInProgress, nextRenderExpirationTime);
            {
              resetCurrentFiber();
            }

            if (nextUnitOfWork !== null) {
              return nextUnitOfWork;
            }

            if (returnFiber !== null && (returnFiber.effectTag & Incomplete) === NoEffect) {
              if (returnFiber.firstEffect === null) {
                returnFiber.firstEffect = workInProgress.firstEffect;
              }

              if (workInProgress.lastEffect !== null) {
                if (returnFiber.lastEffect !== null) {
                  returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
                }

                returnFiber.lastEffect = workInProgress.lastEffect;
              }

              var effectTag = workInProgress.effectTag;

              if (effectTag > PerformedWork) {
                if (returnFiber.lastEffect !== null) {
                  returnFiber.lastEffect.nextEffect = workInProgress;
                } else {
                  returnFiber.firstEffect = workInProgress;
                }

                returnFiber.lastEffect = workInProgress;
              }
            }

            if (true && ReactFiberInstrumentation_1.debugTool) {
              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
            }

            if (siblingFiber !== null) {
              return siblingFiber;
            } else if (returnFiber !== null) {
              workInProgress = returnFiber;
              continue;
            } else {
              return null;
            }
          } else {
            if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
              stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
              var actualDuration = workInProgress.actualDuration;
              var child = workInProgress.child;

              while (child !== null) {
                actualDuration += child.actualDuration;
                child = child.sibling;
              }

              workInProgress.actualDuration = actualDuration;
            }

            var next = unwindWork(workInProgress, nextRenderExpirationTime);

            if (workInProgress.effectTag & DidCapture) {
              stopFailedWorkTimer(workInProgress);
            } else {
              stopWorkTimer(workInProgress);
            }

            {
              resetCurrentFiber();
            }

            if (next !== null) {
              stopWorkTimer(workInProgress);

              if (true && ReactFiberInstrumentation_1.debugTool) {
                ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
              }

              next.effectTag &= HostEffectMask;
              return next;
            }

            if (returnFiber !== null) {
              returnFiber.firstEffect = returnFiber.lastEffect = null;
              returnFiber.effectTag |= Incomplete;
            }

            if (true && ReactFiberInstrumentation_1.debugTool) {
              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
            }

            if (siblingFiber !== null) {
              return siblingFiber;
            } else if (returnFiber !== null) {
              workInProgress = returnFiber;
              continue;
            } else {
              return null;
            }
          }
        }

        return null;
      }

      function performUnitOfWork(workInProgress) {
        var current$$1 = workInProgress.alternate;
        startWorkTimer(workInProgress);
        {
          setCurrentFiber(workInProgress);
        }

        if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
          stashedWorkInProgressProperties = assignFiberPropertiesInDEV(stashedWorkInProgressProperties, workInProgress);
        }

        var next = void 0;

        if (enableProfilerTimer) {
          if (workInProgress.mode & ProfileMode) {
            startProfilerTimer(workInProgress);
          }

          next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
          workInProgress.memoizedProps = workInProgress.pendingProps;

          if (workInProgress.mode & ProfileMode) {
            stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);
          }
        } else {
          next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
          workInProgress.memoizedProps = workInProgress.pendingProps;
        }

        {
          resetCurrentFiber();

          if (isReplayingFailedUnitOfWork) {
            rethrowOriginalError();
          }
        }

        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
        }

        if (next === null) {
          next = completeUnitOfWork(workInProgress);
        }

        ReactCurrentOwner$2.current = null;
        return next;
      }

      function workLoop(isYieldy) {
        if (!isYieldy) {
          while (nextUnitOfWork !== null) {
            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
          }
        } else {
          while (nextUnitOfWork !== null && !shouldYieldToRenderer()) {
            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
          }
        }
      }

      function renderRoot(root, isYieldy) {
        invariant(!isWorking, "renderRoot was called recursively. This error is likely caused " + "by a bug in React. Please file an issue.");
        flushPassiveEffects();
        isWorking = true;

        if (enableHooks) {
          ReactCurrentOwner$2.currentDispatcher = Dispatcher;
        } else {
          ReactCurrentOwner$2.currentDispatcher = DispatcherWithoutHooks;
        }

        var expirationTime = root.nextExpirationTimeToWorkOn;

        if (expirationTime !== nextRenderExpirationTime || root !== nextRoot || nextUnitOfWork === null) {
          resetStack();
          nextRoot = root;
          nextRenderExpirationTime = expirationTime;
          nextUnitOfWork = createWorkInProgress(nextRoot.current, null, nextRenderExpirationTime);
          root.pendingCommitExpirationTime = NoWork;

          if (enableSchedulerTracing) {
            var interactions = new Set();
            root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {
              if (scheduledExpirationTime >= expirationTime) {
                scheduledInteractions.forEach(function (interaction) {
                  return interactions.add(interaction);
                });
              }
            });
            root.memoizedInteractions = interactions;

            if (interactions.size > 0) {
              var subscriber = tracing.__subscriberRef.current;

              if (subscriber !== null) {
                var threadID = computeThreadID(expirationTime, root.interactionThreadID);

                try {
                  subscriber.onWorkStarted(interactions, threadID);
                } catch (error) {
                  if (!hasUnhandledError) {
                    hasUnhandledError = true;
                    unhandledError = error;
                  }
                }
              }
            }
          }
        }

        var prevInteractions = null;

        if (enableSchedulerTracing) {
          prevInteractions = tracing.__interactionsRef.current;
          tracing.__interactionsRef.current = root.memoizedInteractions;
        }

        var didFatal = false;
        startWorkLoopTimer(nextUnitOfWork);

        do {
          try {
            workLoop(isYieldy);
          } catch (thrownValue) {
            resetContextDependences();
            resetHooks();
            var mayReplay = void 0;

            if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
              mayReplay = mayReplayFailedUnitOfWork;
              mayReplayFailedUnitOfWork = true;
            }

            if (nextUnitOfWork === null) {
              didFatal = true;
              onUncaughtError(thrownValue);
            } else {
              if (enableProfilerTimer && nextUnitOfWork.mode & ProfileMode) {
                stopProfilerTimerIfRunningAndRecordDelta(nextUnitOfWork, true);
              }

              {
                resetCurrentlyProcessingQueue();
              }

              if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
                if (mayReplay) {
                  var failedUnitOfWork = nextUnitOfWork;
                  replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);
                }
              }

              invariant(nextUnitOfWork !== null, "Failed to replay rendering after an error. This " + "is likely caused by a bug in React. Please file an issue " + "with a reproducing case to help us find it.");
              var sourceFiber = nextUnitOfWork;
              var returnFiber = sourceFiber.return;

              if (returnFiber === null) {
                didFatal = true;
                onUncaughtError(thrownValue);
              } else {
                throwException(root, returnFiber, sourceFiber, thrownValue, nextRenderExpirationTime);
                nextUnitOfWork = completeUnitOfWork(sourceFiber);
                continue;
              }
            }
          }

          break;
        } while (true);

        if (enableSchedulerTracing) {
          tracing.__interactionsRef.current = prevInteractions;
        }

        isWorking = false;
        ReactCurrentOwner$2.currentDispatcher = null;
        resetContextDependences();
        resetHooks();

        if (didFatal) {
          var _didCompleteRoot = false;
          stopWorkLoopTimer(interruptedBy, _didCompleteRoot);
          interruptedBy = null;
          {
            resetStackAfterFatalErrorInDev();
          }
          nextRoot = null;
          onFatal(root);
          return;
        }

        if (nextUnitOfWork !== null) {
          var _didCompleteRoot2 = false;
          stopWorkLoopTimer(interruptedBy, _didCompleteRoot2);
          interruptedBy = null;
          onYield(root);
          return;
        }

        var didCompleteRoot = true;
        stopWorkLoopTimer(interruptedBy, didCompleteRoot);
        var rootWorkInProgress = root.current.alternate;
        invariant(rootWorkInProgress !== null, "Finished root should have a work-in-progress. This error is likely " + "caused by a bug in React. Please file an issue.");
        nextRoot = null;
        interruptedBy = null;

        if (nextRenderDidError) {
          if (hasLowerPriorityWork(root, expirationTime)) {
            markSuspendedPriorityLevel(root, expirationTime);
            var suspendedExpirationTime = expirationTime;
            var rootExpirationTime = root.expirationTime;
            onSuspend(root, rootWorkInProgress, suspendedExpirationTime, rootExpirationTime, -1);
            return;
          } else if (!root.didError && isYieldy) {
            root.didError = true;

            var _suspendedExpirationTime = root.nextExpirationTimeToWorkOn = expirationTime;

            var _rootExpirationTime = root.expirationTime = Sync;

            onSuspend(root, rootWorkInProgress, _suspendedExpirationTime, _rootExpirationTime, -1);
            return;
          }
        }

        if (isYieldy && nextLatestAbsoluteTimeoutMs !== -1) {
          var _suspendedExpirationTime2 = expirationTime;
          markSuspendedPriorityLevel(root, _suspendedExpirationTime2);
          var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, expirationTime);
          var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);

          if (earliestExpirationTimeMs < nextLatestAbsoluteTimeoutMs) {
            nextLatestAbsoluteTimeoutMs = earliestExpirationTimeMs;
          }

          var currentTimeMs = expirationTimeToMs(requestCurrentTime());
          var msUntilTimeout = nextLatestAbsoluteTimeoutMs - currentTimeMs;
          msUntilTimeout = msUntilTimeout < 0 ? 0 : msUntilTimeout;
          var _rootExpirationTime2 = root.expirationTime;
          onSuspend(root, rootWorkInProgress, _suspendedExpirationTime2, _rootExpirationTime2, msUntilTimeout);
          return;
        }

        onComplete(root, rootWorkInProgress, expirationTime);
      }

      function captureCommitPhaseError(sourceFiber, value) {
        var expirationTime = Sync;
        var fiber = sourceFiber.return;

        while (fiber !== null) {
          switch (fiber.tag) {
            case ClassComponent:
              var ctor = fiber.type;
              var instance = fiber.stateNode;

              if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                var errorInfo = createCapturedValue(value, sourceFiber);
                var update = createClassErrorUpdate(fiber, errorInfo, expirationTime);
                enqueueUpdate(fiber, update);
                scheduleWork(fiber, expirationTime);
                return;
              }

              break;

            case HostRoot:
              {
                var _errorInfo = createCapturedValue(value, sourceFiber);

                var _update = createRootErrorUpdate(fiber, _errorInfo, expirationTime);

                enqueueUpdate(fiber, _update);
                scheduleWork(fiber, expirationTime);
                return;
              }
          }

          fiber = fiber.return;
        }

        if (sourceFiber.tag === HostRoot) {
          var rootFiber = sourceFiber;

          var _errorInfo2 = createCapturedValue(value, rootFiber);

          var _update2 = createRootErrorUpdate(rootFiber, _errorInfo2, expirationTime);

          enqueueUpdate(rootFiber, _update2);
          scheduleWork(rootFiber, expirationTime);
        }
      }

      function computeThreadID(expirationTime, interactionThreadID) {
        return expirationTime * 1000 + interactionThreadID;
      }

      function computeExpirationForFiber(currentTime, fiber) {
        var expirationTime = void 0;

        if (expirationContext !== NoWork) {
          expirationTime = expirationContext;
        } else if (isWorking) {
          if (isCommitting$1) {
            expirationTime = Sync;
          } else {
            expirationTime = nextRenderExpirationTime;
          }
        } else {
          if (fiber.mode & ConcurrentMode) {
            if (isBatchingInteractiveUpdates) {
              expirationTime = computeInteractiveExpiration(currentTime);
            } else {
              expirationTime = computeAsyncExpiration(currentTime);
            }

            if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {
              expirationTime -= 1;
            }
          } else {
            expirationTime = Sync;
          }
        }

        if (isBatchingInteractiveUpdates) {
          if (lowestPriorityPendingInteractiveExpirationTime === NoWork || expirationTime < lowestPriorityPendingInteractiveExpirationTime) {
            lowestPriorityPendingInteractiveExpirationTime = expirationTime;
          }
        }

        return expirationTime;
      }

      function renderDidSuspend(root, absoluteTimeoutMs, suspendedTime) {
        if (absoluteTimeoutMs >= 0 && nextLatestAbsoluteTimeoutMs < absoluteTimeoutMs) {
          nextLatestAbsoluteTimeoutMs = absoluteTimeoutMs;
        }
      }

      function renderDidError() {
        nextRenderDidError = true;
      }

      function retrySuspendedRoot(root, boundaryFiber, sourceFiber, suspendedTime) {
        var retryTime = void 0;

        if (isPriorityLevelSuspended(root, suspendedTime)) {
          retryTime = suspendedTime;
          markPingedPriorityLevel(root, retryTime);
        } else {
          var currentTime = requestCurrentTime();
          retryTime = computeExpirationForFiber(currentTime, boundaryFiber);
          markPendingPriorityLevel(root, retryTime);
        }

        if ((boundaryFiber.mode & ConcurrentMode) !== NoContext) {
          if (root === nextRoot && nextRenderExpirationTime === suspendedTime) {
            nextRoot = null;
          }
        }

        scheduleWorkToRoot(boundaryFiber, retryTime);

        if ((boundaryFiber.mode & ConcurrentMode) === NoContext) {
          scheduleWorkToRoot(sourceFiber, retryTime);
          var sourceTag = sourceFiber.tag;

          if (sourceTag === ClassComponent && sourceFiber.stateNode !== null) {
            var update = createUpdate(retryTime);
            update.tag = ForceUpdate;
            enqueueUpdate(sourceFiber, update);
          }
        }

        var rootExpirationTime = root.expirationTime;

        if (rootExpirationTime !== NoWork) {
          requestWork(root, rootExpirationTime);
        }
      }

      function scheduleWorkToRoot(fiber, expirationTime) {
        recordScheduleUpdate();
        {
          if (fiber.tag === ClassComponent) {
            var instance = fiber.stateNode;
            warnAboutInvalidUpdates(instance);
          }
        }

        if (fiber.expirationTime < expirationTime) {
          fiber.expirationTime = expirationTime;
        }

        var alternate = fiber.alternate;

        if (alternate !== null && alternate.expirationTime < expirationTime) {
          alternate.expirationTime = expirationTime;
        }

        var node = fiber.return;
        var root = null;

        if (node === null && fiber.tag === HostRoot) {
          root = fiber.stateNode;
        } else {
          while (node !== null) {
            alternate = node.alternate;

            if (node.childExpirationTime < expirationTime) {
              node.childExpirationTime = expirationTime;

              if (alternate !== null && alternate.childExpirationTime < expirationTime) {
                alternate.childExpirationTime = expirationTime;
              }
            } else if (alternate !== null && alternate.childExpirationTime < expirationTime) {
              alternate.childExpirationTime = expirationTime;
            }

            if (node.return === null && node.tag === HostRoot) {
              root = node.stateNode;
              break;
            }

            node = node.return;
          }
        }

        if (root === null) {
          {
            switch (fiber.tag) {
              case ClassComponent:
                warnAboutUpdateOnUnmounted(fiber, true);
                break;

              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent:
                warnAboutUpdateOnUnmounted(fiber, false);
                break;
            }
          }
          return null;
        }

        if (enableSchedulerTracing) {
          var interactions = tracing.__interactionsRef.current;

          if (interactions.size > 0) {
            var pendingInteractionMap = root.pendingInteractionMap;
            var pendingInteractions = pendingInteractionMap.get(expirationTime);

            if (pendingInteractions != null) {
              interactions.forEach(function (interaction) {
                if (!pendingInteractions.has(interaction)) {
                  interaction.__count++;
                }

                pendingInteractions.add(interaction);
              });
            } else {
              pendingInteractionMap.set(expirationTime, new Set(interactions));
              interactions.forEach(function (interaction) {
                interaction.__count++;
              });
            }

            var subscriber = tracing.__subscriberRef.current;

            if (subscriber !== null) {
              var threadID = computeThreadID(expirationTime, root.interactionThreadID);
              subscriber.onWorkScheduled(interactions, threadID);
            }
          }
        }

        return root;
      }

      function scheduleWork(fiber, expirationTime) {
        var root = scheduleWorkToRoot(fiber, expirationTime);

        if (root === null) {
          return;
        }

        if (!isWorking && nextRenderExpirationTime !== NoWork && expirationTime > nextRenderExpirationTime) {
          interruptedBy = fiber;
          resetStack();
        }

        markPendingPriorityLevel(root, expirationTime);

        if (!isWorking || isCommitting$1 || nextRoot !== root) {
          var rootExpirationTime = root.expirationTime;
          requestWork(root, rootExpirationTime);
        }

        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
          nestedUpdateCount = 0;
          invariant(false, "Maximum update depth exceeded. This can happen when a " + "component repeatedly calls setState inside " + "componentWillUpdate or componentDidUpdate. React limits " + "the number of nested updates to prevent infinite loops.");
        }
      }

      var firstScheduledRoot = null;
      var lastScheduledRoot = null;
      var callbackExpirationTime = NoWork;
      var callbackID = void 0;
      var isRendering = false;
      var nextFlushedRoot = null;
      var nextFlushedExpirationTime = NoWork;
      var lowestPriorityPendingInteractiveExpirationTime = NoWork;
      var hasUnhandledError = false;
      var unhandledError = null;
      var isBatchingUpdates = false;
      var isUnbatchingUpdates = false;
      var isBatchingInteractiveUpdates = false;
      var completedBatches = null;
      var originalStartTimeMs = now();
      var currentRendererTime = msToExpirationTime(originalStartTimeMs);
      var currentSchedulerTime = currentRendererTime;
      var NESTED_UPDATE_LIMIT = 50;
      var nestedUpdateCount = 0;
      var lastCommittedRootDuringThisBatch = null;

      function recomputeCurrentRendererTime() {
        var currentTimeMs = now() - originalStartTimeMs;
        currentRendererTime = msToExpirationTime(currentTimeMs);
      }

      function scheduleCallbackWithExpirationTime(root, expirationTime) {
        if (callbackExpirationTime !== NoWork) {
          if (expirationTime < callbackExpirationTime) {
            return;
          } else {
            if (callbackID !== null) {
              cancelDeferredCallback(callbackID);
            }
          }
        } else {
          startRequestCallbackTimer();
        }

        callbackExpirationTime = expirationTime;
        var currentMs = now() - originalStartTimeMs;
        var expirationTimeMs = expirationTimeToMs(expirationTime);
        var timeout = expirationTimeMs - currentMs;
        callbackID = scheduleDeferredCallback(performAsyncWork, {
          timeout: timeout
        });
      }

      function onFatal(root) {
        root.finishedWork = null;
      }

      function onComplete(root, finishedWork, expirationTime) {
        root.pendingCommitExpirationTime = expirationTime;
        root.finishedWork = finishedWork;
      }

      function onSuspend(root, finishedWork, suspendedExpirationTime, rootExpirationTime, msUntilTimeout) {
        root.expirationTime = rootExpirationTime;

        if (msUntilTimeout === 0 && !shouldYieldToRenderer()) {
          root.pendingCommitExpirationTime = suspendedExpirationTime;
          root.finishedWork = finishedWork;
        } else if (msUntilTimeout > 0) {
          root.timeoutHandle = scheduleTimeout(onTimeout.bind(null, root, finishedWork, suspendedExpirationTime), msUntilTimeout);
        }
      }

      function onYield(root) {
        root.finishedWork = null;
      }

      function onTimeout(root, finishedWork, suspendedExpirationTime) {
        root.pendingCommitExpirationTime = suspendedExpirationTime;
        root.finishedWork = finishedWork;
        recomputeCurrentRendererTime();
        currentSchedulerTime = currentRendererTime;
        flushRoot(root, suspendedExpirationTime);
      }

      function onCommit(root, expirationTime) {
        root.expirationTime = expirationTime;
        root.finishedWork = null;
      }

      function requestCurrentTime() {
        if (isRendering) {
          return currentSchedulerTime;
        }

        findHighestPriorityRoot();

        if (nextFlushedExpirationTime === NoWork || nextFlushedExpirationTime === Never) {
          recomputeCurrentRendererTime();
          currentSchedulerTime = currentRendererTime;
          return currentSchedulerTime;
        }

        return currentSchedulerTime;
      }

      function requestWork(root, expirationTime) {
        addRootToSchedule(root, expirationTime);

        if (isRendering) {
          return;
        }

        if (isBatchingUpdates) {
          if (isUnbatchingUpdates) {
            nextFlushedRoot = root;
            nextFlushedExpirationTime = Sync;
            performWorkOnRoot(root, Sync, false);
          }

          return;
        }

        if (expirationTime === Sync) {
          performSyncWork();
        } else {
          scheduleCallbackWithExpirationTime(root, expirationTime);
        }
      }

      function addRootToSchedule(root, expirationTime) {
        if (root.nextScheduledRoot === null) {
          root.expirationTime = expirationTime;

          if (lastScheduledRoot === null) {
            firstScheduledRoot = lastScheduledRoot = root;
            root.nextScheduledRoot = root;
          } else {
            lastScheduledRoot.nextScheduledRoot = root;
            lastScheduledRoot = root;
            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
          }
        } else {
          var remainingExpirationTime = root.expirationTime;

          if (expirationTime > remainingExpirationTime) {
            root.expirationTime = expirationTime;
          }
        }
      }

      function findHighestPriorityRoot() {
        var highestPriorityWork = NoWork;
        var highestPriorityRoot = null;

        if (lastScheduledRoot !== null) {
          var previousScheduledRoot = lastScheduledRoot;
          var root = firstScheduledRoot;

          while (root !== null) {
            var remainingExpirationTime = root.expirationTime;

            if (remainingExpirationTime === NoWork) {
              invariant(previousScheduledRoot !== null && lastScheduledRoot !== null, "Should have a previous and last root. This error is likely " + "caused by a bug in React. Please file an issue.");

              if (root === root.nextScheduledRoot) {
                root.nextScheduledRoot = null;
                firstScheduledRoot = lastScheduledRoot = null;
                break;
              } else if (root === firstScheduledRoot) {
                var next = root.nextScheduledRoot;
                firstScheduledRoot = next;
                lastScheduledRoot.nextScheduledRoot = next;
                root.nextScheduledRoot = null;
              } else if (root === lastScheduledRoot) {
                lastScheduledRoot = previousScheduledRoot;
                lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
                root.nextScheduledRoot = null;
                break;
              } else {
                previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
                root.nextScheduledRoot = null;
              }

              root = previousScheduledRoot.nextScheduledRoot;
            } else {
              if (remainingExpirationTime > highestPriorityWork) {
                highestPriorityWork = remainingExpirationTime;
                highestPriorityRoot = root;
              }

              if (root === lastScheduledRoot) {
                break;
              }

              if (highestPriorityWork === Sync) {
                break;
              }

              previousScheduledRoot = root;
              root = root.nextScheduledRoot;
            }
          }
        }

        nextFlushedRoot = highestPriorityRoot;
        nextFlushedExpirationTime = highestPriorityWork;
      }

      var didYield = false;

      function shouldYieldToRenderer() {
        if (didYield) {
          return true;
        }

        if (shouldYield()) {
          didYield = true;
          return true;
        }

        return false;
      }

      function performAsyncWork() {
        try {
          if (!shouldYieldToRenderer()) {
            if (firstScheduledRoot !== null) {
              recomputeCurrentRendererTime();
              var root = firstScheduledRoot;

              do {
                didExpireAtExpirationTime(root, currentRendererTime);
                root = root.nextScheduledRoot;
              } while (root !== firstScheduledRoot);
            }
          }

          performWork(NoWork, true);
        } finally {
          didYield = false;
        }
      }

      function performSyncWork() {
        performWork(Sync, false);
      }

      function performWork(minExpirationTime, isYieldy) {
        findHighestPriorityRoot();

        if (isYieldy) {
          recomputeCurrentRendererTime();
          currentSchedulerTime = currentRendererTime;

          if (enableUserTimingAPI) {
            var didExpire = nextFlushedExpirationTime > currentRendererTime;
            var timeout = expirationTimeToMs(nextFlushedExpirationTime);
            stopRequestCallbackTimer(didExpire, timeout);
          }

          while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && minExpirationTime <= nextFlushedExpirationTime && !(didYield && currentRendererTime > nextFlushedExpirationTime)) {
            performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, currentRendererTime > nextFlushedExpirationTime);
            findHighestPriorityRoot();
            recomputeCurrentRendererTime();
            currentSchedulerTime = currentRendererTime;
          }
        } else {
          while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && minExpirationTime <= nextFlushedExpirationTime) {
            performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);
            findHighestPriorityRoot();
          }
        }

        if (isYieldy) {
          callbackExpirationTime = NoWork;
          callbackID = null;
        }

        if (nextFlushedExpirationTime !== NoWork) {
          scheduleCallbackWithExpirationTime(nextFlushedRoot, nextFlushedExpirationTime);
        }

        finishRendering();
      }

      function flushRoot(root, expirationTime) {
        invariant(!isRendering, "work.commit(): Cannot commit while already rendering. This likely " + "means you attempted to commit from inside a lifecycle method.");
        nextFlushedRoot = root;
        nextFlushedExpirationTime = expirationTime;
        performWorkOnRoot(root, expirationTime, false);
        performSyncWork();
      }

      function finishRendering() {
        nestedUpdateCount = 0;
        lastCommittedRootDuringThisBatch = null;

        if (completedBatches !== null) {
          var batches = completedBatches;
          completedBatches = null;

          for (var i = 0; i < batches.length; i++) {
            var batch = batches[i];

            try {
              batch._onComplete();
            } catch (error) {
              if (!hasUnhandledError) {
                hasUnhandledError = true;
                unhandledError = error;
              }
            }
          }
        }

        if (hasUnhandledError) {
          var error = unhandledError;
          unhandledError = null;
          hasUnhandledError = false;
          throw error;
        }
      }

      function performWorkOnRoot(root, expirationTime, isYieldy) {
        invariant(!isRendering, "performWorkOnRoot was called recursively. This error is likely caused " + "by a bug in React. Please file an issue.");
        isRendering = true;

        if (!isYieldy) {
          var finishedWork = root.finishedWork;

          if (finishedWork !== null) {
            completeRoot(root, finishedWork, expirationTime);
          } else {
            root.finishedWork = null;
            var timeoutHandle = root.timeoutHandle;

            if (timeoutHandle !== noTimeout) {
              root.timeoutHandle = noTimeout;
              cancelTimeout(timeoutHandle);
            }

            renderRoot(root, isYieldy);
            finishedWork = root.finishedWork;

            if (finishedWork !== null) {
              completeRoot(root, finishedWork, expirationTime);
            }
          }
        } else {
          var _finishedWork = root.finishedWork;

          if (_finishedWork !== null) {
            completeRoot(root, _finishedWork, expirationTime);
          } else {
            root.finishedWork = null;
            var _timeoutHandle = root.timeoutHandle;

            if (_timeoutHandle !== noTimeout) {
              root.timeoutHandle = noTimeout;
              cancelTimeout(_timeoutHandle);
            }

            renderRoot(root, isYieldy);
            _finishedWork = root.finishedWork;

            if (_finishedWork !== null) {
              if (!shouldYieldToRenderer()) {
                completeRoot(root, _finishedWork, expirationTime);
              } else {
                root.finishedWork = _finishedWork;
              }
            }
          }
        }

        isRendering = false;
      }

      function completeRoot(root, finishedWork, expirationTime) {
        var firstBatch = root.firstBatch;

        if (firstBatch !== null && firstBatch._expirationTime >= expirationTime) {
          if (completedBatches === null) {
            completedBatches = [firstBatch];
          } else {
            completedBatches.push(firstBatch);
          }

          if (firstBatch._defer) {
            root.finishedWork = finishedWork;
            root.expirationTime = NoWork;
            return;
          }
        }

        root.finishedWork = null;

        if (root === lastCommittedRootDuringThisBatch) {
          nestedUpdateCount++;
        } else {
          lastCommittedRootDuringThisBatch = root;
          nestedUpdateCount = 0;
        }

        commitRoot(root, finishedWork);
      }

      function onUncaughtError(error) {
        invariant(nextFlushedRoot !== null, "Should be working on a root. This error is likely caused by a bug in " + "React. Please file an issue.");
        nextFlushedRoot.expirationTime = NoWork;

        if (!hasUnhandledError) {
          hasUnhandledError = true;
          unhandledError = error;
        }
      }

      function batchedUpdates$1(fn, a) {
        var previousIsBatchingUpdates = isBatchingUpdates;
        isBatchingUpdates = true;

        try {
          return fn(a);
        } finally {
          isBatchingUpdates = previousIsBatchingUpdates;

          if (!isBatchingUpdates && !isRendering) {
            performSyncWork();
          }
        }
      }

      function interactiveUpdates$1(fn, a, b) {
        if (isBatchingInteractiveUpdates) {
          return fn(a, b);
        }

        if (!isBatchingUpdates && !isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {
          performWork(lowestPriorityPendingInteractiveExpirationTime, false);
          lowestPriorityPendingInteractiveExpirationTime = NoWork;
        }

        var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;
        var previousIsBatchingUpdates = isBatchingUpdates;
        isBatchingInteractiveUpdates = true;
        isBatchingUpdates = true;

        try {
          return fn(a, b);
        } finally {
          isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;
          isBatchingUpdates = previousIsBatchingUpdates;

          if (!isBatchingUpdates && !isRendering) {
            performSyncWork();
          }
        }
      }

      function flushInteractiveUpdates$1() {
        if (!isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {
          performWork(lowestPriorityPendingInteractiveExpirationTime, false);
          lowestPriorityPendingInteractiveExpirationTime = NoWork;
        }
      }

      var didWarnAboutNestedUpdates = void 0;
      var didWarnAboutFindNodeInStrictMode = void 0;
      {
        didWarnAboutNestedUpdates = false;
        didWarnAboutFindNodeInStrictMode = {};
      }

      function getContextForSubtree(parentComponent) {
        if (!parentComponent) {
          return emptyContextObject;
        }

        var fiber = get$1(parentComponent);
        var parentContext = findCurrentUnmaskedContext(fiber);

        if (fiber.tag === ClassComponent) {
          var Component = fiber.type;

          if (isContextProvider(Component)) {
            return processChildContext(fiber, Component, parentContext);
          }
        }

        return parentContext;
      }

      function scheduleRootUpdate(current$$1, element, expirationTime, callback) {
        {
          if (phase === "render" && current !== null && !didWarnAboutNestedUpdates) {
            didWarnAboutNestedUpdates = true;
            warningWithoutStack$1(false, "Render methods should be a pure function of props and state; " + "triggering nested component updates from render is not allowed. " + "If necessary, trigger nested updates in componentDidUpdate.\n\n" + "Check the render method of %s.", getComponentName(current.type) || "Unknown");
          }
        }
        var update = createUpdate(expirationTime);
        update.payload = {
          element: element
        };
        callback = callback === undefined ? null : callback;

        if (callback !== null) {
          !(typeof callback === "function") ? warningWithoutStack$1(false, "render(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callback) : void 0;
          update.callback = callback;
        }

        flushPassiveEffects();
        enqueueUpdate(current$$1, update);
        scheduleWork(current$$1, expirationTime);
        return expirationTime;
      }

      function updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback) {
        var current$$1 = container.current;
        {
          if (ReactFiberInstrumentation_1.debugTool) {
            if (current$$1.alternate === null) {
              ReactFiberInstrumentation_1.debugTool.onMountContainer(container);
            } else if (element === null) {
              ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);
            } else {
              ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);
            }
          }
        }
        var context = getContextForSubtree(parentComponent);

        if (container.context === null) {
          container.context = context;
        } else {
          container.pendingContext = context;
        }

        return scheduleRootUpdate(current$$1, element, expirationTime, callback);
      }

      function findHostInstance$1(component) {
        var fiber = get$1(component);

        if (fiber === undefined) {
          if (typeof component.render === "function") {
            invariant(false, "Unable to find node on an unmounted component.");
          } else {
            invariant(false, "Argument appears to not be a ReactComponent. Keys: %s", Object.keys(component));
          }
        }

        var hostFiber = findCurrentHostFiber(fiber);

        if (hostFiber === null) {
          return null;
        }

        return hostFiber.stateNode;
      }

      function findHostInstanceWithWarning$1(component, methodName) {
        {
          var fiber = get$1(component);

          if (fiber === undefined) {
            if (typeof component.render === "function") {
              invariant(false, "Unable to find node on an unmounted component.");
            } else {
              invariant(false, "Argument appears to not be a ReactComponent. Keys: %s", Object.keys(component));
            }
          }

          var hostFiber = findCurrentHostFiber(fiber);

          if (hostFiber === null) {
            return null;
          }

          if (hostFiber.mode & StrictMode) {
            var componentName = getComponentName(fiber.type) || "Component";

            if (!didWarnAboutFindNodeInStrictMode[componentName]) {
              didWarnAboutFindNodeInStrictMode[componentName] = true;

              if (fiber.mode & StrictMode) {
                warningWithoutStack$1(false, "%s is deprecated in StrictMode. " + "%s was passed an instance of %s which is inside StrictMode. " + "Instead, add a ref directly to the element you want to reference." + "\n%s" + "\n\nLearn more about using refs safely here:" + "\nhttps://fb.me/react-strict-mode-find-node", methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));
              } else {
                warningWithoutStack$1(false, "%s is deprecated in StrictMode. " + "%s was passed an instance of %s which renders StrictMode children. " + "Instead, add a ref directly to the element you want to reference." + "\n%s" + "\n\nLearn more about using refs safely here:" + "\nhttps://fb.me/react-strict-mode-find-node", methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));
              }
            }
          }

          return hostFiber.stateNode;
        }
        return findHostInstance$1(component);
      }

      function createContainer(containerInfo, isConcurrent, hydrate) {
        return createFiberRoot(containerInfo, isConcurrent, hydrate);
      }

      function updateContainer(element, container, parentComponent, callback) {
        var current$$1 = container.current;
        var currentTime = requestCurrentTime();
        var expirationTime = computeExpirationForFiber(currentTime, current$$1);
        return updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback);
      }

      function getPublicRootInstance(container) {
        var containerFiber = container.current;

        if (!containerFiber.child) {
          return null;
        }

        switch (containerFiber.child.tag) {
          case HostComponent:
            return getPublicInstance(containerFiber.child.stateNode);

          default:
            return containerFiber.child.stateNode;
        }
      }

      function injectIntoDevTools(devToolsConfig) {
        var _findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
        return injectInternals(_extends({}, devToolsConfig, {
          findHostInstanceByFiber: function findHostInstanceByFiber(fiber) {
            var hostFiber = findCurrentHostFiber(fiber);

            if (hostFiber === null) {
              return null;
            }

            return hostFiber.stateNode;
          },
          findFiberByHostInstance: function findFiberByHostInstance(instance) {
            if (!_findFiberByHostInstance) {
              return null;
            }

            return _findFiberByHostInstance(instance);
          }
        }));
      }

      function _createPortal(children, containerInfo, implementation) {
        var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: key == null ? null : "" + key,
          children: children,
          containerInfo: containerInfo,
          implementation: implementation
        };
      }

      var ReactVersion = "16.6.1";

      var NativeMethodsMixin = function NativeMethodsMixin(findNodeHandle, findHostInstance) {
        var NativeMethodsMixin = {
          measure: function measure(callback) {
            UIManager.measure(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          },
          measureInWindow: function measureInWindow(callback) {
            UIManager.measureInWindow(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          },
          measureLayout: function measureLayout(relativeToNativeNode, onSuccess, onFail) {
            UIManager.measureLayout(findNodeHandle(this), relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
          },
          setNativeProps: function setNativeProps(nativeProps) {
            var maybeInstance = void 0;

            try {
              maybeInstance = findHostInstance(this);
            } catch (error) {}

            if (maybeInstance == null) {
              return;
            }

            var viewConfig = maybeInstance.viewConfig;
            {
              warnForStyleProps(nativeProps, viewConfig.validAttributes);
            }
            var updatePayload = create(nativeProps, viewConfig.validAttributes);

            if (updatePayload != null) {
              UIManager.updateView(maybeInstance._nativeTag, viewConfig.uiViewClassName, updatePayload);
            }
          },
          focus: function focus() {
            TextInputState.focusTextInput(findNodeHandle(this));
          },
          blur: function blur() {
            TextInputState.blurTextInput(findNodeHandle(this));
          }
        };
        {
          var NativeMethodsMixin_DEV = NativeMethodsMixin;
          invariant(!NativeMethodsMixin_DEV.componentWillMount && !NativeMethodsMixin_DEV.componentWillReceiveProps && !NativeMethodsMixin_DEV.UNSAFE_componentWillMount && !NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps, "Do not override existing functions.");

          NativeMethodsMixin_DEV.componentWillMount = function () {
            throwOnStylesProp(this, this.props);
          };

          NativeMethodsMixin_DEV.componentWillReceiveProps = function (newProps) {
            throwOnStylesProp(this, newProps);
          };

          NativeMethodsMixin_DEV.UNSAFE_componentWillMount = function () {
            throwOnStylesProp(this, this.props);
          };

          NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps = function (newProps) {
            throwOnStylesProp(this, newProps);
          };

          NativeMethodsMixin_DEV.componentWillMount.__suppressDeprecationWarning = true;
          NativeMethodsMixin_DEV.componentWillReceiveProps.__suppressDeprecationWarning = true;
        }
        return NativeMethodsMixin;
      };

      function _classCallCheck$1(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      var ReactNativeComponent = function ReactNativeComponent(findNodeHandle, findHostInstance) {
        var ReactNativeComponent = function (_React$Component) {
          _inherits(ReactNativeComponent, _React$Component);

          function ReactNativeComponent() {
            _classCallCheck$1(this, ReactNativeComponent);

            return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
          }

          ReactNativeComponent.prototype.blur = function blur() {
            TextInputState.blurTextInput(findNodeHandle(this));
          };

          ReactNativeComponent.prototype.focus = function focus() {
            TextInputState.focusTextInput(findNodeHandle(this));
          };

          ReactNativeComponent.prototype.measure = function measure(callback) {
            UIManager.measure(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          };

          ReactNativeComponent.prototype.measureInWindow = function measureInWindow(callback) {
            UIManager.measureInWindow(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          };

          ReactNativeComponent.prototype.measureLayout = function measureLayout(relativeToNativeNode, onSuccess, onFail) {
            UIManager.measureLayout(findNodeHandle(this), relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
          };

          ReactNativeComponent.prototype.setNativeProps = function setNativeProps(nativeProps) {
            var maybeInstance = void 0;

            try {
              maybeInstance = findHostInstance(this);
            } catch (error) {}

            if (maybeInstance == null) {
              return;
            }

            var viewConfig = maybeInstance.viewConfig || maybeInstance.canonical.viewConfig;
            var updatePayload = create(nativeProps, viewConfig.validAttributes);

            if (updatePayload != null) {
              UIManager.updateView(maybeInstance._nativeTag, viewConfig.uiViewClassName, updatePayload);
            }
          };

          return ReactNativeComponent;
        }(React.Component);

        return ReactNativeComponent;
      };

      var emptyObject$1 = {};
      {
        Object.freeze(emptyObject$1);
      }
      var getInspectorDataForViewTag = void 0;
      {
        var traverseOwnerTreeUp = function traverseOwnerTreeUp(hierarchy, instance) {
          if (instance) {
            hierarchy.unshift(instance);
            traverseOwnerTreeUp(hierarchy, instance._debugOwner);
          }
        };

        var getOwnerHierarchy = function getOwnerHierarchy(instance) {
          var hierarchy = [];
          traverseOwnerTreeUp(hierarchy, instance);
          return hierarchy;
        };

        var lastNonHostInstance = function lastNonHostInstance(hierarchy) {
          for (var i = hierarchy.length - 1; i > 1; i--) {
            var instance = hierarchy[i];

            if (instance.tag !== HostComponent) {
              return instance;
            }
          }

          return hierarchy[0];
        };

        var getHostProps = function getHostProps(fiber) {
          var host = findCurrentHostFiber(fiber);

          if (host) {
            return host.memoizedProps || emptyObject$1;
          }

          return emptyObject$1;
        };

        var getHostNode = function getHostNode(fiber, findNodeHandle) {
          var hostNode = void 0;

          while (fiber) {
            if (fiber.stateNode !== null && fiber.tag === HostComponent) {
              hostNode = findNodeHandle(fiber.stateNode);
            }

            if (hostNode) {
              return hostNode;
            }

            fiber = fiber.child;
          }

          return null;
        };

        var createHierarchy = function createHierarchy(fiberHierarchy) {
          return fiberHierarchy.map(function (fiber) {
            return {
              name: getComponentName(fiber.type),
              getInspectorData: function getInspectorData(findNodeHandle) {
                return {
                  measure: function measure(callback) {
                    return UIManager.measure(getHostNode(fiber, findNodeHandle), callback);
                  },
                  props: getHostProps(fiber),
                  source: fiber._debugSource
                };
              }
            };
          });
        };

        getInspectorDataForViewTag = function getInspectorDataForViewTag(viewTag) {
          var closestInstance = getInstanceFromTag(viewTag);

          if (!closestInstance) {
            return {
              hierarchy: [],
              props: emptyObject$1,
              selection: null,
              source: null
            };
          }

          var fiber = findCurrentFiberUsingSlowPath(closestInstance);
          var fiberHierarchy = getOwnerHierarchy(fiber);
          var instance = lastNonHostInstance(fiberHierarchy);
          var hierarchy = createHierarchy(fiberHierarchy);
          var props = getHostProps(instance);
          var source = instance._debugSource;
          var selection = fiberHierarchy.indexOf(instance);
          return {
            hierarchy: hierarchy,
            props: props,
            selection: selection,
            source: source
          };
        };
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var findHostInstance = findHostInstance$1;
      var findHostInstanceWithWarning = findHostInstanceWithWarning$1;

      function findNodeHandle(componentOrHandle) {
        {
          var owner = ReactCurrentOwner.current;

          if (owner !== null && owner.stateNode !== null) {
            !owner.stateNode._warnedAboutRefsInRender ? warningWithoutStack$1(false, "%s is accessing findNodeHandle inside its render(). " + "render() should be a pure function of props and state. It should " + "never access something that requires stale data from the previous " + "render, such as refs. Move this logic to componentDidMount and " + "componentDidUpdate instead.", getComponentName(owner.type) || "A component") : void 0;
            owner.stateNode._warnedAboutRefsInRender = true;
          }
        }

        if (componentOrHandle == null) {
          return null;
        }

        if (typeof componentOrHandle === "number") {
          return componentOrHandle;
        }

        if (componentOrHandle._nativeTag) {
          return componentOrHandle._nativeTag;
        }

        if (componentOrHandle.canonical && componentOrHandle.canonical._nativeTag) {
          return componentOrHandle.canonical._nativeTag;
        }

        var hostInstance = void 0;
        {
          hostInstance = findHostInstanceWithWarning(componentOrHandle, "findNodeHandle");
        }

        if (hostInstance == null) {
          return hostInstance;
        }

        if (hostInstance.canonical) {
          return hostInstance.canonical._nativeTag;
        }

        return hostInstance._nativeTag;
      }

      setBatchingImplementation(batchedUpdates$1, interactiveUpdates$1, flushInteractiveUpdates$1);

      function computeComponentStackForErrorReporting(reactTag) {
        var fiber = getInstanceFromTag(reactTag);

        if (!fiber) {
          return "";
        }

        return getStackByFiberInDevAndProd(fiber);
      }

      var roots = new Map();
      var ReactNativeRenderer = {
        NativeComponent: ReactNativeComponent(findNodeHandle, findHostInstance),
        findNodeHandle: findNodeHandle,
        render: function render(element, containerTag, callback) {
          var root = roots.get(containerTag);

          if (!root) {
            root = createContainer(containerTag, false, false);
            roots.set(containerTag, root);
          }

          updateContainer(element, root, null, callback);
          return getPublicRootInstance(root);
        },
        unmountComponentAtNode: function unmountComponentAtNode(containerTag) {
          var root = roots.get(containerTag);

          if (root) {
            updateContainer(null, root, null, function () {
              roots.delete(containerTag);
            });
          }
        },
        unmountComponentAtNodeAndRemoveContainer: function unmountComponentAtNodeAndRemoveContainer(containerTag) {
          ReactNativeRenderer.unmountComponentAtNode(containerTag);
          UIManager.removeRootView(containerTag);
        },
        createPortal: function createPortal(children, containerTag) {
          var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          return _createPortal(children, containerTag, null, key);
        },
        unstable_batchedUpdates: batchedUpdates,
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
          NativeMethodsMixin: NativeMethodsMixin(findNodeHandle, findHostInstance),
          computeComponentStackForErrorReporting: computeComponentStackForErrorReporting
        }
      };
      injectIntoDevTools({
        findFiberByHostInstance: getInstanceFromTag,
        getInspectorDataForViewTag: getInspectorDataForViewTag,
        bundleType: 1,
        version: ReactVersion,
        rendererPackageName: "react-native-renderer"
      });
      var ReactNativeRenderer$2 = Object.freeze({
        default: ReactNativeRenderer
      });
      var ReactNativeRenderer$3 = ReactNativeRenderer$2 && ReactNativeRenderer || ReactNativeRenderer$2;
      var reactNativeRenderer = ReactNativeRenderer$3.default || ReactNativeRenderer$3;
      module.exports = reactNativeRenderer;
    })();
  }
},179,[112,180,257,145,258,109,134,259,174,260,114,261,264,188],"node_modules\\react-native\\Libraries\\Renderer\\oss\\ReactNativeRenderer-dev.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _require = _$$_REQUIRE(_dependencyMap[0], "PolyfillFunctions"),
      polyfillObjectProperty = _require.polyfillObjectProperty,
      polyfillGlobal = _require.polyfillGlobal;

  if (global.GLOBAL === undefined) {
    global.GLOBAL = global;
  }

  if (global.window === undefined) {
    global.window = global;
  }

  var _shouldPolyfillCollection = _$$_REQUIRE(_dependencyMap[1], "_shouldPolyfillES6Collection");

  if (_shouldPolyfillCollection('Map')) {
    polyfillGlobal('Map', function () {
      return _$$_REQUIRE(_dependencyMap[2], "Map");
    });
  }

  if (_shouldPolyfillCollection('Set')) {
    polyfillGlobal('Set', function () {
      return _$$_REQUIRE(_dependencyMap[3], "Set");
    });
  }

  global.process = global.process || {};
  global.process.env = global.process.env || {};

  if (!global.process.env.NODE_ENV) {
    global.process.env.NODE_ENV = __DEV__ ? 'development' : 'production';
  }

  if (global.__RCTProfileIsProfiling) {
    var Systrace = _$$_REQUIRE(_dependencyMap[4], "Systrace");

    Systrace.installReactHook();
    Systrace.setEnabled(true);
  }

  var ExceptionsManager = _$$_REQUIRE(_dependencyMap[5], "ExceptionsManager");

  ExceptionsManager.installConsoleErrorReporter();

  if (!global.__fbDisableExceptionsManager) {
    var handleError = function handleError(e, isFatal) {
      try {
        ExceptionsManager.handleException(e, isFatal);
      } catch (ee) {
        console.log('Failed to print error: ', ee.message);
        throw e;
      }
    };

    var ErrorUtils = _$$_REQUIRE(_dependencyMap[6], "ErrorUtils");

    ErrorUtils.setGlobalHandler(handleError);
  }

  var ReactNativeVersionCheck = _$$_REQUIRE(_dependencyMap[7], "ReactNativeVersionCheck");

  ReactNativeVersionCheck.checkVersions();
  polyfillGlobal('Promise', function () {
    return _$$_REQUIRE(_dependencyMap[8], "Promise");
  });
  polyfillGlobal('regeneratorRuntime', function () {
    delete global.regeneratorRuntime;
    return _$$_REQUIRE(_dependencyMap[9], "regenerator-runtime/runtime");
  });

  var defineLazyTimer = function defineLazyTimer(name) {
    polyfillGlobal(name, function () {
      return _$$_REQUIRE(_dependencyMap[10], "JSTimers")[name];
    });
  };

  defineLazyTimer('setTimeout');
  defineLazyTimer('setInterval');
  defineLazyTimer('setImmediate');
  defineLazyTimer('clearTimeout');
  defineLazyTimer('clearInterval');
  defineLazyTimer('clearImmediate');
  defineLazyTimer('requestAnimationFrame');
  defineLazyTimer('cancelAnimationFrame');
  defineLazyTimer('requestIdleCallback');
  defineLazyTimer('cancelIdleCallback');
  polyfillGlobal('XMLHttpRequest', function () {
    return _$$_REQUIRE(_dependencyMap[11], "XMLHttpRequest");
  });
  polyfillGlobal('FormData', function () {
    return _$$_REQUIRE(_dependencyMap[12], "FormData");
  });
  polyfillGlobal('fetch', function () {
    return _$$_REQUIRE(_dependencyMap[13], "fetch").fetch;
  });
  polyfillGlobal('Headers', function () {
    return _$$_REQUIRE(_dependencyMap[13], "fetch").Headers;
  });
  polyfillGlobal('Request', function () {
    return _$$_REQUIRE(_dependencyMap[13], "fetch").Request;
  });
  polyfillGlobal('Response', function () {
    return _$$_REQUIRE(_dependencyMap[13], "fetch").Response;
  });
  polyfillGlobal('WebSocket', function () {
    return _$$_REQUIRE(_dependencyMap[14], "WebSocket");
  });
  polyfillGlobal('Blob', function () {
    return _$$_REQUIRE(_dependencyMap[15], "Blob");
  });
  polyfillGlobal('File', function () {
    return _$$_REQUIRE(_dependencyMap[16], "File");
  });
  polyfillGlobal('FileReader', function () {
    return _$$_REQUIRE(_dependencyMap[17], "FileReader");
  });
  polyfillGlobal('URL', function () {
    return _$$_REQUIRE(_dependencyMap[18], "URL");
  });

  if (!global.alert) {
    global.alert = function (text) {
      _$$_REQUIRE(_dependencyMap[19], "Alert").alert('Alert', '' + text);
    };
  }

  var navigator = global.navigator;

  if (navigator === undefined) {
    global.navigator = navigator = {};
  }

  polyfillObjectProperty(navigator, 'product', function () {
    return 'ReactNative';
  });
  polyfillObjectProperty(navigator, 'geolocation', function () {
    return _$$_REQUIRE(_dependencyMap[20], "Geolocation");
  });

  var BatchedBridge = _$$_REQUIRE(_dependencyMap[21], "BatchedBridge");

  BatchedBridge.registerLazyCallableModule('Systrace', function () {
    return _$$_REQUIRE(_dependencyMap[4], "Systrace");
  });
  BatchedBridge.registerLazyCallableModule('JSTimers', function () {
    return _$$_REQUIRE(_dependencyMap[10], "JSTimers");
  });
  BatchedBridge.registerLazyCallableModule('HeapCapture', function () {
    return _$$_REQUIRE(_dependencyMap[22], "HeapCapture");
  });
  BatchedBridge.registerLazyCallableModule('SamplingProfiler', function () {
    return _$$_REQUIRE(_dependencyMap[23], "SamplingProfiler");
  });
  BatchedBridge.registerLazyCallableModule('RCTLog', function () {
    return _$$_REQUIRE(_dependencyMap[24], "RCTLog");
  });
  BatchedBridge.registerLazyCallableModule('RCTDeviceEventEmitter', function () {
    return _$$_REQUIRE(_dependencyMap[25], "RCTDeviceEventEmitter");
  });
  BatchedBridge.registerLazyCallableModule('RCTNativeAppEventEmitter', function () {
    return _$$_REQUIRE(_dependencyMap[26], "RCTNativeAppEventEmitter");
  });
  BatchedBridge.registerLazyCallableModule('PerformanceLogger', function () {
    return _$$_REQUIRE(_dependencyMap[27], "PerformanceLogger");
  });
  BatchedBridge.registerLazyCallableModule('JSDevSupportModule', function () {
    return _$$_REQUIRE(_dependencyMap[28], "JSDevSupportModule");
  });

  global.__fetchSegment = function (segmentId, options, callback) {
    var _require2 = _$$_REQUIRE(_dependencyMap[29], "NativeModules"),
        SegmentFetcher = _require2.SegmentFetcher;

    if (!SegmentFetcher) {
      throw new Error('SegmentFetcher is missing. Please ensure that it is ' + 'included as a NativeModule.');
    }

    SegmentFetcher.fetchSegment(segmentId, options, function (errorObject) {
      if (errorObject) {
        var error = new Error(errorObject.message);
        error.code = errorObject.code;
        callback(error);
      }

      callback(null);
    });
  };

  if (__DEV__) {
    if (!global.__RCTProfileIsProfiling) {
      BatchedBridge.registerCallableModule('HMRClient', _$$_REQUIRE(_dependencyMap[30], "HMRClient"));

      if (!window.document) {
        _$$_REQUIRE(_dependencyMap[31], "setupDevtools");
      }

      var JSInspector = _$$_REQUIRE(_dependencyMap[32], "JSInspector");

      JSInspector.registerAgent(_$$_REQUIRE(_dependencyMap[33], "NetworkAgent"));
    }
  }
},180,[181,182,183,187,133,188,132,196,198,206,207,212,226,194,227,223,229,230,231,232,234,126,237,238,239,137,240,241,243,119,244,251,254,255],"node_modules\\react-native\\Libraries\\Core\\InitializeCore.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var defineLazyObjectProperty = _$$_REQUIRE(_dependencyMap[1], "defineLazyObjectProperty");

  function polyfillObjectProperty(object, name, getValue) {
    var descriptor = Object.getOwnPropertyDescriptor(object, name);

    if (__DEV__ && descriptor) {
      var backupName = "original" + name[0].toUpperCase() + name.substr(1);
      Object.defineProperty(object, backupName, _objectSpread({}, descriptor, {
        value: object[name]
      }));
    }

    var _ref = descriptor || {},
        enumerable = _ref.enumerable,
        writable = _ref.writable,
        configurable = _ref.configurable;

    if (descriptor && !configurable) {
      console.error('Failed to set polyfill. ' + name + ' is not configurable.');
      return;
    }

    defineLazyObjectProperty(object, name, {
      get: getValue,
      enumerable: enumerable !== false,
      writable: writable !== false
    });
  }

  function polyfillGlobal(name, getValue) {
    polyfillObjectProperty(global, name, getValue);
  }

  module.exports = {
    polyfillObjectProperty: polyfillObjectProperty,
    polyfillGlobal: polyfillGlobal
  };
},181,[148,136],"node_modules\\react-native\\Libraries\\Utilities\\PolyfillFunctions.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _shouldActuallyPolyfillES6Collection(collectionName) {
    var Collection = global[collectionName];

    if (Collection == null) {
      return true;
    }

    if (typeof global.Symbol !== 'function') {
      return true;
    }

    var proto = Collection.prototype;
    return Collection == null || typeof Collection !== 'function' || typeof proto.clear !== 'function' || new Collection().size !== 0 || typeof proto.keys !== 'function' || typeof proto.forEach !== 'function';
  }

  var cache = {};

  function _shouldPolyfillES6Collection(collectionName) {
    var result = cache[collectionName];

    if (result !== undefined) {
      return result;
    }

    result = _shouldActuallyPolyfillES6Collection(collectionName);
    cache[collectionName] = result;
    return result;
  }

  module.exports = _shouldPolyfillES6Collection;
},182,[],"node_modules\\react-native\\Libraries\\vendor\\core\\_shouldPolyfillES6Collection.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _shouldPolyfillES6Collection = _$$_REQUIRE(_dependencyMap[2], "_shouldPolyfillES6Collection");

  var guid = _$$_REQUIRE(_dependencyMap[3], "guid");

  var isNode = _$$_REQUIRE(_dependencyMap[4], "fbjs/lib/isNode");

  var toIterator = _$$_REQUIRE(_dependencyMap[5], "toIterator");

  module.exports = function (global, undefined) {
    if (!_shouldPolyfillES6Collection('Map')) {
      return global.Map;
    }

    var KIND_KEY = 'key';
    var KIND_VALUE = 'value';
    var KIND_KEY_VALUE = 'key+value';
    var KEY_PREFIX = '$map_';
    var SECRET_SIZE_PROP;

    if (__DEV__) {
      SECRET_SIZE_PROP = '$size' + guid();
    }

    var OLD_IE_HASH_PREFIX = 'IE_HASH_';

    var Map = function () {
      function Map(iterable) {
        _classCallCheck(this, Map);

        if (!isObject(this)) {
          throw new TypeError('Wrong map object type.');
        }

        initMap(this);

        if (iterable != null) {
          var it = toIterator(iterable);
          var next;

          while (!(next = it.next()).done) {
            if (!isObject(next.value)) {
              throw new TypeError('Expected iterable items to be pair objects.');
            }

            this.set(next.value[0], next.value[1]);
          }
        }
      }

      _createClass(Map, [{
        key: "clear",
        value: function clear() {
          initMap(this);
        }
      }, {
        key: "has",
        value: function has(key) {
          var index = getIndex(this, key);
          return !!(index != null && this._mapData[index]);
        }
      }, {
        key: "set",
        value: function set(key, value) {
          var index = getIndex(this, key);

          if (index != null && this._mapData[index]) {
            this._mapData[index][1] = value;
          } else {
            index = this._mapData.push([key, value]) - 1;
            setIndex(this, key, index);

            if (__DEV__) {
              this[SECRET_SIZE_PROP] += 1;
            } else {
              this.size += 1;
            }
          }

          return this;
        }
      }, {
        key: "get",
        value: function get(key) {
          var index = getIndex(this, key);

          if (index == null) {
            return undefined;
          } else {
            return this._mapData[index][1];
          }
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          var index = getIndex(this, key);

          if (index != null && this._mapData[index]) {
            setIndex(this, key, undefined);
            this._mapData[index] = undefined;

            if (__DEV__) {
              this[SECRET_SIZE_PROP] -= 1;
            } else {
              this.size -= 1;
            }

            return true;
          } else {
            return false;
          }
        }
      }, {
        key: "entries",
        value: function entries() {
          return new MapIterator(this, KIND_KEY_VALUE);
        }
      }, {
        key: "keys",
        value: function keys() {
          return new MapIterator(this, KIND_KEY);
        }
      }, {
        key: "values",
        value: function values() {
          return new MapIterator(this, KIND_VALUE);
        }
      }, {
        key: "forEach",
        value: function forEach(callback, thisArg) {
          if (typeof callback !== 'function') {
            throw new TypeError('Callback must be callable.');
          }

          var boundCallback = callback.bind(thisArg || undefined);
          var mapData = this._mapData;

          for (var i = 0; i < mapData.length; i++) {
            var entry = mapData[i];

            if (entry != null) {
              boundCallback(entry[1], entry[0], this);
            }
          }
        }
      }]);

      return Map;
    }();

    Map.prototype[toIterator.ITERATOR_SYMBOL] = Map.prototype.entries;

    var MapIterator = function () {
      function MapIterator(map, kind) {
        _classCallCheck(this, MapIterator);

        if (!(isObject(map) && map._mapData)) {
          throw new TypeError('Object is not a map.');
        }

        if ([KIND_KEY, KIND_KEY_VALUE, KIND_VALUE].indexOf(kind) === -1) {
          throw new Error('Invalid iteration kind.');
        }

        this._map = map;
        this._nextIndex = 0;
        this._kind = kind;
      }

      _createClass(MapIterator, [{
        key: "next",
        value: function next() {
          if (!this instanceof Map) {
            throw new TypeError('Expected to be called on a MapIterator.');
          }

          var map = this._map;
          var index = this._nextIndex;
          var kind = this._kind;

          if (map == null) {
            return createIterResultObject(undefined, true);
          }

          var entries = map._mapData;

          while (index < entries.length) {
            var record = entries[index];
            index += 1;
            this._nextIndex = index;

            if (record) {
              if (kind === KIND_KEY) {
                return createIterResultObject(record[0], false);
              } else if (kind === KIND_VALUE) {
                return createIterResultObject(record[1], false);
              } else if (kind) {
                return createIterResultObject(record, false);
              }
            }
          }

          this._map = undefined;
          return createIterResultObject(undefined, true);
        }
      }]);

      return MapIterator;
    }();

    MapIterator.prototype[toIterator.ITERATOR_SYMBOL] = function () {
      return this;
    };

    function getIndex(map, key) {
      if (isObject(key)) {
        var hash = getHash(key);
        return map._objectIndex[hash];
      } else {
        var prefixedKey = KEY_PREFIX + key;

        if (typeof key === 'string') {
          return map._stringIndex[prefixedKey];
        } else {
          return map._otherIndex[prefixedKey];
        }
      }
    }

    function setIndex(map, key, index) {
      var shouldDelete = index == null;

      if (isObject(key)) {
        var hash = getHash(key);

        if (shouldDelete) {
          delete map._objectIndex[hash];
        } else {
          map._objectIndex[hash] = index;
        }
      } else {
        var prefixedKey = KEY_PREFIX + key;

        if (typeof key === 'string') {
          if (shouldDelete) {
            delete map._stringIndex[prefixedKey];
          } else {
            map._stringIndex[prefixedKey] = index;
          }
        } else {
          if (shouldDelete) {
            delete map._otherIndex[prefixedKey];
          } else {
            map._otherIndex[prefixedKey] = index;
          }
        }
      }
    }

    function initMap(map) {
      map._mapData = [];
      map._objectIndex = {};
      map._stringIndex = {};
      map._otherIndex = {};

      if (__DEV__) {
        if (isES5) {
          if (map.hasOwnProperty(SECRET_SIZE_PROP)) {
            map[SECRET_SIZE_PROP] = 0;
          } else {
            Object.defineProperty(map, SECRET_SIZE_PROP, {
              value: 0,
              writable: true
            });
            Object.defineProperty(map, 'size', {
              set: function set(v) {
                console.error('PLEASE FIX ME: You are changing the map size property which ' + 'should not be writable and will break in production.');
                throw new Error('The map size property is not writable.');
              },
              get: function get() {
                return map[SECRET_SIZE_PROP];
              }
            });
          }

          return;
        }
      }

      map.size = 0;
    }

    function isObject(o) {
      return o != null && (typeof o === 'object' || typeof o === 'function');
    }

    function createIterResultObject(value, done) {
      return {
        value: value,
        done: done
      };
    }

    var isES5 = function () {
      try {
        Object.defineProperty({}, 'x', {});
        return true;
      } catch (e) {
        return false;
      }
    }();

    function isExtensible(o) {
      if (!isES5) {
        return true;
      } else {
        return Object.isExtensible(o);
      }
    }

    function getIENodeHash(node) {
      var uniqueID;

      switch (node.nodeType) {
        case 1:
          uniqueID = node.uniqueID;
          break;

        case 9:
          uniqueID = node.documentElement.uniqueID;
          break;

        default:
          return null;
      }

      if (uniqueID) {
        return OLD_IE_HASH_PREFIX + uniqueID;
      } else {
        return null;
      }
    }

    var getHash = function () {
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      var hashProperty = guid();
      var hashCounter = 0;
      return function getHash(o) {
        if (o[hashProperty]) {
          return o[hashProperty];
        } else if (!isES5 && o.propertyIsEnumerable && o.propertyIsEnumerable[hashProperty]) {
          return o.propertyIsEnumerable[hashProperty];
        } else if (!isES5 && isNode(o) && getIENodeHash(o)) {
          return getIENodeHash(o);
        } else if (!isES5 && o[hashProperty]) {
          return o[hashProperty];
        }

        if (isExtensible(o)) {
          hashCounter += 1;

          if (isES5) {
            Object.defineProperty(o, hashProperty, {
              enumerable: false,
              writable: false,
              configurable: false,
              value: hashCounter
            });
          } else if (o.propertyIsEnumerable) {
            o.propertyIsEnumerable = function () {
              return propIsEnumerable.apply(this, arguments);
            };

            o.propertyIsEnumerable[hashProperty] = hashCounter;
          } else if (isNode(o)) {
            o[hashProperty] = hashCounter;
          } else {
            throw new Error('Unable to set a non-enumerable property on object.');
          }

          return hashCounter;
        } else {
          throw new Error('Non-extensible objects are not allowed as keys.');
        }
      };
    }();

    return Map;
  }(Function('return this')());
},183,[24,25,182,184,185,186],"node_modules\\react-native\\Libraries\\vendor\\core\\Map.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function guid() {
    return 'f' + (Math.random() * (1 << 30)).toString(16).replace('.', '');
  }

  module.exports = guid;
},184,[],"node_modules\\react-native\\Libraries\\vendor\\core\\guid.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  function isNode(object) {
    var doc = object ? object.ownerDocument || object : document;
    var defaultView = doc.defaultView || window;
    return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
  }

  module.exports = isNode;
},185,[],"node_modules\\fbjs\\lib\\isNode.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var KIND_KEY = 'key';
  var KIND_VALUE = 'value';
  var KIND_KEY_VAL = 'key+value';
  var ITERATOR_SYMBOL = typeof Symbol === 'function' ? typeof Symbol === "function" ? Symbol.iterator : "@@iterator" : '@@iterator';

  var toIterator = function () {
    if (!(Array.prototype[ITERATOR_SYMBOL] && String.prototype[ITERATOR_SYMBOL])) {
      return function () {
        var ArrayIterator = function () {
          function ArrayIterator(array, kind) {
            _classCallCheck(this, ArrayIterator);

            if (!Array.isArray(array)) {
              throw new TypeError('Object is not an Array');
            }

            this._iteratedObject = array;
            this._kind = kind;
            this._nextIndex = 0;
          }

          _createClass(ArrayIterator, [{
            key: "next",
            value: function next() {
              if (!this instanceof ArrayIterator) {
                throw new TypeError('Object is not an ArrayIterator');
              }

              if (this._iteratedObject == null) {
                return createIterResultObject(undefined, true);
              }

              var array = this._iteratedObject;
              var len = this._iteratedObject.length;
              var index = this._nextIndex;
              var kind = this._kind;

              if (index >= len) {
                this._iteratedObject = undefined;
                return createIterResultObject(undefined, true);
              }

              this._nextIndex = index + 1;

              if (kind === KIND_KEY) {
                return createIterResultObject(index, false);
              } else if (kind === KIND_VALUE) {
                return createIterResultObject(array[index], false);
              } else if (kind === KIND_KEY_VAL) {
                return createIterResultObject([index, array[index]], false);
              }
            }
          }, {
            key: '@@iterator',
            value: function iterator() {
              return this;
            }
          }]);

          return ArrayIterator;
        }();

        var StringIterator = function () {
          function StringIterator(string) {
            _classCallCheck(this, StringIterator);

            if (typeof string !== 'string') {
              throw new TypeError('Object is not a string');
            }

            this._iteratedString = string;
            this._nextIndex = 0;
          }

          _createClass(StringIterator, [{
            key: "next",
            value: function next() {
              if (!this instanceof StringIterator) {
                throw new TypeError('Object is not a StringIterator');
              }

              if (this._iteratedString == null) {
                return createIterResultObject(undefined, true);
              }

              var index = this._nextIndex;
              var s = this._iteratedString;
              var len = s.length;

              if (index >= len) {
                this._iteratedString = undefined;
                return createIterResultObject(undefined, true);
              }

              var ret;
              var first = s.charCodeAt(index);

              if (first < 0xd800 || first > 0xdbff || index + 1 === len) {
                ret = s[index];
              } else {
                var second = s.charCodeAt(index + 1);

                if (second < 0xdc00 || second > 0xdfff) {
                  ret = s[index];
                } else {
                  ret = s[index] + s[index + 1];
                }
              }

              this._nextIndex = index + ret.length;
              return createIterResultObject(ret, false);
            }
          }, {
            key: '@@iterator',
            value: function iterator() {
              return this;
            }
          }]);

          return StringIterator;
        }();

        function createIterResultObject(value, done) {
          return {
            value: value,
            done: done
          };
        }

        return function (object, kind) {
          if (typeof object === 'string') {
            return new StringIterator(object);
          } else if (Array.isArray(object)) {
            return new ArrayIterator(object, kind || KIND_VALUE);
          } else {
            return object[ITERATOR_SYMBOL]();
          }
        };
      }();
    } else {
      return function (object) {
        return object[ITERATOR_SYMBOL]();
      };
    }
  }();

  _extends(toIterator, {
    KIND_KEY: KIND_KEY,
    KIND_VALUE: KIND_VALUE,
    KIND_KEY_VAL: KIND_KEY_VAL,
    ITERATOR_SYMBOL: ITERATOR_SYMBOL
  });

  module.exports = toIterator;
},186,[112,24,25],"node_modules\\react-native\\Libraries\\vendor\\core\\toIterator.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var Map = _$$_REQUIRE(_dependencyMap[2], "Map");

  var _shouldPolyfillES6Collection = _$$_REQUIRE(_dependencyMap[3], "_shouldPolyfillES6Collection");

  var toIterator = _$$_REQUIRE(_dependencyMap[4], "toIterator");

  module.exports = function (global) {
    if (!_shouldPolyfillES6Collection('Set')) {
      return global.Set;
    }

    var Set = function () {
      function Set(iterable) {
        _classCallCheck(this, Set);

        if (this == null || typeof this !== 'object' && typeof this !== 'function') {
          throw new TypeError('Wrong set object type.');
        }

        initSet(this);

        if (iterable != null) {
          var it = toIterator(iterable);
          var next;

          while (!(next = it.next()).done) {
            this.add(next.value);
          }
        }
      }

      _createClass(Set, [{
        key: "add",
        value: function add(value) {
          this._map.set(value, value);

          this.size = this._map.size;
          return this;
        }
      }, {
        key: "clear",
        value: function clear() {
          initSet(this);
        }
      }, {
        key: "delete",
        value: function _delete(value) {
          var ret = this._map.delete(value);

          this.size = this._map.size;
          return ret;
        }
      }, {
        key: "entries",
        value: function entries() {
          return this._map.entries();
        }
      }, {
        key: "forEach",
        value: function forEach(callback) {
          var thisArg = arguments[1];

          var it = this._map.keys();

          var next;

          while (!(next = it.next()).done) {
            callback.call(thisArg, next.value, next.value, this);
          }
        }
      }, {
        key: "has",
        value: function has(value) {
          return this._map.has(value);
        }
      }, {
        key: "values",
        value: function values() {
          return this._map.values();
        }
      }]);

      return Set;
    }();

    Set.prototype[toIterator.ITERATOR_SYMBOL] = Set.prototype.values;
    Set.prototype.keys = Set.prototype.values;

    function initSet(set) {
      set._map = new Map();
      set.size = set._map.size;
    }

    return Set;
  }(Function('return this')());
},187,[24,25,183,182,186],"node_modules\\react-native\\Libraries\\vendor\\core\\Set.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var exceptionID = 0;

  function reportException(e, isFatal) {
    var _require = _$$_REQUIRE(_dependencyMap[0], "NativeModules"),
        ExceptionsManager = _require.ExceptionsManager;

    if (ExceptionsManager) {
      var parseErrorStack = _$$_REQUIRE(_dependencyMap[1], "parseErrorStack");

      var stack = parseErrorStack(e);
      var currentExceptionID = ++exceptionID;

      if (isFatal) {
        ExceptionsManager.reportFatalException(e.message, stack, currentExceptionID);
      } else {
        ExceptionsManager.reportSoftException(e.message, stack, currentExceptionID);
      }

      if (__DEV__) {
        var symbolicateStackTrace = _$$_REQUIRE(_dependencyMap[2], "symbolicateStackTrace");

        symbolicateStackTrace(stack).then(function (prettyStack) {
          if (prettyStack) {
            ExceptionsManager.updateExceptionMessage(e.message, prettyStack, currentExceptionID);
          } else {
            throw new Error('The stack is null');
          }
        }).catch(function (error) {
          return console.warn('Unable to symbolicate stack trace: ' + error.message);
        });
      }
    }
  }

  function handleException(e, isFatal) {
    if (!e.message) {
      e = new Error(e);
    }

    if (console._errorOriginal) {
      console._errorOriginal(e.message);
    } else {
      console.error(e.message);
    }

    reportException(e, isFatal);
  }

  function reactConsoleErrorHandler() {
    console._errorOriginal.apply(console, arguments);

    if (!console.reportErrorsAsExceptions) {
      return;
    }

    if (arguments[0] && arguments[0].stack) {
      reportException(arguments[0], false);
    } else {
      var stringifySafe = _$$_REQUIRE(_dependencyMap[3], "stringifySafe");

      var str = Array.prototype.map.call(arguments, stringifySafe).join(', ');

      if (str.slice(0, 10) === '"Warning: ') {
        return;
      }

      var error = new Error('console.error: ' + str);
      error.framesToPop = 1;
      reportException(error, false);
    }
  }

  function installConsoleErrorReporter() {
    if (console._errorOriginal) {
      return;
    }

    console._errorOriginal = console.error.bind(console);
    console.error = reactConsoleErrorHandler;

    if (console.reportErrorsAsExceptions === undefined) {
      console.reportErrorsAsExceptions = true;
    }
  }

  module.exports = {
    handleException: handleException,
    installConsoleErrorReporter: installConsoleErrorReporter
  };
},188,[119,189,192,135],"node_modules\\react-native\\Libraries\\Core\\ExceptionsManager.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function parseErrorStack(e) {
    if (!e || !e.stack) {
      return [];
    }

    var stacktraceParser = _$$_REQUIRE(_dependencyMap[0], "stacktrace-parser");

    var stack = Array.isArray(e.stack) ? e.stack : stacktraceParser.parse(e.stack);
    var framesToPop = typeof e.framesToPop === 'number' ? e.framesToPop : 0;

    while (framesToPop--) {
      stack.shift();
    }

    return stack;
  }

  module.exports = parseErrorStack;
},189,[190],"node_modules\\react-native\\Libraries\\Core\\Devtools\\parseErrorStack.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0], "./lib/stacktrace-parser.js");
},190,[191],"node_modules\\stacktrace-parser\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var UNKNOWN_FUNCTION = '<unknown>';
  var StackTraceParser = {
    parse: function parse(stackString) {
      var chrome = /^\s*at (?:(?:(?:Anonymous function)?|((?:\[object object\])?\S+(?: \[as \S+\])?)) )?\(?((?:file|http|https):.*?):(\d+)(?::(\d+))?\)?\s*$/i,
          gecko = /^(?:\s*([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i,
          node = /^\s*at (?:((?:\[object object\])?\S+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i,
          lines = stackString.split('\n'),
          stack = [],
          parts,
          element;

      for (var i = 0, j = lines.length; i < j; ++i) {
        if (parts = gecko.exec(lines[i])) {
          element = {
            'file': parts[3],
            'methodName': parts[1] || UNKNOWN_FUNCTION,
            'lineNumber': +parts[4],
            'column': parts[5] ? +parts[5] : null
          };
        } else if (parts = chrome.exec(lines[i])) {
          element = {
            'file': parts[2],
            'methodName': parts[1] || UNKNOWN_FUNCTION,
            'lineNumber': +parts[3],
            'column': parts[4] ? +parts[4] : null
          };
        } else if (parts = node.exec(lines[i])) {
          element = {
            'file': parts[2],
            'methodName': parts[1] || UNKNOWN_FUNCTION,
            'lineNumber': +parts[3],
            'column': parts[4] ? +parts[4] : null
          };
        } else {
          continue;
        }

        stack.push(element);
      }

      return stack;
    }
  };
  module.exports = StackTraceParser;
},191,[],"node_modules\\stacktrace-parser\\lib\\stacktrace-parser.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _regeneratorRuntime = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/regenerator");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread");

  var getDevServer = _$$_REQUIRE(_dependencyMap[2], "getDevServer");

  var _require = _$$_REQUIRE(_dependencyMap[3], "NativeModules"),
      SourceCode = _require.SourceCode;

  var fetch;

  function isSourcedFromDisk(sourcePath) {
    return !/^http/.test(sourcePath) && /[\\/]/.test(sourcePath);
  }

  function symbolicateStackTrace(stack) {
    var devServer, stackCopy, foundInternalSource, response, json;
    return _regeneratorRuntime.async(function symbolicateStackTrace$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!fetch) {
              fetch = global.fetch || _$$_REQUIRE(_dependencyMap[4], "fetch").fetch;
            }

            devServer = getDevServer();

            if (devServer.bundleLoadedFromServer) {
              _context.next = 4;
              break;
            }

            throw new Error('Bundle was not loaded from the packager');

          case 4:
            stackCopy = stack;

            if (SourceCode.scriptURL) {
              foundInternalSource = false;
              stackCopy = stack.map(function (frame) {
                if (!foundInternalSource && isSourcedFromDisk(frame.file)) {
                  return _objectSpread({}, frame, {
                    file: SourceCode.scriptURL
                  });
                }

                foundInternalSource = true;
                return frame;
              });
            }

            _context.next = 8;
            return _regeneratorRuntime.awrap(fetch(devServer.url + 'symbolicate', {
              method: 'POST',
              body: JSON.stringify({
                stack: stackCopy
              })
            }));

          case 8:
            response = _context.sent;
            _context.next = 11;
            return _regeneratorRuntime.awrap(response.json());

          case 11:
            json = _context.sent;
            return _context.abrupt("return", json.stack);

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, null, this);
  }

  module.exports = symbolicateStackTrace;
},192,[105,148,193,119,194],"node_modules\\react-native\\Libraries\\Core\\Devtools\\symbolicateStackTrace.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _require = _$$_REQUIRE(_dependencyMap[0], "NativeModules"),
      SourceCode = _require.SourceCode;

  var _cachedDevServerURL;

  var FALLBACK = 'http://localhost:8081/';

  function getDevServer() {
    if (_cachedDevServerURL === undefined) {
      var match = SourceCode && SourceCode.scriptURL && SourceCode.scriptURL.match(/^https?:\/\/.*?\//);
      _cachedDevServerURL = match ? match[0] : null;
    }

    return {
      url: _cachedDevServerURL || FALLBACK,
      bundleLoadedFromServer: _cachedDevServerURL !== null
    };
  }

  module.exports = getDevServer;
},193,[119],"node_modules\\react-native\\Libraries\\Core\\Devtools\\getDevServer.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var whatwg = _$$_REQUIRE(_dependencyMap[0], "whatwg-fetch");

  if (whatwg && whatwg.fetch) {
    module.exports = whatwg;
  } else {
    module.exports = {
      fetch: fetch,
      Headers: Headers,
      Request: Request,
      Response: Response
    };
  }
},194,[195],"node_modules\\react-native\\Libraries\\Network\\fetch.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  (function (self) {
    'use strict';

    if (self.fetch) {
      return;
    }

    var support = {
      searchParams: 'URLSearchParams' in self,
      iterable: 'Symbol' in self && 'iterator' in Symbol,
      blob: 'FileReader' in self && 'Blob' in self && function () {
        try {
          new Blob();
          return true;
        } catch (e) {
          return false;
        }
      }(),
      formData: 'FormData' in self,
      arrayBuffer: 'ArrayBuffer' in self
    };

    if (support.arrayBuffer) {
      var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

      var isDataView = function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      };

      var isArrayBufferView = ArrayBuffer.isView || function (obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
      };
    }

    function normalizeName(name) {
      if (typeof name !== 'string') {
        name = String(name);
      }

      if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
        throw new TypeError('Invalid character in header field name');
      }

      return name.toLowerCase();
    }

    function normalizeValue(value) {
      if (typeof value !== 'string') {
        value = String(value);
      }

      return value;
    }

    function iteratorFor(items) {
      var iterator = {
        next: function next() {
          var value = items.shift();
          return {
            done: value === undefined,
            value: value
          };
        }
      };

      if (support.iterable) {
        iterator[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"] = function () {
          return iterator;
        };
      }

      return iterator;
    }

    function Headers(headers) {
      this.map = {};

      if (headers instanceof Headers) {
        headers.forEach(function (value, name) {
          this.append(name, value);
        }, this);
      } else if (Array.isArray(headers)) {
        headers.forEach(function (header) {
          this.append(header[0], header[1]);
        }, this);
      } else if (headers) {
        Object.getOwnPropertyNames(headers).forEach(function (name) {
          this.append(name, headers[name]);
        }, this);
      }
    }

    Headers.prototype.append = function (name, value) {
      name = normalizeName(name);
      value = normalizeValue(value);
      var oldValue = this.map[name];
      this.map[name] = oldValue ? oldValue + ',' + value : value;
    };

    Headers.prototype['delete'] = function (name) {
      delete this.map[normalizeName(name)];
    };

    Headers.prototype.get = function (name) {
      name = normalizeName(name);
      return this.has(name) ? this.map[name] : null;
    };

    Headers.prototype.has = function (name) {
      return this.map.hasOwnProperty(normalizeName(name));
    };

    Headers.prototype.set = function (name, value) {
      this.map[normalizeName(name)] = normalizeValue(value);
    };

    Headers.prototype.forEach = function (callback, thisArg) {
      for (var name in this.map) {
        if (this.map.hasOwnProperty(name)) {
          callback.call(thisArg, this.map[name], name, this);
        }
      }
    };

    Headers.prototype.keys = function () {
      var items = [];
      this.forEach(function (value, name) {
        items.push(name);
      });
      return iteratorFor(items);
    };

    Headers.prototype.values = function () {
      var items = [];
      this.forEach(function (value) {
        items.push(value);
      });
      return iteratorFor(items);
    };

    Headers.prototype.entries = function () {
      var items = [];
      this.forEach(function (value, name) {
        items.push([name, value]);
      });
      return iteratorFor(items);
    };

    if (support.iterable) {
      Headers.prototype[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"] = Headers.prototype.entries;
    }

    function consumed(body) {
      if (body.bodyUsed) {
        return Promise.reject(new TypeError('Already read'));
      }

      body.bodyUsed = true;
    }

    function fileReaderReady(reader) {
      return new Promise(function (resolve, reject) {
        reader.onload = function () {
          resolve(reader.result);
        };

        reader.onerror = function () {
          reject(reader.error);
        };
      });
    }

    function readBlobAsArrayBuffer(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsArrayBuffer(blob);
      return promise;
    }

    function readBlobAsText(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsText(blob);
      return promise;
    }

    function readArrayBufferAsText(buf) {
      var view = new Uint8Array(buf);
      var chars = new Array(view.length);

      for (var i = 0; i < view.length; i++) {
        chars[i] = String.fromCharCode(view[i]);
      }

      return chars.join('');
    }

    function bufferClone(buf) {
      if (buf.slice) {
        return buf.slice(0);
      } else {
        var view = new Uint8Array(buf.byteLength);
        view.set(new Uint8Array(buf));
        return view.buffer;
      }
    }

    function Body() {
      this.bodyUsed = false;

      this._initBody = function (body) {
        this._bodyInit = body;

        if (!body) {
          this._bodyText = '';
        } else if (typeof body === 'string') {
          this._bodyText = body;
        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
          this._bodyBlob = body;
        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
          this._bodyFormData = body;
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this._bodyText = body.toString();
        } else if (support.arrayBuffer && support.blob && isDataView(body)) {
          this._bodyArrayBuffer = bufferClone(body.buffer);
          this._bodyInit = new Blob([this._bodyArrayBuffer]);
        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
          this._bodyArrayBuffer = bufferClone(body);
        } else {
          throw new Error('unsupported BodyInit type');
        }

        if (!this.headers.get('content-type')) {
          if (typeof body === 'string') {
            this.headers.set('content-type', 'text/plain;charset=UTF-8');
          } else if (this._bodyBlob && this._bodyBlob.type) {
            this.headers.set('content-type', this._bodyBlob.type);
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
          }
        }
      };

      if (support.blob) {
        this.blob = function () {
          var rejected = consumed(this);

          if (rejected) {
            return rejected;
          }

          if (this._bodyBlob) {
            return Promise.resolve(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          } else if (this._bodyFormData) {
            throw new Error('could not read FormData body as blob');
          } else {
            return Promise.resolve(new Blob([this._bodyText]));
          }
        };

        this.arrayBuffer = function () {
          if (this._bodyArrayBuffer) {
            return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
          } else {
            return this.blob().then(readBlobAsArrayBuffer);
          }
        };
      }

      this.text = function () {
        var rejected = consumed(this);

        if (rejected) {
          return rejected;
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob);
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text');
        } else {
          return Promise.resolve(this._bodyText);
        }
      };

      if (support.formData) {
        this.formData = function () {
          return this.text().then(decode);
        };
      }

      this.json = function () {
        return this.text().then(JSON.parse);
      };

      return this;
    }

    var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

    function normalizeMethod(method) {
      var upcased = method.toUpperCase();
      return methods.indexOf(upcased) > -1 ? upcased : method;
    }

    function Request(input, options) {
      options = options || {};
      var body = options.body;

      if (input instanceof Request) {
        if (input.bodyUsed) {
          throw new TypeError('Already read');
        }

        this.url = input.url;
        this.credentials = input.credentials;

        if (!options.headers) {
          this.headers = new Headers(input.headers);
        }

        this.method = input.method;
        this.mode = input.mode;

        if (!body && input._bodyInit != null) {
          body = input._bodyInit;
          input.bodyUsed = true;
        }
      } else {
        this.url = String(input);
      }

      this.credentials = options.credentials || this.credentials || 'omit';

      if (options.headers || !this.headers) {
        this.headers = new Headers(options.headers);
      }

      this.method = normalizeMethod(options.method || this.method || 'GET');
      this.mode = options.mode || this.mode || null;
      this.referrer = null;

      if ((this.method === 'GET' || this.method === 'HEAD') && body) {
        throw new TypeError('Body not allowed for GET or HEAD requests');
      }

      this._initBody(body);
    }

    Request.prototype.clone = function () {
      return new Request(this, {
        body: this._bodyInit
      });
    };

    function decode(body) {
      var form = new FormData();
      body.trim().split('&').forEach(function (bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
      return form;
    }

    function parseHeaders(rawHeaders) {
      var headers = new Headers();
      var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
      preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
        var parts = line.split(':');
        var key = parts.shift().trim();

        if (key) {
          var value = parts.join(':').trim();
          headers.append(key, value);
        }
      });
      return headers;
    }

    Body.call(Request.prototype);

    function Response(bodyInit, options) {
      if (!options) {
        options = {};
      }

      this.type = 'default';
      this.status = options.status === undefined ? 200 : options.status;
      this.ok = this.status >= 200 && this.status < 300;
      this.statusText = 'statusText' in options ? options.statusText : 'OK';
      this.headers = new Headers(options.headers);
      this.url = options.url || '';

      this._initBody(bodyInit);
    }

    Body.call(Response.prototype);

    Response.prototype.clone = function () {
      return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
      });
    };

    Response.error = function () {
      var response = new Response(null, {
        status: 0,
        statusText: ''
      });
      response.type = 'error';
      return response;
    };

    var redirectStatuses = [301, 302, 303, 307, 308];

    Response.redirect = function (url, status) {
      if (redirectStatuses.indexOf(status) === -1) {
        throw new RangeError('Invalid status code');
      }

      return new Response(null, {
        status: status,
        headers: {
          location: url
        }
      });
    };

    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;

    self.fetch = function (input, init) {
      return new Promise(function (resolve, reject) {
        var request = new Request(input, init);
        var xhr = new XMLHttpRequest();

        xhr.onload = function () {
          var options = {
            status: xhr.status,
            statusText: xhr.statusText,
            headers: parseHeaders(xhr.getAllResponseHeaders() || '')
          };
          options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
          var body = 'response' in xhr ? xhr.response : xhr.responseText;
          resolve(new Response(body, options));
        };

        xhr.onerror = function () {
          reject(new TypeError('Network request failed'));
        };

        xhr.ontimeout = function () {
          reject(new TypeError('Network request failed'));
        };

        xhr.open(request.method, request.url, true);

        if (request.credentials === 'include') {
          xhr.withCredentials = true;
        } else if (request.credentials === 'omit') {
          xhr.withCredentials = false;
        }

        request.headers.forEach(function (value, name) {
          xhr.setRequestHeader(name, value);
        });
        xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
      });
    };

    self.fetch.polyfill = true;
  })(typeof self !== 'undefined' ? self : this);
},195,[],"node_modules\\react-native\\Libraries\\vendor\\core\\whatwg-fetch.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _require = _$$_REQUIRE(_dependencyMap[0], "NativeModules"),
      PlatformConstants = _require.PlatformConstants;

  var ReactNativeVersion = _$$_REQUIRE(_dependencyMap[1], "ReactNativeVersion");

  exports.checkVersions = function checkVersions() {
    if (!PlatformConstants) {
      return;
    }

    var nativeVersion = PlatformConstants.reactNativeVersion;

    if (ReactNativeVersion.version.major !== nativeVersion.major || ReactNativeVersion.version.minor !== nativeVersion.minor) {
      console.error("React Native version mismatch.\n\nJavaScript version: " + _formatVersion(ReactNativeVersion.version) + "\n" + ("Native version: " + _formatVersion(nativeVersion) + "\n\n") + 'Make sure that you have rebuilt the native code. If the problem ' + 'persists try clearing the Watchman and packager caches with ' + '`watchman watch-del-all && react-native start --reset-cache`.');
    }
  };

  function _formatVersion(version) {
    return version.major + "." + version.minor + "." + version.patch + (version.prerelease !== null ? "-" + version.prerelease : '');
  }
},196,[119,197],"node_modules\\react-native\\Libraries\\Core\\ReactNativeVersionCheck.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  exports.version = {
    major: 0,
    minor: 57,
    patch: 5,
    prerelease: null
  };
},197,[],"node_modules\\react-native\\Libraries\\Core\\ReactNativeVersion.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Promise = _$$_REQUIRE(_dependencyMap[0], "fbjs/lib/Promise.native");

  if (__DEV__) {
    _$$_REQUIRE(_dependencyMap[1], "promise/setimmediate/rejection-tracking").enable({
      allRejections: true,
      onUnhandled: function onUnhandled(id) {
        var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var message;
        var stack;
        var stringValue = Object.prototype.toString.call(error);

        if (stringValue === '[object Error]') {
          message = Error.prototype.toString.call(error);
          stack = error.stack;
        } else {
          message = _$$_REQUIRE(_dependencyMap[2], "pretty-format")(error);
        }

        var warning = "Possible Unhandled Promise Rejection (id: " + id + "):\n" + (message + "\n") + (stack == null ? '' : stack);
        console.warn(warning);
      },
      onHandled: function onHandled(id) {
        var warning = "Promise Rejection Handled (id: " + id + ")\n" + 'This means you can ignore any previous messages of the form ' + ("\"Possible Unhandled Promise Rejection (id: " + id + "):\"");
        console.warn(warning);
      }
    });
  }

  module.exports = Promise;
},198,[199,203,204],"node_modules\\react-native\\Libraries\\Promise.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Promise = _$$_REQUIRE(_dependencyMap[0], "promise/setimmediate/es6-extensions");

  _$$_REQUIRE(_dependencyMap[1], "promise/setimmediate/done");

  Promise.prototype["finally"] = function (onSettled) {
    return this.then(onSettled, onSettled);
  };

  module.exports = Promise;
},199,[200,202],"node_modules\\fbjs\\lib\\Promise.native.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Promise = _$$_REQUIRE(_dependencyMap[0], "./core.js");

  module.exports = Promise;
  var TRUE = valuePromise(true);
  var FALSE = valuePromise(false);
  var NULL = valuePromise(null);
  var UNDEFINED = valuePromise(undefined);
  var ZERO = valuePromise(0);
  var EMPTYSTRING = valuePromise('');

  function valuePromise(value) {
    var p = new Promise(Promise._61);
    p._65 = 1;
    p._55 = value;
    return p;
  }

  Promise.resolve = function (value) {
    if (value instanceof Promise) return value;
    if (value === null) return NULL;
    if (value === undefined) return UNDEFINED;
    if (value === true) return TRUE;
    if (value === false) return FALSE;
    if (value === 0) return ZERO;
    if (value === '') return EMPTYSTRING;

    if (typeof value === 'object' || typeof value === 'function') {
      try {
        var then = value.then;

        if (typeof then === 'function') {
          return new Promise(then.bind(value));
        }
      } catch (ex) {
        return new Promise(function (resolve, reject) {
          reject(ex);
        });
      }
    }

    return valuePromise(value);
  };

  Promise.all = function (arr) {
    var args = Array.prototype.slice.call(arr);
    return new Promise(function (resolve, reject) {
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          if (val instanceof Promise && val.then === Promise.prototype.then) {
            while (val._65 === 3) {
              val = val._55;
            }

            if (val._65 === 1) return res(i, val._55);
            if (val._65 === 2) reject(val._55);
            val.then(function (val) {
              res(i, val);
            }, reject);
            return;
          } else {
            var then = val.then;

            if (typeof then === 'function') {
              var p = new Promise(then.bind(val));
              p.then(function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
        }

        args[i] = val;

        if (--remaining === 0) {
          resolve(args);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      values.forEach(function (value) {
        Promise.resolve(value).then(resolve, reject);
      });
    });
  };

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };
},200,[201],"node_modules\\promise\\setimmediate\\es6-extensions.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function noop() {}

  var LAST_ERROR = null;
  var IS_ERROR = {};

  function getThen(obj) {
    try {
      return obj.then;
    } catch (ex) {
      LAST_ERROR = ex;
      return IS_ERROR;
    }
  }

  function tryCallOne(fn, a) {
    try {
      return fn(a);
    } catch (ex) {
      LAST_ERROR = ex;
      return IS_ERROR;
    }
  }

  function tryCallTwo(fn, a, b) {
    try {
      fn(a, b);
    } catch (ex) {
      LAST_ERROR = ex;
      return IS_ERROR;
    }
  }

  module.exports = Promise;

  function Promise(fn) {
    if (typeof this !== 'object') {
      throw new TypeError('Promises must be constructed via new');
    }

    if (typeof fn !== 'function') {
      throw new TypeError('Promise constructor\'s argument is not a function');
    }

    this._40 = 0;
    this._65 = 0;
    this._55 = null;
    this._72 = null;
    if (fn === noop) return;
    doResolve(fn, this);
  }

  Promise._37 = null;
  Promise._87 = null;
  Promise._61 = noop;

  Promise.prototype.then = function (onFulfilled, onRejected) {
    if (this.constructor !== Promise) {
      return safeThen(this, onFulfilled, onRejected);
    }

    var res = new Promise(noop);
    handle(this, new Handler(onFulfilled, onRejected, res));
    return res;
  };

  function safeThen(self, onFulfilled, onRejected) {
    return new self.constructor(function (resolve, reject) {
      var res = new Promise(noop);
      res.then(resolve, reject);
      handle(self, new Handler(onFulfilled, onRejected, res));
    });
  }

  function handle(self, deferred) {
    while (self._65 === 3) {
      self = self._55;
    }

    if (Promise._37) {
      Promise._37(self);
    }

    if (self._65 === 0) {
      if (self._40 === 0) {
        self._40 = 1;
        self._72 = deferred;
        return;
      }

      if (self._40 === 1) {
        self._40 = 2;
        self._72 = [self._72, deferred];
        return;
      }

      self._72.push(deferred);

      return;
    }

    handleResolved(self, deferred);
  }

  function handleResolved(self, deferred) {
    setImmediate(function () {
      var cb = self._65 === 1 ? deferred.onFulfilled : deferred.onRejected;

      if (cb === null) {
        if (self._65 === 1) {
          resolve(deferred.promise, self._55);
        } else {
          reject(deferred.promise, self._55);
        }

        return;
      }

      var ret = tryCallOne(cb, self._55);

      if (ret === IS_ERROR) {
        reject(deferred.promise, LAST_ERROR);
      } else {
        resolve(deferred.promise, ret);
      }
    });
  }

  function resolve(self, newValue) {
    if (newValue === self) {
      return reject(self, new TypeError('A promise cannot be resolved with itself.'));
    }

    if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
      var then = getThen(newValue);

      if (then === IS_ERROR) {
        return reject(self, LAST_ERROR);
      }

      if (then === self.then && newValue instanceof Promise) {
        self._65 = 3;
        self._55 = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(then.bind(newValue), self);
        return;
      }
    }

    self._65 = 1;
    self._55 = newValue;
    finale(self);
  }

  function reject(self, newValue) {
    self._65 = 2;
    self._55 = newValue;

    if (Promise._87) {
      Promise._87(self, newValue);
    }

    finale(self);
  }

  function finale(self) {
    if (self._40 === 1) {
      handle(self, self._72);
      self._72 = null;
    }

    if (self._40 === 2) {
      for (var i = 0; i < self._72.length; i++) {
        handle(self, self._72[i]);
      }

      self._72 = null;
    }
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  function doResolve(fn, promise) {
    var done = false;
    var res = tryCallTwo(fn, function (value) {
      if (done) return;
      done = true;
      resolve(promise, value);
    }, function (reason) {
      if (done) return;
      done = true;
      reject(promise, reason);
    });

    if (!done && res === IS_ERROR) {
      done = true;
      reject(promise, LAST_ERROR);
    }
  }
},201,[],"node_modules\\promise\\setimmediate\\core.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Promise = _$$_REQUIRE(_dependencyMap[0], "./core.js");

  module.exports = Promise;

  Promise.prototype.done = function (onFulfilled, onRejected) {
    var self = arguments.length ? this.then.apply(this, arguments) : this;
    self.then(null, function (err) {
      setTimeout(function () {
        throw err;
      }, 0);
    });
  };
},202,[201],"node_modules\\promise\\setimmediate\\done.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Promise = _$$_REQUIRE(_dependencyMap[0], "./core");

  var DEFAULT_WHITELIST = [ReferenceError, TypeError, RangeError];
  var enabled = false;
  exports.disable = disable;

  function disable() {
    enabled = false;
    Promise._37 = null;
    Promise._87 = null;
  }

  exports.enable = enable;

  function enable(options) {
    options = options || {};
    if (enabled) disable();
    enabled = true;
    var id = 0;
    var displayId = 0;
    var rejections = {};

    Promise._37 = function (promise) {
      if (promise._65 === 2 && rejections[promise._51]) {
        if (rejections[promise._51].logged) {
          onHandled(promise._51);
        } else {
          clearTimeout(rejections[promise._51].timeout);
        }

        delete rejections[promise._51];
      }
    };

    Promise._87 = function (promise, err) {
      if (promise._40 === 0) {
        promise._51 = id++;
        rejections[promise._51] = {
          displayId: null,
          error: err,
          timeout: setTimeout(onUnhandled.bind(null, promise._51), matchWhitelist(err, DEFAULT_WHITELIST) ? 100 : 2000),
          logged: false
        };
      }
    };

    function onUnhandled(id) {
      if (options.allRejections || matchWhitelist(rejections[id].error, options.whitelist || DEFAULT_WHITELIST)) {
        rejections[id].displayId = displayId++;

        if (options.onUnhandled) {
          rejections[id].logged = true;
          options.onUnhandled(rejections[id].displayId, rejections[id].error);
        } else {
          rejections[id].logged = true;
          logError(rejections[id].displayId, rejections[id].error);
        }
      }
    }

    function onHandled(id) {
      if (rejections[id].logged) {
        if (options.onHandled) {
          options.onHandled(rejections[id].displayId, rejections[id].error);
        } else if (!rejections[id].onUnhandled) {
          console.warn('Promise Rejection Handled (id: ' + rejections[id].displayId + '):');
          console.warn('  This means you can ignore any previous messages of the form "Possible Unhandled Promise Rejection" with id ' + rejections[id].displayId + '.');
        }
      }
    }
  }

  function logError(id, error) {
    console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');
    var errStr = (error && (error.stack || error)) + '';
    errStr.split('\n').forEach(function (line) {
      console.warn('  ' + line);
    });
  }

  function matchWhitelist(error, list) {
    return list.some(function (cls) {
      return error instanceof cls;
    });
  }
},203,[201],"node_modules\\promise\\setimmediate\\rejection-tracking.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var printString = _$$_REQUIRE(_dependencyMap[0], "./printString");

  var toString = Object.prototype.toString;
  var toISOString = Date.prototype.toISOString;
  var errorToString = Error.prototype.toString;
  var regExpToString = RegExp.prototype.toString;
  var symbolToString = (typeof Symbol === "function" ? Symbol.prototype : "@@prototype").toString;
  var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
  var NEWLINE_REGEXP = /\n/ig;

  var getSymbols = Object.getOwnPropertySymbols || function (obj) {
    return [];
  };

  function isToStringedArrayType(toStringed) {
    return toStringed === '[object Array]' || toStringed === '[object ArrayBuffer]' || toStringed === '[object DataView]' || toStringed === '[object Float32Array]' || toStringed === '[object Float64Array]' || toStringed === '[object Int8Array]' || toStringed === '[object Int16Array]' || toStringed === '[object Int32Array]' || toStringed === '[object Uint8Array]' || toStringed === '[object Uint8ClampedArray]' || toStringed === '[object Uint16Array]' || toStringed === '[object Uint32Array]';
  }

  function printNumber(val) {
    if (val != +val) return 'NaN';
    var isNegativeZero = val === 0 && 1 / val < 0;
    return isNegativeZero ? '-0' : '' + val;
  }

  function printFunction(val, printFunctionName) {
    if (!printFunctionName) {
      return '[Function]';
    } else if (val.name === '') {
      return '[Function anonymous]';
    } else {
      return '[Function ' + val.name + ']';
    }
  }

  function printSymbol(val) {
    return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
  }

  function printError(val) {
    return '[' + errorToString.call(val) + ']';
  }

  function printBasicValue(val, printFunctionName, escapeRegex) {
    if (val === true || val === false) return '' + val;
    if (val === undefined) return 'undefined';
    if (val === null) return 'null';
    var typeOf = typeof val;
    if (typeOf === 'number') return printNumber(val);
    if (typeOf === 'string') return '"' + printString(val) + '"';
    if (typeOf === 'function') return printFunction(val, printFunctionName);
    if (typeOf === 'symbol') return printSymbol(val);
    var toStringed = toString.call(val);
    if (toStringed === '[object WeakMap]') return 'WeakMap {}';
    if (toStringed === '[object WeakSet]') return 'WeakSet {}';
    if (toStringed === '[object Function]' || toStringed === '[object GeneratorFunction]') return printFunction(val, printFunctionName);
    if (toStringed === '[object Symbol]') return printSymbol(val);
    if (toStringed === '[object Date]') return toISOString.call(val);
    if (toStringed === '[object Error]') return printError(val);

    if (toStringed === '[object RegExp]') {
      if (escapeRegex) {
        return printString(regExpToString.call(val));
      }

      return regExpToString.call(val);
    }

    ;
    if (toStringed === '[object Arguments]' && val.length === 0) return 'Arguments []';
    if (isToStringedArrayType(toStringed) && val.length === 0) return val.constructor.name + ' []';
    if (val instanceof Error) return printError(val);
    return false;
  }

  function printList(list, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex) {
    var body = '';

    if (list.length) {
      body += edgeSpacing;
      var innerIndent = prevIndent + indent;

      for (var i = 0; i < list.length; i++) {
        body += innerIndent + print(list[i], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);

        if (i < list.length - 1) {
          body += ',' + spacing;
        }
      }

      body += (min ? '' : ',') + edgeSpacing + prevIndent;
    }

    return '[' + body + ']';
  }

  function printArguments(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex) {
    return (min ? '' : 'Arguments ') + printList(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
  }

  function printArray(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex) {
    return (min ? '' : val.constructor.name + ' ') + printList(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
  }

  function printMap(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex) {
    var result = 'Map {';
    var iterator = val.entries();
    var current = iterator.next();

    if (!current.done) {
      result += edgeSpacing;
      var innerIndent = prevIndent + indent;

      while (!current.done) {
        var key = print(current.value[0], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
        var value = print(current.value[1], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
        result += innerIndent + key + ' => ' + value;
        current = iterator.next();

        if (!current.done) {
          result += ',' + spacing;
        }
      }

      result += (min ? '' : ',') + edgeSpacing + prevIndent;
    }

    return result + '}';
  }

  function printObject(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex) {
    var constructor = min ? '' : val.constructor ? val.constructor.name + ' ' : 'Object ';
    var result = constructor + '{';
    var keys = Object.keys(val).sort();
    var symbols = getSymbols(val);

    if (symbols.length) {
      keys = keys.filter(function (key) {
        return !(typeof key === 'symbol' || toString.call(key) === '[object Symbol]');
      }).concat(symbols);
    }

    if (keys.length) {
      result += edgeSpacing;
      var innerIndent = prevIndent + indent;

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var name = print(key, indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
        var value = print(val[key], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
        result += innerIndent + name + ': ' + value;

        if (i < keys.length - 1) {
          result += ',' + spacing;
        }
      }

      result += (min ? '' : ',') + edgeSpacing + prevIndent;
    }

    return result + '}';
  }

  function printSet(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex) {
    var result = 'Set {';
    var iterator = val.entries();
    var current = iterator.next();

    if (!current.done) {
      result += edgeSpacing;
      var innerIndent = prevIndent + indent;

      while (!current.done) {
        result += innerIndent + print(current.value[1], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
        current = iterator.next();

        if (!current.done) {
          result += ',' + spacing;
        }
      }

      result += (min ? '' : ',') + edgeSpacing + prevIndent;
    }

    return result + '}';
  }

  function printComplexValue(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex) {
    refs = refs.slice();

    if (refs.indexOf(val) > -1) {
      return '[Circular]';
    } else {
      refs.push(val);
    }

    currentDepth++;
    var hitMaxDepth = currentDepth > maxDepth;

    if (callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === 'function') {
      return print(val.toJSON(), indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
    }

    var toStringed = toString.call(val);

    if (toStringed === '[object Arguments]') {
      return hitMaxDepth ? '[Arguments]' : printArguments(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
    } else if (isToStringedArrayType(toStringed)) {
      return hitMaxDepth ? '[Array]' : printArray(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
    } else if (toStringed === '[object Map]') {
      return hitMaxDepth ? '[Map]' : printMap(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
    } else if (toStringed === '[object Set]') {
      return hitMaxDepth ? '[Set]' : printSet(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
    } else if (typeof val === 'object') {
      return hitMaxDepth ? '[Object]' : printObject(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
    }
  }

  function printPlugin(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex) {
    var match = false;
    var plugin;

    for (var p = 0; p < plugins.length; p++) {
      plugin = plugins[p];

      if (plugin.test(val)) {
        match = true;
        break;
      }
    }

    if (!match) {
      return false;
    }

    function boundPrint(val) {
      return print(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
    }

    function boundIndent(str) {
      var indentation = prevIndent + indent;
      return indentation + str.replace(NEWLINE_REGEXP, '\n' + indentation);
    }

    return plugin.print(val, boundPrint, boundIndent, {
      edgeSpacing: edgeSpacing,
      spacing: spacing
    });
  }

  function print(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex) {
    var basic = printBasicValue(val, printFunctionName, escapeRegex);
    if (basic) return basic;
    var plugin = printPlugin(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
    if (plugin) return plugin;
    return printComplexValue(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex);
  }

  var DEFAULTS = {
    callToJSON: true,
    indent: 2,
    maxDepth: Infinity,
    min: false,
    plugins: [],
    printFunctionName: true,
    escapeRegex: false
  };

  function validateOptions(opts) {
    Object.keys(opts).forEach(function (key) {
      if (!DEFAULTS.hasOwnProperty(key)) {
        throw new Error('prettyFormat: Invalid option: ' + key);
      }
    });

    if (opts.min && opts.indent !== undefined && opts.indent !== 0) {
      throw new Error('prettyFormat: Cannot run with min option and indent');
    }
  }

  function normalizeOptions(opts) {
    var result = {};
    Object.keys(DEFAULTS).forEach(function (key) {
      return result[key] = opts.hasOwnProperty(key) ? opts[key] : DEFAULTS[key];
    });

    if (result.min) {
      result.indent = 0;
    }

    return result;
  }

  function createIndent(indent) {
    return new Array(indent + 1).join(' ');
  }

  function prettyFormat(val, opts) {
    if (!opts) {
      opts = DEFAULTS;
    } else {
      validateOptions(opts);
      opts = normalizeOptions(opts);
    }

    var indent;
    var refs;
    var prevIndent = '';
    var currentDepth = 0;
    var spacing = opts.min ? ' ' : '\n';
    var edgeSpacing = opts.min ? '' : '\n';

    if (opts && opts.plugins.length) {
      indent = createIndent(opts.indent);
      refs = [];
      var pluginsResult = printPlugin(val, indent, prevIndent, spacing, edgeSpacing, refs, opts.maxDepth, currentDepth, opts.plugins, opts.min, opts.callToJSON, opts.printFunctionName, opts.escapeRegex);
      if (pluginsResult) return pluginsResult;
    }

    var basicResult = printBasicValue(val, opts.printFunctionName, opts.escapeRegex);
    if (basicResult) return basicResult;
    if (!indent) indent = createIndent(opts.indent);
    if (!refs) refs = [];
    return printComplexValue(val, indent, prevIndent, spacing, edgeSpacing, refs, opts.maxDepth, currentDepth, opts.plugins, opts.min, opts.callToJSON, opts.printFunctionName, opts.escapeRegex);
  }

  module.exports = prettyFormat;
},204,[205],"node_modules\\react-native\\node_modules\\pretty-format\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var ESCAPED_CHARACTERS = /(\\|\"|\')/g;

  module.exports = function printString(val) {
    return val.replace(ESCAPED_CHARACTERS, '\\$1');
  };
},205,[],"node_modules\\react-native\\node_modules\\pretty-format\\printString.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  !function (global) {
    "use strict";

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    var inModule = typeof module === "object";
    var runtime = global.regeneratorRuntime;

    if (runtime) {
      if (inModule) {
        module.exports = runtime;
      }

      return;
    }

    runtime = global.regeneratorRuntime = inModule ? module.exports : {};

    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    runtime.wrap = wrap;

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {}

    var IteratorPrototype = {};

    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        prototype[method] = function (arg) {
          return this._invoke(method, arg);
        };
      });
    }

    runtime.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    runtime.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;

        if (!(toStringTagSymbol in genFun)) {
          genFun[toStringTagSymbol] = "GeneratorFunction";
        }
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    runtime.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return Promise.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return Promise.resolve(value).then(function (unwrapped) {
            result.value = unwrapped;
            resolve(result);
          }, reject);
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new Promise(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }

      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);

    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };

    runtime.AsyncIterator = AsyncIterator;

    runtime.async = function (innerFn, outerFn, self, tryLocsList) {
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
      return runtime.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined) {
        context.delegate = null;

        if (context.method === "throw") {
          if (delegate.iterator.return) {
            context.method = "return";
            context.arg = undefined;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        context[delegate.resultName] = info.value;
        context.next = delegate.nextLoc;

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined;
        }
      } else {
        return info;
      }

      context.delegate = null;
      return ContinueSentinel;
    }

    defineIteratorMethods(Gp);
    Gp[toStringTagSymbol] = "Generator";

    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    runtime.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse();
      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      }

      return {
        next: doneResult
      };
    }

    runtime.values = values;

    function doneResult() {
      return {
        value: undefined,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            context.method = "next";
            context.arg = undefined;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        }

        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          this.arg = undefined;
        }

        return ContinueSentinel;
      }
    };
  }(function () {
    return this;
  }() || Function("return this")());
},206,[],"node_modules\\regenerator-runtime\\runtime.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Platform = _$$_REQUIRE(_dependencyMap[0], "Platform");

  var Systrace = _$$_REQUIRE(_dependencyMap[1], "Systrace");

  var invariant = _$$_REQUIRE(_dependencyMap[2], "fbjs/lib/invariant");

  var _require = _$$_REQUIRE(_dependencyMap[3], "NativeModules"),
      Timing = _require.Timing;

  var BatchedBridge = _$$_REQUIRE(_dependencyMap[4], "BatchedBridge");

  var _performanceNow = null;

  function performanceNow() {
    if (!_performanceNow) {
      _performanceNow = _$$_REQUIRE(_dependencyMap[5], "fbjs/lib/performanceNow");
    }

    return _performanceNow();
  }

  var FRAME_DURATION = 1000 / 60;
  var IDLE_CALLBACK_FRAME_DEADLINE = 1;
  var MAX_TIMER_DURATION_MS = 60 * 1000;
  var IS_ANDROID = Platform.OS === 'android';
  var ANDROID_LONG_TIMER_MESSAGE = 'Setting a timer for a long period of time, i.e. multiple minutes, is a ' + 'performance and correctness issue on Android as it keeps the timer ' + 'module awake, and timers can only be called when the app is in the foreground. ' + 'See https://github.com/facebook/react-native/issues/12981 for more info.';
  var callbacks = [];
  var types = [];
  var timerIDs = [];
  var immediates = [];
  var requestIdleCallbacks = [];
  var requestIdleCallbackTimeouts = {};
  var identifiers = [];
  var GUID = 1;
  var errors = null;
  var hasEmittedTimeDriftWarning = false;

  function _getFreeIndex() {
    var freeIndex = timerIDs.indexOf(null);

    if (freeIndex === -1) {
      freeIndex = timerIDs.length;
    }

    return freeIndex;
  }

  function _allocateCallback(func, type) {
    var id = GUID++;

    var freeIndex = _getFreeIndex();

    timerIDs[freeIndex] = id;
    callbacks[freeIndex] = func;
    types[freeIndex] = type;

    if (__DEV__) {
      var parseErrorStack = _$$_REQUIRE(_dependencyMap[6], "parseErrorStack");

      var error = new Error();
      error.framesToPop = 1;
      var stack = parseErrorStack(error);

      if (stack) {
        identifiers[freeIndex] = stack.shift();
      }
    }

    return id;
  }

  function _callTimer(timerID, frameTime, didTimeout) {
    _$$_REQUIRE(_dependencyMap[7], "fbjs/lib/warning")(timerID <= GUID, 'Tried to call timer with ID %s but no such timer exists.', timerID);

    var timerIndex = timerIDs.indexOf(timerID);

    if (timerIndex === -1) {
      return;
    }

    var type = types[timerIndex];
    var callback = callbacks[timerIndex];

    if (!callback || !type) {
      console.error('No callback found for timerID ' + timerID);
      return;
    }

    if (__DEV__) {
      var identifier = identifiers[timerIndex] || {};
      Systrace.beginEvent('Systrace.callTimer: ' + identifier.methodName);
    }

    if (type === 'setTimeout' || type === 'setImmediate' || type === 'requestAnimationFrame' || type === 'requestIdleCallback') {
      _clearIndex(timerIndex);
    }

    try {
      if (type === 'setTimeout' || type === 'setInterval' || type === 'setImmediate') {
        callback();
      } else if (type === 'requestAnimationFrame') {
        callback(performanceNow());
      } else if (type === 'requestIdleCallback') {
        callback({
          timeRemaining: function timeRemaining() {
            return Math.max(0, FRAME_DURATION - (performanceNow() - frameTime));
          },
          didTimeout: !!didTimeout
        });
      } else {
        console.error('Tried to call a callback with invalid type: ' + type);
      }
    } catch (e) {
      if (!errors) {
        errors = [e];
      } else {
        errors.push(e);
      }
    }

    if (__DEV__) {
      Systrace.endEvent();
    }
  }

  function _callImmediatesPass() {
    if (__DEV__) {
      Systrace.beginEvent('callImmediatesPass()');
    }

    if (immediates.length > 0) {
      var passImmediates = immediates.slice();
      immediates = [];

      for (var i = 0; i < passImmediates.length; ++i) {
        _callTimer(passImmediates[i], 0);
      }
    }

    if (__DEV__) {
      Systrace.endEvent();
    }

    return immediates.length > 0;
  }

  function _clearIndex(i) {
    timerIDs[i] = null;
    callbacks[i] = null;
    types[i] = null;
    identifiers[i] = null;
  }

  function _freeCallback(timerID) {
    if (timerID == null) {
      return;
    }

    var index = timerIDs.indexOf(timerID);

    if (index !== -1) {
      _clearIndex(index);

      var type = types[index];

      if (type !== 'setImmediate' && type !== 'requestIdleCallback') {
        Timing.deleteTimer(timerID);
      }
    }
  }

  var JSTimers = {
    setTimeout: function setTimeout(func, duration) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {
        console.warn(ANDROID_LONG_TIMER_MESSAGE + '\n' + '(Saw setTimeout with duration ' + duration + 'ms)');
      }

      var id = _allocateCallback(function () {
        return func.apply(undefined, args);
      }, 'setTimeout');

      Timing.createTimer(id, duration || 0, Date.now(), false);
      return id;
    },
    setInterval: function setInterval(func, duration) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {
        console.warn(ANDROID_LONG_TIMER_MESSAGE + '\n' + '(Saw setInterval with duration ' + duration + 'ms)');
      }

      var id = _allocateCallback(function () {
        return func.apply(undefined, args);
      }, 'setInterval');

      Timing.createTimer(id, duration || 0, Date.now(), true);
      return id;
    },
    setImmediate: function setImmediate(func) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      var id = _allocateCallback(function () {
        return func.apply(undefined, args);
      }, 'setImmediate');

      immediates.push(id);
      return id;
    },
    requestAnimationFrame: function requestAnimationFrame(func) {
      var id = _allocateCallback(func, 'requestAnimationFrame');

      Timing.createTimer(id, 1, Date.now(), false);
      return id;
    },
    requestIdleCallback: function requestIdleCallback(func, options) {
      if (requestIdleCallbacks.length === 0) {
        Timing.setSendIdleEvents(true);
      }

      var timeout = options && options.timeout;

      var id = _allocateCallback(timeout != null ? function (deadline) {
        var timeoutId = requestIdleCallbackTimeouts[id];

        if (timeoutId) {
          JSTimers.clearTimeout(timeoutId);
          delete requestIdleCallbackTimeouts[id];
        }

        return func(deadline);
      } : func, 'requestIdleCallback');

      requestIdleCallbacks.push(id);

      if (timeout != null) {
        var timeoutId = JSTimers.setTimeout(function () {
          var index = requestIdleCallbacks.indexOf(id);

          if (index > -1) {
            requestIdleCallbacks.splice(index, 1);

            _callTimer(id, performanceNow(), true);
          }

          delete requestIdleCallbackTimeouts[id];

          if (requestIdleCallbacks.length === 0) {
            Timing.setSendIdleEvents(false);
          }
        }, timeout);
        requestIdleCallbackTimeouts[id] = timeoutId;
      }

      return id;
    },
    cancelIdleCallback: function cancelIdleCallback(timerID) {
      _freeCallback(timerID);

      var index = requestIdleCallbacks.indexOf(timerID);

      if (index !== -1) {
        requestIdleCallbacks.splice(index, 1);
      }

      var timeoutId = requestIdleCallbackTimeouts[timerID];

      if (timeoutId) {
        JSTimers.clearTimeout(timeoutId);
        delete requestIdleCallbackTimeouts[timerID];
      }

      if (requestIdleCallbacks.length === 0) {
        Timing.setSendIdleEvents(false);
      }
    },
    clearTimeout: function clearTimeout(timerID) {
      _freeCallback(timerID);
    },
    clearInterval: function clearInterval(timerID) {
      _freeCallback(timerID);
    },
    clearImmediate: function clearImmediate(timerID) {
      _freeCallback(timerID);

      var index = immediates.indexOf(timerID);

      if (index !== -1) {
        immediates.splice(index, 1);
      }
    },
    cancelAnimationFrame: function cancelAnimationFrame(timerID) {
      _freeCallback(timerID);
    },
    callTimers: function callTimers(timersToCall) {
      invariant(timersToCall.length !== 0, 'Cannot call `callTimers` with an empty list of IDs.');
      errors = null;

      for (var i = 0; i < timersToCall.length; i++) {
        _callTimer(timersToCall[i], 0);
      }

      if (errors) {
        var errorCount = errors.length;

        if (errorCount > 1) {
          for (var ii = 1; ii < errorCount; ii++) {
            JSTimers.setTimeout(function (error) {
              throw error;
            }.bind(null, errors[ii]), 0);
          }
        }

        throw errors[0];
      }
    },
    callIdleCallbacks: function callIdleCallbacks(frameTime) {
      if (FRAME_DURATION - (performanceNow() - frameTime) < IDLE_CALLBACK_FRAME_DEADLINE) {
        return;
      }

      errors = null;

      if (requestIdleCallbacks.length > 0) {
        var passIdleCallbacks = requestIdleCallbacks.slice();
        requestIdleCallbacks = [];

        for (var i = 0; i < passIdleCallbacks.length; ++i) {
          _callTimer(passIdleCallbacks[i], frameTime);
        }
      }

      if (requestIdleCallbacks.length === 0) {
        Timing.setSendIdleEvents(false);
      }

      if (errors) {
        errors.forEach(function (error) {
          return JSTimers.setTimeout(function () {
            throw error;
          }, 0);
        });
      }
    },
    callImmediates: function callImmediates() {
      errors = null;

      while (_callImmediatesPass()) {}

      if (errors) {
        errors.forEach(function (error) {
          return JSTimers.setTimeout(function () {
            throw error;
          }, 0);
        });
      }
    },
    emitTimeDriftWarning: function emitTimeDriftWarning(warningMessage) {
      if (hasEmittedTimeDriftWarning) {
        return;
      }

      hasEmittedTimeDriftWarning = true;
      console.warn(warningMessage);
    }
  };
  var ExportedJSTimers;

  if (!Timing) {
    console.warn("Timing native module is not available, can't set timers.");
    ExportedJSTimers = {
      callImmediates: JSTimers.callImmediates,
      setImmediate: JSTimers.setImmediate
    };
  } else {
    ExportedJSTimers = JSTimers;
  }

  BatchedBridge.setImmediatesCallback(ExportedJSTimers.callImmediates.bind(ExportedJSTimers));
  module.exports = ExportedJSTimers;
},207,[146,133,117,119,126,208,189,211],"node_modules\\react-native\\Libraries\\Core\\Timers\\JSTimers.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var performance = _$$_REQUIRE(_dependencyMap[0], "./performance");

  var performanceNow;

  if (performance.now) {
    performanceNow = function performanceNow() {
      return performance.now();
    };
  } else {
    performanceNow = function performanceNow() {
      return Date.now();
    };
  }

  module.exports = performanceNow;
},208,[209],"node_modules\\fbjs\\lib\\performanceNow.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var ExecutionEnvironment = _$$_REQUIRE(_dependencyMap[0], "./ExecutionEnvironment");

  var performance;

  if (ExecutionEnvironment.canUseDOM) {
    performance = window.performance || window.msPerformance || window.webkitPerformance;
  }

  module.exports = performance || {};
},209,[210],"node_modules\\fbjs\\lib\\performance.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
  var ExecutionEnvironment = {
    canUseDOM: canUseDOM,
    canUseWorkers: typeof Worker !== 'undefined',
    canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
    canUseViewport: canUseDOM && !!window.screen,
    isInWorker: !canUseDOM
  };
  module.exports = ExecutionEnvironment;
},210,[],"node_modules\\fbjs\\lib\\ExecutionEnvironment.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var emptyFunction = _$$_REQUIRE(_dependencyMap[0], "./emptyFunction");

  function printWarning(format) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });

    if (typeof console !== 'undefined') {
      console.error(message);
    }

    try {
      throw new Error(message);
    } catch (x) {}
  }

  var warning = process.env.NODE_ENV !== "production" ? function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(void 0, [format].concat(args));
    }
  } : emptyFunction;
  module.exports = warning;
},211,[144],"node_modules\\fbjs\\lib\\warning.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _toConsumableArray = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/toConsumableArray");

  var _get = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/get");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/classCallCheck");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/defineProperty");

  var EventTarget = _$$_REQUIRE(_dependencyMap[9], "event-target-shim");

  var RCTNetworking = _$$_REQUIRE(_dependencyMap[10], "RCTNetworking");

  var base64 = _$$_REQUIRE(_dependencyMap[11], "base64-js");

  var invariant = _$$_REQUIRE(_dependencyMap[12], "fbjs/lib/invariant");

  var warning = _$$_REQUIRE(_dependencyMap[13], "fbjs/lib/warning");

  var BlobManager = _$$_REQUIRE(_dependencyMap[14], "BlobManager");

  if (BlobManager.isAvailable) {
    BlobManager.addNetworkingHandler();
  }

  var UNSENT = 0;
  var OPENED = 1;
  var HEADERS_RECEIVED = 2;
  var LOADING = 3;
  var DONE = 4;
  var SUPPORTED_RESPONSE_TYPES = {
    arraybuffer: typeof global.ArrayBuffer === 'function',
    blob: typeof global.Blob === 'function',
    document: false,
    json: true,
    text: true,
    '': true
  };
  var REQUEST_EVENTS = ['abort', 'error', 'load', 'loadstart', 'progress', 'timeout', 'loadend'];
  var XHR_EVENTS = REQUEST_EVENTS.concat('readystatechange');

  var XMLHttpRequestEventTarget = function (_EventTarget) {
    _inherits(XMLHttpRequestEventTarget, _EventTarget);

    function XMLHttpRequestEventTarget() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, XMLHttpRequestEventTarget);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(XMLHttpRequestEventTarget)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onload", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onloadstart", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onprogress", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "ontimeout", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onerror", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onabort", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onloadend", void 0);

      return _this;
    }

    return XMLHttpRequestEventTarget;
  }(EventTarget.apply(void 0, REQUEST_EVENTS));

  var XMLHttpRequest = function (_EventTarget2) {
    _inherits(XMLHttpRequest, _EventTarget2);

    _createClass(XMLHttpRequest, null, [{
      key: "setInterceptor",
      value: function setInterceptor(interceptor) {
        XMLHttpRequest._interceptor = interceptor;
      }
    }]);

    function XMLHttpRequest() {
      var _this2;

      _classCallCheck(this, XMLHttpRequest);

      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(XMLHttpRequest).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "UNSENT", UNSENT);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "OPENED", OPENED);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "HEADERS_RECEIVED", HEADERS_RECEIVED);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "LOADING", LOADING);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "DONE", DONE);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "onload", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "onloadstart", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "onprogress", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "ontimeout", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "onerror", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "onabort", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "onloadend", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "onreadystatechange", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "readyState", UNSENT);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "responseHeaders", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "status", 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "timeout", 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "responseURL", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "withCredentials", true);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "upload", new XMLHttpRequestEventTarget());

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_requestId", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_subscriptions", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_aborted", false);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_cachedResponse", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_hasError", false);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_headers", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_lowerCaseResponseHeaders", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_method", null);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_response", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_responseType", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_response", '');

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_sent", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_url", null);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_timedOut", false);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_trackingName", 'unknown');

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_incrementalEvents", false);

      _this2._reset();

      return _this2;
    }

    _createClass(XMLHttpRequest, [{
      key: "_reset",
      value: function _reset() {
        this.readyState = this.UNSENT;
        this.responseHeaders = undefined;
        this.status = 0;
        delete this.responseURL;
        this._requestId = null;
        this._cachedResponse = undefined;
        this._hasError = false;
        this._headers = {};
        this._response = '';
        this._responseType = '';
        this._sent = false;
        this._lowerCaseResponseHeaders = {};

        this._clearSubscriptions();

        this._timedOut = false;
      }
    }, {
      key: "__didCreateRequest",
      value: function __didCreateRequest(requestId) {
        this._requestId = requestId;
        XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.requestSent(requestId, this._url || '', this._method || 'GET', this._headers);
      }
    }, {
      key: "__didUploadProgress",
      value: function __didUploadProgress(requestId, progress, total) {
        if (requestId === this._requestId) {
          this.upload.dispatchEvent({
            type: 'progress',
            lengthComputable: true,
            loaded: progress,
            total: total
          });
        }
      }
    }, {
      key: "__didReceiveResponse",
      value: function __didReceiveResponse(requestId, status, responseHeaders, responseURL) {
        if (requestId === this._requestId) {
          this.status = status;
          this.setResponseHeaders(responseHeaders);
          this.setReadyState(this.HEADERS_RECEIVED);

          if (responseURL || responseURL === '') {
            this.responseURL = responseURL;
          } else {
            delete this.responseURL;
          }

          XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.responseReceived(requestId, responseURL || this._url || '', status, responseHeaders || {});
        }
      }
    }, {
      key: "__didReceiveData",
      value: function __didReceiveData(requestId, response) {
        if (requestId !== this._requestId) {
          return;
        }

        this._response = response;
        this._cachedResponse = undefined;
        this.setReadyState(this.LOADING);
        XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.dataReceived(requestId, response);
      }
    }, {
      key: "__didReceiveIncrementalData",
      value: function __didReceiveIncrementalData(requestId, responseText, progress, total) {
        if (requestId !== this._requestId) {
          return;
        }

        if (!this._response) {
          this._response = responseText;
        } else {
          this._response += responseText;
        }

        XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.dataReceived(requestId, responseText);
        this.setReadyState(this.LOADING);

        this.__didReceiveDataProgress(requestId, progress, total);
      }
    }, {
      key: "__didReceiveDataProgress",
      value: function __didReceiveDataProgress(requestId, loaded, total) {
        if (requestId !== this._requestId) {
          return;
        }

        this.dispatchEvent({
          type: 'progress',
          lengthComputable: total >= 0,
          loaded: loaded,
          total: total
        });
      }
    }, {
      key: "__didCompleteResponse",
      value: function __didCompleteResponse(requestId, error, timeOutError) {
        if (requestId === this._requestId) {
          if (error) {
            if (this._responseType === '' || this._responseType === 'text') {
              this._response = error;
            }

            this._hasError = true;

            if (timeOutError) {
              this._timedOut = true;
            }
          }

          this._clearSubscriptions();

          this._requestId = null;
          this.setReadyState(this.DONE);

          if (error) {
            XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.loadingFailed(requestId, error);
          } else {
            XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.loadingFinished(requestId, this._response.length);
          }
        }
      }
    }, {
      key: "_clearSubscriptions",
      value: function _clearSubscriptions() {
        (this._subscriptions || []).forEach(function (sub) {
          if (sub) {
            sub.remove();
          }
        });
        this._subscriptions = [];
      }
    }, {
      key: "getAllResponseHeaders",
      value: function getAllResponseHeaders() {
        if (!this.responseHeaders) {
          return null;
        }

        var headers = this.responseHeaders || {};
        return Object.keys(headers).map(function (headerName) {
          return headerName + ': ' + headers[headerName];
        }).join('\r\n');
      }
    }, {
      key: "getResponseHeader",
      value: function getResponseHeader(header) {
        var value = this._lowerCaseResponseHeaders[header.toLowerCase()];

        return value !== undefined ? value : null;
      }
    }, {
      key: "setRequestHeader",
      value: function setRequestHeader(header, value) {
        if (this.readyState !== this.OPENED) {
          throw new Error('Request has not been opened');
        }

        this._headers[header.toLowerCase()] = String(value);
      }
    }, {
      key: "setTrackingName",
      value: function setTrackingName(trackingName) {
        this._trackingName = trackingName;
        return this;
      }
    }, {
      key: "open",
      value: function open(method, url, async) {
        if (this.readyState !== this.UNSENT) {
          throw new Error('Cannot open, already sending');
        }

        if (async !== undefined && !async) {
          throw new Error('Synchronous http requests are not supported');
        }

        if (!url) {
          throw new Error('Cannot load an empty url');
        }

        this._method = method.toUpperCase();
        this._url = url;
        this._aborted = false;
        this.setReadyState(this.OPENED);
      }
    }, {
      key: "send",
      value: function send(data) {
        var _this3 = this;

        if (this.readyState !== this.OPENED) {
          throw new Error('Request has not been opened');
        }

        if (this._sent) {
          throw new Error('Request has already been sent');
        }

        this._sent = true;
        var incrementalEvents = this._incrementalEvents || !!this.onreadystatechange || !!this.onprogress;

        this._subscriptions.push(RCTNetworking.addListener('didSendNetworkData', function (args) {
          return _this3.__didUploadProgress.apply(_this3, _toConsumableArray(args));
        }));

        this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkResponse', function (args) {
          return _this3.__didReceiveResponse.apply(_this3, _toConsumableArray(args));
        }));

        this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkData', function (args) {
          return _this3.__didReceiveData.apply(_this3, _toConsumableArray(args));
        }));

        this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkIncrementalData', function (args) {
          return _this3.__didReceiveIncrementalData.apply(_this3, _toConsumableArray(args));
        }));

        this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkDataProgress', function (args) {
          return _this3.__didReceiveDataProgress.apply(_this3, _toConsumableArray(args));
        }));

        this._subscriptions.push(RCTNetworking.addListener('didCompleteNetworkResponse', function (args) {
          return _this3.__didCompleteResponse.apply(_this3, _toConsumableArray(args));
        }));

        var nativeResponseType = 'text';

        if (this._responseType === 'arraybuffer') {
          nativeResponseType = 'base64';
        }

        if (this._responseType === 'blob') {
          nativeResponseType = 'blob';
        }

        invariant(this._method, 'Request method needs to be defined.');
        invariant(this._url, 'Request URL needs to be defined.');
        RCTNetworking.sendRequest(this._method, this._trackingName, this._url, this._headers, data, nativeResponseType, incrementalEvents, this.timeout, this.__didCreateRequest.bind(this), this.withCredentials);
      }
    }, {
      key: "abort",
      value: function abort() {
        this._aborted = true;

        if (this._requestId) {
          RCTNetworking.abortRequest(this._requestId);
        }

        if (!(this.readyState === this.UNSENT || this.readyState === this.OPENED && !this._sent || this.readyState === this.DONE)) {
          this._reset();

          this.setReadyState(this.DONE);
        }

        this._reset();
      }
    }, {
      key: "setResponseHeaders",
      value: function setResponseHeaders(responseHeaders) {
        this.responseHeaders = responseHeaders || null;
        var headers = responseHeaders || {};
        this._lowerCaseResponseHeaders = Object.keys(headers).reduce(function (lcaseHeaders, headerName) {
          lcaseHeaders[headerName.toLowerCase()] = headers[headerName];
          return lcaseHeaders;
        }, {});
      }
    }, {
      key: "setReadyState",
      value: function setReadyState(newState) {
        this.readyState = newState;
        this.dispatchEvent({
          type: 'readystatechange'
        });

        if (newState === this.DONE) {
          if (this._aborted) {
            this.dispatchEvent({
              type: 'abort'
            });
          } else if (this._hasError) {
            if (this._timedOut) {
              this.dispatchEvent({
                type: 'timeout'
              });
            } else {
              this.dispatchEvent({
                type: 'error'
              });
            }
          } else {
            this.dispatchEvent({
              type: 'load'
            });
          }

          this.dispatchEvent({
            type: 'loadend'
          });
        }
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener) {
        if (type === 'readystatechange' || type === 'progress') {
          this._incrementalEvents = true;
        }

        _get(_getPrototypeOf(XMLHttpRequest.prototype), "addEventListener", this).call(this, type, listener);
      }
    }, {
      key: "responseType",
      get: function get() {
        return this._responseType;
      },
      set: function set(responseType) {
        if (this._sent) {
          throw new Error("Failed to set the 'responseType' property on 'XMLHttpRequest': The " + 'response type cannot be set after the request has been sent.');
        }

        if (!SUPPORTED_RESPONSE_TYPES.hasOwnProperty(responseType)) {
          warning(false, "The provided value '" + responseType + "' is not a valid 'responseType'.");
          return;
        }

        invariant(SUPPORTED_RESPONSE_TYPES[responseType] || responseType === 'document', "The provided value '" + responseType + "' is unsupported in this environment.");

        if (responseType === 'blob') {
          invariant(BlobManager.isAvailable, 'Native module BlobModule is required for blob support');
        }

        this._responseType = responseType;
      }
    }, {
      key: "responseText",
      get: function get() {
        if (this._responseType !== '' && this._responseType !== 'text') {
          throw new Error("The 'responseText' property is only available if 'responseType' " + ("is set to '' or 'text', but it is '" + this._responseType + "'."));
        }

        if (this.readyState < LOADING) {
          return '';
        }

        return this._response;
      }
    }, {
      key: "response",
      get: function get() {
        var responseType = this.responseType;

        if (responseType === '' || responseType === 'text') {
          return this.readyState < LOADING || this._hasError ? '' : this._response;
        }

        if (this.readyState !== DONE) {
          return null;
        }

        if (this._cachedResponse !== undefined) {
          return this._cachedResponse;
        }

        switch (responseType) {
          case 'document':
            this._cachedResponse = null;
            break;

          case 'arraybuffer':
            this._cachedResponse = base64.toByteArray(this._response).buffer;
            break;

          case 'blob':
            if (typeof this._response === 'object' && this._response) {
              this._cachedResponse = BlobManager.createFromOptions(this._response);
            } else if (this._response === '') {
              this._cachedResponse = null;
            } else {
              throw new Error("Invalid response for blob: " + this._response);
            }

            break;

          case 'json':
            try {
              this._cachedResponse = JSON.parse(this._response);
            } catch (_) {
              this._cachedResponse = null;
            }

            break;

          default:
            this._cachedResponse = null;
        }

        return this._cachedResponse;
      }
    }]);

    return XMLHttpRequest;
  }(EventTarget.apply(void 0, _toConsumableArray(XHR_EVENTS)));

  _defineProperty(XMLHttpRequest, "UNSENT", UNSENT);

  _defineProperty(XMLHttpRequest, "OPENED", OPENED);

  _defineProperty(XMLHttpRequest, "HEADERS_RECEIVED", HEADERS_RECEIVED);

  _defineProperty(XMLHttpRequest, "LOADING", LOADING);

  _defineProperty(XMLHttpRequest, "DONE", DONE);

  _defineProperty(XMLHttpRequest, "_interceptor", null);

  module.exports = XMLHttpRequest;
},212,[128,138,25,24,26,29,30,28,32,213,217,222,117,211,224],"node_modules\\react-native\\Libraries\\Network\\XMLHttpRequest.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var Commons = _$$_REQUIRE(_dependencyMap[0], "./commons");

  var CustomEventTarget = _$$_REQUIRE(_dependencyMap[1], "./custom-event-target");

  var EventWrapper = _$$_REQUIRE(_dependencyMap[2], "./event-wrapper");

  var LISTENERS = Commons.LISTENERS;
  var CAPTURE = Commons.CAPTURE;
  var BUBBLE = Commons.BUBBLE;
  var ATTRIBUTE = Commons.ATTRIBUTE;
  var newNode = Commons.newNode;
  var defineCustomEventTarget = CustomEventTarget.defineCustomEventTarget;
  var createEventWrapper = EventWrapper.createEventWrapper;
  var STOP_IMMEDIATE_PROPAGATION_FLAG = EventWrapper.STOP_IMMEDIATE_PROPAGATION_FLAG;
  var HAS_EVENTTARGET_INTERFACE = typeof window !== "undefined" && typeof window.EventTarget !== "undefined";

  var EventTarget = module.exports = function EventTarget() {
    if (this instanceof EventTarget) {
      Object.defineProperty(this, LISTENERS, {
        value: Object.create(null)
      });
    } else if (arguments.length === 1 && Array.isArray(arguments[0])) {
      return defineCustomEventTarget(EventTarget, arguments[0]);
    } else if (arguments.length > 0) {
      var types = Array(arguments.length);

      for (var i = 0; i < arguments.length; ++i) {
        types[i] = arguments[i];
      }

      return defineCustomEventTarget(EventTarget, types);
    } else {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  EventTarget.prototype = Object.create((HAS_EVENTTARGET_INTERFACE ? window.EventTarget : Object).prototype, {
    constructor: {
      value: EventTarget,
      writable: true,
      configurable: true
    },
    addEventListener: {
      value: function addEventListener(type, listener, capture) {
        if (listener == null) {
          return false;
        }

        if (typeof listener !== "function" && typeof listener !== "object") {
          throw new TypeError("\"listener\" is not an object.");
        }

        var kind = capture ? CAPTURE : BUBBLE;
        var node = this[LISTENERS][type];

        if (node == null) {
          this[LISTENERS][type] = newNode(listener, kind);
          return true;
        }

        var prev = null;

        while (node != null) {
          if (node.listener === listener && node.kind === kind) {
            return false;
          }

          prev = node;
          node = node.next;
        }

        prev.next = newNode(listener, kind);
        return true;
      },
      configurable: true,
      writable: true
    },
    removeEventListener: {
      value: function removeEventListener(type, listener, capture) {
        if (listener == null) {
          return false;
        }

        var kind = capture ? CAPTURE : BUBBLE;
        var prev = null;
        var node = this[LISTENERS][type];

        while (node != null) {
          if (node.listener === listener && node.kind === kind) {
            if (prev == null) {
              this[LISTENERS][type] = node.next;
            } else {
              prev.next = node.next;
            }

            return true;
          }

          prev = node;
          node = node.next;
        }

        return false;
      },
      configurable: true,
      writable: true
    },
    dispatchEvent: {
      value: function dispatchEvent(event) {
        var node = this[LISTENERS][event.type];

        if (node == null) {
          return true;
        }

        var wrapped = createEventWrapper(event, this);

        while (node != null) {
          if (typeof node.listener === "function") {
            node.listener.call(this, wrapped);
          } else if (node.kind !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
            node.listener.handleEvent(wrapped);
          }

          if (wrapped[STOP_IMMEDIATE_PROPAGATION_FLAG]) {
            break;
          }

          node = node.next;
        }

        return !wrapped.defaultPrevented;
      },
      configurable: true,
      writable: true
    }
  });
},213,[214,215,216],"node_modules\\event-target-shim\\lib\\event-target.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var createUniqueKey = exports.createUniqueKey = typeof Symbol !== "undefined" ? Symbol : function createUniqueKey(name) {
    return "[[" + name + "_" + Math.random().toFixed(8).slice(2) + "]]";
  };
  exports.LISTENERS = createUniqueKey("listeners");
  exports.CAPTURE = 1;
  exports.BUBBLE = 2;
  exports.ATTRIBUTE = 3;

  exports.newNode = function newNode(listener, kind) {
    return {
      listener: listener,
      kind: kind,
      next: null
    };
  };
},214,[],"node_modules\\event-target-shim\\lib\\commons.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var Commons = _$$_REQUIRE(_dependencyMap[0], "./commons");

  var LISTENERS = Commons.LISTENERS;
  var ATTRIBUTE = Commons.ATTRIBUTE;
  var newNode = Commons.newNode;

  function getAttributeListener(eventTarget, type) {
    var node = eventTarget[LISTENERS][type];

    while (node != null) {
      if (node.kind === ATTRIBUTE) {
        return node.listener;
      }

      node = node.next;
    }

    return null;
  }

  function setAttributeListener(eventTarget, type, listener) {
    if (typeof listener !== "function" && typeof listener !== "object") {
      listener = null;
    }

    var prev = null;
    var node = eventTarget[LISTENERS][type];

    while (node != null) {
      if (node.kind === ATTRIBUTE) {
        if (prev == null) {
          eventTarget[LISTENERS][type] = node.next;
        } else {
          prev.next = node.next;
        }
      } else {
        prev = node;
      }

      node = node.next;
    }

    if (listener != null) {
      if (prev == null) {
        eventTarget[LISTENERS][type] = newNode(listener, ATTRIBUTE);
      } else {
        prev.next = newNode(listener, ATTRIBUTE);
      }
    }
  }

  exports.defineCustomEventTarget = function (EventTargetBase, types) {
    function EventTarget() {
      EventTargetBase.call(this);
    }

    var descripter = {
      constructor: {
        value: EventTarget,
        configurable: true,
        writable: true
      }
    };
    types.forEach(function (type) {
      descripter["on" + type] = {
        get: function get() {
          return getAttributeListener(this, type);
        },
        set: function set(listener) {
          setAttributeListener(this, type, listener);
        },
        configurable: true,
        enumerable: true
      };
    });
    EventTarget.prototype = Object.create(EventTargetBase.prototype, descripter);
    return EventTarget;
  };
},215,[214],"node_modules\\event-target-shim\\lib\\custom-event-target.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var createUniqueKey = _$$_REQUIRE(_dependencyMap[0], "./commons").createUniqueKey;

  var STOP_IMMEDIATE_PROPAGATION_FLAG = createUniqueKey("stop_immediate_propagation_flag");
  var CANCELED_FLAG = createUniqueKey("canceled_flag");
  var ORIGINAL_EVENT = createUniqueKey("original_event");
  var wrapperPrototypeDefinition = Object.freeze({
    stopPropagation: Object.freeze({
      value: function stopPropagation() {
        var e = this[ORIGINAL_EVENT];

        if (typeof e.stopPropagation === "function") {
          e.stopPropagation();
        }
      },
      writable: true,
      configurable: true
    }),
    stopImmediatePropagation: Object.freeze({
      value: function stopImmediatePropagation() {
        this[STOP_IMMEDIATE_PROPAGATION_FLAG] = true;
        var e = this[ORIGINAL_EVENT];

        if (typeof e.stopImmediatePropagation === "function") {
          e.stopImmediatePropagation();
        }
      },
      writable: true,
      configurable: true
    }),
    preventDefault: Object.freeze({
      value: function preventDefault() {
        if (this.cancelable === true) {
          this[CANCELED_FLAG] = true;
        }

        var e = this[ORIGINAL_EVENT];

        if (typeof e.preventDefault === "function") {
          e.preventDefault();
        }
      },
      writable: true,
      configurable: true
    }),
    defaultPrevented: Object.freeze({
      get: function defaultPrevented() {
        return this[CANCELED_FLAG];
      },
      enumerable: true,
      configurable: true
    })
  });
  exports.STOP_IMMEDIATE_PROPAGATION_FLAG = STOP_IMMEDIATE_PROPAGATION_FLAG;

  exports.createEventWrapper = function createEventWrapper(event, eventTarget) {
    var timeStamp = typeof event.timeStamp === "number" ? event.timeStamp : Date.now();
    var propertyDefinition = {
      type: {
        value: event.type,
        enumerable: true
      },
      target: {
        value: eventTarget,
        enumerable: true
      },
      currentTarget: {
        value: eventTarget,
        enumerable: true
      },
      eventPhase: {
        value: 2,
        enumerable: true
      },
      bubbles: {
        value: Boolean(event.bubbles),
        enumerable: true
      },
      cancelable: {
        value: Boolean(event.cancelable),
        enumerable: true
      },
      timeStamp: {
        value: timeStamp,
        enumerable: true
      },
      isTrusted: {
        value: false,
        enumerable: true
      }
    };
    propertyDefinition[STOP_IMMEDIATE_PROPAGATION_FLAG] = {
      value: false,
      writable: true
    };
    propertyDefinition[CANCELED_FLAG] = {
      value: false,
      writable: true
    };
    propertyDefinition[ORIGINAL_EVENT] = {
      value: event
    };

    if (typeof event.detail !== "undefined") {
      propertyDefinition.detail = {
        value: event.detail,
        enumerable: true
      };
    }

    return Object.create(Object.create(event, wrapperPrototypeDefinition), propertyDefinition);
  };
},216,[214],"node_modules\\event-target-shim\\lib\\event-wrapper.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var MissingNativeEventEmitterShim = _$$_REQUIRE(_dependencyMap[8], "MissingNativeEventEmitterShim");

  var NativeEventEmitter = _$$_REQUIRE(_dependencyMap[9], "NativeEventEmitter");

  var RCTNetworkingNative = _$$_REQUIRE(_dependencyMap[10], "NativeModules").Networking;

  var convertRequestBody = _$$_REQUIRE(_dependencyMap[11], "convertRequestBody");

  function convertHeadersMapToArray(headers) {
    var headerArray = [];

    for (var name in headers) {
      headerArray.push([name, headers[name]]);
    }

    return headerArray;
  }

  var _requestId = 1;

  function generateRequestId() {
    return _requestId++;
  }

  var RCTNetworking = function (_NativeEventEmitter) {
    _inherits(RCTNetworking, _NativeEventEmitter);

    function RCTNetworking() {
      var _this;

      _classCallCheck(this, RCTNetworking);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(RCTNetworking).call(this, RCTNetworkingNative));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "isAvailable", true);

      return _this;
    }

    _createClass(RCTNetworking, [{
      key: "sendRequest",
      value: function sendRequest(method, trackingName, url, headers, data, responseType, incrementalUpdates, timeout, callback, withCredentials) {
        var body = convertRequestBody(data);

        if (body && body.formData) {
          body.formData = body.formData.map(function (part) {
            return _objectSpread({}, part, {
              headers: convertHeadersMapToArray(part.headers)
            });
          });
        }

        var requestId = generateRequestId();
        RCTNetworkingNative.sendRequest(method, url, requestId, convertHeadersMapToArray(headers), _objectSpread({}, body, {
          trackingName: trackingName
        }), responseType, incrementalUpdates, timeout, withCredentials);
        callback(requestId);
      }
    }, {
      key: "abortRequest",
      value: function abortRequest(requestId) {
        RCTNetworkingNative.abortRequest(requestId);
      }
    }, {
      key: "clearCookies",
      value: function clearCookies(callback) {
        RCTNetworkingNative.clearCookies(callback);
      }
    }]);

    return RCTNetworking;
  }(NativeEventEmitter);

  if (__DEV__ && !RCTNetworkingNative) {
    var MissingNativeRCTNetworkingShim = function (_MissingNativeEventEm) {
      _inherits(MissingNativeRCTNetworkingShim, _MissingNativeEventEm);

      function MissingNativeRCTNetworkingShim() {
        _classCallCheck(this, MissingNativeRCTNetworkingShim);

        return _possibleConstructorReturn(this, _getPrototypeOf(MissingNativeRCTNetworkingShim).call(this, 'RCTNetworking', 'Networking'));
      }

      _createClass(MissingNativeRCTNetworkingShim, [{
        key: "sendRequest",
        value: function sendRequest() {
          this.throwMissingNativeModule();
        }
      }, {
        key: "abortRequest",
        value: function abortRequest() {
          this.throwMissingNativeModule();
        }
      }, {
        key: "clearCookies",
        value: function clearCookies() {
          this.throwMissingNativeModule();
        }
      }]);

      return MissingNativeRCTNetworkingShim;
    }(MissingNativeEventEmitterShim);

    RCTNetworking = new MissingNativeRCTNetworkingShim();
  } else {
    RCTNetworking = new RCTNetworking();
  }

  module.exports = RCTNetworking;
},217,[148,24,25,26,29,30,28,32,218,219,119,220],"node_modules\\react-native\\Libraries\\Network\\RCTNetworking.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/defineProperty");

  var EmitterSubscription = _$$_REQUIRE(_dependencyMap[7], "EmitterSubscription");

  var EventEmitter = _$$_REQUIRE(_dependencyMap[8], "EventEmitter");

  var invariant = _$$_REQUIRE(_dependencyMap[9], "fbjs/lib/invariant");

  var MissingNativeEventEmitterShim = function (_EventEmitter) {
    _inherits(MissingNativeEventEmitterShim, _EventEmitter);

    function MissingNativeEventEmitterShim(nativeModuleName, nativeEventEmitterName) {
      var _this;

      _classCallCheck(this, MissingNativeEventEmitterShim);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MissingNativeEventEmitterShim).call(this, null));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "isAvailable", false);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_nativeModuleName", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_nativeEventEmitterName", void 0);

      _this._nativeModuleName = nativeModuleName;
      _this._nativeEventEmitterName = nativeEventEmitterName;
      return _this;
    }

    _createClass(MissingNativeEventEmitterShim, [{
      key: "throwMissingNativeModule",
      value: function throwMissingNativeModule() {
        invariant(false, "Cannot use '" + this._nativeEventEmitterName + "' module when " + ("native '" + this._nativeModuleName + "' is not included in the build. ") + ("Either include it, or check '" + this._nativeEventEmitterName + "'.isAvailable ") + 'before calling any methods.');
      }
    }, {
      key: "addListener",
      value: function addListener(eventType, listener, context) {
        this.throwMissingNativeModule();
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners(eventType) {
        this.throwMissingNativeModule();
      }
    }, {
      key: "removeSubscription",
      value: function removeSubscription(subscription) {
        this.throwMissingNativeModule();
      }
    }]);

    return MissingNativeEventEmitterShim;
  }(EventEmitter);

  module.exports = MissingNativeEventEmitterShim;
},218,[24,25,26,29,30,28,32,141,140,117],"node_modules\\react-native\\Libraries\\EventEmitter\\MissingNativeEventEmitterShim.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _get = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/get");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var EventEmitter = _$$_REQUIRE(_dependencyMap[8], "EventEmitter");

  var Platform = _$$_REQUIRE(_dependencyMap[9], "Platform");

  var RCTDeviceEventEmitter = _$$_REQUIRE(_dependencyMap[10], "RCTDeviceEventEmitter");

  var invariant = _$$_REQUIRE(_dependencyMap[11], "fbjs/lib/invariant");

  var NativeEventEmitter = function (_EventEmitter) {
    _inherits(NativeEventEmitter, _EventEmitter);

    function NativeEventEmitter(nativeModule) {
      var _this;

      _classCallCheck(this, NativeEventEmitter);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(NativeEventEmitter).call(this, RCTDeviceEventEmitter.sharedSubscriber));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_nativeModule", void 0);

      if (Platform.OS === 'ios') {
        invariant(nativeModule, 'Native module cannot be null.');
        _this._nativeModule = nativeModule;
      }

      return _this;
    }

    _createClass(NativeEventEmitter, [{
      key: "addListener",
      value: function addListener(eventType, listener, context) {
        if (this._nativeModule != null) {
          this._nativeModule.addListener(eventType);
        }

        return _get(_getPrototypeOf(NativeEventEmitter.prototype), "addListener", this).call(this, eventType, listener, context);
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners(eventType) {
        invariant(eventType, 'eventType argument is required.');
        var count = this.listeners(eventType).length;

        if (this._nativeModule != null) {
          this._nativeModule.removeListeners(count);
        }

        _get(_getPrototypeOf(NativeEventEmitter.prototype), "removeAllListeners", this).call(this, eventType);
      }
    }, {
      key: "removeSubscription",
      value: function removeSubscription(subscription) {
        if (this._nativeModule != null) {
          this._nativeModule.removeListeners(1);
        }

        _get(_getPrototypeOf(NativeEventEmitter.prototype), "removeSubscription", this).call(this, subscription);
      }
    }]);

    return NativeEventEmitter;
  }(EventEmitter);

  module.exports = NativeEventEmitter;
},219,[24,25,26,29,138,30,28,32,140,146,137,117],"node_modules\\react-native\\Libraries\\EventEmitter\\NativeEventEmitter.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var binaryToBase64 = _$$_REQUIRE(_dependencyMap[0], "binaryToBase64");

  var Blob = _$$_REQUIRE(_dependencyMap[1], "Blob");

  var FormData = _$$_REQUIRE(_dependencyMap[2], "FormData");

  function convertRequestBody(body) {
    if (typeof body === 'string') {
      return {
        string: body
      };
    }

    if (body instanceof Blob) {
      return {
        blob: body.data
      };
    }

    if (body instanceof FormData) {
      return {
        formData: body.getParts()
      };
    }

    if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
      return {
        base64: binaryToBase64(body)
      };
    }

    return body;
  }

  module.exports = convertRequestBody;
},220,[221,223,226],"node_modules\\react-native\\Libraries\\Network\\convertRequestBody.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var base64 = _$$_REQUIRE(_dependencyMap[0], "base64-js");

  function binaryToBase64(data) {
    if (data instanceof ArrayBuffer) {
      data = new Uint8Array(data);
    }

    if (data instanceof Uint8Array) {
      return base64.fromByteArray(data);
    }

    if (!ArrayBuffer.isView(data)) {
      throw new Error('data must be ArrayBuffer or typed array');
    }

    var _data = data,
        buffer = _data.buffer,
        byteOffset = _data.byteOffset,
        byteLength = _data.byteLength;
    return base64.fromByteArray(new Uint8Array(buffer, byteOffset, byteLength));
  }

  module.exports = binaryToBase64;
},221,[222],"node_modules\\react-native\\Libraries\\Utilities\\binaryToBase64.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  exports.byteLength = byteLength;
  exports.toByteArray = toByteArray;
  exports.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;

  function getLens(b64) {
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    }

    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }

  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }

  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }

  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

    for (var i = 0; i < len; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 0xFF;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    return arr;
  }

  function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  }

  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];

    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
      output.push(tripletToBase64(tmp));
    }

    return output.join('');
  }

  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var parts = [];
    var maxChunkLength = 16383;

    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }

    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }

    return parts.join('');
  }
},222,[],"node_modules\\base64-js\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/defineProperty");

  var Blob = function () {
    function Blob() {
      var parts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, Blob);

      _defineProperty(this, "_data", void 0);

      var BlobManager = _$$_REQUIRE(_dependencyMap[3], "BlobManager");

      this.data = BlobManager.createFromParts(parts, options).data;
    }

    _createClass(Blob, [{
      key: "slice",
      value: function slice(start, end) {
        var BlobManager = _$$_REQUIRE(_dependencyMap[3], "BlobManager");

        var _this$data = this.data,
            offset = _this$data.offset,
            size = _this$data.size;

        if (typeof start === 'number') {
          if (start > size) {
            start = size;
          }

          offset += start;
          size -= start;

          if (typeof end === 'number') {
            if (end < 0) {
              end = this.size + end;
            }

            size = end - start;
          }
        }

        return BlobManager.createFromOptions({
          blobId: this.data.blobId,
          offset: offset,
          size: size
        });
      }
    }, {
      key: "close",
      value: function close() {
        var BlobManager = _$$_REQUIRE(_dependencyMap[3], "BlobManager");

        BlobManager.release(this.data.blobId);
        this.data = null;
      }
    }, {
      key: "data",
      set: function set(data) {
        this._data = data;
      },
      get: function get() {
        if (!this._data) {
          throw new Error('Blob has been closed and is no longer available');
        }

        return this._data;
      }
    }, {
      key: "size",
      get: function get() {
        return this.data.size;
      }
    }, {
      key: "type",
      get: function get() {
        return this.data.type || '';
      }
    }]);

    return Blob;
  }();

  module.exports = Blob;
},223,[24,25,32,224],"node_modules\\react-native\\Libraries\\Blob\\Blob.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/defineProperty");

  var Blob = _$$_REQUIRE(_dependencyMap[4], "Blob");

  var BlobRegistry = _$$_REQUIRE(_dependencyMap[5], "BlobRegistry");

  var _require = _$$_REQUIRE(_dependencyMap[6], "NativeModules"),
      BlobModule = _require.BlobModule;

  function uuidv4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0,
          v = c == 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  }

  var BlobManager = function () {
    function BlobManager() {
      _classCallCheck(this, BlobManager);
    }

    _createClass(BlobManager, null, [{
      key: "createFromParts",
      value: function createFromParts(parts, options) {
        var blobId = uuidv4();
        var items = parts.map(function (part) {
          if (part instanceof ArrayBuffer || global.ArrayBufferView && part instanceof global.ArrayBufferView) {
            throw new Error("Creating blobs from 'ArrayBuffer' and 'ArrayBufferView' are not supported");
          }

          if (part instanceof Blob) {
            return {
              data: part.data,
              type: 'blob'
            };
          } else {
            return {
              data: String(part),
              type: 'string'
            };
          }
        });
        var size = items.reduce(function (acc, curr) {
          if (curr.type === 'string') {
            return acc + global.unescape(encodeURI(curr.data)).length;
          } else {
            return acc + curr.data.size;
          }
        }, 0);
        BlobModule.createFromParts(items, blobId);
        return BlobManager.createFromOptions({
          blobId: blobId,
          offset: 0,
          size: size,
          type: options ? options.type : '',
          lastModified: options ? options.lastModified : Date.now()
        });
      }
    }, {
      key: "createFromOptions",
      value: function createFromOptions(options) {
        BlobRegistry.register(options.blobId);
        return _extends(Object.create(Blob.prototype), {
          data: options
        });
      }
    }, {
      key: "release",
      value: function release(blobId) {
        BlobRegistry.unregister(blobId);

        if (BlobRegistry.has(blobId)) {
          return;
        }

        BlobModule.release(blobId);
      }
    }, {
      key: "addNetworkingHandler",
      value: function addNetworkingHandler() {
        BlobModule.addNetworkingHandler();
      }
    }, {
      key: "addWebSocketHandler",
      value: function addWebSocketHandler(socketId) {
        BlobModule.addWebSocketHandler(socketId);
      }
    }, {
      key: "removeWebSocketHandler",
      value: function removeWebSocketHandler(socketId) {
        BlobModule.removeWebSocketHandler(socketId);
      }
    }, {
      key: "sendOverSocket",
      value: function sendOverSocket(blob, socketId) {
        BlobModule.sendOverSocket(blob.data, socketId);
      }
    }]);

    return BlobManager;
  }();

  _defineProperty(BlobManager, "isAvailable", !!BlobModule);

  module.exports = BlobManager;
},224,[112,24,25,32,223,225,119],"node_modules\\react-native\\Libraries\\Blob\\BlobManager.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var registry = {};

  var register = function register(id) {
    if (registry[id]) {
      registry[id]++;
    } else {
      registry[id] = 1;
    }
  };

  var unregister = function unregister(id) {
    if (registry[id]) {
      registry[id]--;

      if (registry[id] <= 0) {
        delete registry[id];
      }
    }
  };

  var has = function has(id) {
    return registry[id] && registry[id] > 0;
  };

  module.exports = {
    register: register,
    unregister: unregister,
    has: has
  };
},225,[],"node_modules\\react-native\\Libraries\\Blob\\BlobRegistry.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var _slicedToArray = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/slicedToArray");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/defineProperty");

  var FormData = function () {
    function FormData() {
      _classCallCheck(this, FormData);

      _defineProperty(this, "_parts", void 0);

      this._parts = [];
    }

    _createClass(FormData, [{
      key: "append",
      value: function append(key, value) {
        this._parts.push([key, value]);
      }
    }, {
      key: "getParts",
      value: function getParts() {
        return this._parts.map(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              name = _ref2[0],
              value = _ref2[1];

          var contentDisposition = 'form-data; name="' + name + '"';
          var headers = {
            'content-disposition': contentDisposition
          };

          if (typeof value === 'object' && value) {
            if (typeof value.name === 'string') {
              headers['content-disposition'] += '; filename="' + value.name + '"';
            }

            if (typeof value.type === 'string') {
              headers['content-type'] = value.type;
            }

            return _objectSpread({}, value, {
              headers: headers,
              fieldName: name
            });
          }

          return {
            string: String(value),
            headers: headers,
            fieldName: name
          };
        });
      }
    }]);

    return FormData;
  }();

  module.exports = FormData;
},226,[148,122,24,25,32],"node_modules\\react-native\\Libraries\\Network\\FormData.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectWithoutProperties = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutProperties");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var Blob = _$$_REQUIRE(_dependencyMap[8], "Blob");

  var EventTarget = _$$_REQUIRE(_dependencyMap[9], "event-target-shim");

  var NativeEventEmitter = _$$_REQUIRE(_dependencyMap[10], "NativeEventEmitter");

  var BlobManager = _$$_REQUIRE(_dependencyMap[11], "BlobManager");

  var NativeModules = _$$_REQUIRE(_dependencyMap[12], "NativeModules");

  var Platform = _$$_REQUIRE(_dependencyMap[13], "Platform");

  var WebSocketEvent = _$$_REQUIRE(_dependencyMap[14], "WebSocketEvent");

  var base64 = _$$_REQUIRE(_dependencyMap[15], "base64-js");

  var binaryToBase64 = _$$_REQUIRE(_dependencyMap[16], "binaryToBase64");

  var invariant = _$$_REQUIRE(_dependencyMap[17], "fbjs/lib/invariant");

  var WebSocketModule = NativeModules.WebSocketModule;
  var CONNECTING = 0;
  var OPEN = 1;
  var CLOSING = 2;
  var CLOSED = 3;
  var CLOSE_NORMAL = 1000;
  var WEBSOCKET_EVENTS = ['close', 'error', 'message', 'open'];
  var nextWebSocketId = 0;

  var WebSocket = function (_EventTarget) {
    _inherits(WebSocket, _EventTarget);

    function WebSocket(url, protocols, options) {
      var _this;

      _classCallCheck(this, WebSocket);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(WebSocket).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "CONNECTING", CONNECTING);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "OPEN", OPEN);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "CLOSING", CLOSING);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "CLOSED", CLOSED);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_socketId", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_eventEmitter", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_subscriptions", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_binaryType", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onclose", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onerror", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onmessage", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onopen", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "bufferedAmount", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "extension", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "protocol", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "readyState", CONNECTING);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "url", void 0);

      if (typeof protocols === 'string') {
        protocols = [protocols];
      }

      var _ref = options || {},
          _ref$headers = _ref.headers,
          headers = _ref$headers === void 0 ? {} : _ref$headers,
          unrecognized = _objectWithoutProperties(_ref, ["headers"]);

      if (unrecognized && typeof unrecognized.origin === 'string') {
        console.warn('Specifying `origin` as a WebSocket connection option is deprecated. Include it under `headers` instead.');
        headers.origin = unrecognized.origin;
        delete unrecognized.origin;
      }

      if (Object.keys(unrecognized).length > 0) {
        console.warn('Unrecognized WebSocket connection option(s) `' + Object.keys(unrecognized).join('`, `') + '`. ' + 'Did you mean to put these under `headers`?');
      }

      if (!Array.isArray(protocols)) {
        protocols = null;
      }

      if (!WebSocket.isAvailable) {
        throw new Error('Cannot initialize WebSocket module. ' + 'Native module WebSocketModule is missing.');
      }

      _this._eventEmitter = new NativeEventEmitter(WebSocketModule);
      _this._socketId = nextWebSocketId++;

      _this._registerEvents();

      WebSocketModule.connect(url, protocols, {
        headers: headers
      }, _this._socketId);
      return _this;
    }

    _createClass(WebSocket, [{
      key: "close",
      value: function close(code, reason) {
        if (this.readyState === this.CLOSING || this.readyState === this.CLOSED) {
          return;
        }

        this.readyState = this.CLOSING;

        this._close(code, reason);
      }
    }, {
      key: "send",
      value: function send(data) {
        if (this.readyState === this.CONNECTING) {
          throw new Error('INVALID_STATE_ERR');
        }

        if (data instanceof Blob) {
          invariant(BlobManager.isAvailable, 'Native module BlobModule is required for blob support');
          BlobManager.sendOverSocket(data, this._socketId);
          return;
        }

        if (typeof data === 'string') {
          WebSocketModule.send(data, this._socketId);
          return;
        }

        if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
          WebSocketModule.sendBinary(binaryToBase64(data), this._socketId);
          return;
        }

        throw new Error('Unsupported data type');
      }
    }, {
      key: "ping",
      value: function ping() {
        if (this.readyState === this.CONNECTING) {
          throw new Error('INVALID_STATE_ERR');
        }

        WebSocketModule.ping(this._socketId);
      }
    }, {
      key: "_close",
      value: function _close(code, reason) {
        if (Platform.OS === 'android') {
          var statusCode = typeof code === 'number' ? code : CLOSE_NORMAL;
          var closeReason = typeof reason === 'string' ? reason : '';
          WebSocketModule.close(statusCode, closeReason, this._socketId);
        } else {
          WebSocketModule.close(this._socketId);
        }

        if (BlobManager.isAvailable && this._binaryType === 'blob') {
          BlobManager.removeWebSocketHandler(this._socketId);
        }
      }
    }, {
      key: "_unregisterEvents",
      value: function _unregisterEvents() {
        this._subscriptions.forEach(function (e) {
          return e.remove();
        });

        this._subscriptions = [];
      }
    }, {
      key: "_registerEvents",
      value: function _registerEvents() {
        var _this2 = this;

        this._subscriptions = [this._eventEmitter.addListener('websocketMessage', function (ev) {
          if (ev.id !== _this2._socketId) {
            return;
          }

          var data = ev.data;

          switch (ev.type) {
            case 'binary':
              data = base64.toByteArray(ev.data).buffer;
              break;

            case 'blob':
              data = BlobManager.createFromOptions(ev.data);
              break;
          }

          _this2.dispatchEvent(new WebSocketEvent('message', {
            data: data
          }));
        }), this._eventEmitter.addListener('websocketOpen', function (ev) {
          if (ev.id !== _this2._socketId) {
            return;
          }

          _this2.readyState = _this2.OPEN;

          _this2.dispatchEvent(new WebSocketEvent('open'));
        }), this._eventEmitter.addListener('websocketClosed', function (ev) {
          if (ev.id !== _this2._socketId) {
            return;
          }

          _this2.readyState = _this2.CLOSED;

          _this2.dispatchEvent(new WebSocketEvent('close', {
            code: ev.code,
            reason: ev.reason
          }));

          _this2._unregisterEvents();

          _this2.close();
        }), this._eventEmitter.addListener('websocketFailed', function (ev) {
          if (ev.id !== _this2._socketId) {
            return;
          }

          _this2.readyState = _this2.CLOSED;

          _this2.dispatchEvent(new WebSocketEvent('error', {
            message: ev.message
          }));

          _this2.dispatchEvent(new WebSocketEvent('close', {
            message: ev.message
          }));

          _this2._unregisterEvents();

          _this2.close();
        })];
      }
    }, {
      key: "binaryType",
      get: function get() {
        return this._binaryType;
      },
      set: function set(binaryType) {
        if (binaryType !== 'blob' && binaryType !== 'arraybuffer') {
          throw new Error("binaryType must be either 'blob' or 'arraybuffer'");
        }

        if (this._binaryType === 'blob' || binaryType === 'blob') {
          invariant(BlobManager.isAvailable, 'Native module BlobModule is required for blob support');

          if (binaryType === 'blob') {
            BlobManager.addWebSocketHandler(this._socketId);
          } else {
            BlobManager.removeWebSocketHandler(this._socketId);
          }
        }

        this._binaryType = binaryType;
      }
    }]);

    return WebSocket;
  }(EventTarget.apply(void 0, WEBSOCKET_EVENTS));

  _defineProperty(WebSocket, "CONNECTING", CONNECTING);

  _defineProperty(WebSocket, "OPEN", OPEN);

  _defineProperty(WebSocket, "CLOSING", CLOSING);

  _defineProperty(WebSocket, "CLOSED", CLOSED);

  _defineProperty(WebSocket, "isAvailable", !!WebSocketModule);

  module.exports = WebSocket;
},227,[120,24,25,26,29,30,28,32,223,213,219,224,119,146,228,222,221,117],"node_modules\\react-native\\Libraries\\WebSocket\\WebSocket.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var WebSocketEvent = function WebSocketEvent(type, eventInitDict) {
    _classCallCheck(this, WebSocketEvent);

    this.type = type.toString();

    _extends(this, eventInitDict);
  };

  module.exports = WebSocketEvent;
},228,[112,24],"node_modules\\react-native\\Libraries\\WebSocket\\WebSocketEvent.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/inherits");

  var Blob = _$$_REQUIRE(_dependencyMap[5], "Blob");

  var invariant = _$$_REQUIRE(_dependencyMap[6], "fbjs/lib/invariant");

  var File = function (_Blob) {
    _inherits(File, _Blob);

    function File(parts, name, options) {
      var _this;

      _classCallCheck(this, File);

      invariant(parts != null && name != null, 'Failed to construct `File`: Must pass both `parts` and `name` arguments.');
      _this = _possibleConstructorReturn(this, _getPrototypeOf(File).call(this, parts, options));
      _this.data.name = name;
      return _this;
    }

    _createClass(File, [{
      key: "name",
      get: function get() {
        invariant(this.data.name != null, 'Files must have a name set.');
        return this.data.name;
      }
    }, {
      key: "lastModified",
      get: function get() {
        return this.data.lastModified || 0;
      }
    }]);

    return File;
  }(Blob);

  module.exports = File;
},229,[24,25,26,29,30,223,117],"node_modules\\react-native\\Libraries\\Blob\\File.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/defineProperty");

  var EventTarget = _$$_REQUIRE(_dependencyMap[7], "event-target-shim");

  var Blob = _$$_REQUIRE(_dependencyMap[8], "Blob");

  var _require = _$$_REQUIRE(_dependencyMap[9], "NativeModules"),
      FileReaderModule = _require.FileReaderModule;

  var READER_EVENTS = ['abort', 'error', 'load', 'loadstart', 'loadend', 'progress'];
  var EMPTY = 0;
  var LOADING = 1;
  var DONE = 2;

  var FileReader = function (_EventTarget) {
    _inherits(FileReader, _EventTarget);

    function FileReader() {
      var _this;

      _classCallCheck(this, FileReader);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FileReader).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "EMPTY", EMPTY);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "LOADING", LOADING);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "DONE", DONE);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_readyState", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_error", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_result", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_aborted", false);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_subscriptions", []);

      _this._reset();

      return _this;
    }

    _createClass(FileReader, [{
      key: "_reset",
      value: function _reset() {
        this._readyState = EMPTY;
        this._error = null;
        this._result = null;
      }
    }, {
      key: "_clearSubscriptions",
      value: function _clearSubscriptions() {
        this._subscriptions.forEach(function (sub) {
          return sub.remove();
        });

        this._subscriptions = [];
      }
    }, {
      key: "_setReadyState",
      value: function _setReadyState(newState) {
        this._readyState = newState;
        this.dispatchEvent({
          type: 'readystatechange'
        });

        if (newState === DONE) {
          if (this._aborted) {
            this.dispatchEvent({
              type: 'abort'
            });
          } else if (this._error) {
            this.dispatchEvent({
              type: 'error'
            });
          } else {
            this.dispatchEvent({
              type: 'load'
            });
          }

          this.dispatchEvent({
            type: 'loadend'
          });
        }
      }
    }, {
      key: "readAsArrayBuffer",
      value: function readAsArrayBuffer() {
        throw new Error('FileReader.readAsArrayBuffer is not implemented');
      }
    }, {
      key: "readAsDataURL",
      value: function readAsDataURL(blob) {
        var _this2 = this;

        this._aborted = false;
        FileReaderModule.readAsDataURL(blob.data).then(function (text) {
          if (_this2._aborted) {
            return;
          }

          _this2._result = text;

          _this2._setReadyState(DONE);
        }, function (error) {
          if (_this2._aborted) {
            return;
          }

          _this2._error = error;

          _this2._setReadyState(DONE);
        });
      }
    }, {
      key: "readAsText",
      value: function readAsText(blob) {
        var _this3 = this;

        var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'UTF-8';
        this._aborted = false;
        FileReaderModule.readAsText(blob.data, encoding).then(function (text) {
          if (_this3._aborted) {
            return;
          }

          _this3._result = text;

          _this3._setReadyState(DONE);
        }, function (error) {
          if (_this3._aborted) {
            return;
          }

          _this3._error = error;

          _this3._setReadyState(DONE);
        });
      }
    }, {
      key: "abort",
      value: function abort() {
        this._aborted = true;

        if (this._readyState !== EMPTY && this._readyState !== DONE) {
          this._reset();

          this._setReadyState(DONE);
        }

        this._reset();
      }
    }, {
      key: "readyState",
      get: function get() {
        return this._readyState;
      }
    }, {
      key: "error",
      get: function get() {
        return this._error;
      }
    }, {
      key: "result",
      get: function get() {
        return this._result;
      }
    }]);

    return FileReader;
  }(EventTarget.apply(void 0, READER_EVENTS));

  _defineProperty(FileReader, "EMPTY", EMPTY);

  _defineProperty(FileReader, "LOADING", LOADING);

  _defineProperty(FileReader, "DONE", DONE);

  module.exports = FileReader;
},230,[24,25,26,29,30,28,32,213,223,119],"node_modules\\react-native\\Libraries\\Blob\\FileReader.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var Blob = _$$_REQUIRE(_dependencyMap[2], "Blob");

  var _require = _$$_REQUIRE(_dependencyMap[3], "NativeModules"),
      BlobModule = _require.BlobModule;

  var BLOB_URL_PREFIX = null;

  if (BlobModule && typeof BlobModule.BLOB_URI_SCHEME === 'string') {
    BLOB_URL_PREFIX = BlobModule.BLOB_URI_SCHEME + ':';

    if (typeof BlobModule.BLOB_URI_HOST === 'string') {
      BLOB_URL_PREFIX += "//" + BlobModule.BLOB_URI_HOST + "/";
    }
  }

  var URL = function () {
    function URL() {
      _classCallCheck(this, URL);

      throw new Error('Creating URL objects is not supported yet.');
    }

    _createClass(URL, null, [{
      key: "createObjectURL",
      value: function createObjectURL(blob) {
        if (BLOB_URL_PREFIX === null) {
          throw new Error('Cannot create URL for blob!');
        }

        return "" + BLOB_URL_PREFIX + blob.data.blobId + "?offset=" + blob.data.offset + "&size=" + blob.size;
      }
    }, {
      key: "revokeObjectURL",
      value: function revokeObjectURL(url) {}
    }]);

    return URL;
  }();

  module.exports = URL;
},231,[24,25,223,119],"node_modules\\react-native\\Libraries\\Blob\\URL.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var AlertIOS = _$$_REQUIRE(_dependencyMap[3], "AlertIOS");

  var NativeModules = _$$_REQUIRE(_dependencyMap[4], "NativeModules");

  var Platform = _$$_REQUIRE(_dependencyMap[5], "Platform");

  var Alert = function () {
    function Alert() {
      _classCallCheck(this, Alert);
    }

    _createClass(Alert, null, [{
      key: "alert",
      value: function alert(title, message, buttons, options, type) {
        if (Platform.OS === 'ios') {
          if (typeof type !== 'undefined') {
            console.warn('Alert.alert() with a 5th "type" parameter is deprecated and will be removed. Use AlertIOS.prompt() instead.');
            AlertIOS.alert(title, message, buttons, type);
            return;
          }

          AlertIOS.alert(title, message, buttons);
        } else if (Platform.OS === 'android') {
          AlertAndroid.alert(title, message, buttons, options);
        }
      }
    }]);

    return Alert;
  }();

  var AlertAndroid = function () {
    function AlertAndroid() {
      _classCallCheck(this, AlertAndroid);
    }

    _createClass(AlertAndroid, null, [{
      key: "alert",
      value: function alert(title, message, buttons, options) {
        var config = {
          title: title || '',
          message: message || ''
        };

        if (options) {
          config = _objectSpread({}, config, {
            cancelable: options.cancelable
          });
        }

        var validButtons = buttons ? buttons.slice(0, 3) : [{
          text: 'OK'
        }];
        var buttonPositive = validButtons.pop();
        var buttonNegative = validButtons.pop();
        var buttonNeutral = validButtons.pop();

        if (buttonNeutral) {
          config = _objectSpread({}, config, {
            buttonNeutral: buttonNeutral.text || ''
          });
        }

        if (buttonNegative) {
          config = _objectSpread({}, config, {
            buttonNegative: buttonNegative.text || ''
          });
        }

        if (buttonPositive) {
          config = _objectSpread({}, config, {
            buttonPositive: buttonPositive.text || ''
          });
        }

        NativeModules.DialogManagerAndroid.showAlert(config, function (errorMessage) {
          return console.warn(errorMessage);
        }, function (action, buttonKey) {
          if (action === NativeModules.DialogManagerAndroid.buttonClicked) {
            if (buttonKey === NativeModules.DialogManagerAndroid.buttonNeutral) {
              buttonNeutral.onPress && buttonNeutral.onPress();
            } else if (buttonKey === NativeModules.DialogManagerAndroid.buttonNegative) {
              buttonNegative.onPress && buttonNegative.onPress();
            } else if (buttonKey === NativeModules.DialogManagerAndroid.buttonPositive) {
              buttonPositive.onPress && buttonPositive.onPress();
            }
          } else if (action === NativeModules.DialogManagerAndroid.dismissed) {
            options && options.onDismiss && options.onDismiss();
          }
        });
      }
    }]);

    return AlertAndroid;
  }();

  module.exports = Alert;
},232,[148,24,25,233,119,146],"node_modules\\react-native\\Libraries\\Alert\\Alert.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var RCTAlertManager = _$$_REQUIRE(_dependencyMap[2], "NativeModules").AlertManager;

  var AlertIOS = function () {
    function AlertIOS() {
      _classCallCheck(this, AlertIOS);
    }

    _createClass(AlertIOS, null, [{
      key: "alert",
      value: function alert(title, message, callbackOrButtons, type) {
        if (typeof type !== 'undefined') {
          console.warn('AlertIOS.alert() with a 4th "type" parameter is deprecated and will be removed. Use AlertIOS.prompt() instead.');
          this.prompt(title, message, callbackOrButtons, type);
          return;
        }

        this.prompt(title, message, callbackOrButtons, 'default');
      }
    }, {
      key: "prompt",
      value: function prompt(title, message, callbackOrButtons) {
        var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'plain-text';
        var defaultValue = arguments.length > 4 ? arguments[4] : undefined;
        var keyboardType = arguments.length > 5 ? arguments[5] : undefined;

        if (typeof type === 'function') {
          console.warn('You passed a callback function as the "type" argument to AlertIOS.prompt(). React Native is ' + 'assuming  you want to use the deprecated AlertIOS.prompt(title, defaultValue, buttons, callback) ' + 'signature. The current signature is AlertIOS.prompt(title, message, callbackOrButtons, type, defaultValue, ' + 'keyboardType) and the old syntax will be removed in a future version.');
          var callback = type;
          RCTAlertManager.alertWithArgs({
            title: title || '',
            type: 'plain-text',
            defaultValue: message
          }, function (id, value) {
            callback(value);
          });
          return;
        }

        var callbacks = [];
        var buttons = [];
        var cancelButtonKey;
        var destructiveButtonKey;

        if (typeof callbackOrButtons === 'function') {
          callbacks = [callbackOrButtons];
        } else if (callbackOrButtons instanceof Array) {
          callbackOrButtons.forEach(function (btn, index) {
            callbacks[index] = btn.onPress;

            if (btn.style === 'cancel') {
              cancelButtonKey = String(index);
            } else if (btn.style === 'destructive') {
              destructiveButtonKey = String(index);
            }

            if (btn.text || index < (callbackOrButtons || []).length - 1) {
              var btnDef = {};
              btnDef[index] = btn.text || '';
              buttons.push(btnDef);
            }
          });
        }

        RCTAlertManager.alertWithArgs({
          title: title || '',
          message: message || undefined,
          buttons: buttons,
          type: type || undefined,
          defaultValue: defaultValue,
          cancelButtonKey: cancelButtonKey,
          destructiveButtonKey: destructiveButtonKey,
          keyboardType: keyboardType
        }, function (id, value) {
          var cb = callbacks[id];
          cb && cb(value);
        });
      }
    }]);

    return AlertIOS;
  }();

  module.exports = AlertIOS;
},233,[24,25,119],"node_modules\\react-native\\Libraries\\Alert\\AlertIOS.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _regeneratorRuntime = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/regenerator");

  var NativeEventEmitter = _$$_REQUIRE(_dependencyMap[1], "NativeEventEmitter");

  var RCTLocationObserver = _$$_REQUIRE(_dependencyMap[2], "NativeModules").LocationObserver;

  var invariant = _$$_REQUIRE(_dependencyMap[3], "fbjs/lib/invariant");

  var logError = _$$_REQUIRE(_dependencyMap[4], "logError");

  var warning = _$$_REQUIRE(_dependencyMap[5], "fbjs/lib/warning");

  var LocationEventEmitter = new NativeEventEmitter(RCTLocationObserver);

  var Platform = _$$_REQUIRE(_dependencyMap[6], "Platform");

  var PermissionsAndroid = _$$_REQUIRE(_dependencyMap[7], "PermissionsAndroid");

  var subscriptions = [];
  var updatesEnabled = false;
  var Geolocation = {
    setRNConfiguration: function setRNConfiguration(config) {
      if (RCTLocationObserver.setConfiguration) {
        RCTLocationObserver.setConfiguration(config);
      }
    },
    requestAuthorization: function requestAuthorization() {
      RCTLocationObserver.requestAuthorization();
    },
    getCurrentPosition: function getCurrentPosition(geo_success, geo_error, geo_options) {
      var hasPermission, status;
      return _regeneratorRuntime.async(function getCurrentPosition$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              invariant(typeof geo_success === 'function', 'Must provide a valid geo_success callback.');
              hasPermission = true;

              if (!(Platform.OS === 'android' && Platform.Version >= 23)) {
                _context.next = 11;
                break;
              }

              _context.next = 5;
              return _regeneratorRuntime.awrap(PermissionsAndroid.check(PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION));

            case 5:
              hasPermission = _context.sent;

              if (hasPermission) {
                _context.next = 11;
                break;
              }

              _context.next = 9;
              return _regeneratorRuntime.awrap(PermissionsAndroid.request(PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION));

            case 9:
              status = _context.sent;
              hasPermission = status === PermissionsAndroid.RESULTS.GRANTED;

            case 11:
              if (hasPermission) {
                RCTLocationObserver.getCurrentPosition(geo_options || {}, geo_success, geo_error || logError);
              }

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    },
    watchPosition: function watchPosition(success, error, options) {
      if (!updatesEnabled) {
        RCTLocationObserver.startObserving(options || {});
        updatesEnabled = true;
      }

      var watchID = subscriptions.length;
      subscriptions.push([LocationEventEmitter.addListener('geolocationDidChange', success), error ? LocationEventEmitter.addListener('geolocationError', error) : null]);
      return watchID;
    },
    clearWatch: function clearWatch(watchID) {
      var sub = subscriptions[watchID];

      if (!sub) {
        return;
      }

      sub[0].remove();
      var sub1 = sub[1];
      sub1 && sub1.remove();
      subscriptions[watchID] = undefined;
      var noWatchers = true;

      for (var ii = 0; ii < subscriptions.length; ii++) {
        if (subscriptions[ii]) {
          noWatchers = false;
        }
      }

      if (noWatchers) {
        Geolocation.stopObserving();
      }
    },
    stopObserving: function stopObserving() {
      if (updatesEnabled) {
        RCTLocationObserver.stopObserving();
        updatesEnabled = false;

        for (var ii = 0; ii < subscriptions.length; ii++) {
          var sub = subscriptions[ii];

          if (sub) {
            warning(false, 'Called stopObserving with existing subscriptions.');
            sub[0].remove();
            var sub1 = sub[1];
            sub1 && sub1.remove();
          }
        }

        subscriptions = [];
      }
    }
  };
  module.exports = Geolocation;
},234,[105,219,119,117,235,211,146,236],"node_modules\\react-native\\Libraries\\Geolocation\\Geolocation.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var logError = function logError() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length === 1 && args[0] instanceof Error) {
      var err = args[0];
      console.error('Error: "' + err.message + '".  Stack:\n' + err.stack);
    } else {
      console.error.apply(console, args);
    }
  };

  module.exports = logError;
},235,[],"node_modules\\react-native\\Libraries\\Utilities\\logError.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _regeneratorRuntime = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/regenerator");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/defineProperty");

  var NativeModules = _$$_REQUIRE(_dependencyMap[4], "NativeModules");

  var PermissionsAndroid = function () {
    function PermissionsAndroid() {
      _classCallCheck(this, PermissionsAndroid);

      _defineProperty(this, "PERMISSIONS", void 0);

      _defineProperty(this, "RESULTS", void 0);

      this.PERMISSIONS = {
        READ_CALENDAR: 'android.permission.READ_CALENDAR',
        WRITE_CALENDAR: 'android.permission.WRITE_CALENDAR',
        CAMERA: 'android.permission.CAMERA',
        READ_CONTACTS: 'android.permission.READ_CONTACTS',
        WRITE_CONTACTS: 'android.permission.WRITE_CONTACTS',
        GET_ACCOUNTS: 'android.permission.GET_ACCOUNTS',
        ACCESS_FINE_LOCATION: 'android.permission.ACCESS_FINE_LOCATION',
        ACCESS_COARSE_LOCATION: 'android.permission.ACCESS_COARSE_LOCATION',
        RECORD_AUDIO: 'android.permission.RECORD_AUDIO',
        READ_PHONE_STATE: 'android.permission.READ_PHONE_STATE',
        CALL_PHONE: 'android.permission.CALL_PHONE',
        READ_CALL_LOG: 'android.permission.READ_CALL_LOG',
        WRITE_CALL_LOG: 'android.permission.WRITE_CALL_LOG',
        ADD_VOICEMAIL: 'com.android.voicemail.permission.ADD_VOICEMAIL',
        USE_SIP: 'android.permission.USE_SIP',
        PROCESS_OUTGOING_CALLS: 'android.permission.PROCESS_OUTGOING_CALLS',
        BODY_SENSORS: 'android.permission.BODY_SENSORS',
        SEND_SMS: 'android.permission.SEND_SMS',
        RECEIVE_SMS: 'android.permission.RECEIVE_SMS',
        READ_SMS: 'android.permission.READ_SMS',
        RECEIVE_WAP_PUSH: 'android.permission.RECEIVE_WAP_PUSH',
        RECEIVE_MMS: 'android.permission.RECEIVE_MMS',
        READ_EXTERNAL_STORAGE: 'android.permission.READ_EXTERNAL_STORAGE',
        WRITE_EXTERNAL_STORAGE: 'android.permission.WRITE_EXTERNAL_STORAGE'
      };
      this.RESULTS = {
        GRANTED: 'granted',
        DENIED: 'denied',
        NEVER_ASK_AGAIN: 'never_ask_again'
      };
    }

    _createClass(PermissionsAndroid, [{
      key: "checkPermission",
      value: function checkPermission(permission) {
        console.warn('"PermissionsAndroid.checkPermission" is deprecated. Use "PermissionsAndroid.check" instead');
        return NativeModules.PermissionsAndroid.checkPermission(permission);
      }
    }, {
      key: "check",
      value: function check(permission) {
        return NativeModules.PermissionsAndroid.checkPermission(permission);
      }
    }, {
      key: "requestPermission",
      value: function requestPermission(permission, rationale) {
        var response;
        return _regeneratorRuntime.async(function requestPermission$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                console.warn('"PermissionsAndroid.requestPermission" is deprecated. Use "PermissionsAndroid.request" instead');
                _context.next = 3;
                return _regeneratorRuntime.awrap(this.request(permission, rationale));

              case 3:
                response = _context.sent;
                return _context.abrupt("return", response === this.RESULTS.GRANTED);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, null, this);
      }
    }, {
      key: "request",
      value: function request(permission, rationale) {
        var shouldShowRationale;
        return _regeneratorRuntime.async(function request$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!rationale) {
                  _context2.next = 6;
                  break;
                }

                _context2.next = 3;
                return _regeneratorRuntime.awrap(NativeModules.PermissionsAndroid.shouldShowRequestPermissionRationale(permission));

              case 3:
                shouldShowRationale = _context2.sent;

                if (!shouldShowRationale) {
                  _context2.next = 6;
                  break;
                }

                return _context2.abrupt("return", new Promise(function (resolve, reject) {
                  NativeModules.DialogManagerAndroid.showAlert(rationale, function () {
                    return reject(new Error('Error showing rationale'));
                  }, function () {
                    return resolve(NativeModules.PermissionsAndroid.requestPermission(permission));
                  });
                }));

              case 6:
                return _context2.abrupt("return", NativeModules.PermissionsAndroid.requestPermission(permission));

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, null, this);
      }
    }, {
      key: "requestMultiple",
      value: function requestMultiple(permissions) {
        return NativeModules.PermissionsAndroid.requestMultiplePermissions(permissions);
      }
    }]);

    return PermissionsAndroid;
  }();

  PermissionsAndroid = new PermissionsAndroid();
  module.exports = PermissionsAndroid;
},236,[105,24,25,32,119],"node_modules\\react-native\\Libraries\\PermissionsAndroid\\PermissionsAndroid.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var HeapCapture = {
    captureHeap: function captureHeap(path) {
      var error = null;

      try {
        global.nativeCaptureHeap(path);
        console.log('HeapCapture.captureHeap succeeded: ' + path);
      } catch (e) {
        console.log('HeapCapture.captureHeap error: ' + e.toString());
        error = e.toString();
      }

      _$$_REQUIRE(_dependencyMap[0], "NativeModules").JSCHeapCapture.captureComplete(path, error);
    }
  };
  module.exports = HeapCapture;
},237,[119],"node_modules\\react-native\\Libraries\\Utilities\\HeapCapture.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var SamplingProfiler = {
    poke: function poke(token) {
      var error = null;
      var result = null;

      try {
        result = global.pokeSamplingProfiler();

        if (result === null) {
          console.log('The JSC Sampling Profiler has started');
        } else {
          console.log('The JSC Sampling Profiler has stopped');
        }
      } catch (e) {
        console.log('Error occurred when restarting Sampling Profiler: ' + e.toString());
        error = e.toString();
      }

      var _require = _$$_REQUIRE(_dependencyMap[0], "NativeModules"),
          JSCSamplingProfiler = _require.JSCSamplingProfiler;

      JSCSamplingProfiler.operationComplete(token, result, error);
    }
  };
  module.exports = SamplingProfiler;
},238,[119],"node_modules\\react-native\\Libraries\\Performance\\SamplingProfiler.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var invariant = _$$_REQUIRE(_dependencyMap[0], "fbjs/lib/invariant");

  var levelsMap = {
    log: 'log',
    info: 'info',
    warn: 'warn',
    error: 'error',
    fatal: 'error'
  };
  var warningHandler = null;
  var RCTLog = {
    logIfNoNativeHook: function logIfNoNativeHook(level) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (typeof global.nativeLoggingHook === 'undefined') {
        RCTLog.logToConsole.apply(RCTLog, [level].concat(args));
      } else {
        if (warningHandler && level === 'warn') {
          warningHandler.apply(void 0, args);
        }
      }
    },
    logToConsole: function logToConsole(level) {
      var _console;

      var logFn = levelsMap[level];
      invariant(logFn, 'Level "' + level + '" not one of ' + Object.keys(levelsMap).toString());

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      (_console = console)[logFn].apply(_console, args);
    },
    setWarningHandler: function setWarningHandler(handler) {
      warningHandler = handler;
    }
  };
  module.exports = RCTLog;
},239,[117],"node_modules\\react-native\\Libraries\\Utilities\\RCTLog.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var RCTDeviceEventEmitter = _$$_REQUIRE(_dependencyMap[0], "RCTDeviceEventEmitter");

  var RCTNativeAppEventEmitter = RCTDeviceEventEmitter;
  module.exports = RCTNativeAppEventEmitter;
},240,[137],"node_modules\\react-native\\Libraries\\EventEmitter\\RCTNativeAppEventEmitter.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Systrace = _$$_REQUIRE(_dependencyMap[0], "Systrace");

  var infoLog = _$$_REQUIRE(_dependencyMap[1], "infoLog");

  var performanceNow = global.nativeQPLTimestamp || global.nativePerformanceNow || _$$_REQUIRE(_dependencyMap[2], "fbjs/lib/performanceNow");

  var timespans = {};
  var extras = {};
  var cookies = {};
  var PRINT_TO_CONSOLE = false;
  var PerformanceLogger = {
    addTimespan: function addTimespan(key, lengthInMs, description) {
      if (timespans[key]) {
        if (__DEV__) {
          infoLog('PerformanceLogger: Attempting to add a timespan that already exists ', key);
        }

        return;
      }

      timespans[key] = {
        description: description,
        totalTime: lengthInMs
      };
    },
    startTimespan: function startTimespan(key, description) {
      if (timespans[key]) {
        if (__DEV__) {
          infoLog('PerformanceLogger: Attempting to start a timespan that already exists ', key);
        }

        return;
      }

      timespans[key] = {
        description: description,
        startTime: performanceNow()
      };
      cookies[key] = Systrace.beginAsyncEvent(key);

      if (PRINT_TO_CONSOLE) {
        infoLog('PerformanceLogger.js', 'start: ' + key);
      }
    },
    stopTimespan: function stopTimespan(key) {
      var timespan = timespans[key];

      if (!timespan || !timespan.startTime) {
        if (__DEV__) {
          infoLog('PerformanceLogger: Attempting to end a timespan that has not started ', key);
        }

        return;
      }

      if (timespan.endTime) {
        if (__DEV__) {
          infoLog('PerformanceLogger: Attempting to end a timespan that has already ended ', key);
        }

        return;
      }

      timespan.endTime = performanceNow();
      timespan.totalTime = timespan.endTime - (timespan.startTime || 0);

      if (PRINT_TO_CONSOLE) {
        infoLog('PerformanceLogger.js', 'end: ' + key);
      }

      Systrace.endAsyncEvent(key, cookies[key]);
      delete cookies[key];
    },
    clear: function clear() {
      timespans = {};
      extras = {};

      if (PRINT_TO_CONSOLE) {
        infoLog('PerformanceLogger.js', 'clear');
      }
    },
    clearCompleted: function clearCompleted() {
      for (var _key in timespans) {
        if (timespans[_key].totalTime) {
          delete timespans[_key];
        }
      }

      extras = {};

      if (PRINT_TO_CONSOLE) {
        infoLog('PerformanceLogger.js', 'clearCompleted');
      }
    },
    clearExceptTimespans: function clearExceptTimespans(keys) {
      timespans = Object.keys(timespans).reduce(function (previous, key) {
        if (keys.indexOf(key) !== -1) {
          previous[key] = timespans[key];
        }

        return previous;
      }, {});
      extras = {};

      if (PRINT_TO_CONSOLE) {
        infoLog('PerformanceLogger.js', 'clearExceptTimespans', keys);
      }
    },
    currentTimestamp: function currentTimestamp() {
      return performanceNow();
    },
    getTimespans: function getTimespans() {
      return timespans;
    },
    hasTimespan: function hasTimespan(key) {
      return !!timespans[key];
    },
    logTimespans: function logTimespans() {
      for (var _key2 in timespans) {
        if (timespans[_key2].totalTime) {
          infoLog(_key2 + ': ' + timespans[_key2].totalTime + 'ms');
        }
      }
    },
    addTimespans: function addTimespans(newTimespans, labels) {
      for (var ii = 0, l = newTimespans.length; ii < l; ii += 2) {
        var label = labels[ii / 2];
        PerformanceLogger.addTimespan(label, newTimespans[ii + 1] - newTimespans[ii], label);
      }
    },
    setExtra: function setExtra(key, value) {
      if (extras[key]) {
        if (__DEV__) {
          infoLog('PerformanceLogger: Attempting to set an extra that already exists ', {
            key: key,
            currentValue: extras[key],
            attemptedValue: value
          });
        }

        return;
      }

      extras[key] = value;
    },
    getExtras: function getExtras() {
      return extras;
    },
    logExtras: function logExtras() {
      infoLog(extras);
    }
  };
  module.exports = PerformanceLogger;
},241,[133,242,208],"node_modules\\react-native\\Libraries\\Utilities\\PerformanceLogger.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function infoLog() {
    var _console;

    return (_console = console).log.apply(_console, arguments);
  }

  module.exports = infoLog;
},242,[],"node_modules\\react-native\\Libraries\\Utilities\\infoLog.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var JSDevSupport = _$$_REQUIRE(_dependencyMap[0], "NativeModules").JSDevSupport;

  var ReactNative = _$$_REQUIRE(_dependencyMap[1], "ReactNative");

  var JSDevSupportModule = {
    getJSHierarchy: function getJSHierarchy(tag) {
      try {
        var computeComponentStackForErrorReporting = ReactNative.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.computeComponentStackForErrorReporting;
        var componentStack = computeComponentStackForErrorReporting(tag);

        if (!componentStack) {
          JSDevSupport.onFailure(JSDevSupport.ERROR_CODE_VIEW_NOT_FOUND, "Component stack doesn't exist for tag " + tag);
        } else {
          JSDevSupport.onSuccess(componentStack);
        }
      } catch (e) {
        JSDevSupport.onFailure(JSDevSupport.ERROR_CODE_EXCEPTION, e.message);
      }
    }
  };
  module.exports = JSDevSupportModule;
},243,[119,178],"node_modules\\react-native\\Libraries\\Utilities\\JSDevSupportModule.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Platform = _$$_REQUIRE(_dependencyMap[0], "Platform");

  var invariant = _$$_REQUIRE(_dependencyMap[1], "fbjs/lib/invariant");

  var MetroHMRClient = _$$_REQUIRE(_dependencyMap[2], "metro/src/lib/bundle-modules/HMRClient");

  var HMRClient = {
    enable: function enable(platform, bundleEntry, host, port) {
      invariant(platform, 'Missing required parameter `platform`');
      invariant(bundleEntry, 'Missing required paramenter `bundleEntry`');
      invariant(host, 'Missing required paramenter `host`');

      var HMRLoadingView = _$$_REQUIRE(_dependencyMap[3], "HMRLoadingView");

      var wsHostPort = port !== null && port !== '' ? host + ":" + port : host;
      bundleEntry = bundleEntry.replace(/\.(bundle|delta)/, '.js');
      var wsUrl = "ws://" + wsHostPort + "/hot?" + ("platform=" + platform + "&") + ("bundleEntry=" + bundleEntry);
      var hmrClient = new MetroHMRClient(wsUrl);
      hmrClient.on('connection-error', function (e) {
        var error = "Hot loading isn't working because it cannot connect to the development server.\n\nTry the following to fix the issue:\n- Ensure that the packager server is running and available on the same network";

        if (Platform.OS === 'ios') {
          error += "\n- Ensure that the Packager server URL is correctly set in AppDelegate";
        } else {
          error += "\n- Ensure that your device/emulator is connected to your machine and has USB debugging enabled - run 'adb devices' to see a list of connected devices\n- If you're on a physical device connected to the same machine, run 'adb reverse tcp:8081 tcp:8081' to forward requests from your device\n- If your device is on the same Wi-Fi network, set 'Debug server host & port for device' in 'Dev settings' to your machine's IP address and the port of the local dev server - e.g. 10.0.1.1:8081";
        }

        error += "\n\nURL: " + host + ":" + port + "\n\nError: " + e.message;
        throw new Error(error);
      });
      hmrClient.on('update-start', function () {
        HMRLoadingView.showMessage('Hot Loading...');
      });
      hmrClient.on('update', function () {
        if (Platform.OS === 'ios') {
          var RCTRedBox = _$$_REQUIRE(_dependencyMap[4], "NativeModules").RedBox;

          RCTRedBox && RCTRedBox.dismiss && RCTRedBox.dismiss();
        } else {
          var RCTExceptionsManager = _$$_REQUIRE(_dependencyMap[4], "NativeModules").ExceptionsManager;

          RCTExceptionsManager && RCTExceptionsManager.dismissRedbox && RCTExceptionsManager.dismissRedbox();
        }
      });
      hmrClient.on('update-done', function () {
        HMRLoadingView.hide();
      });
      hmrClient.on('error', function (data) {
        HMRLoadingView.hide();
        throw new Error(data.type + " " + data.message);
      });
      hmrClient.enable();
    }
  };
  module.exports = HMRClient;
},244,[146,117,245,249,119],"node_modules\\react-native\\Libraries\\Utilities\\HMRClient.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/inherits");

  var WebSocketHMRClient = _$$_REQUIRE(_dependencyMap[4], "./WebSocketHMRClient");

  var injectDelta = _$$_REQUIRE(_dependencyMap[5], "./injectDelta");

  var HMRClient = function (_WebSocketHMRClient) {
    _inherits(HMRClient, _WebSocketHMRClient);

    function HMRClient(url) {
      var _this;

      _classCallCheck(this, HMRClient);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(HMRClient).call(this, url));

      _this.on("update", function (update) {
        injectDelta(update.delta);
      });

      return _this;
    }

    return HMRClient;
  }(WebSocketHMRClient);

  module.exports = HMRClient;
},245,[24,26,29,30,246,248],"node_modules\\metro\\src\\lib\\bundle-modules\\HMRClient.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/inherits");

  var EventEmitter = _$$_REQUIRE(_dependencyMap[5], "eventemitter3");

  var WebSocketHMRClient = function (_EventEmitter) {
    _inherits(WebSocketHMRClient, _EventEmitter);

    function WebSocketHMRClient(url) {
      var _this;

      _classCallCheck(this, WebSocketHMRClient);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(WebSocketHMRClient).call(this));
      _this._url = url;
      return _this;
    }

    _createClass(WebSocketHMRClient, [{
      key: "enable",
      value: function enable() {
        var _this2 = this;

        if (this._ws) {
          this.disable();
        }

        this._ws = new global.WebSocket(this._url);

        this._ws.onopen = function () {
          _this2.emit("open");
        };

        this._ws.onerror = function (error) {
          _this2.emit("connection-error", error);
        };

        this._ws.onclose = function () {
          _this2.emit("close");
        };

        this._ws.onmessage = function (message) {
          var data = JSON.parse(message.data);

          switch (data.type) {
            case "update-start":
              _this2.emit("update-start");

              break;

            case "update":
              _this2.emit("update", data.body);

              break;

            case "update-done":
              _this2.emit("update-done");

              break;

            case "error":
              _this2.emit("error", data.body);

              break;

            default:
              _this2.emit("error", {
                type: "unknown-message",
                message: data
              });

          }
        };
      }
    }, {
      key: "disable",
      value: function disable() {
        if (this._ws) {
          this._ws.close();

          this._ws = undefined;
        }
      }
    }]);

    return WebSocketHMRClient;
  }(EventEmitter);

  module.exports = WebSocketHMRClient;
},246,[24,25,26,29,30,247],"node_modules\\metro\\src\\lib\\bundle-modules\\WebSocketHMRClient.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var has = Object.prototype.hasOwnProperty,
      prefix = '~';

  function Events() {}

  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__) prefix = false;
  }

  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }

  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== 'function') {
      throw new TypeError('The listener must be a function');
    }

    var listener = new EE(fn, context || emitter, once),
        evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }

  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
  }

  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }

  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [],
        events,
        name;
    if (this._eventsCount === 0) return names;

    for (name in events = this._events) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }

    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }

    return names;
  };

  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event,
        handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];

    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }

    return ee;
  };

  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event,
        listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };

  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt],
        len = arguments.length,
        args,
        i;

    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;

        case 2:
          return listeners.fn.call(listeners.context, a1), true;

        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;

        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;

        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;

        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }

      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }

      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length,
          j;

      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;

          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;

          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;

          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;

          default:
            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }

    return true;
  };

  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };

  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };

  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;

    if (!fn) {
      clearEvent(this, evt);
      return this;
    }

    var listeners = this._events[evt];

    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }

      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
    }

    return this;
  };

  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;

    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }

    return this;
  };

  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;

  if ('undefined' !== typeof module) {
    module.exports = EventEmitter;
  }
},247,[],"node_modules\\eventemitter3\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if ((typeof Symbol === "function" ? Symbol.iterator : "@@iterator") in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  function injectDelta(modules) {
    modules.forEach(function (_ref, i) {
      var _ref2 = _slicedToArray(_ref, 2);

      var id = _ref2[0],
          code = _ref2[1];
      var injectFunction = typeof global.nativeInjectHMRUpdate === "function" ? global.nativeInjectHMRUpdate : eval;
      injectFunction(code);
    });
  }

  module.exports = injectDelta;
},248,[],"node_modules\\metro\\src\\lib\\bundle-modules\\injectDelta.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/defineProperty");

  var ToastAndroid = _$$_REQUIRE(_dependencyMap[3], "ToastAndroid");

  var TOAST_SHORT_DELAY = 2000;

  var HMRLoadingView = function () {
    function HMRLoadingView() {
      _classCallCheck(this, HMRLoadingView);
    }

    _createClass(HMRLoadingView, null, [{
      key: "showMessage",
      value: function showMessage(message) {
        if (HMRLoadingView._showing) {
          return;
        }

        ToastAndroid.show(message, ToastAndroid.SHORT);
        HMRLoadingView._showing = true;
        setTimeout(function () {
          HMRLoadingView._showing = false;
        }, TOAST_SHORT_DELAY);
      }
    }, {
      key: "hide",
      value: function hide() {}
    }]);

    return HMRLoadingView;
  }();

  _defineProperty(HMRLoadingView, "_showing", void 0);

  module.exports = HMRLoadingView;
},249,[24,25,32,250],"node_modules\\react-native\\Libraries\\Utilities\\HMRLoadingView.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var RCTToastAndroid = _$$_REQUIRE(_dependencyMap[0], "NativeModules").ToastAndroid;

  var ToastAndroid = {
    SHORT: RCTToastAndroid.SHORT,
    LONG: RCTToastAndroid.LONG,
    TOP: RCTToastAndroid.TOP,
    BOTTOM: RCTToastAndroid.BOTTOM,
    CENTER: RCTToastAndroid.CENTER,
    show: function show(message, duration) {
      RCTToastAndroid.show(message, duration);
    },
    showWithGravity: function showWithGravity(message, duration, gravity) {
      RCTToastAndroid.showWithGravity(message, duration, gravity);
    },
    showWithGravityAndOffset: function showWithGravityAndOffset(message, duration, gravity, xOffset, yOffset) {
      RCTToastAndroid.showWithGravityAndOffset(message, duration, gravity, xOffset, yOffset);
    }
  };
  module.exports = ToastAndroid;
},250,[119],"node_modules\\react-native\\Libraries\\Components\\ToastAndroid\\ToastAndroid.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var register = function register() {};

  if (__DEV__) {
    var AppState = _$$_REQUIRE(_dependencyMap[0], "AppState");

    var WebSocket = _$$_REQUIRE(_dependencyMap[1], "WebSocket");

    var reactDevTools = _$$_REQUIRE(_dependencyMap[2], "react-devtools-core");

    var getDevServer = _$$_REQUIRE(_dependencyMap[3], "getDevServer");

    if (WebSocket.isAvailable) {
      var isAppActive = function isAppActive() {
        return AppState.currentState !== 'background';
      };

      var devServer = getDevServer();
      var host = devServer.bundleLoadedFromServer ? devServer.url.replace(/https?:\/\//, '').split(':')[0] : 'localhost';
      reactDevTools.connectToDevTools({
        isAppActive: isAppActive,
        host: host,
        port: window.__REACT_DEVTOOLS_PORT__,
        resolveRNStyle: _$$_REQUIRE(_dependencyMap[4], "flattenStyle")
      });
    }
  }

  module.exports = {
    register: register
  };
},251,[252,227,253,193,174],"node_modules\\react-native\\Libraries\\Core\\Devtools\\setupDevtools.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/defineProperty");

  var MissingNativeEventEmitterShim = _$$_REQUIRE(_dependencyMap[7], "MissingNativeEventEmitterShim");

  var NativeEventEmitter = _$$_REQUIRE(_dependencyMap[8], "NativeEventEmitter");

  var NativeModules = _$$_REQUIRE(_dependencyMap[9], "NativeModules");

  var RCTAppState = NativeModules.AppState;

  var logError = _$$_REQUIRE(_dependencyMap[10], "logError");

  var invariant = _$$_REQUIRE(_dependencyMap[11], "fbjs/lib/invariant");

  var AppState = function (_NativeEventEmitter) {
    _inherits(AppState, _NativeEventEmitter);

    function AppState() {
      var _this;

      _classCallCheck(this, AppState);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AppState).call(this, RCTAppState));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_eventHandlers", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "currentState", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "isAvailable", true);

      _this.isAvailable = true;
      _this._eventHandlers = {
        change: new Map(),
        memoryWarning: new Map()
      };
      _this.currentState = RCTAppState.initialAppState || 'active';
      var eventUpdated = false;

      _this.addListener('appStateDidChange', function (appStateData) {
        eventUpdated = true;
        _this.currentState = appStateData.app_state;
      });

      RCTAppState.getCurrentAppState(function (appStateData) {
        if (!eventUpdated && _this.currentState !== appStateData.app_state) {
          _this.currentState = appStateData.app_state;

          _this.emit('appStateDidChange', appStateData);
        }
      }, logError);
      return _this;
    }

    _createClass(AppState, [{
      key: "addEventListener",
      value: function addEventListener(type, handler) {
        invariant(['change', 'memoryWarning'].indexOf(type) !== -1, 'Trying to subscribe to unknown event: "%s"', type);

        if (type === 'change') {
          this._eventHandlers[type].set(handler, this.addListener('appStateDidChange', function (appStateData) {
            handler(appStateData.app_state);
          }));
        } else if (type === 'memoryWarning') {
          this._eventHandlers[type].set(handler, this.addListener('memoryWarning', handler));
        }
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, handler) {
        invariant(['change', 'memoryWarning'].indexOf(type) !== -1, 'Trying to remove listener for unknown event: "%s"', type);

        if (!this._eventHandlers[type].has(handler)) {
          return;
        }

        this._eventHandlers[type].get(handler).remove();

        this._eventHandlers[type].delete(handler);
      }
    }]);

    return AppState;
  }(NativeEventEmitter);

  if (__DEV__ && !RCTAppState) {
    var MissingNativeAppStateShim = function (_MissingNativeEventEm) {
      _inherits(MissingNativeAppStateShim, _MissingNativeEventEm);

      function MissingNativeAppStateShim() {
        _classCallCheck(this, MissingNativeAppStateShim);

        return _possibleConstructorReturn(this, _getPrototypeOf(MissingNativeAppStateShim).call(this, 'RCTAppState', 'AppState'));
      }

      _createClass(MissingNativeAppStateShim, [{
        key: "addEventListener",
        value: function addEventListener() {
          this.throwMissingNativeModule();
        }
      }, {
        key: "removeEventListener",
        value: function removeEventListener() {
          this.throwMissingNativeModule();
        }
      }, {
        key: "currentState",
        get: function get() {
          this.throwMissingNativeModule();
        }
      }]);

      return MissingNativeAppStateShim;
    }(MissingNativeEventEmitterShim);

    AppState = new MissingNativeAppStateShim();
  } else {
    AppState = new AppState();
  }

  module.exports = AppState;
},252,[24,25,26,29,30,28,32,218,219,119,235,117],"node_modules\\react-native\\Libraries\\AppState\\AppState.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  !function (root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define([], factory) : "object" == typeof exports ? exports.ReactDevToolsBackend = factory() : root.ReactDevToolsBackend = factory();
  }(this, function () {
    return function (modules) {
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
          exports: {},
          id: moduleId,
          loaded: !1
        };
        return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.loaded = !0, module.exports;
      }

      var installedModules = {};
      return __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.p = "", __webpack_require__(0);
    }([function (module, exports, __webpack_require__) {
      "use strict";

      function connectToDevTools(options) {
        function scheduleRetry() {
          setTimeout(function () {
            return connectToDevTools(options);
          }, 2e3);
        }

        function handleClose() {
          hasClosed || (hasClosed = !0, scheduleRetry(), closeListeners.forEach(function (fn) {
            return fn();
          }));
        }

        function handleMessage(evt) {
          var data;

          try {
            invariant("string" == typeof evt.data), data = JSON.parse(evt.data);
          } catch (e) {
            return void console.error("failed to parse json: " + String(evt.data));
          }

          messageListeners.forEach(function (fn) {
            try {
              fn(data);
            } catch (e) {
              throw console.log(data), e;
            }
          });
        }

        var _ref = options || {},
            _ref$host = _ref.host,
            host = void 0 === _ref$host ? "localhost" : _ref$host,
            _ref$port = _ref.port,
            port = void 0 === _ref$port ? 8097 : _ref$port,
            websocket = _ref.websocket,
            _ref$resolveRNStyle = _ref.resolveRNStyle,
            resolveRNStyle = void 0 === _ref$resolveRNStyle ? null : _ref$resolveRNStyle,
            _ref$isAppActive = _ref.isAppActive,
            isAppActive = void 0 === _ref$isAppActive ? function () {
          return !0;
        } : _ref$isAppActive;

        if (!isAppActive()) return void scheduleRetry();
        var messageListeners = [],
            closeListeners = [],
            uri = "ws://" + host + ":" + port,
            ws = websocket ? websocket : new window.WebSocket(uri);
        ws.onclose = handleClose, ws.onerror = handleClose, ws.onmessage = handleMessage, ws.onopen = function () {
          var wall = {
            listen: function listen(fn) {
              messageListeners.push(fn);
            },
            onClose: function onClose(fn) {
              closeListeners.push(fn);
            },
            send: function send(data) {
              ws.send(JSON.stringify(data));
            }
          };
          setupBackend(wall, resolveRNStyle);
        };
        var hasClosed = !1;
      }

      function setupBackend(wall, resolveRNStyle) {
        wall.onClose(function () {
          agent && agent.emit("shutdown"), window.__REACT_DEVTOOLS_GLOBAL_HOOK__.emit("shutdown"), bridge = null, agent = null, console.log("closing devtools");
        });
        var bridge = new Bridge(wall),
            agent = new Agent(window, {
          rnStyle: !!resolveRNStyle,
          rnStyleMeasure: !!resolveRNStyle
        });
        agent.addBridge(bridge), resolveRNStyle && setupRNStyle(bridge, agent, resolveRNStyle), setupProfiler(bridge, agent, window.__REACT_DEVTOOLS_GLOBAL_HOOK__), setupRelay(bridge, agent, window.__REACT_DEVTOOLS_GLOBAL_HOOK__);

        var _connectTimeout = setTimeout(function () {
          console.warn("react-devtools agent got no connection");
        }, 2e4);

        agent.once("connected", function () {
          agent && (inject(window.__REACT_DEVTOOLS_GLOBAL_HOOK__, agent), clearTimeout(_connectTimeout));
        }), ProfileCollector.init(agent);
      }

      var Agent = __webpack_require__(1),
          Bridge = __webpack_require__(7),
          ProfileCollector = __webpack_require__(32),
          installGlobalHook = __webpack_require__(33),
          installRelayHook = __webpack_require__(34),
          inject = __webpack_require__(35),
          invariant = __webpack_require__(47),
          setupRNStyle = __webpack_require__(51),
          setupProfiler = __webpack_require__(53),
          setupRelay = __webpack_require__(54);

      installGlobalHook(window), installRelayHook(window), window.document && window.__REACT_DEVTOOLS_GLOBAL_HOOK__.on("react-devtools", function (agent) {
        var setupHighlighter = __webpack_require__(55);

        setupHighlighter(agent);
      }), module.exports = {
        connectToDevTools: connectToDevTools
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !call || "object" != typeof call && "function" != typeof call ? self : call;
      }

      function _inherits(subClass, superClass) {
        if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
      }

      var _typeof = "function" == typeof Symbol && "symbol" == typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
      },
          _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
        };
      }(),
          _require = __webpack_require__(2),
          EventEmitter = _require.EventEmitter,
          assign = __webpack_require__(3),
          nullthrows = __webpack_require__(4)["default"],
          guid = __webpack_require__(5),
          getIn = __webpack_require__(6),
          Agent = function (_EventEmitter) {
        function Agent(global, capabilities) {
          _classCallCheck(this, Agent);

          var _this = _possibleConstructorReturn(this, (Agent.__proto__ || Object.getPrototypeOf(Agent)).call(this));

          _this.global = global, _this.internalInstancesById = new Map(), _this.idsByInternalInstances = new WeakMap(), _this.renderers = new Map(), _this.elementData = new Map(), _this.roots = new Set(), _this.reactInternals = {};
          var lastSelected;
          _this.on("selected", function (id) {
            var data = _this.elementData.get(id);

            data && data.publicInstance && _this.global.$r === lastSelected && (_this.global.$r = data.publicInstance, lastSelected = data.publicInstance);
          }), _this._prevSelected = null, _this._scrollUpdate = !1;
          var isReactDOM = window.document && "function" == typeof window.document.createElement;
          return _this.capabilities = assign({
            scroll: isReactDOM && "function" == typeof window.document.body.scrollIntoView,
            dom: isReactDOM,
            editTextContent: !1
          }, capabilities), isReactDOM && (_this._updateScroll = _this._updateScroll.bind(_this), window.addEventListener("scroll", _this._onScroll.bind(_this), !0), window.addEventListener("click", _this._onClick.bind(_this), !0), window.addEventListener("mouseover", _this._onMouseOver.bind(_this), !0), window.addEventListener("resize", _this._onResize.bind(_this), !0)), _this;
        }

        return _inherits(Agent, _EventEmitter), _createClass(Agent, [{
          key: "sub",
          value: function value(ev, fn) {
            var _this2 = this;

            return this.on(ev, fn), function () {
              _this2.removeListener(ev, fn);
            };
          }
        }, {
          key: "setReactInternals",
          value: function value(renderer, reactInternals) {
            this.reactInternals[renderer] = reactInternals;
          }
        }, {
          key: "addBridge",
          value: function value(bridge) {
            var _this3 = this;

            bridge.on("requestCapabilities", function () {
              bridge.send("capabilities", _this3.capabilities), _this3.emit("connected");
            }), bridge.on("setState", this._setState.bind(this)), bridge.on("setProps", this._setProps.bind(this)), bridge.on("setContext", this._setContext.bind(this)), bridge.on("makeGlobal", this._makeGlobal.bind(this)), bridge.on("highlight", function (id) {
              return _this3.highlight(id);
            }), bridge.on("highlightMany", function (id) {
              return _this3.highlightMany(id);
            }), bridge.on("hideHighlight", function () {
              return _this3.emit("hideHighlight");
            }), bridge.on("startInspecting", function () {
              return _this3.emit("startInspecting");
            }), bridge.on("stopInspecting", function () {
              return _this3.emit("stopInspecting");
            }), bridge.on("selected", function (id) {
              return _this3.emit("selected", id);
            }), bridge.on("isRecording", function (isRecording) {
              return _this3.emit("isRecording", isRecording);
            }), bridge.on("setInspectEnabled", function (enabled) {
              _this3._inspectEnabled = enabled, _this3.emit("stopInspecting");
            }), bridge.on("shutdown", function () {
              return _this3.emit("shutdown");
            }), bridge.on("changeTextContent", function (_ref) {
              var id = _ref.id,
                  text = _ref.text,
                  node = _this3.getNodeForID(id);

              node && (node.textContent = text);
            }), bridge.on("putSelectedNode", function (id) {
              window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$node = _this3.getNodeForID(id);
            }), bridge.on("putSelectedInstance", function (id) {
              var node = _this3.elementData.get(id);

              node ? window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$type = node.type : window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$type = null, node && node.publicInstance ? window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$inst = node.publicInstance : window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$inst = null;
            }), bridge.on("checkSelection", function () {
              var newSelected = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0;

              if (newSelected !== _this3._prevSelected) {
                _this3._prevSelected = newSelected;
                var sentSelected = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$node;
                newSelected !== sentSelected && _this3.selectFromDOMNode(newSelected, !0);
              }
            }), bridge.on("scrollToNode", function (id) {
              return _this3.scrollToNode(id);
            }), bridge.on("traceupdatesstatechange", function (value) {
              return _this3.emit("traceupdatesstatechange", value);
            }), bridge.on("colorizerchange", function (value) {
              return _this3.emit("colorizerchange", value);
            }), this.on("root", function (id) {
              return bridge.send("root", id);
            }), this.on("mount", function (data) {
              return bridge.send("mount", data);
            }), this.on("update", function (data) {
              return bridge.send("update", data);
            }), this.on("updateProfileTimes", function (data) {
              return bridge.send("updateProfileTimes", data);
            }), this.on("unmount", function (id) {
              bridge.send("unmount", id), bridge.forget(id);
            }), this.on("setSelection", function (data) {
              return bridge.send("select", data);
            }), this.on("setInspectEnabled", function (data) {
              return bridge.send("setInspectEnabled", data);
            }), this.on("isRecording", function (isRecording) {
              return bridge.send("isRecording", isRecording);
            }), this.on("storeSnapshot", function (data) {
              return bridge.send("storeSnapshot", data);
            }), this.on("clearSnapshots", function () {
              return bridge.send("clearSnapshots");
            });
          }
        }, {
          key: "scrollToNode",
          value: function value(id) {
            var node = this.getNodeForID(id);
            if (!node) return void console.warn("unable to get the node for scrolling");
            var domElement = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;
            return domElement ? ("function" == typeof domElement.scrollIntoViewIfNeeded ? domElement.scrollIntoViewIfNeeded() : "function" == typeof domElement.scrollIntoView && domElement.scrollIntoView(), void this.highlight(id)) : void console.warn("unable to get the domElement for scrolling");
          }
        }, {
          key: "highlight",
          value: function value(id) {
            var data = this.elementData.get(id),
                node = this.getNodeForID(id);
            data && node && this.emit("highlight", {
              node: node,
              name: data.name,
              props: data.props
            });
          }
        }, {
          key: "highlightMany",
          value: function value(ids) {
            var _this4 = this,
                nodes = [];

            ids.forEach(function (id) {
              var node = _this4.getNodeForID(id);

              node && nodes.push(node);
            }), nodes.length && this.emit("highlightMany", nodes);
          }
        }, {
          key: "getNodeForID",
          value: function value(id) {
            var component = this.internalInstancesById.get(id);
            if (!component) return null;
            var renderer = this.renderers.get(id);
            return renderer && this.reactInternals[renderer].getNativeFromReactElement ? this.reactInternals[renderer].getNativeFromReactElement(component) : null;
          }
        }, {
          key: "selectFromDOMNode",
          value: function value(node, quiet) {
            var offsetFromLeaf = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                id = this.getIDForNode(node);
            id && this.emit("setSelection", {
              id: id,
              quiet: quiet,
              offsetFromLeaf: offsetFromLeaf
            });
          }
        }, {
          key: "selectFromReactInstance",
          value: function value(instance, quiet) {
            var id = this.getId(instance);
            return id ? void this.emit("setSelection", {
              id: id,
              quiet: quiet
            }) : void console.log("no instance id", instance);
          }
        }, {
          key: "getIDForNode",
          value: function value(node) {
            if (!this.reactInternals) return null;
            var component;

            for (var renderer in this.reactInternals) {
              try {
                component = this.reactInternals[renderer].getReactElementFromNative(node);
              } catch (e) {}

              if (component) return this.getId(component);
            }

            return null;
          }
        }, {
          key: "_setProps",
          value: function value(_ref2) {
            var id = _ref2.id,
                path = _ref2.path,
                value = _ref2.value,
                data = this.elementData.get(id);
            data && data.updater && "function" == typeof data.updater.setInProps ? data.updater.setInProps(path, value) : console.warn("trying to set props on a component that doesn't support it");
          }
        }, {
          key: "_setState",
          value: function value(_ref3) {
            var id = _ref3.id,
                path = _ref3.path,
                value = _ref3.value,
                data = this.elementData.get(id);
            data && data.updater && "function" == typeof data.updater.setInState ? data.updater.setInState(path, value) : console.warn("trying to set state on a component that doesn't support it");
          }
        }, {
          key: "_setContext",
          value: function value(_ref4) {
            var id = _ref4.id,
                path = _ref4.path,
                value = _ref4.value,
                data = this.elementData.get(id);
            data && data.updater && "function" == typeof data.updater.setInContext ? data.updater.setInContext(path, value) : console.warn("trying to set context on a component that doesn't support it");
          }
        }, {
          key: "_makeGlobal",
          value: function value(_ref5) {
            var id = _ref5.id,
                path = _ref5.path,
                data = this.elementData.get(id);

            if (data) {
              var value;
              value = "instance" === path ? data.publicInstance : getIn(data, path), this.global.$tmp = value, console.log("$tmp =", value);
            }
          }
        }, {
          key: "getId",
          value: function value(internalInstance) {
            return "object" === ("undefined" == typeof internalInstance ? "undefined" : _typeof(internalInstance)) && internalInstance ? (this.idsByInternalInstances.has(internalInstance) || (this.idsByInternalInstances.set(internalInstance, guid()), this.internalInstancesById.set(nullthrows(this.idsByInternalInstances.get(internalInstance)), internalInstance)), nullthrows(this.idsByInternalInstances.get(internalInstance))) : internalInstance;
          }
        }, {
          key: "addRoot",
          value: function value(renderer, internalInstance) {
            var id = this.getId(internalInstance);
            this.roots.add(id), this.emit("root", id);
          }
        }, {
          key: "rootCommitted",
          value: function value(renderer, internalInstance, data) {
            var id = this.getId(internalInstance);
            this.emit("rootCommitted", id, internalInstance, data);
          }
        }, {
          key: "onMounted",
          value: function value(renderer, component, data) {
            var _this5 = this,
                id = this.getId(component);

            this.renderers.set(id, renderer), this.elementData.set(id, data);
            var send = assign({}, data);
            send.children && send.children.map && (send.children = send.children.map(function (c) {
              return _this5.getId(c);
            })), send.id = id, send.canUpdate = send.updater && !!send.updater.forceUpdate, delete send.type, delete send.updater, this.emit("mount", send);
          }
        }, {
          key: "onUpdated",
          value: function value(component, data) {
            var _this6 = this,
                id = this.getId(component);

            this.elementData.set(id, data);
            var send = assign({}, data);
            send.children && send.children.map && (send.children = send.children.map(function (c) {
              return _this6.getId(c);
            })), send.id = id, send.canUpdate = send.updater && !!send.updater.forceUpdate, delete send.type, delete send.updater, this.emit("update", send);
          }
        }, {
          key: "onUpdatedProfileTimes",
          value: function value(component, data) {
            var _this7 = this,
                id = this.getId(component);

            this.elementData.set(id, data);
            var send = assign({}, data);
            send.children && send.children.map && (send.children = send.children.map(function (c) {
              return _this7.getId(c);
            })), send.id = id, send.canUpdate = send.updater && !!send.updater.forceUpdate, delete send.type, delete send.updater, this.emit("updateProfileTimes", send);
          }
        }, {
          key: "onUnmounted",
          value: function value(component) {
            var id = this.getId(component);
            this.elementData["delete"](id), this.roots.has(id) && (this.roots["delete"](id), this.emit("rootUnmounted", id)), this.renderers["delete"](id), this.emit("unmount", id), this.idsByInternalInstances["delete"](component);
          }
        }, {
          key: "_onScroll",
          value: function value() {
            this._scrollUpdate || (this._scrollUpdate = !0, window.requestAnimationFrame(this._updateScroll));
          }
        }, {
          key: "_updateScroll",
          value: function value() {
            this.emit("refreshMultiOverlay"), this.emit("stopInspecting"), this._scrollUpdate = !1;
          }
        }, {
          key: "_onClick",
          value: function value(event) {
            if (this._inspectEnabled) {
              var id = this.getIDForNode(event.target);
              id && (event.stopPropagation(), event.preventDefault(), this.emit("setSelection", {
                id: id
              }), this.emit("setInspectEnabled", !1));
            }
          }
        }, {
          key: "_onMouseOver",
          value: function value(event) {
            if (this._inspectEnabled) {
              var id = this.getIDForNode(event.target);
              if (!id) return;
              this.highlight(id);
            }
          }
        }, {
          key: "_onResize",
          value: function value(event) {
            this.emit("stopInspecting");
          }
        }]), Agent;
      }(EventEmitter);

      module.exports = Agent;
    }, function (module, exports) {
      function EventEmitter() {
        this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
      }

      function isFunction(arg) {
        return "function" == typeof arg;
      }

      function isNumber(arg) {
        return "number" == typeof arg;
      }

      function isObject(arg) {
        return "object" == typeof arg && null !== arg;
      }

      function isUndefined(arg) {
        return void 0 === arg;
      }

      module.exports = EventEmitter, EventEmitter.EventEmitter = EventEmitter, EventEmitter.prototype._events = void 0, EventEmitter.prototype._maxListeners = void 0, EventEmitter.defaultMaxListeners = 10, EventEmitter.prototype.setMaxListeners = function (n) {
        if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError("n must be a positive number");
        return this._maxListeners = n, this;
      }, EventEmitter.prototype.emit = function (type) {
        var er, handler, len, args, i, listeners;

        if (this._events || (this._events = {}), "error" === type && (!this._events.error || isObject(this._events.error) && !this._events.error.length)) {
          if (er = arguments[1], er instanceof Error) throw er;
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          throw err.context = er, err;
        }

        if (handler = this._events[type], isUndefined(handler)) return !1;
        if (isFunction(handler)) switch (arguments.length) {
          case 1:
            handler.call(this);
            break;

          case 2:
            handler.call(this, arguments[1]);
            break;

          case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;

          default:
            args = Array.prototype.slice.call(arguments, 1), handler.apply(this, args);
        } else if (isObject(handler)) for (args = Array.prototype.slice.call(arguments, 1), listeners = handler.slice(), len = listeners.length, i = 0; i < len; i++) {
          listeners[i].apply(this, args);
        }
        return !0;
      }, EventEmitter.prototype.addListener = function (type, listener) {
        var m;
        if (!isFunction(listener)) throw TypeError("listener must be a function");
        return this._events || (this._events = {}), this._events.newListener && this.emit("newListener", type, isFunction(listener.listener) ? listener.listener : listener), this._events[type] ? isObject(this._events[type]) ? this._events[type].push(listener) : this._events[type] = [this._events[type], listener] : this._events[type] = listener, isObject(this._events[type]) && !this._events[type].warned && (m = isUndefined(this._maxListeners) ? EventEmitter.defaultMaxListeners : this._maxListeners, m && m > 0 && this._events[type].length > m && (this._events[type].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[type].length), "function" == typeof console.trace && console.trace())), this;
      }, EventEmitter.prototype.on = EventEmitter.prototype.addListener, EventEmitter.prototype.once = function (type, listener) {
        function g() {
          this.removeListener(type, g), fired || (fired = !0, listener.apply(this, arguments));
        }

        if (!isFunction(listener)) throw TypeError("listener must be a function");
        var fired = !1;
        return g.listener = listener, this.on(type, g), this;
      }, EventEmitter.prototype.removeListener = function (type, listener) {
        var list, position, length, i;
        if (!isFunction(listener)) throw TypeError("listener must be a function");
        if (!this._events || !this._events[type]) return this;
        if (list = this._events[type], length = list.length, position = -1, list === listener || isFunction(list.listener) && list.listener === listener) delete this._events[type], this._events.removeListener && this.emit("removeListener", type, listener);else if (isObject(list)) {
          for (i = length; i-- > 0;) {
            if (list[i] === listener || list[i].listener && list[i].listener === listener) {
              position = i;
              break;
            }
          }

          if (position < 0) return this;
          1 === list.length ? (list.length = 0, delete this._events[type]) : list.splice(position, 1), this._events.removeListener && this.emit("removeListener", type, listener);
        }
        return this;
      }, EventEmitter.prototype.removeAllListeners = function (type) {
        var key, listeners;
        if (!this._events) return this;
        if (!this._events.removeListener) return 0 === arguments.length ? this._events = {} : this._events[type] && delete this._events[type], this;

        if (0 === arguments.length) {
          for (key in this._events) {
            "removeListener" !== key && this.removeAllListeners(key);
          }

          return this.removeAllListeners("removeListener"), this._events = {}, this;
        }

        if (listeners = this._events[type], isFunction(listeners)) this.removeListener(type, listeners);else if (listeners) for (; listeners.length;) {
          this.removeListener(type, listeners[listeners.length - 1]);
        }
        return delete this._events[type], this;
      }, EventEmitter.prototype.listeners = function (type) {
        var ret;
        return ret = this._events && this._events[type] ? isFunction(this._events[type]) ? [this._events[type]] : this._events[type].slice() : [];
      }, EventEmitter.prototype.listenerCount = function (type) {
        if (this._events) {
          var evlistener = this._events[type];
          if (isFunction(evlistener)) return 1;
          if (evlistener) return evlistener.length;
        }

        return 0;
      }, EventEmitter.listenerCount = function (emitter, type) {
        return emitter.listenerCount(type);
      };
    }, function (module, exports) {
      "use strict";

      function toObject(val) {
        if (null === val || void 0 === val) throw new TypeError("Object.assign cannot be called with null or undefined");
        return Object(val);
      }

      var hasOwnProperty = Object.prototype.hasOwnProperty,
          propIsEnumerable = Object.prototype.propertyIsEnumerable;

      module.exports = Object.assign || function (target, source) {
        for (var from, symbols, to = toObject(target), s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);

          for (var key in from) {
            hasOwnProperty.call(from, key) && (to[key] = from[key]);
          }

          if (Object.getOwnPropertySymbols) {
            symbols = Object.getOwnPropertySymbols(from);

            for (var i = 0; i < symbols.length; i++) {
              propIsEnumerable.call(from, symbols[i]) && (to[symbols[i]] = from[symbols[i]]);
            }
          }
        }

        return to;
      };
    }, function (module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports["default"] = function (x) {
        if (null != x) return x;
        throw new Error("Got unexpected null or undefined");
      };
    }, function (module, exports) {
      "use strict";

      function guid() {
        return "g" + Math.random().toString(16).substr(2);
      }

      module.exports = guid;
    }, function (module, exports) {
      "use strict";

      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        }

        return Array.from(arr);
      }

      function getIn(base, path) {
        return path.reduce(function (obj, attr) {
          if (obj) {
            if (hasOwnProperty.call(obj, attr)) return obj[attr];
            if ("function" == typeof obj[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]) return [].concat(_toConsumableArray(obj))[attr];
          }

          return null;
        }, base);
      }

      var hasOwnProperty = Object.prototype.hasOwnProperty;
      module.exports = getIn;
    }, function (module, exports, __webpack_require__) {
      "use strict";

      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        }

        return Array.from(arr);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
      }

      function getWindowFunction(name, polyfill) {
        return String(window[name]).indexOf("[native code]") === -1 ? polyfill : window[name];
      }

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
          }
        }

        return target;
      },
          _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
        };
      }(),
          consts = __webpack_require__(8),
          hydrate = __webpack_require__(27),
          dehydrate = __webpack_require__(28),
          getIn = __webpack_require__(6),
          performanceNow = __webpack_require__(29),
          lastRunTimeMS = 5,
          cancelIdleCallback = getWindowFunction("cancelIdleCallback", clearTimeout),
          requestIdleCallback = getWindowFunction("requestIdleCallback", function (cb, options) {
        var delayMS = 3e3 * lastRunTimeMS;
        return delayMS > 500 && (delayMS = 500), setTimeout(function () {
          var startTime = performanceNow();
          cb({
            didTimeout: !1,
            timeRemaining: function timeRemaining() {
              return 1 / 0;
            }
          });
          var endTime = performanceNow();
          lastRunTimeMS = (endTime - startTime) / 1e3;
        }, delayMS);
      }),
          Bridge = function () {
        function Bridge(wall) {
          _classCallCheck(this, Bridge), this._cbs = new Map(), this._inspectables = new Map(), this._cid = 0, this._listeners = {}, this._buffer = [], this._flushHandle = null, this._callers = {}, this._paused = !1, this._wall = wall, wall.listen(this._handleMessage.bind(this));
        }

        return _createClass(Bridge, [{
          key: "inspect",
          value: function value(id, path, cb) {
            var _cid = this._cid++;

            this._cbs.set(_cid, function (data, cleaned, proto, protoclean) {
              cleaned.length && hydrate(data, cleaned), proto && protoclean.length && hydrate(proto, protoclean), proto && (data[consts.proto] = proto), cb(data);
            }), this._wall.send({
              type: "inspect",
              callback: _cid,
              path: path,
              id: id
            });
          }
        }, {
          key: "call",
          value: function value(name, args, cb) {
            var _cid = this._cid++;

            this._cbs.set(_cid, cb), this._wall.send({
              type: "call",
              callback: _cid,
              args: args,
              name: name
            });
          }
        }, {
          key: "onCall",
          value: function value(name, handler) {
            if (this._callers[name]) throw new Error("only one call handler per call name allowed");
            this._callers[name] = handler;
          }
        }, {
          key: "pause",
          value: function value() {
            this._wall.send({
              type: "pause"
            });
          }
        }, {
          key: "resume",
          value: function value() {
            this._wall.send({
              type: "resume"
            });
          }
        }, {
          key: "setInspectable",
          value: function value(id, data) {
            var prev = this._inspectables.get(id);

            return prev ? void this._inspectables.set(id, _extends({}, prev, data)) : void this._inspectables.set(id, data);
          }
        }, {
          key: "send",
          value: function value(evt, data) {
            this._buffer.push({
              evt: evt,
              data: data
            }), this.scheduleFlush();
          }
        }, {
          key: "scheduleFlush",
          value: function value() {
            if (!this._flushHandle && this._buffer.length) {
              var timeout = this._paused ? 5e3 : 500;
              this._flushHandle = requestIdleCallback(this.flushBufferWhileIdle.bind(this), {
                timeout: timeout
              });
            }
          }
        }, {
          key: "cancelFlush",
          value: function value() {
            this._flushHandle && (cancelIdleCallback(this._flushHandle), this._flushHandle = null);
          }
        }, {
          key: "flushBufferWhileIdle",
          value: function value(deadline) {
            this._flushHandle = null;

            for (var chunkCount = this._paused ? 20 : 10, chunkSize = Math.round(this._buffer.length / chunkCount), minChunkSize = this._paused ? 50 : 100; this._buffer.length && (deadline.timeRemaining() > 0 || deadline.didTimeout);) {
              var take = Math.min(this._buffer.length, Math.max(minChunkSize, chunkSize)),
                  currentBuffer = this._buffer.splice(0, take);

              this.flushBufferSlice(currentBuffer);
            }

            this._buffer.length && this.scheduleFlush();
          }
        }, {
          key: "flushBufferSlice",
          value: function value(bufferSlice) {
            var _this = this,
                events = bufferSlice.map(function (_ref) {
              var evt = _ref.evt,
                  data = _ref.data,
                  cleaned = [],
                  san = dehydrate(data, cleaned);
              return cleaned.length && _this.setInspectable(data.id, data), {
                type: "event",
                evt: evt,
                data: san,
                cleaned: cleaned
              };
            });

            this._wall.send({
              type: "many-events",
              events: events
            });
          }
        }, {
          key: "forget",
          value: function value(id) {
            this._inspectables["delete"](id);
          }
        }, {
          key: "on",
          value: function value(evt, fn) {
            this._listeners[evt] ? this._listeners[evt].push(fn) : this._listeners[evt] = [fn];
          }
        }, {
          key: "off",
          value: function value(evt, fn) {
            if (this._listeners[evt]) {
              var ix = this._listeners[evt].indexOf(fn);

              ix !== -1 && this._listeners[evt].splice(ix, 1);
            }
          }
        }, {
          key: "once",
          value: function value(evt, fn) {
            var self = this,
                listener = function listener() {
              fn.apply(this, arguments), self.off(evt, listener);
            };

            this.on(evt, listener);
          }
        }, {
          key: "_handleMessage",
          value: function value(payload) {
            var _this2 = this;

            if ("resume" === payload.type) return this._paused = !1, void this.scheduleFlush();
            if ("pause" === payload.type) return this._paused = !0, void this.cancelFlush();

            if ("callback" === payload.type) {
              var callback = this._cbs.get(payload.id);

              return void (callback && (callback.apply(void 0, _toConsumableArray(payload.args)), this._cbs["delete"](payload.id)));
            }

            if ("call" === payload.type) return void this._handleCall(payload.name, payload.args, payload.callback);
            if ("inspect" === payload.type) return void this._inspectResponse(payload.id, payload.path, payload.callback);

            if ("event" === payload.type) {
              payload.cleaned && hydrate(payload.data, payload.cleaned);
              var fns = this._listeners[payload.evt],
                  data = payload.data;
              fns && fns.forEach(function (fn) {
                return fn(data);
              });
            }

            "many-events" === payload.type && payload.events.forEach(function (event) {
              event.cleaned && hydrate(event.data, event.cleaned);
              var handlers = _this2._listeners[event.evt];
              handlers && handlers.forEach(function (fn) {
                return fn(event.data);
              });
            });
          }
        }, {
          key: "_handleCall",
          value: function value(name, args, callback) {
            if (!this._callers[name]) return void console.warn('unknown call: "' + name + '"');
            args = Array.isArray(args) ? args : [args];
            var result;

            try {
              result = this._callers[name].apply(null, args);
            } catch (e) {
              return void console.error("Failed to call", e);
            }

            this._wall.send({
              type: "callback",
              id: callback,
              args: [result]
            });
          }
        }, {
          key: "_inspectResponse",
          value: function value(id, path, callback) {
            var inspectable = this._inspectables.get(id),
                result = {},
                cleaned = [],
                proto = null,
                protoclean = [];

            if (inspectable) {
              var val = getIn(inspectable, path),
                  protod = !1,
                  isFn = "function" == typeof val;

              if (val && "function" == typeof val[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]) {
                var iterVal = Object.create({}),
                    count = 0,
                    _iteratorNormalCompletion = !0,
                    _didIteratorError = !1,
                    _iteratorError = void 0;

                try {
                  for (var _step, _iterator = val[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
                    var entry = _step.value;
                    if (count > 100) break;
                    iterVal[count] = entry, count++;
                  }
                } catch (err) {
                  _didIteratorError = !0, _iteratorError = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion && _iterator["return"] && _iterator["return"]();
                  } finally {
                    if (_didIteratorError) throw _iteratorError;
                  }
                }

                val = iterVal;
              }

              if (Object.getOwnPropertyNames(val).forEach(function (name) {
                "__proto__" === name && (protod = !0), (!isFn || "arguments" !== name && "callee" !== name && "caller" !== name) && (result[name] = dehydrate(val[name], cleaned, [name]));
              }), !protod && val.__proto__ && "Object" !== val.constructor.name) {
                var newProto = {},
                    pIsFn = "function" == typeof val.__proto__;
                Object.getOwnPropertyNames(val.__proto__).forEach(function (name) {
                  (!pIsFn || "arguments" !== name && "callee" !== name && "caller" !== name) && (newProto[name] = dehydrate(val.__proto__[name], protoclean, [name]));
                }), proto = newProto;
              }
            }

            this._wall.send({
              type: "callback",
              id: callback,
              args: [result, cleaned, proto, protoclean]
            });
          }
        }]), Bridge;
      }();

      module.exports = Bridge;
    }, function (module, exports, __webpack_require__) {
      "use strict";

      var _Symbol = __webpack_require__(9);

      module.exports = {
        name: _Symbol("name"),
        type: _Symbol("type"),
        inspected: _Symbol("inspected"),
        meta: _Symbol("meta"),
        proto: _Symbol("proto")
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      module.exports = __webpack_require__(10)() ? Symbol : __webpack_require__(11);
    }, function (module, exports) {
      "use strict";

      module.exports = function () {
        var symbol;
        if ("function" != typeof Symbol) return !1;
        symbol = Symbol("test symbol");

        try {
          String(symbol);
        } catch (e) {
          return !1;
        }

        return "symbol" == typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") || "object" == typeof (typeof Symbol === "function" ? Symbol.isConcatSpreadable : "@@isConcatSpreadable") && "object" == typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") && "object" == typeof (typeof Symbol === "function" ? Symbol.toPrimitive : "@@toPrimitive") && "object" == typeof (typeof Symbol === "function" ? Symbol.toStringTag : "@@toStringTag") && "object" == typeof (typeof Symbol === "function" ? Symbol.unscopables : "@@unscopables");
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      var NativeSymbol,
          SymbolPolyfill,
          _HiddenSymbol,
          d = __webpack_require__(12),
          validateSymbol = __webpack_require__(25),
          create = Object.create,
          defineProperties = Object.defineProperties,
          defineProperty = Object.defineProperty,
          objPrototype = Object.prototype,
          globalSymbols = create(null);

      "function" == typeof Symbol && (NativeSymbol = Symbol);

      var generateName = function () {
        var created = create(null);
        return function (desc) {
          for (var name, ie11BugWorkaround, postfix = 0; created[desc + (postfix || "")];) {
            ++postfix;
          }

          return desc += postfix || "", created[desc] = !0, name = "@@" + desc, defineProperty(objPrototype, name, d.gs(null, function (value) {
            ie11BugWorkaround || (ie11BugWorkaround = !0, defineProperty(this, name, d(value)), ie11BugWorkaround = !1);
          })), name;
        };
      }();

      _HiddenSymbol = function HiddenSymbol(description) {
        if (this instanceof _HiddenSymbol) throw new TypeError("TypeError: Symbol is not a constructor");
        return SymbolPolyfill(description);
      }, module.exports = SymbolPolyfill = function Symbol(description) {
        var symbol;
        if (this instanceof Symbol) throw new TypeError("TypeError: Symbol is not a constructor");
        return symbol = create(_HiddenSymbol.prototype), description = void 0 === description ? "" : String(description), defineProperties(symbol, {
          __description__: d("", description),
          __name__: d("", generateName(description))
        });
      }, defineProperties(SymbolPolyfill, {
        "for": d(function (key) {
          return globalSymbols[key] ? globalSymbols[key] : globalSymbols[key] = SymbolPolyfill(String(key));
        }),
        keyFor: d(function (s) {
          var key;
          validateSymbol(s);

          for (key in globalSymbols) {
            if (globalSymbols[key] === s) return key;
          }
        }),
        hasInstance: d("", NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill("hasInstance")),
        isConcatSpreadable: d("", NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill("isConcatSpreadable")),
        iterator: d("", NativeSymbol && NativeSymbol.iterator || SymbolPolyfill("iterator")),
        match: d("", NativeSymbol && NativeSymbol.match || SymbolPolyfill("match")),
        replace: d("", NativeSymbol && NativeSymbol.replace || SymbolPolyfill("replace")),
        search: d("", NativeSymbol && NativeSymbol.search || SymbolPolyfill("search")),
        species: d("", NativeSymbol && NativeSymbol.species || SymbolPolyfill("species")),
        split: d("", NativeSymbol && NativeSymbol.split || SymbolPolyfill("split")),
        toPrimitive: d("", NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill("toPrimitive")),
        toStringTag: d("", NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill("toStringTag")),
        unscopables: d("", NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill("unscopables"))
      }), defineProperties(_HiddenSymbol.prototype, {
        constructor: d(SymbolPolyfill),
        toString: d("", function () {
          return this.__name__;
        })
      }), defineProperties(SymbolPolyfill.prototype, {
        toString: d(function () {
          return "Symbol (" + validateSymbol(this).__description__ + ")";
        }),
        valueOf: d(function () {
          return validateSymbol(this);
        })
      }), defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d("", function () {
        return validateSymbol(this);
      })), defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d("c", "Symbol")), defineProperty(_HiddenSymbol.prototype, SymbolPolyfill.toStringTag, d("c", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])), defineProperty(_HiddenSymbol.prototype, SymbolPolyfill.toPrimitive, d("c", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));
    }, function (module, exports, __webpack_require__) {
      "use strict";

      var d,
          assign = __webpack_require__(13),
          normalizeOpts = __webpack_require__(20),
          isCallable = __webpack_require__(21),
          contains = __webpack_require__(22);

      d = module.exports = function (dscr, value) {
        var c, e, w, options, desc;
        return arguments.length < 2 || "string" != typeof dscr ? (options = value, value = dscr, dscr = null) : options = arguments[2], null == dscr ? (c = w = !0, e = !1) : (c = contains.call(dscr, "c"), e = contains.call(dscr, "e"), w = contains.call(dscr, "w")), desc = {
          value: value,
          configurable: c,
          enumerable: e,
          writable: w
        }, options ? assign(normalizeOpts(options), desc) : desc;
      }, d.gs = function (dscr, get, set) {
        var c, e, options, desc;
        return "string" != typeof dscr ? (options = set, set = get, get = dscr, dscr = null) : options = arguments[3], null == get ? get = void 0 : isCallable(get) ? null == set ? set = void 0 : isCallable(set) || (options = set, set = void 0) : (options = get, get = set = void 0), null == dscr ? (c = !0, e = !1) : (c = contains.call(dscr, "c"), e = contains.call(dscr, "e")), desc = {
          get: get,
          set: set,
          configurable: c,
          enumerable: e
        }, options ? assign(normalizeOpts(options), desc) : desc;
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      module.exports = __webpack_require__(14)() ? Object.assign : __webpack_require__(15);
    }, function (module, exports) {
      "use strict";

      module.exports = function () {
        var obj,
            assign = Object.assign;
        return "function" == typeof assign && (obj = {
          foo: "raz"
        }, assign(obj, {
          bar: "dwa"
        }, {
          trzy: "trzy"
        }), obj.foo + obj.bar + obj.trzy === "razdwatrzy");
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      var keys = __webpack_require__(16),
          value = __webpack_require__(19),
          max = Math.max;

      module.exports = function (dest, src) {
        var error,
            i,
            assign,
            l = max(arguments.length, 2);

        for (dest = Object(value(dest)), assign = function assign(key) {
          try {
            dest[key] = src[key];
          } catch (e) {
            error || (error = e);
          }
        }, i = 1; i < l; ++i) {
          src = arguments[i], keys(src).forEach(assign);
        }

        if (void 0 !== error) throw error;
        return dest;
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      module.exports = __webpack_require__(17)() ? Object.keys : __webpack_require__(18);
    }, function (module, exports) {
      "use strict";

      module.exports = function () {
        try {
          return Object.keys("primitive"), !0;
        } catch (e) {
          return !1;
        }
      };
    }, function (module, exports) {
      "use strict";

      var keys = Object.keys;

      module.exports = function (object) {
        return keys(null == object ? object : Object(object));
      };
    }, function (module, exports) {
      "use strict";

      module.exports = function (value) {
        if (null == value) throw new TypeError("Cannot use null or undefined");
        return value;
      };
    }, function (module, exports) {
      "use strict";

      var forEach = Array.prototype.forEach,
          create = Object.create,
          process = function process(src, obj) {
        var key;

        for (key in src) {
          obj[key] = src[key];
        }
      };

      module.exports = function (options) {
        var result = create(null);
        return forEach.call(arguments, function (options) {
          null != options && process(Object(options), result);
        }), result;
      };
    }, function (module, exports) {
      "use strict";

      module.exports = function (obj) {
        return "function" == typeof obj;
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      module.exports = __webpack_require__(23)() ? String.prototype.contains : __webpack_require__(24);
    }, function (module, exports) {
      "use strict";

      var str = "razdwatrzy";

      module.exports = function () {
        return "function" == typeof str.contains && str.contains("dwa") === !0 && str.contains("foo") === !1;
      };
    }, function (module, exports) {
      "use strict";

      var indexOf = String.prototype.indexOf;

      module.exports = function (searchString) {
        return indexOf.call(this, searchString, arguments[1]) > -1;
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      var isSymbol = __webpack_require__(26);

      module.exports = function (value) {
        if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
        return value;
      };
    }, function (module, exports) {
      "use strict";

      module.exports = function (x) {
        return x && ("symbol" == typeof x || "Symbol" === x["@@toStringTag"]) || !1;
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      function hydrate(data, cleaned) {
        cleaned.forEach(function (path) {
          var last = path.pop(),
              obj = path.reduce(function (obj_, attr) {
            return obj_ ? obj_[attr] : null;
          }, data);

          if (obj && obj[last]) {
            var replace = {};
            replace[consts.name] = obj[last].name, replace[consts.type] = obj[last].type, replace[consts.meta] = obj[last].meta, replace[consts.inspected] = !1, obj[last] = replace;
          }
        });
      }

      var consts = __webpack_require__(8);

      module.exports = hydrate;
    }, function (module, exports) {
      "use strict";

      function getPropType(data) {
        if (!data) return null;
        var type = "undefined" == typeof data ? "undefined" : _typeof(data);

        if ("object" === type) {
          if (data._reactFragment) return "react_fragment";
          if (Array.isArray(data)) return "array";
          if (ArrayBuffer.isView(data)) return data instanceof DataView ? "data_view" : "typed_array";
          if (data instanceof ArrayBuffer) return "array_buffer";
          if ("function" == typeof data[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]) return "iterator";
          if ("[object Date]" === Object.prototype.toString.call(data)) return "date";
        }

        return type;
      }

      function createDehydrated(type, data, cleaned, path) {
        var meta = {};
        return "array" !== type && "typed_array" !== type || (meta.length = data.length), "iterator" !== type && "typed_array" !== type || (meta.readOnly = !0), cleaned.push(path), {
          type: type,
          meta: meta,
          name: data.constructor && "Object" !== data.constructor.name ? data.constructor.name : ""
        };
      }

      function dehydrate(data, cleaned) {
        var path = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [],
            level = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
            type = getPropType(data);

        switch (type) {
          case "function":
            return cleaned.push(path), {
              name: data.name,
              type: "function"
            };

          case "string":
            return data.length <= 500 ? data : data.slice(0, 500) + "...";

          case "symbol":
            return cleaned.push(path), {
              type: "symbol",
              name: data.toString()
            };

          case "react_fragment":
            return "A React Fragment";

          case "array_buffer":
          case "data_view":
            return cleaned.push(path), {
              type: type,
              name: "data_view" === type ? "DataView" : "ArrayBuffer",
              meta: {
                length: data.byteLength,
                uninspectable: !0
              }
            };

          case "array":
            return level > 2 ? createDehydrated(type, data, cleaned, path) : data.map(function (item, i) {
              return dehydrate(item, cleaned, path.concat([i]), level + 1);
            });

          case "typed_array":
          case "iterator":
            return createDehydrated(type, data, cleaned, path);

          case "date":
            return cleaned.push(path), {
              name: data.toString(),
              type: "date",
              meta: {
                uninspectable: !0
              }
            };

          case "object":
            if (level > 2 || data.constructor && "function" == typeof data.constructor && "Object" !== data.constructor.name) return createDehydrated(type, data, cleaned, path);
            var res = {};

            for (var name in data) {
              res[name] = dehydrate(data[name], cleaned, path.concat([name]), level + 1);
            }

            return res;

          default:
            return data;
        }
      }

      var _typeof = "function" == typeof Symbol && "symbol" == typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
      };

      module.exports = dehydrate;
    }, function (module, exports, __webpack_require__) {
      "use strict";

      var performanceNow,
          performance = __webpack_require__(30);

      performanceNow = performance.now ? function () {
        return performance.now();
      } : function () {
        return Date.now();
      }, module.exports = performanceNow;
    }, function (module, exports, __webpack_require__) {
      "use strict";

      var performance,
          ExecutionEnvironment = __webpack_require__(31);

      ExecutionEnvironment.canUseDOM && (performance = window.performance || window.msPerformance || window.webkitPerformance), module.exports = performance || {};
    }, function (module, exports) {
      "use strict";

      var canUseDOM = !("undefined" == typeof window || !window.document || !window.document.createElement),
          ExecutionEnvironment = {
        canUseDOM: canUseDOM,
        canUseWorkers: "undefined" != typeof Worker,
        canUseEventListeners: canUseDOM && !(!window.addEventListener && !window.attachEvent),
        canUseViewport: canUseDOM && !!window.screen,
        isInWorker: !canUseDOM
      };
      module.exports = ExecutionEnvironment;
    }, function (module, exports) {
      "use strict";

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
      }

      function init(agent) {
        return new ProfileCollector(agent);
      }

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
        };
      }(),
          _typeof = "function" == typeof Symbol && "symbol" == typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
      },
          hasNativePerformanceNow = "object" === ("undefined" == typeof performance ? "undefined" : _typeof(performance)) && "function" == typeof performance.now,
          now = hasNativePerformanceNow ? function () {
        return performance.now();
      } : function () {
        return Date.now();
      },
          ProfileCollector = function () {
        function ProfileCollector(agent) {
          var _this = this;

          _classCallCheck(this, ProfileCollector), this._committedNodes = new Set(), this._isRecording = !1, this._maxActualDuration = 0, this._recordingStartTime = 0, this._onIsRecording = function (isRecording) {
            _this._committedNodes = new Set(), _this._isRecording = isRecording, _this._recordingStartTime = isRecording ? now() : 0, isRecording && _this._agent.emit("clearSnapshots");
          }, this._onMountOrUpdate = function (data) {
            _this._isRecording && void 0 !== data.actualDuration && (_this._committedNodes.add(data.id), _this._maxActualDuration = Math.max(_this._maxActualDuration, data.actualDuration));
          }, this._onRootCommitted = function (id, internalInstance, data) {
            _this._isRecording && (_this._takeCommitSnapshotForRoot(id, data), _this._committedNodes = new Set(), _this._maxActualDuration = 0);
          }, this._onUnmount = function (id) {
            _this._committedNodes["delete"](id);
          }, this._agent = agent, agent.on("isRecording", this._onIsRecording), agent.on("mount", this._onMountOrUpdate), agent.on("rootCommitted", this._onRootCommitted), agent.on("unmount", this._onUnmount), agent.on("update", this._onMountOrUpdate);
        }

        return _createClass(ProfileCollector, [{
          key: "_takeCommitSnapshotForRoot",
          value: function value(id, data) {
            var _this2 = this,
                interactionsArray = null != data.memoizedInteractions ? Array.from(data.memoizedInteractions) : [],
                memoizedInteractions = interactionsArray.map(function (_ref) {
              var name = _ref.name,
                  timestamp = _ref.timestamp;
              return {
                name: name,
                timestamp: timestamp - _this2._recordingStartTime
              };
            }),
                storeSnapshot = {
              memoizedInteractions: memoizedInteractions,
              committedNodes: Array.from(this._committedNodes),
              commitTime: now() - this._recordingStartTime,
              duration: this._maxActualDuration,
              root: id
            };

            this._agent.emit("storeSnapshot", storeSnapshot);
          }
        }]), ProfileCollector;
      }();

      module.exports = {
        init: init
      };
    }, function (module, exports) {
      "use strict";

      function installGlobalHook(window) {
        function detectReactBuildType(renderer) {
          try {
            if ("string" == typeof renderer.version) return renderer.bundleType > 0 ? "development" : "production";
            var toString = Function.prototype.toString;

            if (renderer.Mount && renderer.Mount._renderNewRootComponent) {
              var renderRootCode = toString.call(renderer.Mount._renderNewRootComponent);
              return 0 !== renderRootCode.indexOf("function") ? "production" : renderRootCode.indexOf("storedMeasure") !== -1 ? "development" : renderRootCode.indexOf("should be a pure function") !== -1 ? renderRootCode.indexOf("NODE_ENV") !== -1 ? "development" : renderRootCode.indexOf("development") !== -1 ? "development" : renderRootCode.indexOf("true") !== -1 ? "development" : renderRootCode.indexOf("nextElement") !== -1 || renderRootCode.indexOf("nextComponent") !== -1 ? "unminified" : "development" : renderRootCode.indexOf("nextElement") !== -1 || renderRootCode.indexOf("nextComponent") !== -1 ? "unminified" : "outdated";
            }
          } catch (err) {}

          return "production";
        }

        if (!window.__REACT_DEVTOOLS_GLOBAL_HOOK__) {
          var hasDetectedBadDCE = !1,
              hook = {
            _renderers: {},
            helpers: {},
            checkDCE: function checkDCE(fn) {
              try {
                var toString = Function.prototype.toString,
                    code = toString.call(fn);
                code.indexOf("^_^") > -1 && (hasDetectedBadDCE = !0, setTimeout(function () {
                  throw new Error("React is running in production mode, but dead code elimination has not been applied. Read how to correctly configure React for production: https://fb.me/react-perf-use-the-production-build");
                }));
              } catch (err) {}
            },
            inject: function inject(renderer) {
              var id = Math.random().toString(16).slice(2);
              hook._renderers[id] = renderer;
              var reactBuildType = hasDetectedBadDCE ? "deadcode" : detectReactBuildType(renderer);
              return hook.emit("renderer", {
                id: id,
                renderer: renderer,
                reactBuildType: reactBuildType
              }), id;
            },
            _listeners: {},
            sub: function sub(evt, fn) {
              return hook.on(evt, fn), function () {
                return hook.off(evt, fn);
              };
            },
            on: function on(evt, fn) {
              hook._listeners[evt] || (hook._listeners[evt] = []), hook._listeners[evt].push(fn);
            },
            off: function off(evt, fn) {
              if (hook._listeners[evt]) {
                var ix = hook._listeners[evt].indexOf(fn);

                ix !== -1 && hook._listeners[evt].splice(ix, 1), hook._listeners[evt].length || (hook._listeners[evt] = null);
              }
            },
            emit: function emit(evt, data) {
              hook._listeners[evt] && hook._listeners[evt].map(function (fn) {
                return fn(data);
              });
            },
            supportsFiber: !0,
            _fiberRoots: {},
            getFiberRoots: function getFiberRoots(rendererID) {
              var roots = hook._fiberRoots;
              return roots[rendererID] || (roots[rendererID] = new Set()), roots[rendererID];
            },
            onCommitFiberUnmount: function onCommitFiberUnmount(rendererID, fiber) {
              hook.helpers[rendererID] && hook.helpers[rendererID].handleCommitFiberUnmount(fiber);
            },
            onCommitFiberRoot: function onCommitFiberRoot(rendererID, root) {
              var mountedRoots = hook.getFiberRoots(rendererID),
                  current = root.current,
                  isKnownRoot = mountedRoots.has(root),
                  isUnmounting = null == current.memoizedState || null == current.memoizedState.element;
              isKnownRoot || isUnmounting ? isKnownRoot && isUnmounting && mountedRoots["delete"](root) : mountedRoots.add(root), hook.helpers[rendererID] && hook.helpers[rendererID].handleCommitFiberRoot(root);
            }
          };
          Object.defineProperty(window, "__REACT_DEVTOOLS_GLOBAL_HOOK__", {
            value: hook
          });
        }
      }

      module.exports = installGlobalHook;
    }, function (module, exports) {
      "use strict";

      function installRelayHook(window) {
        function decorate(obj, attr, fn) {
          var old = obj[attr];

          obj[attr] = function () {
            var res = old.apply(this, arguments);
            return fn.apply(this, arguments), res;
          };
        }

        function emit(name, data) {
          _eventQueue.push({
            name: name,
            data: data
          }), _listener && _listener(name, data);
        }

        function setRequestListener(listener) {
          if (_listener) throw new Error("Relay Devtools: Called only call setRequestListener once.");
          return _listener = listener, _eventQueue.forEach(function (_ref) {
            var name = _ref.name,
                data = _ref.data;
            listener(name, data);
          }), function () {
            _listener = null;
          };
        }

        function recordRequest(type, start, request, requestNumber) {
          var id = Math.random().toString(16).substr(2);
          request.getPromise().then(function (response) {
            emit("relay:success", {
              id: id,
              end: performanceNow(),
              response: response.response
            });
          }, function (error) {
            emit("relay:failure", {
              id: id,
              end: performanceNow(),
              error: error
            });
          });

          for (var textChunks = [], text = request.getQueryString(); text.length > 0;) {
            textChunks.push(text.substr(0, TEXT_CHUNK_LENGTH)), text = text.substr(TEXT_CHUNK_LENGTH);
          }

          return {
            id: id,
            name: request.getDebugName(),
            requestNumber: requestNumber,
            start: start,
            text: textChunks,
            type: type,
            variables: request.getVariables()
          };
        }

        function instrumentRelayRequests(relayInternals) {
          var NetworkLayer = relayInternals.NetworkLayer;
          decorate(NetworkLayer, "sendMutation", function (mutation) {
            requestNumber++, emit("relay:pending", [recordRequest("mutation", performanceNow(), mutation, requestNumber)]);
          }), decorate(NetworkLayer, "sendQueries", function (queries) {
            requestNumber++;
            var start = performanceNow();
            emit("relay:pending", queries.map(function (query) {
              return recordRequest("query", start, query, requestNumber);
            }));
          });
          var instrumented = {};

          for (var key in relayInternals) {
            relayInternals.hasOwnProperty(key) && (instrumented[key] = relayInternals[key]);
          }

          return instrumented.setRequestListener = setRequestListener, instrumented;
        }

        var performanceNow,
            performance = window.performance;
        performanceNow = performance && "function" == typeof performance.now ? function () {
          return performance.now();
        } : function () {
          return Date.now();
        };
        var TEXT_CHUNK_LENGTH = 500,
            hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;

        if (hook) {
          var _eventQueue = [],
              _listener = null,
              requestNumber = 0,
              _relayInternals = null;
          Object.defineProperty(hook, "_relayInternals", {
            configurable: !0,
            set: function set(relayInternals) {
              _relayInternals = instrumentRelayRequests(relayInternals);
            },
            get: function get() {
              return _relayInternals;
            }
          });
        }
      }

      module.exports = installRelayHook;
    }, function (module, exports, __webpack_require__) {
      "use strict";

      var setupBackend = __webpack_require__(36);

      module.exports = function (hook, agent) {
        var subs = [hook.sub("renderer-attached", function (_ref) {
          var id = _ref.id,
              helpers = (_ref.renderer, _ref.helpers);
          agent.setReactInternals(id, helpers), helpers.walkTree(agent.onMounted.bind(agent, id), agent.addRoot.bind(agent, id));
        }), hook.sub("mount", function (_ref2) {
          var renderer = _ref2.renderer,
              internalInstance = _ref2.internalInstance,
              data = _ref2.data;
          return agent.onMounted(renderer, internalInstance, data);
        }), hook.sub("unmount", function (_ref3) {
          var internalInstance = (_ref3.renderer, _ref3.internalInstance);
          return agent.onUnmounted(internalInstance);
        }), hook.sub("update", function (_ref4) {
          var internalInstance = (_ref4.renderer, _ref4.internalInstance),
              data = _ref4.data;
          return agent.onUpdated(internalInstance, data);
        }), hook.sub("root", function (_ref5) {
          var renderer = _ref5.renderer,
              internalInstance = _ref5.internalInstance;
          return agent.addRoot(renderer, internalInstance);
        }), hook.sub("rootCommitted", function (_ref6) {
          var renderer = _ref6.renderer,
              internalInstance = _ref6.internalInstance,
              data = _ref6.data;
          return agent.rootCommitted(renderer, internalInstance, data);
        }), hook.sub("updateProfileTimes", function (_ref7) {
          var internalInstance = (_ref7.renderer, _ref7.internalInstance),
              data = _ref7.data;
          return agent.onUpdatedProfileTimes(internalInstance, data);
        })],
            success = setupBackend(hook);
        success && (hook.emit("react-devtools", agent), hook.reactDevtoolsAgent = agent, agent.on("shutdown", function () {
          subs.forEach(function (fn) {
            return fn();
          }), hook.reactDevtoolsAgent = null;
        }));
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      var attachRenderer = __webpack_require__(37);

      module.exports = function (hook) {
        var oldReact = window.React && window.React.__internals;
        oldReact && 0 === Object.keys(hook._renderers).length && hook.inject(oldReact);

        for (var rid in hook._renderers) {
          hook.helpers[rid] = attachRenderer(hook, rid, hook._renderers[rid]), hook.emit("renderer-attached", {
            id: rid,
            renderer: hook._renderers[rid],
            helpers: hook.helpers[rid]
          });
        }

        hook.on("renderer", function (_ref) {
          var id = _ref.id,
              renderer = _ref.renderer;
          hook.helpers[id] = attachRenderer(hook, id, renderer), hook.emit("renderer-attached", {
            id: id,
            renderer: renderer,
            helpers: hook.helpers[id]
          });
        });

        var shutdown = function shutdown() {
          for (var id in hook.helpers) {
            hook.helpers[id].cleanup();
          }

          hook.off("shutdown", shutdown);
        };

        return hook.on("shutdown", shutdown), !0;
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      function attachRenderer(hook, rid, renderer) {
        var rootNodeIDMap = new Map(),
            extras = {},
            isPre013 = !renderer.Reconciler;
        if ("function" == typeof renderer.findFiberByHostInstance) return attachRendererFiber(hook, rid, renderer);
        renderer.Mount.findNodeHandle && renderer.Mount.nativeTagToRootNodeID ? (extras.getNativeFromReactElement = function (component) {
          return renderer.Mount.findNodeHandle(component);
        }, extras.getReactElementFromNative = function (nativeTag) {
          var id = renderer.Mount.nativeTagToRootNodeID(nativeTag);
          return rootNodeIDMap.get(id);
        }) : renderer.ComponentTree ? (extras.getNativeFromReactElement = function (component) {
          return renderer.ComponentTree.getNodeFromInstance(component);
        }, extras.getReactElementFromNative = function (node) {
          return renderer.ComponentTree.getClosestInstanceFromNode(node);
        }) : renderer.Mount.getID && renderer.Mount.getNode ? (extras.getNativeFromReactElement = function (component) {
          try {
            return renderer.Mount.getNode(component._rootNodeID);
          } catch (e) {
            return;
          }
        }, extras.getReactElementFromNative = function (node) {
          for (var id = renderer.Mount.getID(node); node && node.parentNode && !id;) {
            node = node.parentNode, id = renderer.Mount.getID(node);
          }

          return rootNodeIDMap.get(id);
        }) : console.warn("Unknown react version (does not have getID), probably an unshimmed React Native");
        var oldMethods, oldRenderComponent, oldRenderRoot;
        return renderer.Mount._renderNewRootComponent ? oldRenderRoot = decorateResult(renderer.Mount, "_renderNewRootComponent", function (internalInstance) {
          hook.emit("root", {
            renderer: rid,
            internalInstance: internalInstance
          });
        }) : renderer.Mount.renderComponent && (oldRenderComponent = decorateResult(renderer.Mount, "renderComponent", function (internalInstance) {
          hook.emit("root", {
            renderer: rid,
            internalInstance: internalInstance._reactInternalInstance
          });
        })), renderer.Component ? (console.error("You are using a version of React with limited support in this version of the devtools.\nPlease upgrade to use at least 0.13, or you can downgrade to use the old version of the devtools:\ninstructions here https://github.com/facebook/react-devtools/tree/devtools-next#how-do-i-use-this-for-react--013"), oldMethods = decorateMany(renderer.Component.Mixin, {
          mountComponent: function mountComponent() {
            var _this = this;

            rootNodeIDMap.set(this._rootNodeID, this), setTimeout(function () {
              hook.emit("mount", {
                internalInstance: _this,
                data: getData012(_this),
                renderer: rid
              });
            }, 0);
          },
          updateComponent: function updateComponent() {
            var _this2 = this;

            setTimeout(function () {
              hook.emit("update", {
                internalInstance: _this2,
                data: getData012(_this2),
                renderer: rid
              });
            }, 0);
          },
          unmountComponent: function unmountComponent() {
            hook.emit("unmount", {
              internalInstance: this,
              renderer: rid
            }), rootNodeIDMap["delete"](this._rootNodeID);
          }
        })) : renderer.Reconciler && (oldMethods = decorateMany(renderer.Reconciler, {
          mountComponent: function mountComponent(internalInstance, rootID, transaction, context) {
            var data = getData(internalInstance);
            rootNodeIDMap.set(internalInstance._rootNodeID, internalInstance), hook.emit("mount", {
              internalInstance: internalInstance,
              data: data,
              renderer: rid
            });
          },
          performUpdateIfNecessary: function performUpdateIfNecessary(internalInstance, nextChild, transaction, context) {
            hook.emit("update", {
              internalInstance: internalInstance,
              data: getData(internalInstance),
              renderer: rid
            });
          },
          receiveComponent: function receiveComponent(internalInstance, nextChild, transaction, context) {
            hook.emit("update", {
              internalInstance: internalInstance,
              data: getData(internalInstance),
              renderer: rid
            });
          },
          unmountComponent: function unmountComponent(internalInstance) {
            hook.emit("unmount", {
              internalInstance: internalInstance,
              renderer: rid
            }), rootNodeIDMap["delete"](internalInstance._rootNodeID);
          }
        })), extras.walkTree = function (visit, visitRoot) {
          var onMount = function onMount(component, data) {
            rootNodeIDMap.set(component._rootNodeID, component), visit(component, data);
          };

          walkRoots(renderer.Mount._instancesByReactRootID || renderer.Mount._instancesByContainerID, onMount, visitRoot, isPre013);
        }, extras.cleanup = function () {
          oldMethods && (renderer.Component ? restoreMany(renderer.Component.Mixin, oldMethods) : restoreMany(renderer.Reconciler, oldMethods)), oldRenderRoot && (renderer.Mount._renderNewRootComponent = oldRenderRoot), oldRenderComponent && (renderer.Mount.renderComponent = oldRenderComponent), oldMethods = null, oldRenderRoot = null, oldRenderComponent = null;
        }, extras;
      }

      function walkRoots(roots, onMount, onRoot, isPre013) {
        for (var name in roots) {
          walkNode(roots[name], onMount, isPre013), onRoot(roots[name]);
        }
      }

      function walkNode(internalInstance, onMount, isPre013) {
        var data = isPre013 ? getData012(internalInstance) : getData(internalInstance);
        data.children && Array.isArray(data.children) && data.children.forEach(function (child) {
          return walkNode(child, onMount, isPre013);
        }), onMount(internalInstance, data);
      }

      function decorateResult(obj, attr, fn) {
        var old = obj[attr];
        return obj[attr] = function (instance) {
          var res = old.apply(this, arguments);
          return fn(res), res;
        }, old;
      }

      function decorate(obj, attr, fn) {
        var old = obj[attr];
        return obj[attr] = function (instance) {
          var res = old.apply(this, arguments);
          return fn.apply(this, arguments), res;
        }, old;
      }

      function decorateMany(source, fns) {
        var olds = {};

        for (var name in fns) {
          olds[name] = decorate(source, name, fns[name]);
        }

        return olds;
      }

      function restoreMany(source, olds) {
        for (var name in olds) {
          source[name] = olds[name];
        }
      }

      var getData = __webpack_require__(38),
          getData012 = __webpack_require__(43),
          attachRendererFiber = __webpack_require__(44);

      module.exports = attachRenderer;
    }, function (module, exports, __webpack_require__) {
      "use strict";

      function getData(internalInstance) {
        var children = null,
            props = null,
            state = null,
            context = null,
            updater = null,
            name = null,
            type = null,
            key = null,
            ref = null,
            source = null,
            text = null,
            publicInstance = null,
            nodeType = "Native";
        if ("object" !== ("undefined" == typeof internalInstance ? "undefined" : _typeof(internalInstance))) nodeType = "Text", text = internalInstance + "";else if (null === internalInstance._currentElement || internalInstance._currentElement === !1) nodeType = "Empty";else if (internalInstance._renderedComponent) nodeType = "NativeWrapper", children = [internalInstance._renderedComponent], props = internalInstance._instance.props, state = internalInstance._instance.state, context = internalInstance._instance.context, context && 0 === Object.keys(context).length && (context = null);else if (internalInstance._renderedChildren) children = childrenList(internalInstance._renderedChildren);else if (internalInstance._currentElement && internalInstance._currentElement.props) {
          var unfilteredChildren = internalInstance._currentElement.props.children,
              filteredChildren = [];
          traverseAllChildrenImpl(unfilteredChildren, "", function (_traverseContext, child) {
            var childType = "undefined" == typeof child ? "undefined" : _typeof(child);
            "string" !== childType && "number" !== childType || filteredChildren.push(child);
          }), children = filteredChildren.length <= 1 ? filteredChildren.length ? String(filteredChildren[0]) : void 0 : filteredChildren;
        }

        if (!props && internalInstance._currentElement && internalInstance._currentElement.props && (props = internalInstance._currentElement.props), null != internalInstance._currentElement && (type = internalInstance._currentElement.type, internalInstance._currentElement.key && (key = String(internalInstance._currentElement.key)), source = internalInstance._currentElement._source, ref = internalInstance._currentElement.ref, "string" == typeof type ? (name = type, null != internalInstance._nativeNode && (publicInstance = internalInstance._nativeNode), null != internalInstance._hostNode && (publicInstance = internalInstance._hostNode)) : "function" == typeof type ? (nodeType = "Composite", name = getDisplayName(type), internalInstance._renderedComponent && (internalInstance._currentElement.props === internalInstance._renderedComponent._currentElement || internalInstance._currentElement.type.isReactTopLevelWrapper) && (nodeType = "Wrapper"), null === name && (name = "No display name")) : "string" == typeof internalInstance._stringText ? (nodeType = "Text", text = internalInstance._stringText) : name = getDisplayName(type)), internalInstance._instance) {
          var inst = internalInstance._instance,
              forceUpdate = inst.forceUpdate || inst.updater && inst.updater.enqueueForceUpdate && function (cb) {
            inst.updater.enqueueForceUpdate(this, cb, "forceUpdate");
          };

          updater = {
            setState: inst.setState && inst.setState.bind(inst),
            forceUpdate: forceUpdate && forceUpdate.bind(inst),
            setInProps: forceUpdate && setInProps.bind(null, internalInstance, forceUpdate),
            setInState: inst.forceUpdate && setInState.bind(null, inst),
            setInContext: forceUpdate && setInContext.bind(null, inst, forceUpdate)
          }, "function" == typeof type && (publicInstance = inst), inst._renderedChildren && (children = childrenList(inst._renderedChildren));
        }

        return "function" == typeof internalInstance.setNativeProps && (updater = {
          setNativeProps: function setNativeProps(nativeProps) {
            internalInstance.setNativeProps(nativeProps);
          }
        }), {
          nodeType: nodeType,
          type: type,
          key: key,
          ref: ref,
          source: source,
          name: name,
          props: props,
          state: state,
          context: context,
          children: children,
          text: text,
          updater: updater,
          publicInstance: publicInstance
        };
      }

      function setInProps(internalInst, forceUpdate, path, value) {
        var element = internalInst._currentElement;
        internalInst._currentElement = _extends({}, element, {
          props: copyWithSet(element.props, path, value)
        }), forceUpdate.call(internalInst._instance);
      }

      function setInState(inst, path, value) {
        setIn(inst.state, path, value), inst.forceUpdate();
      }

      function setInContext(inst, forceUpdate, path, value) {
        setIn(inst.context, path, value), forceUpdate.call(inst);
      }

      function setIn(obj, path, value) {
        var last = path.pop(),
            parent = path.reduce(function (obj_, attr) {
          return obj_ ? obj_[attr] : null;
        }, obj);
        parent && (parent[last] = value);
      }

      function childrenList(children) {
        var res = [];

        for (var name in children) {
          res.push(children[name]);
        }

        return res;
      }

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
          }
        }

        return target;
      },
          _typeof = "function" == typeof Symbol && "symbol" == typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
      },
          copyWithSet = __webpack_require__(39),
          getDisplayName = __webpack_require__(40),
          traverseAllChildrenImpl = __webpack_require__(41);

      module.exports = getData;
    }, function (module, exports) {
      "use strict";

      function copyWithSetImpl(obj, path, idx, value) {
        if (idx >= path.length) return value;
        var key = path[idx],
            updated = Array.isArray(obj) ? obj.slice() : _extends({}, obj);
        return updated[key] = copyWithSetImpl(obj[key], path, idx + 1, value), updated;
      }

      function copyWithSet(obj, path, value) {
        return copyWithSetImpl(obj, path, 0, value);
      }

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
          }
        }

        return target;
      };

      module.exports = copyWithSet;
    }, function (module, exports) {
      "use strict";

      function getDisplayName(type) {
        var fallbackName = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "Unknown",
            nameFromCache = cachedDisplayNames.get(type);
        if (null != nameFromCache) return nameFromCache;
        var displayName = void 0;
        "string" == typeof type.displayName && (displayName = type.displayName), displayName || (displayName = type.name || fallbackName);
        var match = displayName.match(FB_MODULE_RE);

        if (match) {
          var componentName = match[1],
              moduleName = match[2];
          componentName && moduleName && (moduleName === componentName || moduleName.startsWith(componentName + ".")) && (displayName = componentName);
        }

        return cachedDisplayNames.set(type, displayName), displayName;
      }

      var FB_MODULE_RE = /^(.*) \[from (.*)\]$/,
          cachedDisplayNames = new WeakMap();
      module.exports = getDisplayName;
    }, function (module, exports, __webpack_require__) {
      "use strict";

      function escape(key) {
        var escapeRegex = /[=:]/g,
            escaperLookup = {
          "=": "=0",
          ":": "=2"
        },
            escapedString = ("" + key).replace(escapeRegex, function (match) {
          return escaperLookup[match];
        });
        return "$" + escapedString;
      }

      function getComponentKey(component, index) {
        return "object" === ("undefined" == typeof component ? "undefined" : _typeof(component)) && null !== component && null != component.key ? escape(component.key) : index.toString(36);
      }

      function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
        var type = "undefined" == typeof children ? "undefined" : _typeof(children);
        if ("undefined" !== type && "boolean" !== type || (children = null), null === children || "string" === type || "number" === type || "object" === type && children.$$typeof === REACT_ELEMENT_TYPE) return callback(traverseContext, children, "" === nameSoFar ? SEPARATOR + getComponentKey(children, 0) : nameSoFar), 1;
        var child,
            nextName,
            subtreeCount = 0,
            nextNamePrefix = "" === nameSoFar ? SEPARATOR : nameSoFar + SUBSEPARATOR;
        if (Array.isArray(children)) for (var i = 0; i < children.length; i++) {
          child = children[i], nextName = nextNamePrefix + getComponentKey(child, i), subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        } else {
          var iteratorFn = ITERATOR_SYMBOL && children[ITERATOR_SYMBOL] || children[FAUX_ITERATOR_SYMBOL];
          if ("function" == typeof iteratorFn) for (var step, iterator = iteratorFn.call(children), ii = 0; !(step = iterator.next()).done;) {
            child = step.value, nextName = nextNamePrefix + getComponentKey(child, ii++), subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          } else if ("object" === type) {
            var addendum = " If you meant to render a collection of children, use an array instead.",
                childrenString = "" + children;
            invariant(!1, "The React Devtools cannot render an object as a child. (found: %s).%s", "[object Object]" === childrenString ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString, addendum);
          }
        }
        return subtreeCount;
      }

      var _typeof = "function" == typeof Symbol && "symbol" == typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
      },
          invariant = __webpack_require__(42),
          SEPARATOR = ".",
          SUBSEPARATOR = ":",
          FAUX_ITERATOR_SYMBOL = "@@iterator",
          ITERATOR_SYMBOL = "function" == typeof Symbol && (typeof Symbol === "function" ? Symbol.iterator : "@@iterator"),
          REACT_ELEMENT_TYPE = "function" == typeof Symbol && Symbol["for"] && Symbol["for"]("react.element") || 60103;

      module.exports = traverseAllChildrenImpl;
    }, function (module, exports, __webpack_require__) {
      "use strict";

      function invariant(condition, format, a, b, c, d, e, f) {
        if (!condition) {
          var error;
          if (void 0 === format) error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else {
            var args = [a, b, c, d, e, f],
                argIndex = 0;
            error = new Error(format.replace(/%s/g, function () {
              return args[argIndex++];
            })), error.name = "Invariant Violation";
          }
          throw error.framesToPop = 1, error;
        }
      }

      module.exports = invariant;
    }, function (module, exports, __webpack_require__) {
      "use strict";

      function getData012(internalInstance) {
        var children = null,
            props = internalInstance.props,
            state = internalInstance.state,
            context = internalInstance.context,
            updater = null,
            name = null,
            type = null,
            key = null,
            ref = null,
            text = null,
            publicInstance = null,
            nodeType = "Native";
        return internalInstance._renderedComponent ? (nodeType = "Wrapper", children = [internalInstance._renderedComponent], context && 0 === Object.keys(context).length && (context = null)) : internalInstance._renderedChildren ? (name = internalInstance.constructor.displayName, children = childrenList(internalInstance._renderedChildren)) : "string" == typeof props.children && (name = internalInstance.constructor.displayName, children = props.children, nodeType = "Native"), !props && internalInstance._currentElement && internalInstance._currentElement.props && (props = internalInstance._currentElement.props), internalInstance._currentElement && (type = internalInstance._currentElement.type, internalInstance._currentElement.key && (key = String(internalInstance._currentElement.key)), ref = internalInstance._currentElement.ref, "string" == typeof type ? name = type : (nodeType = "Composite", name = type.displayName, name || (name = "No display name"))), name || (name = internalInstance.constructor.displayName || "No display name", nodeType = "Composite"), "string" == typeof props && (nodeType = "Text", text = props, props = null, name = null), internalInstance.forceUpdate && (updater = {
          setState: internalInstance.setState.bind(internalInstance),
          forceUpdate: internalInstance.forceUpdate.bind(internalInstance),
          setInProps: internalInstance.forceUpdate && setInProps.bind(null, internalInstance),
          setInState: internalInstance.forceUpdate && setInState.bind(null, internalInstance),
          setInContext: internalInstance.forceUpdate && setInContext.bind(null, internalInstance)
        }, publicInstance = internalInstance), {
          nodeType: nodeType,
          type: type,
          key: key,
          ref: ref,
          source: null,
          name: name,
          props: props,
          state: state,
          context: context,
          children: children,
          text: text,
          updater: updater,
          publicInstance: publicInstance
        };
      }

      function setInProps(inst, path, value) {
        inst.props = copyWithSet(inst.props, path, value), inst.forceUpdate();
      }

      function setInState(inst, path, value) {
        setIn(inst.state, path, value), inst.forceUpdate();
      }

      function setInContext(inst, path, value) {
        setIn(inst.context, path, value), inst.forceUpdate();
      }

      function setIn(obj, path, value) {
        var last = path.pop(),
            parent = path.reduce(function (obj_, attr) {
          return obj_ ? obj_[attr] : null;
        }, obj);
        parent && (parent[last] = value);
      }

      function childrenList(children) {
        var res = [];

        for (var name in children) {
          res.push(children[name]);
        }

        return res;
      }

      var copyWithSet = __webpack_require__(39);

      module.exports = getData012;
    }, function (module, exports, __webpack_require__) {
      "use strict";

      function getInternalReactConstants(version) {
        var ReactTypeOfWork, ReactSymbols, ReactTypeOfSideEffect;
        return ReactTypeOfWork = semver.gte(version, "16.6.0-beta.0") ? {
          ClassComponent: 1,
          ContextConsumer: 9,
          ContextProvider: 10,
          CoroutineComponent: -1,
          CoroutineHandlerPhase: -1,
          ForwardRef: 11,
          Fragment: 7,
          FunctionalComponent: 0,
          HostComponent: 5,
          HostPortal: 4,
          HostRoot: 3,
          HostText: 6,
          IndeterminateComponent: 2,
          LazyComponent: 16,
          MemoComponent: 14,
          Mode: 8,
          Profiler: 12,
          SimpleMemoComponent: 15,
          SuspenseComponent: 13,
          YieldComponent: -1
        } : semver.gte(version, "16.4.3-alpha") ? {
          ClassComponent: 2,
          ContextConsumer: 11,
          ContextProvider: 12,
          CoroutineComponent: -1,
          CoroutineHandlerPhase: -1,
          ForwardRef: 13,
          Fragment: 9,
          FunctionalComponent: 0,
          HostComponent: 7,
          HostPortal: 6,
          HostRoot: 5,
          HostText: 8,
          IndeterminateComponent: 4,
          LazyComponent: -1,
          MemoComponent: -1,
          Mode: 10,
          Profiler: 15,
          SimpleMemoComponent: -1,
          SuspenseComponent: 16,
          YieldComponent: -1
        } : {
          ClassComponent: 2,
          ContextConsumer: 12,
          ContextProvider: 13,
          CoroutineComponent: 7,
          CoroutineHandlerPhase: 8,
          ForwardRef: 14,
          Fragment: 10,
          FunctionalComponent: 1,
          HostComponent: 5,
          HostPortal: 4,
          HostRoot: 3,
          HostText: 6,
          IndeterminateComponent: 0,
          LazyComponent: -1,
          MemoComponent: -1,
          Mode: 11,
          Profiler: 15,
          SimpleMemoComponent: -1,
          SuspenseComponent: 16,
          YieldComponent: 9
        }, ReactSymbols = {
          CONCURRENT_MODE_NUMBER: 60111,
          CONCURRENT_MODE_SYMBOL_STRING: "Symbol(react.concurrent_mode)",
          DEPRECATED_ASYNC_MODE_SYMBOL_STRING: "Symbol(react.async_mode)",
          CONTEXT_CONSUMER_NUMBER: 60110,
          CONTEXT_CONSUMER_SYMBOL_STRING: "Symbol(react.context)",
          CONTEXT_PROVIDER_NUMBER: 60109,
          CONTEXT_PROVIDER_SYMBOL_STRING: "Symbol(react.provider)",
          FORWARD_REF_NUMBER: 60112,
          FORWARD_REF_SYMBOL_STRING: "Symbol(react.forward_ref)",
          PROFILER_NUMBER: 60114,
          PROFILER_SYMBOL_STRING: "Symbol(react.profiler)",
          PURE_NUMBER: 60115,
          PURE_SYMBOL_STRING: "Symbol(react.pure)",
          STRICT_MODE_NUMBER: 60108,
          STRICT_MODE_SYMBOL_STRING: "Symbol(react.strict_mode)",
          SUSPENSE_NUMBER: 60113,
          SUSPENSE_SYMBOL_STRING: "Symbol(react.suspense)",
          DEPRECATED_PLACEHOLDER_SYMBOL_STRING: "Symbol(react.placeholder)"
        }, ReactTypeOfSideEffect = {
          PerformedWork: 1
        }, {
          ReactTypeOfWork: ReactTypeOfWork,
          ReactSymbols: ReactSymbols,
          ReactTypeOfSideEffect: ReactTypeOfSideEffect
        };
      }

      function attachRendererFiber(hook, rid, renderer) {
        function getDataFiber(fiber) {
          var type = fiber.type,
              key = fiber.key,
              ref = fiber.ref,
              source = fiber._debugSource,
              publicInstance = null,
              props = null,
              state = null,
              children = null,
              context = null,
              updater = null,
              nodeType = null,
              name = null,
              text = null,
              actualDuration = null,
              actualStartTime = null,
              treeBaseDuration = null,
              memoizedInteractions = null,
              resolvedType = type;

          switch ("object" === ("undefined" == typeof type ? "undefined" : _typeof(type)) && null !== type && "function" == typeof type.then && (resolvedType = type._reactResult), fiber.tag) {
            case FunctionalComponent:
            case ClassComponent:
              nodeType = "Composite", name = getDisplayName(resolvedType), publicInstance = fiber.stateNode, props = fiber.memoizedProps, state = fiber.memoizedState, null != publicInstance && (context = publicInstance.context, context && 0 === Object.keys(context).length && (context = null));
              var inst = publicInstance;
              inst && (updater = {
                setState: inst.setState && inst.setState.bind(inst),
                forceUpdate: inst.forceUpdate && inst.forceUpdate.bind(inst),
                setInProps: inst.forceUpdate && setInProps.bind(null, fiber),
                setInState: inst.forceUpdate && setInState.bind(null, inst),
                setInContext: inst.forceUpdate && setInContext.bind(null, inst)
              }), children = [];
              break;

            case ForwardRef:
              var functionName = getDisplayName(resolvedType.render, "");
              nodeType = "Special", name = resolvedType.displayName || ("" !== functionName ? "ForwardRef(" + functionName + ")" : "ForwardRef"), children = [];
              break;

            case HostRoot:
              nodeType = "Wrapper", children = [], memoizedInteractions = fiber.stateNode.memoizedInteractions;
              break;

            case HostPortal:
              nodeType = "Portal", name = "ReactPortal", props = {
                target: fiber.stateNode.containerInfo
              }, children = [];
              break;

            case HostComponent:
              nodeType = "Native", name = fiber.type, name = name.replace("topsecret-", ""), publicInstance = fiber.stateNode, props = fiber.memoizedProps, children = "string" == typeof props.children || "number" == typeof props.children ? props.children.toString() : [], "function" == typeof fiber.stateNode.setNativeProps && (updater = {
                setNativeProps: function setNativeProps(nativeProps) {
                  fiber.stateNode.setNativeProps(nativeProps);
                }
              });
              break;

            case HostText:
              nodeType = "Text", text = fiber.memoizedProps;
              break;

            case Fragment:
              nodeType = "Wrapper", children = [];
              break;

            default:
              var symbolOrNumber = "object" === ("undefined" == typeof type ? "undefined" : _typeof(type)) && null !== type ? type.$$typeof : type,
                  switchValue = "symbol" === ("undefined" == typeof symbolOrNumber ? "undefined" : _typeof(symbolOrNumber)) ? symbolOrNumber.toString() : symbolOrNumber;

              switch (switchValue) {
                case PURE_NUMBER:
                case PURE_SYMBOL_STRING:
                  if (nodeType = "Special", type.displayName) name = type.displayName;else {
                    var displayName = type.render.displayName || type.render.name;
                    name = displayName ? "Pure(" + displayName + ")" : "Pure";
                  }
                  children = [];
                  break;

                case CONCURRENT_MODE_NUMBER:
                case CONCURRENT_MODE_SYMBOL_STRING:
                case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:
                  nodeType = "Special", name = "ConcurrentMode", children = [];
                  break;

                case CONTEXT_PROVIDER_NUMBER:
                case CONTEXT_PROVIDER_SYMBOL_STRING:
                  nodeType = "Special", props = fiber.memoizedProps, name = (fiber.type._context.displayName || "Context") + ".Provider", children = [];
                  break;

                case CONTEXT_CONSUMER_NUMBER:
                case CONTEXT_CONSUMER_SYMBOL_STRING:
                  nodeType = "Special", props = fiber.memoizedProps, name = (fiber.type.displayName || "Context") + ".Consumer", children = [];
                  break;

                case STRICT_MODE_NUMBER:
                case STRICT_MODE_SYMBOL_STRING:
                  nodeType = "Special", name = "StrictMode", children = [];
                  break;

                case SUSPENSE_NUMBER:
                case SUSPENSE_SYMBOL_STRING:
                case DEPRECATED_PLACEHOLDER_SYMBOL_STRING:
                  nodeType = "Special", name = "Suspense", props = fiber.memoizedProps, children = [];
                  break;

                case PROFILER_NUMBER:
                case PROFILER_SYMBOL_STRING:
                  nodeType = "Special", props = fiber.memoizedProps, name = "Profiler(" + fiber.memoizedProps.id + ")", children = [];
                  break;

                default:
                  nodeType = "Native", props = fiber.memoizedProps, name = "TODO_NOT_IMPLEMENTED_YET", children = [];
              }

          }

          if (Array.isArray(children)) for (var child = fiber.child; child;) {
            children.push(getOpaqueNode(child)), child = child.sibling;
          }
          return void 0 !== fiber.actualDuration && (actualDuration = fiber.actualDuration, actualStartTime = fiber.actualStartTime, treeBaseDuration = fiber.treeBaseDuration), {
            nodeType: nodeType,
            type: type,
            key: key,
            ref: ref,
            source: source,
            name: name,
            props: props,
            state: state,
            context: context,
            children: children,
            text: text,
            updater: updater,
            publicInstance: publicInstance,
            memoizedInteractions: memoizedInteractions,
            actualDuration: actualDuration,
            actualStartTime: actualStartTime,
            treeBaseDuration: treeBaseDuration
          };
        }

        function setInProps(fiber, path, value) {
          var inst = fiber.stateNode;
          fiber.pendingProps = copyWithSet(inst.props, path, value), fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps), fiber.stateNode.forceUpdate();
        }

        function setInState(inst, path, value) {
          setIn(inst.state, path, value), inst.forceUpdate();
        }

        function setInContext(inst, path, value) {
          setIn(inst.context, path, value), inst.forceUpdate();
        }

        function setIn(obj, path, value) {
          var last = path.pop(),
              parent = path.reduce(function (obj_, attr) {
            return obj_ ? obj_[attr] : null;
          }, obj);
          parent && (parent[last] = value);
        }

        function getOpaqueNode(fiber) {
          if (opaqueNodes.has(fiber)) return fiber;
          var alternate = fiber.alternate;
          return null != alternate && opaqueNodes.has(alternate) ? alternate : (opaqueNodes.add(fiber), fiber);
        }

        function hasDataChanged(prevFiber, nextFiber) {
          switch (nextFiber.tag) {
            case ClassComponent:
            case FunctionalComponent:
            case ContextConsumer:
              return (nextFiber.effectTag & PerformedWork) === PerformedWork;

            default:
              return prevFiber.memoizedProps !== nextFiber.memoizedProps || prevFiber.memoizedState !== nextFiber.memoizedState || prevFiber.ref !== nextFiber.ref;
          }
        }

        function haveProfilerTimesChanged(prevFiber, nextFiber) {
          return void 0 !== prevFiber.actualDuration && (prevFiber.actualDuration !== nextFiber.actualDuration || prevFiber.actualStartTime !== nextFiber.actualStartTime || prevFiber.treeBaseDuration !== nextFiber.treeBaseDuration);
        }

        function flushPendingEvents() {
          var events = pendingEvents;
          pendingEvents = [];

          for (var i = 0; i < events.length; i++) {
            var event = events[i];
            hook.emit(event.type, event);
          }
        }

        function enqueueMount(fiber) {
          pendingEvents.push({
            internalInstance: getOpaqueNode(fiber),
            data: getDataFiber(fiber),
            renderer: rid,
            type: "mount"
          });
          var isRoot = fiber.tag === HostRoot;
          isRoot && pendingEvents.push({
            internalInstance: getOpaqueNode(fiber),
            renderer: rid,
            type: "root"
          });
        }

        function enqueueUpdateIfNecessary(fiber, hasChildOrderChanged) {
          return hasChildOrderChanged || hasDataChanged(fiber.alternate, fiber) ? void pendingEvents.push({
            internalInstance: getOpaqueNode(fiber),
            data: getDataFiber(fiber),
            renderer: rid,
            type: "update"
          }) : void (haveProfilerTimesChanged(fiber.alternate, fiber) && pendingEvents.push({
            internalInstance: getOpaqueNode(fiber),
            data: getDataFiber(fiber),
            renderer: rid,
            type: "updateProfileTimes"
          }));
        }

        function enqueueUnmount(fiber) {
          var isRoot = fiber.tag === HostRoot,
              opaqueNode = getOpaqueNode(fiber),
              event = {
            internalInstance: opaqueNode,
            renderer: rid,
            type: "unmount"
          };
          isRoot ? pendingEvents.push(event) : pendingEvents.unshift(event), opaqueNodes["delete"](opaqueNode);
        }

        function markRootCommitted(fiber) {
          pendingEvents.push({
            internalInstance: getOpaqueNode(fiber),
            data: getDataFiber(fiber),
            renderer: rid,
            type: "rootCommitted"
          });
        }

        function mountFiber(fiber) {
          var node = fiber;

          outer: for (;;) {
            if (node.child) node.child["return"] = node, node = node.child;else {
              if (enqueueMount(node), node == fiber) return;

              if (!node.sibling) {
                for (; node["return"];) {
                  if (node = node["return"], enqueueMount(node), node == fiber) return;

                  if (node.sibling) {
                    node.sibling["return"] = node["return"], node = node.sibling;
                    continue outer;
                  }
                }

                return;
              }

              node.sibling["return"] = node["return"], node = node.sibling;
            }
          }
        }

        function updateFiber(nextFiber, prevFiber) {
          var hasChildOrderChanged = !1;

          if (nextFiber.child !== prevFiber.child) {
            for (var nextChild = nextFiber.child, prevChildAtSameIndex = prevFiber.child; nextChild;) {
              if (nextChild.alternate) {
                var prevChild = nextChild.alternate;
                updateFiber(nextChild, prevChild), hasChildOrderChanged || prevChild === prevChildAtSameIndex || (hasChildOrderChanged = !0);
              } else mountFiber(nextChild), hasChildOrderChanged || (hasChildOrderChanged = !0);

              nextChild = nextChild.sibling, hasChildOrderChanged || null == prevChildAtSameIndex || (prevChildAtSameIndex = prevChildAtSameIndex.sibling);
            }

            hasChildOrderChanged || null == prevChildAtSameIndex || (hasChildOrderChanged = !0);
          }

          enqueueUpdateIfNecessary(nextFiber, hasChildOrderChanged);
        }

        function walkTree() {
          hook.getFiberRoots(rid).forEach(function (root) {
            mountFiber(root.current), markRootCommitted(root.current);
          }), flushPendingEvents();
        }

        function cleanup() {}

        function handleCommitFiberUnmount(fiber) {
          enqueueUnmount(fiber);
        }

        function handleCommitFiberRoot(root) {
          var current = root.current,
              alternate = current.alternate;

          if (alternate) {
            var wasMounted = null != alternate.memoizedState && null != alternate.memoizedState.element,
                isMounted = null != current.memoizedState && null != current.memoizedState.element;
            !wasMounted && isMounted ? mountFiber(current) : wasMounted && isMounted ? updateFiber(current, alternate) : wasMounted && !isMounted && enqueueUnmount(current);
          } else mountFiber(current);

          markRootCommitted(current), flushPendingEvents();
        }

        function getNativeFromReactElement(fiber) {
          try {
            var opaqueNode = fiber,
                hostInstance = renderer.findHostInstanceByFiber(opaqueNode);
            return hostInstance;
          } catch (err) {
            return null;
          }
        }

        function getReactElementFromNative(hostInstance) {
          var fiber = renderer.findFiberByHostInstance(hostInstance);

          if (null != fiber) {
            var opaqueNode = getOpaqueNode(fiber);
            return opaqueNode;
          }

          return null;
        }

        var _getInternalReactCons = getInternalReactConstants(renderer.version),
            ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork,
            ReactSymbols = _getInternalReactCons.ReactSymbols,
            ReactTypeOfSideEffect = _getInternalReactCons.ReactTypeOfSideEffect,
            PerformedWork = ReactTypeOfSideEffect.PerformedWork,
            FunctionalComponent = ReactTypeOfWork.FunctionalComponent,
            ClassComponent = ReactTypeOfWork.ClassComponent,
            ContextConsumer = ReactTypeOfWork.ContextConsumer,
            HostRoot = ReactTypeOfWork.HostRoot,
            HostPortal = ReactTypeOfWork.HostPortal,
            HostComponent = ReactTypeOfWork.HostComponent,
            HostText = ReactTypeOfWork.HostText,
            Fragment = ReactTypeOfWork.Fragment,
            ForwardRef = ReactTypeOfWork.ForwardRef,
            CONCURRENT_MODE_NUMBER = ReactSymbols.CONCURRENT_MODE_NUMBER,
            CONCURRENT_MODE_SYMBOL_STRING = ReactSymbols.CONCURRENT_MODE_SYMBOL_STRING,
            DEPRECATED_ASYNC_MODE_SYMBOL_STRING = ReactSymbols.DEPRECATED_ASYNC_MODE_SYMBOL_STRING,
            CONTEXT_CONSUMER_NUMBER = ReactSymbols.CONTEXT_CONSUMER_NUMBER,
            CONTEXT_CONSUMER_SYMBOL_STRING = ReactSymbols.CONTEXT_CONSUMER_SYMBOL_STRING,
            CONTEXT_PROVIDER_NUMBER = ReactSymbols.CONTEXT_PROVIDER_NUMBER,
            CONTEXT_PROVIDER_SYMBOL_STRING = ReactSymbols.CONTEXT_PROVIDER_SYMBOL_STRING,
            PROFILER_NUMBER = ReactSymbols.PROFILER_NUMBER,
            PROFILER_SYMBOL_STRING = ReactSymbols.PROFILER_SYMBOL_STRING,
            PURE_NUMBER = ReactSymbols.PURE_NUMBER,
            PURE_SYMBOL_STRING = ReactSymbols.PURE_SYMBOL_STRING,
            STRICT_MODE_NUMBER = ReactSymbols.STRICT_MODE_NUMBER,
            STRICT_MODE_SYMBOL_STRING = ReactSymbols.STRICT_MODE_SYMBOL_STRING,
            SUSPENSE_NUMBER = ReactSymbols.SUSPENSE_NUMBER,
            SUSPENSE_SYMBOL_STRING = ReactSymbols.SUSPENSE_SYMBOL_STRING,
            DEPRECATED_PLACEHOLDER_SYMBOL_STRING = ReactSymbols.DEPRECATED_PLACEHOLDER_SYMBOL_STRING,
            opaqueNodes = new Set(),
            pendingEvents = [];

        return {
          getNativeFromReactElement: getNativeFromReactElement,
          getReactElementFromNative: getReactElementFromNative,
          handleCommitFiberRoot: handleCommitFiberRoot,
          handleCommitFiberUnmount: handleCommitFiberUnmount,
          cleanup: cleanup,
          walkTree: walkTree
        };
      }

      var _typeof = "function" == typeof Symbol && "symbol" == typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
      },
          semver = __webpack_require__(45),
          copyWithSet = __webpack_require__(39),
          getDisplayName = __webpack_require__(40);

      module.exports = attachRendererFiber;
    }, function (module, exports, __webpack_require__) {
      (function (process) {
        function parse(version, loose) {
          if (version instanceof SemVer) return version;
          if ("string" != typeof version) return null;
          if (version.length > MAX_LENGTH) return null;
          var r = loose ? re[LOOSE] : re[FULL];
          if (!r.test(version)) return null;

          try {
            return new SemVer(version, loose);
          } catch (er) {
            return null;
          }
        }

        function valid(version, loose) {
          var v = parse(version, loose);
          return v ? v.version : null;
        }

        function clean(version, loose) {
          var s = parse(version.trim().replace(/^[=v]+/, ""), loose);
          return s ? s.version : null;
        }

        function SemVer(version, loose) {
          if (version instanceof SemVer) {
            if (version.loose === loose) return version;
            version = version.version;
          } else if ("string" != typeof version) throw new TypeError("Invalid Version: " + version);

          if (version.length > MAX_LENGTH) throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
          if (!(this instanceof SemVer)) return new SemVer(version, loose);
          debug("SemVer", version, loose), this.loose = loose;
          var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);
          if (!m) throw new TypeError("Invalid Version: " + version);
          if (this.raw = version, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
          if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
          if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
          m[4] ? this.prerelease = m[4].split(".").map(function (id) {
            if (/^[0-9]+$/.test(id)) {
              var num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
            }

            return id;
          }) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
        }

        function inc(version, release, loose, identifier) {
          "string" == typeof loose && (identifier = loose, loose = void 0);

          try {
            return new SemVer(version, loose).inc(release, identifier).version;
          } catch (er) {
            return null;
          }
        }

        function diff(version1, version2) {
          if (eq(version1, version2)) return null;
          var v1 = parse(version1),
              v2 = parse(version2);

          if (v1.prerelease.length || v2.prerelease.length) {
            for (var key in v1) {
              if (("major" === key || "minor" === key || "patch" === key) && v1[key] !== v2[key]) return "pre" + key;
            }

            return "prerelease";
          }

          for (var key in v1) {
            if (("major" === key || "minor" === key || "patch" === key) && v1[key] !== v2[key]) return key;
          }
        }

        function compareIdentifiers(a, b) {
          var anum = numeric.test(a),
              bnum = numeric.test(b);
          return anum && bnum && (a = +a, b = +b), anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : a > b ? 1 : 0;
        }

        function rcompareIdentifiers(a, b) {
          return compareIdentifiers(b, a);
        }

        function major(a, loose) {
          return new SemVer(a, loose).major;
        }

        function minor(a, loose) {
          return new SemVer(a, loose).minor;
        }

        function patch(a, loose) {
          return new SemVer(a, loose).patch;
        }

        function compare(a, b, loose) {
          return new SemVer(a, loose).compare(new SemVer(b, loose));
        }

        function compareLoose(a, b) {
          return compare(a, b, !0);
        }

        function rcompare(a, b, loose) {
          return compare(b, a, loose);
        }

        function sort(list, loose) {
          return list.sort(function (a, b) {
            return exports.compare(a, b, loose);
          });
        }

        function rsort(list, loose) {
          return list.sort(function (a, b) {
            return exports.rcompare(a, b, loose);
          });
        }

        function gt(a, b, loose) {
          return compare(a, b, loose) > 0;
        }

        function lt(a, b, loose) {
          return compare(a, b, loose) < 0;
        }

        function eq(a, b, loose) {
          return 0 === compare(a, b, loose);
        }

        function neq(a, b, loose) {
          return 0 !== compare(a, b, loose);
        }

        function gte(a, b, loose) {
          return compare(a, b, loose) >= 0;
        }

        function lte(a, b, loose) {
          return compare(a, b, loose) <= 0;
        }

        function cmp(a, op, b, loose) {
          var ret;

          switch (op) {
            case "===":
              "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), ret = a === b;
              break;

            case "!==":
              "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), ret = a !== b;
              break;

            case "":
            case "=":
            case "==":
              ret = eq(a, b, loose);
              break;

            case "!=":
              ret = neq(a, b, loose);
              break;

            case ">":
              ret = gt(a, b, loose);
              break;

            case ">=":
              ret = gte(a, b, loose);
              break;

            case "<":
              ret = lt(a, b, loose);
              break;

            case "<=":
              ret = lte(a, b, loose);
              break;

            default:
              throw new TypeError("Invalid operator: " + op);
          }

          return ret;
        }

        function Comparator(comp, loose) {
          if (comp instanceof Comparator) {
            if (comp.loose === loose) return comp;
            comp = comp.value;
          }

          return this instanceof Comparator ? (debug("comparator", comp, loose), this.loose = loose, this.parse(comp), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, void debug("comp", this)) : new Comparator(comp, loose);
        }

        function Range(range, loose) {
          if (range instanceof Range) return range.loose === loose ? range : new Range(range.raw, loose);
          if (range instanceof Comparator) return new Range(range.value, loose);
          if (!(this instanceof Range)) return new Range(range, loose);
          if (this.loose = loose, this.raw = range, this.set = range.split(/\s*\|\|\s*/).map(function (range) {
            return this.parseRange(range.trim());
          }, this).filter(function (c) {
            return c.length;
          }), !this.set.length) throw new TypeError("Invalid SemVer Range: " + range);
          this.format();
        }

        function toComparators(range, loose) {
          return new Range(range, loose).set.map(function (comp) {
            return comp.map(function (c) {
              return c.value;
            }).join(" ").trim().split(" ");
          });
        }

        function parseComparator(comp, loose) {
          return debug("comp", comp), comp = replaceCarets(comp, loose), debug("caret", comp), comp = replaceTildes(comp, loose), debug("tildes", comp), comp = replaceXRanges(comp, loose), debug("xrange", comp), comp = replaceStars(comp, loose), debug("stars", comp), comp;
        }

        function isX(id) {
          return !id || "x" === id.toLowerCase() || "*" === id;
        }

        function replaceTildes(comp, loose) {
          return comp.trim().split(/\s+/).map(function (comp) {
            return replaceTilde(comp, loose);
          }).join(" ");
        }

        function replaceTilde(comp, loose) {
          var r = loose ? re[TILDELOOSE] : re[TILDE];
          return comp.replace(r, function (_, M, m, p, pr) {
            debug("tilde", comp, _, M, m, p, pr);
            var ret;
            return isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : pr ? (debug("replaceTilde pr", pr), "-" !== pr.charAt(0) && (pr = "-" + pr), ret = ">=" + M + "." + m + "." + p + pr + " <" + M + "." + (+m + 1) + ".0") : ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0", debug("tilde return", ret), ret;
          });
        }

        function replaceCarets(comp, loose) {
          return comp.trim().split(/\s+/).map(function (comp) {
            return replaceCaret(comp, loose);
          }).join(" ");
        }

        function replaceCaret(comp, loose) {
          debug("caret", comp, loose);
          var r = loose ? re[CARETLOOSE] : re[CARET];
          return comp.replace(r, function (_, M, m, p, pr) {
            debug("caret", comp, _, M, m, p, pr);
            var ret;
            return isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = "0" === M ? ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0" : pr ? (debug("replaceCaret pr", pr), "-" !== pr.charAt(0) && (pr = "-" + pr), ret = "0" === M ? "0" === m ? ">=" + M + "." + m + "." + p + pr + " <" + M + "." + m + "." + (+p + 1) : ">=" + M + "." + m + "." + p + pr + " <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + "." + p + pr + " <" + (+M + 1) + ".0.0") : (debug("no pr"), ret = "0" === M ? "0" === m ? ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1) : ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0"), debug("caret return", ret), ret;
          });
        }

        function replaceXRanges(comp, loose) {
          return debug("replaceXRanges", comp, loose), comp.split(/\s+/).map(function (comp) {
            return replaceXRange(comp, loose);
          }).join(" ");
        }

        function replaceXRange(comp, loose) {
          comp = comp.trim();
          var r = loose ? re[XRANGELOOSE] : re[XRANGE];
          return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
            debug("xRange", comp, ret, gtlt, M, m, p, pr);
            var xM = isX(M),
                xm = xM || isX(m),
                xp = xm || isX(p),
                anyX = xp;
            return "=" === gtlt && anyX && (gtlt = ""), xM ? ret = ">" === gtlt || "<" === gtlt ? "<0.0.0" : "*" : gtlt && anyX ? (xm && (m = 0), xp && (p = 0), ">" === gtlt ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : xp && (m = +m + 1, p = 0)) : "<=" === gtlt && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), ret = gtlt + M + "." + m + "." + p) : xm ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : xp && (ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0"), debug("xRange return", ret), ret;
          });
        }

        function replaceStars(comp, loose) {
          return debug("replaceStars", comp, loose), comp.trim().replace(re[STAR], "");
        }

        function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
          return from = isX(fM) ? "" : isX(fm) ? ">=" + fM + ".0.0" : isX(fp) ? ">=" + fM + "." + fm + ".0" : ">=" + from, to = isX(tM) ? "" : isX(tm) ? "<" + (+tM + 1) + ".0.0" : isX(tp) ? "<" + tM + "." + (+tm + 1) + ".0" : tpr ? "<=" + tM + "." + tm + "." + tp + "-" + tpr : "<=" + to, (from + " " + to).trim();
        }

        function testSet(set, version) {
          for (var i = 0; i < set.length; i++) {
            if (!set[i].test(version)) return !1;
          }

          if (version.prerelease.length) {
            for (var i = 0; i < set.length; i++) {
              if (debug(set[i].semver), set[i].semver !== ANY && set[i].semver.prerelease.length > 0) {
                var allowed = set[i].semver;
                if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return !0;
              }
            }

            return !1;
          }

          return !0;
        }

        function satisfies(version, range, loose) {
          try {
            range = new Range(range, loose);
          } catch (er) {
            return !1;
          }

          return range.test(version);
        }

        function maxSatisfying(versions, range, loose) {
          var max = null,
              maxSV = null;

          try {
            var rangeObj = new Range(range, loose);
          } catch (er) {
            return null;
          }

          return versions.forEach(function (v) {
            rangeObj.test(v) && (max && maxSV.compare(v) !== -1 || (max = v, maxSV = new SemVer(max, loose)));
          }), max;
        }

        function minSatisfying(versions, range, loose) {
          var min = null,
              minSV = null;

          try {
            var rangeObj = new Range(range, loose);
          } catch (er) {
            return null;
          }

          return versions.forEach(function (v) {
            rangeObj.test(v) && (min && 1 !== minSV.compare(v) || (min = v, minSV = new SemVer(min, loose)));
          }), min;
        }

        function validRange(range, loose) {
          try {
            return new Range(range, loose).range || "*";
          } catch (er) {
            return null;
          }
        }

        function ltr(version, range, loose) {
          return outside(version, range, "<", loose);
        }

        function gtr(version, range, loose) {
          return outside(version, range, ">", loose);
        }

        function outside(version, range, hilo, loose) {
          version = new SemVer(version, loose), range = new Range(range, loose);
          var gtfn, ltefn, ltfn, comp, ecomp;

          switch (hilo) {
            case ">":
              gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
              break;

            case "<":
              gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
              break;

            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }

          if (satisfies(version, range, loose)) return !1;

          for (var i = 0; i < range.set.length; ++i) {
            var comparators = range.set[i],
                high = null,
                low = null;
            if (comparators.forEach(function (comparator) {
              comparator.semver === ANY && (comparator = new Comparator(">=0.0.0")), high = high || comparator, low = low || comparator, gtfn(comparator.semver, high.semver, loose) ? high = comparator : ltfn(comparator.semver, low.semver, loose) && (low = comparator);
            }), high.operator === comp || high.operator === ecomp) return !1;
            if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) return !1;
            if (low.operator === ecomp && ltfn(version, low.semver)) return !1;
          }

          return !0;
        }

        function prerelease(version, loose) {
          var parsed = parse(version, loose);
          return parsed && parsed.prerelease.length ? parsed.prerelease : null;
        }

        function intersects(r1, r2, loose) {
          return r1 = new Range(r1, loose), r2 = new Range(r2, loose), r1.intersects(r2);
        }

        function coerce(version) {
          if (version instanceof SemVer) return version;
          if ("string" != typeof version) return null;
          var match = version.match(re[COERCE]);
          return null == match ? null : parse((match[1] || "0") + "." + (match[2] || "0") + "." + (match[3] || "0"));
        }

        exports = module.exports = SemVer;
        var debug;
        debug = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function () {
          var args = Array.prototype.slice.call(arguments, 0);
          args.unshift("SEMVER"), console.log.apply(console, args);
        } : function () {}, exports.SEMVER_SPEC_VERSION = "2.0.0";
        var MAX_LENGTH = 256,
            MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991,
            MAX_SAFE_COMPONENT_LENGTH = 16,
            re = exports.re = [],
            src = exports.src = [],
            R = 0,
            NUMERICIDENTIFIER = R++;
        src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
        var NUMERICIDENTIFIERLOOSE = R++;
        src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
        var NONNUMERICIDENTIFIER = R++;
        src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
        var MAINVERSION = R++;
        src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
        var MAINVERSIONLOOSE = R++;
        src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
        var PRERELEASEIDENTIFIER = R++;
        src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
        var PRERELEASEIDENTIFIERLOOSE = R++;
        src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
        var PRERELEASE = R++;
        src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
        var PRERELEASELOOSE = R++;
        src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
        var BUILDIDENTIFIER = R++;
        src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
        var BUILD = R++;
        src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
        var FULL = R++,
            FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
        src[FULL] = "^" + FULLPLAIN + "$";
        var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?",
            LOOSE = R++;
        src[LOOSE] = "^" + LOOSEPLAIN + "$";
        var GTLT = R++;
        src[GTLT] = "((?:<|>)?=?)";
        var XRANGEIDENTIFIERLOOSE = R++;
        src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
        var XRANGEIDENTIFIER = R++;
        src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
        var XRANGEPLAIN = R++;
        src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
        var XRANGEPLAINLOOSE = R++;
        src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
        var XRANGE = R++;
        src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
        var XRANGELOOSE = R++;
        src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
        var COERCE = R++;
        src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
        var LONETILDE = R++;
        src[LONETILDE] = "(?:~>?)";
        var TILDETRIM = R++;
        src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+", re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
        var tildeTrimReplace = "$1~",
            TILDE = R++;
        src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
        var TILDELOOSE = R++;
        src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
        var LONECARET = R++;
        src[LONECARET] = "(?:\\^)";
        var CARETTRIM = R++;
        src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+", re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
        var caretTrimReplace = "$1^",
            CARET = R++;
        src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
        var CARETLOOSE = R++;
        src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
        var COMPARATORLOOSE = R++;
        src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
        var COMPARATOR = R++;
        src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
        var COMPARATORTRIM = R++;
        src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")", re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
        var comparatorTrimReplace = "$1$2$3",
            HYPHENRANGE = R++;
        src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
        var HYPHENRANGELOOSE = R++;
        src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
        var STAR = R++;
        src[STAR] = "(<|>)?=?\\s*\\*";

        for (var i = 0; i < R; i++) {
          debug(i, src[i]), re[i] || (re[i] = new RegExp(src[i]));
        }

        exports.parse = parse, exports.valid = valid, exports.clean = clean, exports.SemVer = SemVer, SemVer.prototype.format = function () {
          return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
        }, SemVer.prototype.toString = function () {
          return this.version;
        }, SemVer.prototype.compare = function (other) {
          return debug("SemVer.compare", this.version, this.loose, other), other instanceof SemVer || (other = new SemVer(other, this.loose)), this.compareMain(other) || this.comparePre(other);
        }, SemVer.prototype.compareMain = function (other) {
          return other instanceof SemVer || (other = new SemVer(other, this.loose)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        }, SemVer.prototype.comparePre = function (other) {
          if (other instanceof SemVer || (other = new SemVer(other, this.loose)), this.prerelease.length && !other.prerelease.length) return -1;
          if (!this.prerelease.length && other.prerelease.length) return 1;
          if (!this.prerelease.length && !other.prerelease.length) return 0;
          var i = 0;

          do {
            var a = this.prerelease[i],
                b = other.prerelease[i];
            if (debug("prerelease compare", i, a, b), void 0 === a && void 0 === b) return 0;
            if (void 0 === b) return 1;
            if (void 0 === a) return -1;
            if (a !== b) return compareIdentifiers(a, b);
          } while (++i);
        }, SemVer.prototype.inc = function (release, identifier) {
          switch (release) {
            case "premajor":
              this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
              break;

            case "preminor":
              this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
              break;

            case "prepatch":
              this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
              break;

            case "prerelease":
              0 === this.prerelease.length && this.inc("patch", identifier), this.inc("pre", identifier);
              break;

            case "major":
              0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
              break;

            case "minor":
              0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
              break;

            case "patch":
              0 === this.prerelease.length && this.patch++, this.prerelease = [];
              break;

            case "pre":
              if (0 === this.prerelease.length) this.prerelease = [0];else {
                for (var i = this.prerelease.length; --i >= 0;) {
                  "number" == typeof this.prerelease[i] && (this.prerelease[i]++, i = -2);
                }

                i === -1 && this.prerelease.push(0);
              }
              identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [identifier, 0]) : this.prerelease = [identifier, 0]);
              break;

            default:
              throw new Error("invalid increment argument: " + release);
          }

          return this.format(), this.raw = this.version, this;
        }, exports.inc = inc, exports.diff = diff, exports.compareIdentifiers = compareIdentifiers;
        var numeric = /^[0-9]+$/;
        exports.rcompareIdentifiers = rcompareIdentifiers, exports.major = major, exports.minor = minor, exports.patch = patch, exports.compare = compare, exports.compareLoose = compareLoose, exports.rcompare = rcompare, exports.sort = sort, exports.rsort = rsort, exports.gt = gt, exports.lt = lt, exports.eq = eq, exports.neq = neq, exports.gte = gte, exports.lte = lte, exports.cmp = cmp, exports.Comparator = Comparator;
        var ANY = {};
        Comparator.prototype.parse = function (comp) {
          var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR],
              m = comp.match(r);
          if (!m) throw new TypeError("Invalid comparator: " + comp);
          this.operator = m[1], "=" === this.operator && (this.operator = ""), m[2] ? this.semver = new SemVer(m[2], this.loose) : this.semver = ANY;
        }, Comparator.prototype.toString = function () {
          return this.value;
        }, Comparator.prototype.test = function (version) {
          return debug("Comparator.test", version, this.loose), this.semver === ANY || ("string" == typeof version && (version = new SemVer(version, this.loose)), cmp(version, this.operator, this.semver, this.loose));
        }, Comparator.prototype.intersects = function (comp, loose) {
          if (!(comp instanceof Comparator)) throw new TypeError("a Comparator is required");
          var rangeTmp;
          if ("" === this.operator) return rangeTmp = new Range(comp.value, loose), satisfies(this.value, rangeTmp, loose);
          if ("" === comp.operator) return rangeTmp = new Range(this.value, loose), satisfies(comp.semver, rangeTmp, loose);
          var sameDirectionIncreasing = !(">=" !== this.operator && ">" !== this.operator || ">=" !== comp.operator && ">" !== comp.operator),
              sameDirectionDecreasing = !("<=" !== this.operator && "<" !== this.operator || "<=" !== comp.operator && "<" !== comp.operator),
              sameSemVer = this.semver.version === comp.semver.version,
              differentDirectionsInclusive = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== comp.operator && "<=" !== comp.operator),
              oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, loose) && (">=" === this.operator || ">" === this.operator) && ("<=" === comp.operator || "<" === comp.operator),
              oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, loose) && ("<=" === this.operator || "<" === this.operator) && (">=" === comp.operator || ">" === comp.operator);
          return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
        }, exports.Range = Range, Range.prototype.format = function () {
          return this.range = this.set.map(function (comps) {
            return comps.join(" ").trim();
          }).join("||").trim(), this.range;
        }, Range.prototype.toString = function () {
          return this.range;
        }, Range.prototype.parseRange = function (range) {
          var loose = this.loose;
          range = range.trim(), debug("range", range, loose);
          var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
          range = range.replace(hr, hyphenReplace), debug("hyphen replace", range), range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace), debug("comparator trim", range, re[COMPARATORTRIM]), range = range.replace(re[TILDETRIM], tildeTrimReplace), range = range.replace(re[CARETTRIM], caretTrimReplace), range = range.split(/\s+/).join(" ");
          var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR],
              set = range.split(" ").map(function (comp) {
            return parseComparator(comp, loose);
          }).join(" ").split(/\s+/);
          return this.loose && (set = set.filter(function (comp) {
            return !!comp.match(compRe);
          })), set = set.map(function (comp) {
            return new Comparator(comp, loose);
          });
        }, Range.prototype.intersects = function (range, loose) {
          if (!(range instanceof Range)) throw new TypeError("a Range is required");
          return this.set.some(function (thisComparators) {
            return thisComparators.every(function (thisComparator) {
              return range.set.some(function (rangeComparators) {
                return rangeComparators.every(function (rangeComparator) {
                  return thisComparator.intersects(rangeComparator, loose);
                });
              });
            });
          });
        }, exports.toComparators = toComparators, Range.prototype.test = function (version) {
          if (!version) return !1;
          "string" == typeof version && (version = new SemVer(version, this.loose));

          for (var i = 0; i < this.set.length; i++) {
            if (testSet(this.set[i], version)) return !0;
          }

          return !1;
        }, exports.satisfies = satisfies, exports.maxSatisfying = maxSatisfying, exports.minSatisfying = minSatisfying, exports.validRange = validRange, exports.ltr = ltr, exports.gtr = gtr, exports.outside = outside, exports.prerelease = prerelease, exports.intersects = intersects, exports.coerce = coerce;
      }).call(exports, __webpack_require__(46));
    }, function (module, exports) {
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }

      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }

      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, setTimeout(fun, 0);

        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }

      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, clearTimeout(marker);

        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }

      function cleanUpNextTick() {
        draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
      }

      function drainQueue() {
        if (!draining) {
          var timeout = runTimeout(cleanUpNextTick);
          draining = !0;

          for (var len = queue.length; len;) {
            for (currentQueue = queue, queue = []; ++queueIndex < len;) {
              currentQueue && currentQueue[queueIndex].run();
            }

            queueIndex = -1, len = queue.length;
          }

          currentQueue = null, draining = !1, runClearTimeout(timeout);
        }
      }

      function Item(fun, array) {
        this.fun = fun, this.array = array;
      }

      function noop() {}

      var cachedSetTimeout,
          cachedClearTimeout,
          process = module.exports = {};
      !function () {
        try {
          cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }

        try {
          cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      }();
      var currentQueue,
          queue = [],
          draining = !1,
          queueIndex = -1;
      process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
        queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
      }, Item.prototype.run = function () {
        this.fun.apply(null, this.array);
      }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], process.version = "", process.versions = {}, process.on = noop, process.addListener = noop, process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, process.emit = noop, process.binding = function (name) {
        throw new Error("process.binding is not supported");
      }, process.cwd = function () {
        return "/";
      }, process.chdir = function (dir) {
        throw new Error("process.chdir is not supported");
      }, process.umask = function () {
        return 0;
      };
    }, function (module, exports, __webpack_require__) {
      (function (global) {
        "use strict";
        /*!
        * The buffer module from node.js, for the browser.
        *
        * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
        * @license  MIT
        */

        function compare(a, b) {
          if (a === b) return 0;

          for (var x = a.length, y = b.length, i = 0, len = Math.min(x, y); i < len; ++i) {
            if (a[i] !== b[i]) {
              x = a[i], y = b[i];
              break;
            }
          }

          return x < y ? -1 : y < x ? 1 : 0;
        }

        function isBuffer(b) {
          return global.Buffer && "function" == typeof global.Buffer.isBuffer ? global.Buffer.isBuffer(b) : !(null == b || !b._isBuffer);
        }

        function pToString(obj) {
          return Object.prototype.toString.call(obj);
        }

        function isView(arrbuf) {
          return !isBuffer(arrbuf) && "function" == typeof global.ArrayBuffer && ("function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(arrbuf) : !!arrbuf && (arrbuf instanceof DataView || !!(arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer)));
        }

        function getName(func) {
          if (util.isFunction(func)) {
            if (functionsHaveNames) return func.name;
            var str = func.toString(),
                match = str.match(regex);
            return match && match[1];
          }
        }

        function truncate(s, n) {
          return "string" == typeof s ? s.length < n ? s : s.slice(0, n) : s;
        }

        function inspect(something) {
          if (functionsHaveNames || !util.isFunction(something)) return util.inspect(something);
          var rawname = getName(something),
              name = rawname ? ": " + rawname : "";
          return "[Function" + name + "]";
        }

        function getMessage(self) {
          return truncate(inspect(self.actual), 128) + " " + self.operator + " " + truncate(inspect(self.expected), 128);
        }

        function fail(actual, expected, message, operator, stackStartFunction) {
          throw new assert.AssertionError({
            message: message,
            actual: actual,
            expected: expected,
            operator: operator,
            stackStartFunction: stackStartFunction
          });
        }

        function ok(value, message) {
          value || fail(value, !0, message, "==", assert.ok);
        }

        function _deepEqual(actual, expected, strict, memos) {
          if (actual === expected) return !0;
          if (isBuffer(actual) && isBuffer(expected)) return 0 === compare(actual, expected);
          if (util.isDate(actual) && util.isDate(expected)) return actual.getTime() === expected.getTime();
          if (util.isRegExp(actual) && util.isRegExp(expected)) return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;

          if (null !== actual && "object" == typeof actual || null !== expected && "object" == typeof expected) {
            if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) return 0 === compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer));
            if (isBuffer(actual) !== isBuffer(expected)) return !1;
            memos = memos || {
              actual: [],
              expected: []
            };
            var actualIndex = memos.actual.indexOf(actual);
            return actualIndex !== -1 && actualIndex === memos.expected.indexOf(expected) || (memos.actual.push(actual), memos.expected.push(expected), objEquiv(actual, expected, strict, memos));
          }

          return strict ? actual === expected : actual == expected;
        }

        function isArguments(object) {
          return "[object Arguments]" == Object.prototype.toString.call(object);
        }

        function objEquiv(a, b, strict, actualVisitedObjects) {
          if (null === a || void 0 === a || null === b || void 0 === b) return !1;
          if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
          if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return !1;
          var aIsArgs = isArguments(a),
              bIsArgs = isArguments(b);
          if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return !1;
          if (aIsArgs) return a = pSlice.call(a), b = pSlice.call(b), _deepEqual(a, b, strict);
          var key,
              i,
              ka = objectKeys(a),
              kb = objectKeys(b);
          if (ka.length !== kb.length) return !1;

          for (ka.sort(), kb.sort(), i = ka.length - 1; i >= 0; i--) {
            if (ka[i] !== kb[i]) return !1;
          }

          for (i = ka.length - 1; i >= 0; i--) {
            if (key = ka[i], !_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return !1;
          }

          return !0;
        }

        function notDeepStrictEqual(actual, expected, message) {
          _deepEqual(actual, expected, !0) && fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
        }

        function expectedException(actual, expected) {
          if (!actual || !expected) return !1;
          if ("[object RegExp]" == Object.prototype.toString.call(expected)) return expected.test(actual);

          try {
            if (actual instanceof expected) return !0;
          } catch (e) {}

          return !Error.isPrototypeOf(expected) && expected.call({}, actual) === !0;
        }

        function _tryBlock(block) {
          var error;

          try {
            block();
          } catch (e) {
            error = e;
          }

          return error;
        }

        function _throws(shouldThrow, block, expected, message) {
          var actual;
          if ("function" != typeof block) throw new TypeError('"block" argument must be a function');
          "string" == typeof expected && (message = expected, expected = null), actual = _tryBlock(block), message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : "."), shouldThrow && !actual && fail(actual, expected, "Missing expected exception" + message);
          var userProvidedMessage = "string" == typeof message,
              isUnwantedException = !shouldThrow && util.isError(actual),
              isUnexpectedException = !shouldThrow && actual && !expected;
          if ((isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) && fail(actual, expected, "Got unwanted exception" + message), shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) throw actual;
        }

        var util = __webpack_require__(48),
            hasOwn = Object.prototype.hasOwnProperty,
            pSlice = Array.prototype.slice,
            functionsHaveNames = function () {
          return "foo" === function () {}.name;
        }(),
            assert = module.exports = ok,
            regex = /\s*function\s+([^\(\s]*)\s*/;

        assert.AssertionError = function (options) {
          this.name = "AssertionError", this.actual = options.actual, this.expected = options.expected, this.operator = options.operator, options.message ? (this.message = options.message, this.generatedMessage = !1) : (this.message = getMessage(this), this.generatedMessage = !0);
          var stackStartFunction = options.stackStartFunction || fail;
          if (Error.captureStackTrace) Error.captureStackTrace(this, stackStartFunction);else {
            var err = new Error();

            if (err.stack) {
              var out = err.stack,
                  fn_name = getName(stackStartFunction),
                  idx = out.indexOf("\n" + fn_name);

              if (idx >= 0) {
                var next_line = out.indexOf("\n", idx + 1);
                out = out.substring(next_line + 1);
              }

              this.stack = out;
            }
          }
        }, util.inherits(assert.AssertionError, Error), assert.fail = fail, assert.ok = ok, assert.equal = function (actual, expected, message) {
          actual != expected && fail(actual, expected, message, "==", assert.equal);
        }, assert.notEqual = function (actual, expected, message) {
          actual == expected && fail(actual, expected, message, "!=", assert.notEqual);
        }, assert.deepEqual = function (actual, expected, message) {
          _deepEqual(actual, expected, !1) || fail(actual, expected, message, "deepEqual", assert.deepEqual);
        }, assert.deepStrictEqual = function (actual, expected, message) {
          _deepEqual(actual, expected, !0) || fail(actual, expected, message, "deepStrictEqual", assert.deepStrictEqual);
        }, assert.notDeepEqual = function (actual, expected, message) {
          _deepEqual(actual, expected, !1) && fail(actual, expected, message, "notDeepEqual", assert.notDeepEqual);
        }, assert.notDeepStrictEqual = notDeepStrictEqual, assert.strictEqual = function (actual, expected, message) {
          actual !== expected && fail(actual, expected, message, "===", assert.strictEqual);
        }, assert.notStrictEqual = function (actual, expected, message) {
          actual === expected && fail(actual, expected, message, "!==", assert.notStrictEqual);
        }, assert["throws"] = function (block, error, message) {
          _throws(!0, block, error, message);
        }, assert.doesNotThrow = function (block, error, message) {
          _throws(!1, block, error, message);
        }, assert.ifError = function (err) {
          if (err) throw err;
        };

        var objectKeys = Object.keys || function (obj) {
          var keys = [];

          for (var key in obj) {
            hasOwn.call(obj, key) && keys.push(key);
          }

          return keys;
        };
      }).call(exports, function () {
        return this;
      }());
    }, function (module, exports, __webpack_require__) {
      (function (global, process) {
        function inspect(obj, opts) {
          var ctx = {
            seen: [],
            stylize: stylizeNoColor
          };
          return arguments.length >= 3 && (ctx.depth = arguments[2]), arguments.length >= 4 && (ctx.colors = arguments[3]), isBoolean(opts) ? ctx.showHidden = opts : opts && exports._extend(ctx, opts), isUndefined(ctx.showHidden) && (ctx.showHidden = !1), isUndefined(ctx.depth) && (ctx.depth = 2), isUndefined(ctx.colors) && (ctx.colors = !1), isUndefined(ctx.customInspect) && (ctx.customInspect = !0), ctx.colors && (ctx.stylize = stylizeWithColor), formatValue(ctx, obj, ctx.depth);
        }

        function stylizeWithColor(str, styleType) {
          var style = inspect.styles[styleType];
          return style ? "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m" : str;
        }

        function stylizeNoColor(str, styleType) {
          return str;
        }

        function arrayToHash(array) {
          var hash = {};
          return array.forEach(function (val, idx) {
            hash[val] = !0;
          }), hash;
        }

        function formatValue(ctx, value, recurseTimes) {
          if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && (!value.constructor || value.constructor.prototype !== value)) {
            var ret = value.inspect(recurseTimes, ctx);
            return isString(ret) || (ret = formatValue(ctx, ret, recurseTimes)), ret;
          }

          var primitive = formatPrimitive(ctx, value);
          if (primitive) return primitive;
          var keys = Object.keys(value),
              visibleKeys = arrayToHash(keys);
          if (ctx.showHidden && (keys = Object.getOwnPropertyNames(value)), isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) return formatError(value);

          if (0 === keys.length) {
            if (isFunction(value)) {
              var name = value.name ? ": " + value.name : "";
              return ctx.stylize("[Function" + name + "]", "special");
            }

            if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
            if (isDate(value)) return ctx.stylize(Date.prototype.toString.call(value), "date");
            if (isError(value)) return formatError(value);
          }

          var base = "",
              array = !1,
              braces = ["{", "}"];

          if (isArray(value) && (array = !0, braces = ["[", "]"]), isFunction(value)) {
            var n = value.name ? ": " + value.name : "";
            base = " [Function" + n + "]";
          }

          if (isRegExp(value) && (base = " " + RegExp.prototype.toString.call(value)), isDate(value) && (base = " " + Date.prototype.toUTCString.call(value)), isError(value) && (base = " " + formatError(value)), 0 === keys.length && (!array || 0 == value.length)) return braces[0] + base + braces[1];
          if (recurseTimes < 0) return isRegExp(value) ? ctx.stylize(RegExp.prototype.toString.call(value), "regexp") : ctx.stylize("[Object]", "special");
          ctx.seen.push(value);
          var output;
          return output = array ? formatArray(ctx, value, recurseTimes, visibleKeys, keys) : keys.map(function (key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          }), ctx.seen.pop(), reduceToSingleString(output, base, braces);
        }

        function formatPrimitive(ctx, value) {
          if (isUndefined(value)) return ctx.stylize("undefined", "undefined");

          if (isString(value)) {
            var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return ctx.stylize(simple, "string");
          }

          return isNumber(value) ? ctx.stylize("" + value, "number") : isBoolean(value) ? ctx.stylize("" + value, "boolean") : isNull(value) ? ctx.stylize("null", "null") : void 0;
        }

        function formatError(value) {
          return "[" + Error.prototype.toString.call(value) + "]";
        }

        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
          for (var output = [], i = 0, l = value.length; i < l; ++i) {
            hasOwnProperty(value, String(i)) ? output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), !0)) : output.push("");
          }

          return keys.forEach(function (key) {
            key.match(/^\d+$/) || output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, !0));
          }), output;
        }

        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
          var name, str, desc;

          if (desc = Object.getOwnPropertyDescriptor(value, key) || {
            value: value[key]
          }, desc.get ? str = desc.set ? ctx.stylize("[Getter/Setter]", "special") : ctx.stylize("[Getter]", "special") : desc.set && (str = ctx.stylize("[Setter]", "special")), hasOwnProperty(visibleKeys, key) || (name = "[" + key + "]"), str || (ctx.seen.indexOf(desc.value) < 0 ? (str = isNull(recurseTimes) ? formatValue(ctx, desc.value, null) : formatValue(ctx, desc.value, recurseTimes - 1), str.indexOf("\n") > -1 && (str = array ? str.split("\n").map(function (line) {
            return "  " + line;
          }).join("\n").substr(2) : "\n" + str.split("\n").map(function (line) {
            return "   " + line;
          }).join("\n"))) : str = ctx.stylize("[Circular]", "special")), isUndefined(name)) {
            if (array && key.match(/^\d+$/)) return str;
            name = JSON.stringify("" + key), name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (name = name.substr(1, name.length - 2), name = ctx.stylize(name, "name")) : (name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), name = ctx.stylize(name, "string"));
          }

          return name + ": " + str;
        }

        function reduceToSingleString(output, base, braces) {
          var numLinesEst = 0,
              length = output.reduce(function (prev, cur) {
            return numLinesEst++, cur.indexOf("\n") >= 0 && numLinesEst++, prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0);
          return length > 60 ? braces[0] + ("" === base ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1] : braces[0] + base + " " + output.join(", ") + " " + braces[1];
        }

        function isArray(ar) {
          return Array.isArray(ar);
        }

        function isBoolean(arg) {
          return "boolean" == typeof arg;
        }

        function isNull(arg) {
          return null === arg;
        }

        function isNullOrUndefined(arg) {
          return null == arg;
        }

        function isNumber(arg) {
          return "number" == typeof arg;
        }

        function isString(arg) {
          return "string" == typeof arg;
        }

        function isSymbol(arg) {
          return "symbol" == typeof arg;
        }

        function isUndefined(arg) {
          return void 0 === arg;
        }

        function isRegExp(re) {
          return isObject(re) && "[object RegExp]" === objectToString(re);
        }

        function isObject(arg) {
          return "object" == typeof arg && null !== arg;
        }

        function isDate(d) {
          return isObject(d) && "[object Date]" === objectToString(d);
        }

        function isError(e) {
          return isObject(e) && ("[object Error]" === objectToString(e) || e instanceof Error);
        }

        function isFunction(arg) {
          return "function" == typeof arg;
        }

        function isPrimitive(arg) {
          return null === arg || "boolean" == typeof arg || "number" == typeof arg || "string" == typeof arg || "symbol" == typeof arg || "undefined" == typeof arg;
        }

        function objectToString(o) {
          return Object.prototype.toString.call(o);
        }

        function pad(n) {
          return n < 10 ? "0" + n.toString(10) : n.toString(10);
        }

        function timestamp() {
          var d = new Date(),
              time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(":");
          return [d.getDate(), months[d.getMonth()], time].join(" ");
        }

        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }

        var formatRegExp = /%[sdj%]/g;
        exports.format = function (f) {
          if (!isString(f)) {
            for (var objects = [], i = 0; i < arguments.length; i++) {
              objects.push(inspect(arguments[i]));
            }

            return objects.join(" ");
          }

          for (var i = 1, args = arguments, len = args.length, str = String(f).replace(formatRegExp, function (x) {
            if ("%%" === x) return "%";
            if (i >= len) return x;

            switch (x) {
              case "%s":
                return String(args[i++]);

              case "%d":
                return Number(args[i++]);

              case "%j":
                try {
                  return JSON.stringify(args[i++]);
                } catch (_) {
                  return "[Circular]";
                }

              default:
                return x;
            }
          }), x = args[i]; i < len; x = args[++i]) {
            str += isNull(x) || !isObject(x) ? " " + x : " " + inspect(x);
          }

          return str;
        }, exports.deprecate = function (fn, msg) {
          function deprecated() {
            if (!warned) {
              if (process.throwDeprecation) throw new Error(msg);
              process.traceDeprecation ? console.trace(msg) : console.error(msg), warned = !0;
            }

            return fn.apply(this, arguments);
          }

          if (isUndefined(global.process)) return function () {
            return exports.deprecate(fn, msg).apply(this, arguments);
          };
          if (process.noDeprecation === !0) return fn;
          var warned = !1;
          return deprecated;
        };
        var debugEnviron,
            debugs = {};
        exports.debuglog = function (set) {
          if (isUndefined(debugEnviron) && (debugEnviron = process.env.NODE_DEBUG || ""), set = set.toUpperCase(), !debugs[set]) if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
            var pid = process.pid;

            debugs[set] = function () {
              var msg = exports.format.apply(exports, arguments);
              console.error("%s %d: %s", set, pid, msg);
            };
          } else debugs[set] = function () {};
          return debugs[set];
        }, exports.inspect = inspect, inspect.colors = {
          bold: [1, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          white: [37, 39],
          grey: [90, 39],
          black: [30, 39],
          blue: [34, 39],
          cyan: [36, 39],
          green: [32, 39],
          magenta: [35, 39],
          red: [31, 39],
          yellow: [33, 39]
        }, inspect.styles = {
          special: "cyan",
          number: "yellow",
          "boolean": "yellow",
          undefined: "grey",
          "null": "bold",
          string: "green",
          date: "magenta",
          regexp: "red"
        }, exports.isArray = isArray, exports.isBoolean = isBoolean, exports.isNull = isNull, exports.isNullOrUndefined = isNullOrUndefined, exports.isNumber = isNumber, exports.isString = isString, exports.isSymbol = isSymbol, exports.isUndefined = isUndefined, exports.isRegExp = isRegExp, exports.isObject = isObject, exports.isDate = isDate, exports.isError = isError, exports.isFunction = isFunction, exports.isPrimitive = isPrimitive, exports.isBuffer = __webpack_require__(49);
        var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        exports.log = function () {
          console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
        }, exports.inherits = __webpack_require__(50), exports._extend = function (origin, add) {
          if (!add || !isObject(add)) return origin;

          for (var keys = Object.keys(add), i = keys.length; i--;) {
            origin[keys[i]] = add[keys[i]];
          }

          return origin;
        };
      }).call(exports, function () {
        return this;
      }(), __webpack_require__(46));
    }, function (module, exports) {
      module.exports = function (arg) {
        return arg && "object" == typeof arg && "function" == typeof arg.copy && "function" == typeof arg.fill && "function" == typeof arg.readUInt8;
      };
    }, function (module, exports) {
      "function" == typeof Object.create ? module.exports = function (ctor, superCtor) {
        ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        });
      } : module.exports = function (ctor, superCtor) {
        ctor.super_ = superCtor;

        var TempCtor = function TempCtor() {};

        TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      function _defineProperty(obj, key, value) {
        return key in obj ? Object.defineProperty(obj, key, {
          value: value,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : obj[key] = value, obj;
      }

      function measureStyle(agent, bridge, resolveRNStyle, id) {
        var node = agent.elementData.get(id);
        if (!node || !node.props) return void bridge.send("rn-style:measure", {});
        var style = resolveRNStyle(node.props.style);
        styleOverridesByHostComponentId[id] && (style = _extends2({}, style, styleOverridesByHostComponentId[id]));
        var instance = node.publicInstance;
        return instance && instance.measure ? void instance.measure(function (x, y, width, height, left, top) {
          if ("number" != typeof x) return void bridge.send("rn-style:measure", {
            style: style
          });
          var margin = style && resolveBoxStyle("margin", style) || blank,
              padding = style && resolveBoxStyle("padding", style) || blank;
          bridge.send("rn-style:measure", {
            style: style,
            measuredLayout: {
              x: x,
              y: y,
              width: width,
              height: height,
              left: left,
              top: top,
              margin: margin,
              padding: padding
            }
          });
        }) : void bridge.send("rn-style:measure", {
          style: style
        });
      }

      function shallowClone(obj) {
        var nobj = {};

        for (var n in obj) {
          nobj[n] = obj[n];
        }

        return nobj;
      }

      function renameStyle(agent, id, oldName, newName, val) {
        var _ref3,
            data = agent.elementData.get(id),
            newStyle = newName ? (_ref3 = {}, _defineProperty(_ref3, oldName, void 0), _defineProperty(_ref3, newName, val), _ref3) : _defineProperty({}, oldName, void 0);

        if (data && data.updater && "function" == typeof data.updater.setInProps) {
          var customStyle,
              style = data && data.props && data.props.style;

          if (Array.isArray(style)) {
            var lastLength = style.length - 1;
            "object" !== _typeof(style[lastLength]) || Array.isArray(style[lastLength]) ? (style = style.concat([newStyle]), data.updater.setInProps(["style"], style)) : (customStyle = shallowClone(style[lastLength]), delete customStyle[oldName], newName ? customStyle[newName] = val : customStyle[oldName] = void 0, data.updater.setInProps(["style", lastLength], customStyle));
          } else "object" === ("undefined" == typeof style ? "undefined" : _typeof(style)) ? (customStyle = shallowClone(style), delete customStyle[oldName], newName ? customStyle[newName] = val : customStyle[oldName] = void 0, data.updater.setInProps(["style"], customStyle)) : (style = [style, newStyle], data.updater.setInProps(["style"], style));
        } else {
          if (!data || !data.updater || "function" != typeof data.updater.setNativeProps) return;
          styleOverridesByHostComponentId[id] ? _extends2(styleOverridesByHostComponentId[id], newStyle) : styleOverridesByHostComponentId[id] = newStyle, data.updater.setNativeProps({
            style: newStyle
          });
        }

        agent.emit("hideHighlight");
      }

      function setStyle(agent, id, attr, val) {
        var data = agent.elementData.get(id),
            newStyle = _defineProperty({}, attr, val);

        if (data && data.updater && "function" == typeof data.updater.setInProps) {
          var style = data.props && data.props.style;

          if (Array.isArray(style)) {
            var lastLength = style.length - 1;
            "object" !== _typeof(style[lastLength]) || Array.isArray(style[lastLength]) ? (style = style.concat([newStyle]), data.updater.setInProps(["style"], style)) : data.updater.setInProps(["style", lastLength, attr], val);
          } else style = [style, newStyle], data.updater.setInProps(["style"], style);
        } else {
          if (!data || !data.updater || "function" != typeof data.updater.setNativeProps) return;
          styleOverridesByHostComponentId[id] ? _extends2(styleOverridesByHostComponentId[id], newStyle) : styleOverridesByHostComponentId[id] = newStyle, data.updater.setNativeProps({
            style: newStyle
          });
        }

        agent.emit("hideHighlight");
      }

      var _typeof = "function" == typeof Symbol && "symbol" == typeof (typeof Symbol === "function" ? Symbol.iterator : "@@iterator") ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== (typeof Symbol === "function" ? Symbol.prototype : "@@prototype") ? "symbol" : typeof obj;
      },
          resolveBoxStyle = __webpack_require__(52),
          styleOverridesByHostComponentId = {};

      module.exports = function (bridge, agent, resolveRNStyle) {
        bridge.onCall("rn-style:get", function (id) {
          var node = agent.elementData.get(id);
          return node && node.props ? resolveRNStyle(node.props.style) : null;
        }), bridge.on("rn-style:measure", function (id) {
          measureStyle(agent, bridge, resolveRNStyle, id);
        }), bridge.on("rn-style:rename", function (_ref) {
          var id = _ref.id,
              oldName = _ref.oldName,
              newName = _ref.newName,
              val = _ref.val;
          renameStyle(agent, id, oldName, newName, val), setTimeout(function () {
            return measureStyle(agent, bridge, resolveRNStyle, id);
          });
        }), bridge.on("rn-style:set", function (_ref2) {
          var id = _ref2.id,
              attr = _ref2.attr,
              val = _ref2.val;
          setStyle(agent, id, attr, val), setTimeout(function () {
            return measureStyle(agent, bridge, resolveRNStyle, id);
          });
        });
      };

      var blank = {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      };
    }, function (module, exports) {
      "use strict";

      function resolveBoxStyle(prefix, style) {
        var res = {},
            subs = ["top", "left", "bottom", "right"],
            set = !1;
        return subs.forEach(function (sub) {
          res[sub] = style[prefix] || 0;
        }), style[prefix] && (set = !0), style[prefix + "Vertical"] && (res.top = res.bottom = style[prefix + "Vertical"], set = !0), style[prefix + "Horizontal"] && (res.left = res.right = style[prefix + "Horizontal"], set = !0), subs.forEach(function (sub) {
          var val = style[prefix + capFirst(sub)];
          val && (res[sub] = val, set = !0);
        }), set ? res : null;
      }

      function capFirst(text) {
        return text[0].toUpperCase() + text.slice(1);
      }

      module.exports = resolveBoxStyle;
    }, function (module, exports) {
      "use strict";

      var emptyFunction = function emptyFunction() {};

      module.exports = function (bridge, agent, hook) {
        var checkIfProfilingIsSupported = function checkIfProfilingIsSupported() {
          var profilingIsSupported = !1;
          agent.roots.forEach(function (rootId) {
            var root = agent.internalInstancesById.get(rootId);
            root.hasOwnProperty("treeBaseDuration") && (profilingIsSupported = !0);
          }), bridge.call("profiler:update", [profilingIsSupported], emptyFunction);
        };

        agent.on("root", checkIfProfilingIsSupported), agent.on("rootUnmounted", checkIfProfilingIsSupported), checkIfProfilingIsSupported();
      };
    }, function (module, exports) {
      "use strict";

      function decorate(obj, attr, fn) {
        var old = obj[attr];
        return obj[attr] = function () {
          var res = old.apply(this, arguments);
          return fn.apply(this, arguments), res;
        }, function () {
          obj[attr] = old;
        };
      }

      var subscriptionEnabled = !1;

      module.exports = function (bridge, agent, hook) {
        function sendStoreData() {
          subscriptionEnabled && bridge.send("relay:store", {
            id: "relay:store",
            nodes: DefaultStoreData.getNodeData()
          });
        }

        var shouldEnable = !!hook._relayInternals;

        if (bridge.onCall("relay:check", function () {
          return shouldEnable;
        }), shouldEnable) {
          var _hook$_relayInternals = hook._relayInternals,
              DefaultStoreData = _hook$_relayInternals.DefaultStoreData,
              setRequestListener = _hook$_relayInternals.setRequestListener;
          bridge.onCall("relay:store:enable", function () {
            subscriptionEnabled = !0, sendStoreData();
          }), bridge.onCall("relay:store:disable", function () {
            subscriptionEnabled = !1;
          }), sendStoreData(), decorate(DefaultStoreData, "handleUpdatePayload", sendStoreData), decorate(DefaultStoreData, "handleQueryPayload", sendStoreData);
          var removeListener = setRequestListener(function (event, data) {
            bridge.send(event, data);
          });
          hook.on("shutdown", removeListener);
        }
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      var Highlighter = __webpack_require__(56);

      module.exports = function (agent) {
        var hl = new Highlighter(window, function (node) {
          agent.selectFromDOMNode(node);
        });
        agent.on("highlight", function (data) {
          return hl.highlight(data.node, data.name);
        }), agent.on("highlightMany", function (nodes) {
          return hl.highlightMany(nodes);
        }), agent.on("hideHighlight", function () {
          return hl.hideHighlight();
        }), agent.on("refreshMultiOverlay", function () {
          return hl.refreshMultiOverlay();
        }), agent.on("startInspecting", function () {
          return hl.startInspecting();
        }), agent.on("stopInspecting", function () {
          return hl.stopInspecting();
        }), agent.on("shutdown", function () {
          hl.remove();
        });
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
      }

      function captureSubscription(obj, evt, cb) {
        return obj.addEventListener(evt, cb, !0), function () {
          return obj.removeEventListener(evt, cb, !0);
        };
      }

      function makeMagnifier() {
        var button = window.document.createElement("button");
        return button.innerHTML = "&#128269;", button.style.backgroundColor = "transparent", button.style.border = "none", button.style.outline = "none", button.style.cursor = "pointer", button.style.position = "fixed", button.style.bottom = "10px", button.style.right = "10px", button.style.fontSize = "30px", button.style.zIndex = 1e7, button;
      }

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
        };
      }(),
          Overlay = __webpack_require__(57),
          MultiOverlay = __webpack_require__(59),
          Highlighter = function () {
        function Highlighter(win, onSelect) {
          _classCallCheck(this, Highlighter), this._win = win, this._onSelect = onSelect, this._overlay = null, this._multiOverlay = null, this._subs = [];
        }

        return _createClass(Highlighter, [{
          key: "startInspecting",
          value: function value() {
            this._inspecting = !0, this._subs = [captureSubscription(this._win, "mouseover", this.onHover.bind(this)), captureSubscription(this._win, "mousedown", this.onMouseDown.bind(this)), captureSubscription(this._win, "click", this.onClick.bind(this))];
          }
        }, {
          key: "stopInspecting",
          value: function value() {
            this._subs.forEach(function (unsub) {
              return unsub();
            }), this.hideHighlight();
          }
        }, {
          key: "remove",
          value: function value() {
            this.stopInspecting(), this._button && this._button.parentNode && this._button.parentNode.removeChild(this._button);
          }
        }, {
          key: "highlight",
          value: function value(node, name) {
            this.removeMultiOverlay(), node.nodeType !== Node.COMMENT_NODE && (this._overlay || (this._overlay = new Overlay(this._win)), this._overlay.inspect(node, name));
          }
        }, {
          key: "highlightMany",
          value: function value(nodes) {
            this.removeOverlay(), this._multiOverlay || (this._multiOverlay = new MultiOverlay(this._win)), this._multiOverlay.highlightMany(nodes);
          }
        }, {
          key: "hideHighlight",
          value: function value() {
            this._inspecting = !1, this.removeOverlay(), this.removeMultiOverlay();
          }
        }, {
          key: "refreshMultiOverlay",
          value: function value() {
            this._multiOverlay && this._multiOverlay.refresh();
          }
        }, {
          key: "removeOverlay",
          value: function value() {
            this._overlay && (this._overlay.remove(), this._overlay = null);
          }
        }, {
          key: "removeMultiOverlay",
          value: function value() {
            this._multiOverlay && (this._multiOverlay.remove(), this._multiOverlay = null);
          }
        }, {
          key: "onMouseDown",
          value: function value(evt) {
            this._inspecting && (evt.preventDefault(), evt.stopPropagation(), evt.cancelBubble = !0, this._onSelect(evt.target));
          }
        }, {
          key: "onClick",
          value: function value(evt) {
            this._inspecting && (this._subs.forEach(function (unsub) {
              return unsub();
            }), evt.preventDefault(), evt.stopPropagation(), evt.cancelBubble = !0, this.hideHighlight());
          }
        }, {
          key: "onHover",
          value: function value(evt) {
            this._inspecting && (evt.preventDefault(), evt.stopPropagation(), evt.cancelBubble = !0, this.highlight(evt.target));
          }
        }, {
          key: "injectButton",
          value: function value() {
            this._button = makeMagnifier(), this._button.onclick = this.startInspecting.bind(this), this._win.document.body.appendChild(this._button);
          }
        }]), Highlighter;
      }();

      module.exports = Highlighter;
    }, function (module, exports, __webpack_require__) {
      "use strict";

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
      }

      function findTipPos(dims, win) {
        var top,
            tipHeight = 20,
            margin = 5;
        return top = dims.top + dims.height + tipHeight <= win.innerHeight ? dims.top + dims.height < 0 ? margin : dims.top + dims.height + margin : dims.top - tipHeight <= win.innerHeight ? dims.top - tipHeight - margin < margin ? margin : dims.top - tipHeight - margin : win.innerHeight - tipHeight - margin, top += "px", dims.left < 0 ? {
          top: top,
          left: margin
        } : dims.left + 200 > win.innerWidth ? {
          top: top,
          right: margin
        } : {
          top: top,
          left: dims.left + margin + "px"
        };
      }

      function getElementDimensions(domElement) {
        var calculatedStyle = window.getComputedStyle(domElement);
        return {
          borderLeft: +calculatedStyle.borderLeftWidth.match(/[0-9]*/)[0],
          borderRight: +calculatedStyle.borderRightWidth.match(/[0-9]*/)[0],
          borderTop: +calculatedStyle.borderTopWidth.match(/[0-9]*/)[0],
          borderBottom: +calculatedStyle.borderBottomWidth.match(/[0-9]*/)[0],
          marginLeft: +calculatedStyle.marginLeft.match(/[0-9]*/)[0],
          marginRight: +calculatedStyle.marginRight.match(/[0-9]*/)[0],
          marginTop: +calculatedStyle.marginTop.match(/[0-9]*/)[0],
          marginBottom: +calculatedStyle.marginBottom.match(/[0-9]*/)[0],
          paddingLeft: +calculatedStyle.paddingLeft.match(/[0-9]*/)[0],
          paddingRight: +calculatedStyle.paddingRight.match(/[0-9]*/)[0],
          paddingTop: +calculatedStyle.paddingTop.match(/[0-9]*/)[0],
          paddingBottom: +calculatedStyle.paddingBottom.match(/[0-9]*/)[0]
        };
      }

      function getOwnerWindow(node) {
        return node.ownerDocument ? node.ownerDocument.defaultView : null;
      }

      function getOwnerIframe(node) {
        var nodeWindow = getOwnerWindow(node);
        return nodeWindow ? nodeWindow.frameElement : null;
      }

      function getBoundingClientRectWithBorderOffset(node) {
        var dimensions = getElementDimensions(node);
        return mergeRectOffsets([node.getBoundingClientRect(), {
          top: dimensions.borderTop,
          left: dimensions.borderLeft,
          bottom: dimensions.borderBottom,
          right: dimensions.borderRight,
          width: 0,
          height: 0
        }]);
      }

      function mergeRectOffsets(rects) {
        return rects.reduce(function (previousRect, rect) {
          return null == previousRect ? rect : {
            top: previousRect.top + rect.top,
            left: previousRect.left + rect.left,
            width: previousRect.width,
            height: previousRect.height,
            bottom: previousRect.bottom + rect.bottom,
            right: previousRect.right + rect.right
          };
        });
      }

      function getNestedBoundingClientRect(node, boundaryWindow) {
        var ownerIframe = getOwnerIframe(node);

        if (ownerIframe && ownerIframe !== boundaryWindow) {
          for (var rects = [node.getBoundingClientRect()], currentIframe = ownerIframe, onlyOneMore = !1; currentIframe;) {
            var rect = getBoundingClientRectWithBorderOffset(currentIframe);
            if (rects.push(rect), currentIframe = getOwnerIframe(currentIframe), onlyOneMore) break;
            currentIframe && getOwnerWindow(currentIframe) === boundaryWindow && (onlyOneMore = !0);
          }

          return mergeRectOffsets(rects);
        }

        return node.getBoundingClientRect();
      }

      function boxWrap(dims, what, node) {
        assign(node.style, {
          borderTopWidth: dims[what + "Top"] + "px",
          borderLeftWidth: dims[what + "Left"] + "px",
          borderRightWidth: dims[what + "Right"] + "px",
          borderBottomWidth: dims[what + "Bottom"] + "px",
          borderStyle: "solid"
        });
      }

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
        };
      }(),
          assign = __webpack_require__(3),
          _require = __webpack_require__(58),
          monospace = _require.monospace,
          Overlay = function () {
        function Overlay(window) {
          _classCallCheck(this, Overlay);

          var doc = window.document;
          this.win = window, this.container = doc.createElement("div"), this.node = doc.createElement("div"), this.border = doc.createElement("div"), this.padding = doc.createElement("div"), this.content = doc.createElement("div"), this.border.style.borderColor = overlayStyles.border, this.padding.style.borderColor = overlayStyles.padding, this.content.style.backgroundColor = overlayStyles.background, assign(this.node.style, {
            borderColor: overlayStyles.margin,
            pointerEvents: "none",
            position: "fixed"
          }), this.tip = doc.createElement("div"), assign(this.tip.style, {
            backgroundColor: "#333740",
            borderRadius: "2px",
            fontFamily: monospace.family,
            fontWeight: "bold",
            padding: "3px 5px",
            position: "fixed",
            fontSize: monospace.sizes.normal + "px"
          }), this.nameSpan = doc.createElement("span"), this.tip.appendChild(this.nameSpan), assign(this.nameSpan.style, {
            color: "#ee78e6",
            borderRight: "1px solid #aaaaaa",
            paddingRight: "0.5rem",
            marginRight: "0.5rem"
          }), this.dimSpan = doc.createElement("span"), this.tip.appendChild(this.dimSpan), assign(this.dimSpan.style, {
            color: "#d7d7d7"
          }), this.container.style.zIndex = 1e7, this.node.style.zIndex = 1e7, this.tip.style.zIndex = 1e7, this.container.appendChild(this.node), this.container.appendChild(this.tip), this.node.appendChild(this.border), this.border.appendChild(this.padding), this.padding.appendChild(this.content), doc.body.appendChild(this.container);
        }

        return _createClass(Overlay, [{
          key: "remove",
          value: function value() {
            this.container.parentNode && this.container.parentNode.removeChild(this.container);
          }
        }, {
          key: "inspect",
          value: function value(node, name) {
            if (node.nodeType === Node.ELEMENT_NODE) {
              var box = getNestedBoundingClientRect(node, this.win),
                  dims = getElementDimensions(node);
              boxWrap(dims, "margin", this.node), boxWrap(dims, "border", this.border), boxWrap(dims, "padding", this.padding), assign(this.content.style, {
                height: box.height - dims.borderTop - dims.borderBottom - dims.paddingTop - dims.paddingBottom + "px",
                width: box.width - dims.borderLeft - dims.borderRight - dims.paddingLeft - dims.paddingRight + "px"
              }), assign(this.node.style, {
                top: box.top - dims.marginTop + "px",
                left: box.left - dims.marginLeft + "px"
              }), this.nameSpan.textContent = name || node.nodeName.toLowerCase(), this.dimSpan.textContent = box.width + "px × " + box.height + "px";
              var tipPos = findTipPos({
                top: box.top - dims.marginTop,
                left: box.left - dims.marginLeft,
                height: box.height + dims.marginTop + dims.marginBottom,
                width: box.width + dims.marginLeft + dims.marginRight
              }, this.win);
              assign(this.tip.style, tipPos);
            }
          }
        }]), Overlay;
      }(),
          overlayStyles = {
        background: "rgba(120, 170, 210, 0.7)",
        padding: "rgba(77, 200, 0, 0.3)",
        margin: "rgba(255, 155, 0, 0.3)",
        border: "rgba(255, 200, 50, 0.3)"
      };

      module.exports = Overlay;
    }, function (module, exports) {
      "use strict";

      module.exports = {
        monospace: {
          family: "Menlo, Consolas, monospace",
          sizes: {
            normal: 11,
            large: 14
          }
        },
        sansSerif: {
          family: '"Helvetica Neue", "Lucida Grande", -apple-system, BlinkMacSystemFont, "Segoe UI", Ubuntu, sans-serif',
          sizes: {
            small: 10,
            normal: 12,
            large: 14
          }
        }
      };
    }, function (module, exports, __webpack_require__) {
      "use strict";

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
      }

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
        };
      }(),
          assign = __webpack_require__(3),
          MultiOverlay = function () {
        function MultiOverlay(window) {
          _classCallCheck(this, MultiOverlay), this.win = window;
          var doc = window.document;
          this.container = doc.createElement("div"), doc.body.appendChild(this.container), this._currentNodes = null;
        }

        return _createClass(MultiOverlay, [{
          key: "highlightMany",
          value: function value(nodes) {
            var _this = this;

            this._currentNodes = nodes, this.container.innerHTML = "", nodes.forEach(function (node) {
              var div = _this.win.document.createElement("div");

              if ("function" == typeof node.getBoundingClientRect) {
                var box = node.getBoundingClientRect();
                box.bottom < 0 || box.top > window.innerHeight || (assign(div.style, {
                  top: box.top + "px",
                  left: box.left + "px",
                  width: box.width + "px",
                  height: box.height + "px",
                  border: "2px dotted rgba(200, 100, 100, .8)",
                  boxSizing: "border-box",
                  backgroundColor: "rgba(200, 100, 100, .2)",
                  position: "fixed",
                  zIndex: 1e7,
                  pointerEvents: "none"
                }), _this.container.appendChild(div));
              }
            });
          }
        }, {
          key: "refresh",
          value: function value() {
            this._currentNodes && this.highlightMany(this._currentNodes);
          }
        }, {
          key: "remove",
          value: function value() {
            this.container.parentNode && (this.container.parentNode.removeChild(this.container), this._currentNodes = null);
          }
        }]), MultiOverlay;
      }();

      module.exports = MultiOverlay;
    }]);
  });
},253,[112],"node_modules\\react-devtools-core\\build\\backend.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var JSInspector = {
    registerAgent: function registerAgent(type) {
      if (global.__registerInspectorAgent) {
        global.__registerInspectorAgent(type);
      }
    },
    getTimestamp: function getTimestamp() {
      return global.__inspectorTimestamp();
    }
  };
  module.exports = JSInspector;
},254,[],"node_modules\\react-native\\Libraries\\JSInspector\\JSInspector.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/assertThisInitialized");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/defineProperty");

  var InspectorAgent = _$$_REQUIRE(_dependencyMap[7], "InspectorAgent");

  var JSInspector = _$$_REQUIRE(_dependencyMap[8], "JSInspector");

  var Map = _$$_REQUIRE(_dependencyMap[9], "Map");

  var XMLHttpRequest = _$$_REQUIRE(_dependencyMap[10], "XMLHttpRequest");

  var Interceptor = function () {
    function Interceptor(agent) {
      _classCallCheck(this, Interceptor);

      _defineProperty(this, "_agent", void 0);

      _defineProperty(this, "_requests", void 0);

      this._agent = agent;
      this._requests = new Map();
    }

    _createClass(Interceptor, [{
      key: "getData",
      value: function getData(requestId) {
        return this._requests.get(requestId);
      }
    }, {
      key: "requestSent",
      value: function requestSent(id, url, method, headers) {
        var requestId = String(id);

        this._requests.set(requestId, '');

        var request = {
          url: url,
          method: method,
          headers: headers,
          initialPriority: 'Medium'
        };
        var event = {
          requestId: requestId,
          documentURL: '',
          frameId: '1',
          loaderId: '1',
          request: request,
          timestamp: JSInspector.getTimestamp(),
          initiator: {
            type: 'other'
          },
          type: 'Other'
        };

        this._agent.sendEvent('requestWillBeSent', event);
      }
    }, {
      key: "responseReceived",
      value: function responseReceived(id, url, status, headers) {
        var requestId = String(id);
        var response = {
          url: url,
          status: status,
          statusText: String(status),
          headers: headers,
          requestHeaders: {},
          mimeType: this._getMimeType(headers),
          connectionReused: false,
          connectionId: -1,
          encodedDataLength: 0,
          securityState: 'unknown'
        };
        var event = {
          requestId: requestId,
          frameId: '1',
          loaderId: '1',
          timestamp: JSInspector.getTimestamp(),
          type: 'Other',
          response: response
        };

        this._agent.sendEvent('responseReceived', event);
      }
    }, {
      key: "dataReceived",
      value: function dataReceived(id, data) {
        var requestId = String(id);
        var existingData = this._requests.get(requestId) || '';

        this._requests.set(requestId, existingData.concat(data));

        var event = {
          requestId: requestId,
          timestamp: JSInspector.getTimestamp(),
          dataLength: data.length,
          encodedDataLength: data.length
        };

        this._agent.sendEvent('dataReceived', event);
      }
    }, {
      key: "loadingFinished",
      value: function loadingFinished(id, encodedDataLength) {
        var event = {
          requestId: String(id),
          timestamp: JSInspector.getTimestamp(),
          encodedDataLength: encodedDataLength
        };

        this._agent.sendEvent('loadingFinished', event);
      }
    }, {
      key: "loadingFailed",
      value: function loadingFailed(id, error) {
        var event = {
          requestId: String(id),
          timestamp: JSInspector.getTimestamp(),
          type: 'Other',
          errorText: error
        };

        this._agent.sendEvent('loadingFailed', event);
      }
    }, {
      key: "_getMimeType",
      value: function _getMimeType(headers) {
        var contentType = headers['Content-Type'] || '';
        return contentType.split(';')[0];
      }
    }]);

    return Interceptor;
  }();

  var NetworkAgent = function (_InspectorAgent) {
    _inherits(NetworkAgent, _InspectorAgent);

    function NetworkAgent() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, NetworkAgent);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(NetworkAgent)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_sendEvent", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_interceptor", void 0);

      return _this;
    }

    _createClass(NetworkAgent, [{
      key: "enable",
      value: function enable(_ref) {
        var maxResourceBufferSize = _ref.maxResourceBufferSize,
            maxTotalBufferSize = _ref.maxTotalBufferSize;
        this._interceptor = new Interceptor(this);
        XMLHttpRequest.setInterceptor(this._interceptor);
      }
    }, {
      key: "disable",
      value: function disable() {
        XMLHttpRequest.setInterceptor(null);
        this._interceptor = null;
      }
    }, {
      key: "getResponseBody",
      value: function getResponseBody(_ref2) {
        var requestId = _ref2.requestId;
        return {
          body: this.interceptor().getData(requestId),
          base64Encoded: false
        };
      }
    }, {
      key: "interceptor",
      value: function interceptor() {
        if (this._interceptor) {
          return this._interceptor;
        } else {
          throw Error('_interceptor can not be null');
        }
      }
    }]);

    return NetworkAgent;
  }(InspectorAgent);

  _defineProperty(NetworkAgent, "DOMAIN", 'Network');

  module.exports = NetworkAgent;
},255,[26,29,30,28,24,25,32,256,254,183,212],"node_modules\\react-native\\Libraries\\JSInspector\\NetworkAgent.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/defineProperty");

  var InspectorAgent = function () {
    function InspectorAgent(eventSender) {
      _classCallCheck(this, InspectorAgent);

      _defineProperty(this, "_eventSender", void 0);

      this._eventSender = eventSender;
    }

    _createClass(InspectorAgent, [{
      key: "sendEvent",
      value: function sendEvent(name, params) {
        this._eventSender(name, params);
      }
    }]);

    return InspectorAgent;
  }();

  module.exports = InspectorAgent;
},256,[24,25,32],"node_modules\\react-native\\Libraries\\JSInspector\\InspectorAgent.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var invariant = _$$_REQUIRE(_dependencyMap[0], "fbjs/lib/invariant");

  var customBubblingEventTypes = {};
  var customDirectEventTypes = {};
  var eventTypes = {};
  exports.customBubblingEventTypes = customBubblingEventTypes;
  exports.customDirectEventTypes = customDirectEventTypes;
  exports.eventTypes = eventTypes;
  var viewConfigCallbacks = new Map();
  var viewConfigs = new Map();

  function processEventTypes(viewConfig) {
    var bubblingEventTypes = viewConfig.bubblingEventTypes,
        directEventTypes = viewConfig.directEventTypes;

    if (__DEV__) {
      if (bubblingEventTypes != null && directEventTypes != null) {
        for (var topLevelType in directEventTypes) {
          invariant(bubblingEventTypes[topLevelType] == null, 'Event cannot be both direct and bubbling: %s', topLevelType);
        }
      }
    }

    if (bubblingEventTypes != null) {
      for (var _topLevelType in bubblingEventTypes) {
        if (customBubblingEventTypes[_topLevelType] == null) {
          eventTypes[_topLevelType] = customBubblingEventTypes[_topLevelType] = bubblingEventTypes[_topLevelType];
        }
      }
    }

    if (directEventTypes != null) {
      for (var _topLevelType2 in directEventTypes) {
        if (customDirectEventTypes[_topLevelType2] == null) {
          eventTypes[_topLevelType2] = customDirectEventTypes[_topLevelType2] = directEventTypes[_topLevelType2];
        }
      }
    }
  }

  exports.register = function (name, callback) {
    invariant(!viewConfigCallbacks.has(name), 'Tried to register two views with the same name %s', name);
    viewConfigCallbacks.set(name, callback);
    return name;
  };

  exports.get = function (name) {
    var viewConfig;

    if (!viewConfigs.has(name)) {
      var callback = viewConfigCallbacks.get(name);

      if (typeof callback !== 'function') {
        invariant(false, 'View config not found for name %s.%s', name, typeof name[0] === 'string' && /[a-z]/.test(name[0]) ? ' Make sure to start component names with a capital letter.' : '');
      }

      viewConfigCallbacks.set(name, null);
      viewConfig = callback();
      processEventTypes(viewConfig);
      viewConfigs.set(name, viewConfig);
    } else {
      viewConfig = viewConfigs.get(name);
    }

    invariant(viewConfig, 'View config not found for name %s', name);
    return viewConfig;
  };
},257,[117],"node_modules\\react-native\\Libraries\\Renderer\\shims\\ReactNativeViewConfigRegistry.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var BatchedBridge = _$$_REQUIRE(_dependencyMap[0], "BatchedBridge");

  var RCTEventEmitter = {
    register: function register(eventEmitter) {
      BatchedBridge.registerCallableModule('RCTEventEmitter', eventEmitter);
    }
  };
  module.exports = RCTEventEmitter;
},258,[126],"node_modules\\react-native\\Libraries\\EventEmitter\\RCTEventEmitter.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var deepDiffer = function deepDiffer(one, two) {
    var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

    if (maxDepth === 0) {
      return true;
    }

    if (one === two) {
      return false;
    }

    if (typeof one === 'function' && typeof two === 'function') {
      return false;
    }

    if (typeof one !== 'object' || one === null) {
      return one !== two;
    }

    if (typeof two !== 'object' || two === null) {
      return true;
    }

    if (one.constructor !== two.constructor) {
      return true;
    }

    if (Array.isArray(one)) {
      var len = one.length;

      if (two.length !== len) {
        return true;
      }

      for (var ii = 0; ii < len; ii++) {
        if (deepDiffer(one[ii], two[ii], maxDepth - 1)) {
          return true;
        }
      }
    } else {
      for (var key in one) {
        if (deepDiffer(one[key], two[key], maxDepth - 1)) {
          return true;
        }
      }

      for (var twoKey in two) {
        if (one[twoKey] === undefined && two[twoKey] !== undefined) {
          return true;
        }
      }
    }

    return false;
  };

  module.exports = deepDiffer;
},259,[],"node_modules\\react-native\\Libraries\\Utilities\\differ\\deepDiffer.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Platform = _$$_REQUIRE(_dependencyMap[0], "Platform");

  var UIManager = _$$_REQUIRE(_dependencyMap[1], "UIManager");

  var currentlyFocusedID = null;
  var inputs = new Set();

  function currentlyFocusedField() {
    return currentlyFocusedID;
  }

  function focusTextInput(textFieldID) {
    if (currentlyFocusedID !== textFieldID && textFieldID !== null) {
      currentlyFocusedID = textFieldID;

      if (Platform.OS === 'ios') {
        UIManager.focus(textFieldID);
      } else if (Platform.OS === 'android') {
        UIManager.dispatchViewManagerCommand(textFieldID, UIManager.AndroidTextInput.Commands.focusTextInput, null);
      }
    }
  }

  function blurTextInput(textFieldID) {
    if (currentlyFocusedID === textFieldID && textFieldID !== null) {
      currentlyFocusedID = null;

      if (Platform.OS === 'ios') {
        UIManager.blur(textFieldID);
      } else if (Platform.OS === 'android') {
        UIManager.dispatchViewManagerCommand(textFieldID, UIManager.AndroidTextInput.Commands.blurTextInput, null);
      }
    }
  }

  function registerInput(textFieldID) {
    inputs.add(textFieldID);
  }

  function unregisterInput(textFieldID) {
    inputs.delete(textFieldID);
  }

  function isTextInput(textFieldID) {
    return inputs.has(textFieldID);
  }

  module.exports = {
    currentlyFocusedField: currentlyFocusedField,
    focusTextInput: focusTextInput,
    blurTextInput: blurTextInput,
    registerInput: registerInput,
    unregisterInput: unregisterInput,
    isTextInput: isTextInput
  };
},260,[146,145],"node_modules\\react-native\\Libraries\\Components\\TextInput\\TextInputState.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = _$$_REQUIRE(_dependencyMap[0], "./cjs/scheduler-tracing.production.min.js");
  } else {
    module.exports = _$$_REQUIRE(_dependencyMap[1], "./cjs/scheduler-tracing.development.js");
  }
},261,[262,263],"node_modules\\scheduler\\tracing.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /** @license React v16.6.1
   * scheduler-tracing.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  var b = 0;
  exports.__interactionsRef = null;
  exports.__subscriberRef = null;

  exports.unstable_clear = function (a) {
    return a();
  };

  exports.unstable_getCurrent = function () {
    return null;
  };

  exports.unstable_getThreadID = function () {
    return ++b;
  };

  exports.unstable_trace = function (a, d, c) {
    return c();
  };

  exports.unstable_wrap = function (a) {
    return a;
  };

  exports.unstable_subscribe = function () {};

  exports.unstable_unsubscribe = function () {};
},262,[],"node_modules\\scheduler\\cjs\\scheduler-tracing.production.min.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /** @license React v16.6.1
   * scheduler-tracing.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  if (process.env.NODE_ENV !== "production") {
    (function () {
      'use strict';

      Object.defineProperty(exports, '__esModule', {
        value: true
      });
      var enableSchedulerTracing = true;
      var DEFAULT_THREAD_ID = 0;
      var interactionIDCounter = 0;
      var threadIDCounter = 0;
      exports.__interactionsRef = null;
      exports.__subscriberRef = null;

      if (enableSchedulerTracing) {
        exports.__interactionsRef = {
          current: new Set()
        };
        exports.__subscriberRef = {
          current: null
        };
      }

      function unstable_clear(callback) {
        if (!enableSchedulerTracing) {
          return callback();
        }

        var prevInteractions = exports.__interactionsRef.current;
        exports.__interactionsRef.current = new Set();

        try {
          return callback();
        } finally {
          exports.__interactionsRef.current = prevInteractions;
        }
      }

      function unstable_getCurrent() {
        if (!enableSchedulerTracing) {
          return null;
        } else {
          return exports.__interactionsRef.current;
        }
      }

      function unstable_getThreadID() {
        return ++threadIDCounter;
      }

      function unstable_trace(name, timestamp, callback) {
        var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;

        if (!enableSchedulerTracing) {
          return callback();
        }

        var interaction = {
          __count: 1,
          id: interactionIDCounter++,
          name: name,
          timestamp: timestamp
        };
        var prevInteractions = exports.__interactionsRef.current;
        var interactions = new Set(prevInteractions);
        interactions.add(interaction);
        exports.__interactionsRef.current = interactions;
        var subscriber = exports.__subscriberRef.current;
        var returnValue = void 0;

        try {
          if (subscriber !== null) {
            subscriber.onInteractionTraced(interaction);
          }
        } finally {
          try {
            if (subscriber !== null) {
              subscriber.onWorkStarted(interactions, threadID);
            }
          } finally {
            try {
              returnValue = callback();
            } finally {
              exports.__interactionsRef.current = prevInteractions;

              try {
                if (subscriber !== null) {
                  subscriber.onWorkStopped(interactions, threadID);
                }
              } finally {
                interaction.__count--;

                if (subscriber !== null && interaction.__count === 0) {
                  subscriber.onInteractionScheduledWorkCompleted(interaction);
                }
              }
            }
          }
        }

        return returnValue;
      }

      function unstable_wrap(callback) {
        var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;

        if (!enableSchedulerTracing) {
          return callback;
        }

        var wrappedInteractions = exports.__interactionsRef.current;
        var subscriber = exports.__subscriberRef.current;

        if (subscriber !== null) {
          subscriber.onWorkScheduled(wrappedInteractions, threadID);
        }

        wrappedInteractions.forEach(function (interaction) {
          interaction.__count++;
        });
        var hasRun = false;

        function wrapped() {
          var prevInteractions = exports.__interactionsRef.current;
          exports.__interactionsRef.current = wrappedInteractions;
          subscriber = exports.__subscriberRef.current;

          try {
            var returnValue = void 0;

            try {
              if (subscriber !== null) {
                subscriber.onWorkStarted(wrappedInteractions, threadID);
              }
            } finally {
              try {
                returnValue = callback.apply(undefined, arguments);
              } finally {
                exports.__interactionsRef.current = prevInteractions;

                if (subscriber !== null) {
                  subscriber.onWorkStopped(wrappedInteractions, threadID);
                }
              }
            }

            return returnValue;
          } finally {
            if (!hasRun) {
              hasRun = true;
              wrappedInteractions.forEach(function (interaction) {
                interaction.__count--;

                if (subscriber !== null && interaction.__count === 0) {
                  subscriber.onInteractionScheduledWorkCompleted(interaction);
                }
              });
            }
          }
        }

        wrapped.cancel = function cancel() {
          subscriber = exports.__subscriberRef.current;

          try {
            if (subscriber !== null) {
              subscriber.onWorkCanceled(wrappedInteractions, threadID);
            }
          } finally {
            wrappedInteractions.forEach(function (interaction) {
              interaction.__count--;

              if (subscriber && interaction.__count === 0) {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
              }
            });
          }
        };

        return wrapped;
      }

      var subscribers = null;

      if (enableSchedulerTracing) {
        subscribers = new Set();
      }

      function unstable_subscribe(subscriber) {
        if (enableSchedulerTracing) {
          subscribers.add(subscriber);

          if (subscribers.size === 1) {
            exports.__subscriberRef.current = {
              onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,
              onInteractionTraced: onInteractionTraced,
              onWorkCanceled: onWorkCanceled,
              onWorkScheduled: onWorkScheduled,
              onWorkStarted: onWorkStarted,
              onWorkStopped: onWorkStopped
            };
          }
        }
      }

      function unstable_unsubscribe(subscriber) {
        if (enableSchedulerTracing) {
          subscribers.delete(subscriber);

          if (subscribers.size === 0) {
            exports.__subscriberRef.current = null;
          }
        }
      }

      function onInteractionTraced(interaction) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function (subscriber) {
          try {
            subscriber.onInteractionTraced(interaction);
          } catch (error) {
            if (!didCatchError) {
              didCatchError = true;
              caughtError = error;
            }
          }
        });

        if (didCatchError) {
          throw caughtError;
        }
      }

      function onInteractionScheduledWorkCompleted(interaction) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function (subscriber) {
          try {
            subscriber.onInteractionScheduledWorkCompleted(interaction);
          } catch (error) {
            if (!didCatchError) {
              didCatchError = true;
              caughtError = error;
            }
          }
        });

        if (didCatchError) {
          throw caughtError;
        }
      }

      function onWorkScheduled(interactions, threadID) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function (subscriber) {
          try {
            subscriber.onWorkScheduled(interactions, threadID);
          } catch (error) {
            if (!didCatchError) {
              didCatchError = true;
              caughtError = error;
            }
          }
        });

        if (didCatchError) {
          throw caughtError;
        }
      }

      function onWorkStarted(interactions, threadID) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function (subscriber) {
          try {
            subscriber.onWorkStarted(interactions, threadID);
          } catch (error) {
            if (!didCatchError) {
              didCatchError = true;
              caughtError = error;
            }
          }
        });

        if (didCatchError) {
          throw caughtError;
        }
      }

      function onWorkStopped(interactions, threadID) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function (subscriber) {
          try {
            subscriber.onWorkStopped(interactions, threadID);
          } catch (error) {
            if (!didCatchError) {
              didCatchError = true;
              caughtError = error;
            }
          }
        });

        if (didCatchError) {
          throw caughtError;
        }
      }

      function onWorkCanceled(interactions, threadID) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function (subscriber) {
          try {
            subscriber.onWorkCanceled(interactions, threadID);
          } catch (error) {
            if (!didCatchError) {
              didCatchError = true;
              caughtError = error;
            }
          }
        });

        if (didCatchError) {
          throw caughtError;
        }
      }

      exports.unstable_clear = unstable_clear;
      exports.unstable_getCurrent = unstable_getCurrent;
      exports.unstable_getThreadID = unstable_getThreadID;
      exports.unstable_trace = unstable_trace;
      exports.unstable_wrap = unstable_wrap;
      exports.unstable_subscribe = unstable_subscribe;
      exports.unstable_unsubscribe = unstable_unsubscribe;
    })();
  }
},263,[],"node_modules\\scheduler\\cjs\\scheduler-tracing.development.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = _$$_REQUIRE(_dependencyMap[0], "./cjs/scheduler.production.min.js");
  } else {
    module.exports = _$$_REQUIRE(_dependencyMap[1], "./cjs/scheduler.development.js");
  }
},264,[265,266],"node_modules\\scheduler\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /** @license React v16.6.1
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  var d = null,
      f = !1,
      h = 3,
      k = -1,
      l = -1,
      m = !1,
      n = !1;

  function p() {
    if (!m) {
      var a = d.expirationTime;
      n ? q() : n = !0;

      _r(t, a);
    }
  }

  function u() {
    var a = d,
        b = d.next;
    if (d === b) d = null;else {
      var c = d.previous;
      d = c.next = b;
      b.previous = c;
    }
    a.next = a.previous = null;
    c = a.callback;
    b = a.expirationTime;
    a = a.priorityLevel;
    var e = h,
        Q = l;
    h = a;
    l = b;

    try {
      var g = c();
    } finally {
      h = e, l = Q;
    }

    if ("function" === typeof g) if (g = {
      callback: g,
      priorityLevel: a,
      expirationTime: b,
      next: null,
      previous: null
    }, null === d) d = g.next = g.previous = g;else {
      c = null;
      a = d;

      do {
        if (a.expirationTime >= b) {
          c = a;
          break;
        }

        a = a.next;
      } while (a !== d);

      null === c ? c = d : c === d && (d = g, p());
      b = c.previous;
      b.next = c.previous = g;
      g.next = c;
      g.previous = b;
    }
  }

  function v() {
    if (-1 === k && null !== d && 1 === d.priorityLevel) {
      m = !0;

      try {
        do {
          u();
        } while (null !== d && 1 === d.priorityLevel);
      } finally {
        m = !1, null !== d ? p() : n = !1;
      }
    }
  }

  function t(a) {
    m = !0;
    var b = f;
    f = a;

    try {
      if (a) for (; null !== d;) {
        var c = exports.unstable_now();

        if (d.expirationTime <= c) {
          do {
            u();
          } while (null !== d && d.expirationTime <= c);
        } else break;
      } else if (null !== d) {
        do {
          u();
        } while (null !== d && !w());
      }
    } finally {
      m = !1, f = b, null !== d ? p() : n = !1, v();
    }
  }

  var x = Date,
      y = "function" === typeof setTimeout ? setTimeout : void 0,
      z = "function" === typeof clearTimeout ? clearTimeout : void 0,
      A = "function" === typeof requestAnimationFrame ? requestAnimationFrame : void 0,
      B = "function" === typeof cancelAnimationFrame ? cancelAnimationFrame : void 0,
      C,
      D;

  function E(a) {
    C = A(function (b) {
      z(D);
      a(b);
    });
    D = y(function () {
      B(C);
      a(exports.unstable_now());
    }, 100);
  }

  if ("object" === typeof performance && "function" === typeof performance.now) {
    var F = performance;

    exports.unstable_now = function () {
      return F.now();
    };
  } else exports.unstable_now = function () {
    return x.now();
  };

  var _r, q, w;

  if ("undefined" !== typeof window && window._schedMock) {
    var G = window._schedMock;
    _r = G[0];
    q = G[1];
    w = G[2];
  } else if ("undefined" === typeof window || "function" !== typeof window.addEventListener) {
    var H = null,
        I = -1,
        J = function J(a, b) {
      if (null !== H) {
        var c = H;
        H = null;

        try {
          I = b, c(a);
        } finally {
          I = -1;
        }
      }
    };

    _r = function r(a, b) {
      -1 !== I ? setTimeout(_r, 0, a, b) : (H = a, setTimeout(J, b, !0, b), setTimeout(J, 1073741823, !1, 1073741823));
    };

    q = function q() {
      H = null;
    };

    w = function w() {
      return !1;
    };

    exports.unstable_now = function () {
      return -1 === I ? 0 : I;
    };
  } else {
    "undefined" !== typeof console && ("function" !== typeof A && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"), "function" !== typeof B && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));
    var K = null,
        L = !1,
        M = -1,
        N = !1,
        O = !1,
        P = 0,
        R = 33,
        S = 33;

    w = function w() {
      return P <= exports.unstable_now();
    };

    var T = "__reactIdleCallback$" + Math.random().toString(36).slice(2);
    window.addEventListener("message", function (a) {
      if (a.source === window && a.data === T) {
        L = !1;
        a = K;
        var b = M;
        K = null;
        M = -1;
        var c = exports.unstable_now(),
            e = !1;
        if (0 >= P - c) if (-1 !== b && b <= c) e = !0;else {
          N || (N = !0, E(U));
          K = a;
          M = b;
          return;
        }

        if (null !== a) {
          O = !0;

          try {
            a(e);
          } finally {
            O = !1;
          }
        }
      }
    }, !1);

    var U = function U(a) {
      if (null !== K) {
        E(U);
        var b = a - P + S;
        b < S && R < S ? (8 > b && (b = 8), S = b < R ? R : b) : R = b;
        P = a + S;
        L || (L = !0, window.postMessage(T, "*"));
      } else N = !1;
    };

    _r = function _r(a, b) {
      K = a;
      M = b;
      O || 0 > b ? window.postMessage(T, "*") : N || (N = !0, E(U));
    };

    q = function q() {
      K = null;
      L = !1;
      M = -1;
    };
  }

  exports.unstable_ImmediatePriority = 1;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_NormalPriority = 3;
  exports.unstable_IdlePriority = 5;
  exports.unstable_LowPriority = 4;

  exports.unstable_runWithPriority = function (a, b) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;

      default:
        a = 3;
    }

    var c = h,
        e = k;
    h = a;
    k = exports.unstable_now();

    try {
      return b();
    } finally {
      h = c, k = e, v();
    }
  };

  exports.unstable_scheduleCallback = function (a, b) {
    var c = -1 !== k ? k : exports.unstable_now();
    if ("object" === typeof b && null !== b && "number" === typeof b.timeout) b = c + b.timeout;else switch (h) {
      case 1:
        b = c + -1;
        break;

      case 2:
        b = c + 250;
        break;

      case 5:
        b = c + 1073741823;
        break;

      case 4:
        b = c + 1E4;
        break;

      default:
        b = c + 5E3;
    }
    a = {
      callback: a,
      priorityLevel: h,
      expirationTime: b,
      next: null,
      previous: null
    };
    if (null === d) d = a.next = a.previous = a, p();else {
      c = null;
      var e = d;

      do {
        if (e.expirationTime > b) {
          c = e;
          break;
        }

        e = e.next;
      } while (e !== d);

      null === c ? c = d : c === d && (d = a, p());
      b = c.previous;
      b.next = c.previous = a;
      a.next = c;
      a.previous = b;
    }
    return a;
  };

  exports.unstable_cancelCallback = function (a) {
    var b = a.next;

    if (null !== b) {
      if (b === a) d = null;else {
        a === d && (d = b);
        var c = a.previous;
        c.next = b;
        b.previous = c;
      }
      a.next = a.previous = null;
    }
  };

  exports.unstable_wrapCallback = function (a) {
    var b = h;
    return function () {
      var c = h,
          e = k;
      h = b;
      k = exports.unstable_now();

      try {
        return a.apply(this, arguments);
      } finally {
        h = c, k = e, v();
      }
    };
  };

  exports.unstable_getCurrentPriorityLevel = function () {
    return h;
  };

  exports.unstable_shouldYield = function () {
    return !f && (null !== d && d.expirationTime < l || w());
  };
},265,[],"node_modules\\scheduler\\cjs\\scheduler.production.min.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /** @license React v16.6.1
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  if (process.env.NODE_ENV !== "production") {
    (function () {
      'use strict';

      Object.defineProperty(exports, '__esModule', {
        value: true
      });
      var ImmediatePriority = 1;
      var UserBlockingPriority = 2;
      var NormalPriority = 3;
      var LowPriority = 4;
      var IdlePriority = 5;
      var maxSigned31BitInt = 1073741823;
      var IMMEDIATE_PRIORITY_TIMEOUT = -1;
      var USER_BLOCKING_PRIORITY = 250;
      var NORMAL_PRIORITY_TIMEOUT = 5000;
      var LOW_PRIORITY_TIMEOUT = 10000;
      var IDLE_PRIORITY = maxSigned31BitInt;
      var firstCallbackNode = null;
      var currentDidTimeout = false;
      var currentPriorityLevel = NormalPriority;
      var currentEventStartTime = -1;
      var currentExpirationTime = -1;
      var isExecutingCallback = false;
      var isHostCallbackScheduled = false;
      var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

      function ensureHostCallbackIsScheduled() {
        if (isExecutingCallback) {
          return;
        }

        var expirationTime = firstCallbackNode.expirationTime;

        if (!isHostCallbackScheduled) {
          isHostCallbackScheduled = true;
        } else {
          cancelHostCallback();
        }

        _requestHostCallback(flushWork, expirationTime);
      }

      function flushFirstCallback() {
        var flushedNode = firstCallbackNode;
        var next = firstCallbackNode.next;

        if (firstCallbackNode === next) {
          firstCallbackNode = null;
          next = null;
        } else {
          var lastCallbackNode = firstCallbackNode.previous;
          firstCallbackNode = lastCallbackNode.next = next;
          next.previous = lastCallbackNode;
        }

        flushedNode.next = flushedNode.previous = null;
        var callback = flushedNode.callback;
        var expirationTime = flushedNode.expirationTime;
        var priorityLevel = flushedNode.priorityLevel;
        var previousPriorityLevel = currentPriorityLevel;
        var previousExpirationTime = currentExpirationTime;
        currentPriorityLevel = priorityLevel;
        currentExpirationTime = expirationTime;
        var continuationCallback;

        try {
          continuationCallback = callback();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
          currentExpirationTime = previousExpirationTime;
        }

        if (typeof continuationCallback === 'function') {
          var continuationNode = {
            callback: continuationCallback,
            priorityLevel: priorityLevel,
            expirationTime: expirationTime,
            next: null,
            previous: null
          };

          if (firstCallbackNode === null) {
            firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;
          } else {
            var nextAfterContinuation = null;
            var node = firstCallbackNode;

            do {
              if (node.expirationTime >= expirationTime) {
                nextAfterContinuation = node;
                break;
              }

              node = node.next;
            } while (node !== firstCallbackNode);

            if (nextAfterContinuation === null) {
              nextAfterContinuation = firstCallbackNode;
            } else if (nextAfterContinuation === firstCallbackNode) {
              firstCallbackNode = continuationNode;
              ensureHostCallbackIsScheduled();
            }

            var previous = nextAfterContinuation.previous;
            previous.next = nextAfterContinuation.previous = continuationNode;
            continuationNode.next = nextAfterContinuation;
            continuationNode.previous = previous;
          }
        }
      }

      function flushImmediateWork() {
        if (currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {
          isExecutingCallback = true;

          try {
            do {
              flushFirstCallback();
            } while (firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);
          } finally {
            isExecutingCallback = false;

            if (firstCallbackNode !== null) {
              ensureHostCallbackIsScheduled();
            } else {
              isHostCallbackScheduled = false;
            }
          }
        }
      }

      function flushWork(didTimeout) {
        isExecutingCallback = true;
        var previousDidTimeout = currentDidTimeout;
        currentDidTimeout = didTimeout;

        try {
          if (didTimeout) {
            while (firstCallbackNode !== null) {
              var currentTime = exports.unstable_now();

              if (firstCallbackNode.expirationTime <= currentTime) {
                do {
                  flushFirstCallback();
                } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime);

                continue;
              }

              break;
            }
          } else {
            if (firstCallbackNode !== null) {
              do {
                flushFirstCallback();
              } while (firstCallbackNode !== null && !shouldYieldToHost());
            }
          }
        } finally {
          isExecutingCallback = false;
          currentDidTimeout = previousDidTimeout;

          if (firstCallbackNode !== null) {
            ensureHostCallbackIsScheduled();
          } else {
            isHostCallbackScheduled = false;
          }

          flushImmediateWork();
        }
      }

      function unstable_runWithPriority(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case ImmediatePriority:
          case UserBlockingPriority:
          case NormalPriority:
          case LowPriority:
          case IdlePriority:
            break;

          default:
            priorityLevel = NormalPriority;
        }

        var previousPriorityLevel = currentPriorityLevel;
        var previousEventStartTime = currentEventStartTime;
        currentPriorityLevel = priorityLevel;
        currentEventStartTime = exports.unstable_now();

        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
          currentEventStartTime = previousEventStartTime;
          flushImmediateWork();
        }
      }

      function unstable_wrapCallback(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function () {
          var previousPriorityLevel = currentPriorityLevel;
          var previousEventStartTime = currentEventStartTime;
          currentPriorityLevel = parentPriorityLevel;
          currentEventStartTime = exports.unstable_now();

          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
            currentEventStartTime = previousEventStartTime;
            flushImmediateWork();
          }
        };
      }

      function unstable_scheduleCallback(callback, deprecated_options) {
        var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();
        var expirationTime;

        if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {
          expirationTime = startTime + deprecated_options.timeout;
        } else {
          switch (currentPriorityLevel) {
            case ImmediatePriority:
              expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;
              break;

            case UserBlockingPriority:
              expirationTime = startTime + USER_BLOCKING_PRIORITY;
              break;

            case IdlePriority:
              expirationTime = startTime + IDLE_PRIORITY;
              break;

            case LowPriority:
              expirationTime = startTime + LOW_PRIORITY_TIMEOUT;
              break;

            case NormalPriority:
            default:
              expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;
          }
        }

        var newNode = {
          callback: callback,
          priorityLevel: currentPriorityLevel,
          expirationTime: expirationTime,
          next: null,
          previous: null
        };

        if (firstCallbackNode === null) {
          firstCallbackNode = newNode.next = newNode.previous = newNode;
          ensureHostCallbackIsScheduled();
        } else {
          var next = null;
          var node = firstCallbackNode;

          do {
            if (node.expirationTime > expirationTime) {
              next = node;
              break;
            }

            node = node.next;
          } while (node !== firstCallbackNode);

          if (next === null) {
            next = firstCallbackNode;
          } else if (next === firstCallbackNode) {
            firstCallbackNode = newNode;
            ensureHostCallbackIsScheduled();
          }

          var previous = next.previous;
          previous.next = next.previous = newNode;
          newNode.next = next;
          newNode.previous = previous;
        }

        return newNode;
      }

      function unstable_cancelCallback(callbackNode) {
        var next = callbackNode.next;

        if (next === null) {
          return;
        }

        if (next === callbackNode) {
          firstCallbackNode = null;
        } else {
          if (callbackNode === firstCallbackNode) {
            firstCallbackNode = next;
          }

          var previous = callbackNode.previous;
          previous.next = next;
          next.previous = previous;
        }

        callbackNode.next = callbackNode.previous = null;
      }

      function unstable_getCurrentPriorityLevel() {
        return currentPriorityLevel;
      }

      function unstable_shouldYield() {
        return !currentDidTimeout && (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime || shouldYieldToHost());
      }

      var localDate = Date;
      var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;
      var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;
      var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;
      var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;
      var ANIMATION_FRAME_TIMEOUT = 100;
      var rAFID;
      var rAFTimeoutID;

      var requestAnimationFrameWithTimeout = function requestAnimationFrameWithTimeout(callback) {
        rAFID = localRequestAnimationFrame(function (timestamp) {
          localClearTimeout(rAFTimeoutID);
          callback(timestamp);
        });
        rAFTimeoutID = localSetTimeout(function () {
          localCancelAnimationFrame(rAFID);
          callback(exports.unstable_now());
        }, ANIMATION_FRAME_TIMEOUT);
      };

      if (hasNativePerformanceNow) {
        var Performance = performance;

        exports.unstable_now = function () {
          return Performance.now();
        };
      } else {
        exports.unstable_now = function () {
          return localDate.now();
        };
      }

      var _requestHostCallback;

      var cancelHostCallback;
      var shouldYieldToHost;

      if (typeof window !== 'undefined' && window._schedMock) {
        var impl = window._schedMock;
        _requestHostCallback = impl[0];
        cancelHostCallback = impl[1];
        shouldYieldToHost = impl[2];
      } else if (typeof window === 'undefined' || typeof window.addEventListener !== 'function') {
        var _callback = null;

        var _currentTime = -1;

        var _flushCallback = function _flushCallback(didTimeout, ms) {
          if (_callback !== null) {
            var cb = _callback;
            _callback = null;

            try {
              _currentTime = ms;
              cb(didTimeout);
            } finally {
              _currentTime = -1;
            }
          }
        };

        _requestHostCallback = function requestHostCallback(cb, ms) {
          if (_currentTime !== -1) {
            setTimeout(_requestHostCallback, 0, cb, ms);
          } else {
            _callback = cb;
            setTimeout(_flushCallback, ms, true, ms);
            setTimeout(_flushCallback, maxSigned31BitInt, false, maxSigned31BitInt);
          }
        };

        cancelHostCallback = function cancelHostCallback() {
          _callback = null;
        };

        shouldYieldToHost = function shouldYieldToHost() {
          return false;
        };

        exports.unstable_now = function () {
          return _currentTime === -1 ? 0 : _currentTime;
        };
      } else {
        if (typeof console !== 'undefined') {
          if (typeof localRequestAnimationFrame !== 'function') {
            console.error("This browser doesn't support requestAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
          }

          if (typeof localCancelAnimationFrame !== 'function') {
            console.error("This browser doesn't support cancelAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
          }
        }

        var scheduledHostCallback = null;
        var isMessageEventScheduled = false;
        var timeoutTime = -1;
        var isAnimationFrameScheduled = false;
        var isFlushingHostCallback = false;
        var frameDeadline = 0;
        var previousFrameTime = 33;
        var activeFrameTime = 33;

        shouldYieldToHost = function shouldYieldToHost() {
          return frameDeadline <= exports.unstable_now();
        };

        var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);

        var idleTick = function idleTick(event) {
          if (event.source !== window || event.data !== messageKey) {
            return;
          }

          isMessageEventScheduled = false;
          var prevScheduledCallback = scheduledHostCallback;
          var prevTimeoutTime = timeoutTime;
          scheduledHostCallback = null;
          timeoutTime = -1;
          var currentTime = exports.unstable_now();
          var didTimeout = false;

          if (frameDeadline - currentTime <= 0) {
            if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {
              didTimeout = true;
            } else {
              if (!isAnimationFrameScheduled) {
                isAnimationFrameScheduled = true;
                requestAnimationFrameWithTimeout(animationTick);
              }

              scheduledHostCallback = prevScheduledCallback;
              timeoutTime = prevTimeoutTime;
              return;
            }
          }

          if (prevScheduledCallback !== null) {
            isFlushingHostCallback = true;

            try {
              prevScheduledCallback(didTimeout);
            } finally {
              isFlushingHostCallback = false;
            }
          }
        };

        window.addEventListener('message', idleTick, false);

        var animationTick = function animationTick(rafTime) {
          if (scheduledHostCallback !== null) {
            requestAnimationFrameWithTimeout(animationTick);
          } else {
            isAnimationFrameScheduled = false;
            return;
          }

          var nextFrameTime = rafTime - frameDeadline + activeFrameTime;

          if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {
            if (nextFrameTime < 8) {
              nextFrameTime = 8;
            }

            activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;
          } else {
            previousFrameTime = nextFrameTime;
          }

          frameDeadline = rafTime + activeFrameTime;

          if (!isMessageEventScheduled) {
            isMessageEventScheduled = true;
            window.postMessage(messageKey, '*');
          }
        };

        _requestHostCallback = function _requestHostCallback(callback, absoluteTimeout) {
          scheduledHostCallback = callback;
          timeoutTime = absoluteTimeout;

          if (isFlushingHostCallback || absoluteTimeout < 0) {
            window.postMessage(messageKey, '*');
          } else if (!isAnimationFrameScheduled) {
            isAnimationFrameScheduled = true;
            requestAnimationFrameWithTimeout(animationTick);
          }
        };

        cancelHostCallback = function cancelHostCallback() {
          scheduledHostCallback = null;
          isMessageEventScheduled = false;
          timeoutTime = -1;
        };
      }

      exports.unstable_ImmediatePriority = ImmediatePriority;
      exports.unstable_UserBlockingPriority = UserBlockingPriority;
      exports.unstable_NormalPriority = NormalPriority;
      exports.unstable_IdlePriority = IdlePriority;
      exports.unstable_LowPriority = LowPriority;
      exports.unstable_runWithPriority = unstable_runWithPriority;
      exports.unstable_scheduleCallback = unstable_scheduleCallback;
      exports.unstable_cancelCallback = unstable_cancelCallback;
      exports.unstable_wrapCallback = unstable_wrapCallback;
      exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
      exports.unstable_shouldYield = unstable_shouldYield;
    })();
  }
},266,[],"node_modules\\scheduler\\cjs\\scheduler.development.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  _$$_REQUIRE(_dependencyMap[1], "InitializeCore");

  var ReactNativeViewConfigRegistry = _$$_REQUIRE(_dependencyMap[2], "ReactNativeViewConfigRegistry"),
      UIManager = _$$_REQUIRE(_dependencyMap[3], "UIManager"),
      RCTEventEmitter = _$$_REQUIRE(_dependencyMap[4], "RCTEventEmitter"),
      React = _$$_REQUIRE(_dependencyMap[5], "react"),
      deepDiffer = _$$_REQUIRE(_dependencyMap[6], "deepDiffer"),
      flattenStyle = _$$_REQUIRE(_dependencyMap[7], "flattenStyle"),
      TextInputState = _$$_REQUIRE(_dependencyMap[8], "TextInputState");

  var scheduler = _$$_REQUIRE(_dependencyMap[9], "scheduler"),
      ExceptionsManager = _$$_REQUIRE(_dependencyMap[10], "ExceptionsManager");

  function invariant(condition, format, a, b, c, d, e, f) {
    if (!condition) {
      condition = void 0;
      if (void 0 === format) condition = Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else {
        var args = [a, b, c, d, e, f],
            argIndex = 0;
        condition = Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        condition.name = "Invariant Violation";
      }
      condition.framesToPop = 1;
      throw condition;
    }
  }

  function invokeGuardedCallbackImpl(name, func, context, a, b, c, d, e, f) {
    var funcArgs = Array.prototype.slice.call(arguments, 3);

    try {
      func.apply(context, funcArgs);
    } catch (error) {
      this.onError(error);
    }
  }

  var hasError = !1,
      caughtError = null,
      hasRethrowError = !1,
      rethrowError = null,
      reporter = {
    onError: function onError(error) {
      hasError = !0;
      caughtError = error;
    }
  };

  function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
    hasError = !1;
    caughtError = null;
    invokeGuardedCallbackImpl.apply(reporter, arguments);
  }

  function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
    invokeGuardedCallback.apply(this, arguments);

    if (hasError) {
      if (hasError) {
        var error = caughtError;
        hasError = !1;
        caughtError = null;
      } else invariant(!1, "clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue."), error = void 0;

      hasRethrowError || (hasRethrowError = !0, rethrowError = error);
    }
  }

  var eventPluginOrder = null,
      namesToPlugins = {};

  function recomputePluginOrdering() {
    if (eventPluginOrder) for (var pluginName in namesToPlugins) {
      var pluginModule = namesToPlugins[pluginName],
          pluginIndex = eventPluginOrder.indexOf(pluginName);
      invariant(-1 < pluginIndex, "EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.", pluginName);

      if (!plugins[pluginIndex]) {
        invariant(pluginModule.extractEvents, "EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.", pluginName);
        plugins[pluginIndex] = pluginModule;
        pluginIndex = pluginModule.eventTypes;

        for (var eventName in pluginIndex) {
          var JSCompiler_inline_result = void 0;
          var dispatchConfig = pluginIndex[eventName],
              pluginModule$jscomp$0 = pluginModule,
              eventName$jscomp$0 = eventName;
          invariant(!eventNameDispatchConfigs.hasOwnProperty(eventName$jscomp$0), "EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.", eventName$jscomp$0);
          eventNameDispatchConfigs[eventName$jscomp$0] = dispatchConfig;
          var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

          if (phasedRegistrationNames) {
            for (JSCompiler_inline_result in phasedRegistrationNames) {
              phasedRegistrationNames.hasOwnProperty(JSCompiler_inline_result) && publishRegistrationName(phasedRegistrationNames[JSCompiler_inline_result], pluginModule$jscomp$0, eventName$jscomp$0);
            }

            JSCompiler_inline_result = !0;
          } else dispatchConfig.registrationName ? (publishRegistrationName(dispatchConfig.registrationName, pluginModule$jscomp$0, eventName$jscomp$0), JSCompiler_inline_result = !0) : JSCompiler_inline_result = !1;

          invariant(JSCompiler_inline_result, "EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.", eventName, pluginName);
        }
      }
    }
  }

  function publishRegistrationName(registrationName, pluginModule) {
    invariant(!registrationNameModules[registrationName], "EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
    registrationNameModules[registrationName] = pluginModule;
  }

  var plugins = [],
      eventNameDispatchConfigs = {},
      registrationNameModules = {},
      getFiberCurrentPropsFromNode = null,
      getInstanceFromNode = null,
      getNodeFromInstance = null;

  function executeDispatch(event, listener, inst) {
    var type = event.type || "unknown-event";
    event.currentTarget = getNodeFromInstance(inst);
    invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
    event.currentTarget = null;
  }

  function executeDirectDispatch(event) {
    var dispatchListener = event._dispatchListeners,
        dispatchInstance = event._dispatchInstances;
    invariant(!Array.isArray(dispatchListener), "executeDirectDispatch(...): Invalid `event`.");
    event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;
    dispatchListener = dispatchListener ? dispatchListener(event) : null;
    event.currentTarget = null;
    event._dispatchListeners = null;
    event._dispatchInstances = null;
    return dispatchListener;
  }

  function accumulateInto(current, next) {
    invariant(null != next, "accumulateInto(...): Accumulated items must not be null or undefined.");
    if (null == current) return next;

    if (Array.isArray(current)) {
      if (Array.isArray(next)) return current.push.apply(current, next), current;
      current.push(next);
      return current;
    }

    return Array.isArray(next) ? [current].concat(next) : [current, next];
  }

  function forEachAccumulated(arr, cb, scope) {
    Array.isArray(arr) ? arr.forEach(cb, scope) : arr && cb.call(scope, arr);
  }

  var eventQueue = null;

  function executeDispatchesAndReleaseTopLevel(e) {
    if (e) {
      var dispatchListeners = e._dispatchListeners,
          dispatchInstances = e._dispatchInstances;
      if (Array.isArray(dispatchListeners)) for (var i = 0; i < dispatchListeners.length && !e.isPropagationStopped(); i++) {
        executeDispatch(e, dispatchListeners[i], dispatchInstances[i]);
      } else dispatchListeners && executeDispatch(e, dispatchListeners, dispatchInstances);
      e._dispatchListeners = null;
      e._dispatchInstances = null;
      e.isPersistent() || e.constructor.release(e);
    }
  }

  var injection = {
    injectEventPluginOrder: function injectEventPluginOrder(injectedEventPluginOrder) {
      invariant(!eventPluginOrder, "EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.");
      eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
      recomputePluginOrdering();
    },
    injectEventPluginsByName: function injectEventPluginsByName(injectedNamesToPlugins) {
      var isOrderingDirty = !1,
          pluginName;

      for (pluginName in injectedNamesToPlugins) {
        if (injectedNamesToPlugins.hasOwnProperty(pluginName)) {
          var pluginModule = injectedNamesToPlugins[pluginName];
          namesToPlugins.hasOwnProperty(pluginName) && namesToPlugins[pluginName] === pluginModule || (invariant(!namesToPlugins[pluginName], "EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.", pluginName), namesToPlugins[pluginName] = pluginModule, isOrderingDirty = !0);
        }
      }

      isOrderingDirty && recomputePluginOrdering();
    }
  };

  function getListener(inst, registrationName) {
    var listener = inst.stateNode;
    if (!listener) return null;
    var props = getFiberCurrentPropsFromNode(listener);
    if (!props) return null;
    listener = props[registrationName];

    a: switch (registrationName) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
        (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
        inst = !props;
        break a;

      default:
        inst = !1;
    }

    if (inst) return null;
    invariant(!listener || "function" === typeof listener, "Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
    return listener;
  }

  function getParent(inst) {
    do {
      inst = inst.return;
    } while (inst && 5 !== inst.tag);

    return inst ? inst : null;
  }

  function traverseTwoPhase(inst, fn, arg) {
    for (var path = []; inst;) {
      path.push(inst), inst = getParent(inst);
    }

    for (inst = path.length; 0 < inst--;) {
      fn(path[inst], "captured", arg);
    }

    for (inst = 0; inst < path.length; inst++) {
      fn(path[inst], "bubbled", arg);
    }
  }

  function accumulateDirectionalDispatches(inst, phase, event) {
    if (phase = getListener(inst, event.dispatchConfig.phasedRegistrationNames[phase])) event._dispatchListeners = accumulateInto(event._dispatchListeners, phase), event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }

  function accumulateTwoPhaseDispatchesSingle(event) {
    event && event.dispatchConfig.phasedRegistrationNames && traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }

  function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
    if (event && event.dispatchConfig.phasedRegistrationNames) {
      var targetInst = event._targetInst;
      targetInst = targetInst ? getParent(targetInst) : null;
      traverseTwoPhase(targetInst, accumulateDirectionalDispatches, event);
    }
  }

  function accumulateDirectDispatchesSingle(event) {
    if (event && event.dispatchConfig.registrationName) {
      var inst = event._targetInst;

      if (inst && event && event.dispatchConfig.registrationName) {
        var listener = getListener(inst, event.dispatchConfig.registrationName);
        listener && (event._dispatchListeners = accumulateInto(event._dispatchListeners, listener), event._dispatchInstances = accumulateInto(event._dispatchInstances, inst));
      }
    }
  }

  function functionThatReturnsTrue() {
    return !0;
  }

  function functionThatReturnsFalse() {
    return !1;
  }

  function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
    this.dispatchConfig = dispatchConfig;
    this._targetInst = targetInst;
    this.nativeEvent = nativeEvent;
    dispatchConfig = this.constructor.Interface;

    for (var propName in dispatchConfig) {
      dispatchConfig.hasOwnProperty(propName) && ((targetInst = dispatchConfig[propName]) ? this[propName] = targetInst(nativeEvent) : "target" === propName ? this.target = nativeEventTarget : this[propName] = nativeEvent[propName]);
    }

    this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : !1 === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }

  _extends(SyntheticEvent.prototype, {
    preventDefault: function preventDefault() {
      this.defaultPrevented = !0;
      var event = this.nativeEvent;
      event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = !1), this.isDefaultPrevented = functionThatReturnsTrue);
    },
    stopPropagation: function stopPropagation() {
      var event = this.nativeEvent;
      event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = !0), this.isPropagationStopped = functionThatReturnsTrue);
    },
    persist: function persist() {
      this.isPersistent = functionThatReturnsTrue;
    },
    isPersistent: functionThatReturnsFalse,
    destructor: function destructor() {
      var Interface = this.constructor.Interface,
          propName;

      for (propName in Interface) {
        this[propName] = null;
      }

      this.nativeEvent = this._targetInst = this.dispatchConfig = null;
      this.isPropagationStopped = this.isDefaultPrevented = functionThatReturnsFalse;
      this._dispatchInstances = this._dispatchListeners = null;
    }
  });

  SyntheticEvent.Interface = {
    type: null,
    target: null,
    currentTarget: function currentTarget() {
      return null;
    },
    eventPhase: null,
    bubbles: null,
    cancelable: null,
    timeStamp: function timeStamp(event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: null,
    isTrusted: null
  };

  SyntheticEvent.extend = function (Interface) {
    function E() {}

    function Class() {
      return Super.apply(this, arguments);
    }

    var Super = this;
    E.prototype = Super.prototype;
    var prototype = new E();

    _extends(prototype, Class.prototype);

    Class.prototype = prototype;
    Class.prototype.constructor = Class;
    Class.Interface = _extends({}, Super.Interface, Interface);
    Class.extend = Super.extend;
    addEventPoolingTo(Class);
    return Class;
  };

  addEventPoolingTo(SyntheticEvent);

  function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
    if (this.eventPool.length) {
      var instance = this.eventPool.pop();
      this.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
      return instance;
    }

    return new this(dispatchConfig, targetInst, nativeEvent, nativeInst);
  }

  function releasePooledEvent(event) {
    invariant(event instanceof this, "Trying to release an event instance into a pool of a different type.");
    event.destructor();
    10 > this.eventPool.length && this.eventPool.push(event);
  }

  function addEventPoolingTo(EventConstructor) {
    EventConstructor.eventPool = [];
    EventConstructor.getPooled = getPooledEvent;
    EventConstructor.release = releasePooledEvent;
  }

  var ResponderSyntheticEvent = SyntheticEvent.extend({
    touchHistory: function touchHistory() {
      return null;
    }
  });

  function isStartish(topLevelType) {
    return "topTouchStart" === topLevelType;
  }

  function isMoveish(topLevelType) {
    return "topTouchMove" === topLevelType;
  }

  var startDependencies = ["topTouchStart"],
      moveDependencies = ["topTouchMove"],
      endDependencies = ["topTouchCancel", "topTouchEnd"],
      touchBank = [],
      touchHistory = {
    touchBank: touchBank,
    numberActiveTouches: 0,
    indexOfSingleActiveTouch: -1,
    mostRecentTimeStamp: 0
  };

  function timestampForTouch(touch) {
    return touch.timeStamp || touch.timestamp;
  }

  function getTouchIdentifier(_ref) {
    _ref = _ref.identifier;
    invariant(null != _ref, "Touch object is missing identifier.");
    return _ref;
  }

  function recordTouchStart(touch) {
    var identifier = getTouchIdentifier(touch),
        touchRecord = touchBank[identifier];
    touchRecord ? (touchRecord.touchActive = !0, touchRecord.startPageX = touch.pageX, touchRecord.startPageY = touch.pageY, touchRecord.startTimeStamp = timestampForTouch(touch), touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchRecord.previousPageX = touch.pageX, touchRecord.previousPageY = touch.pageY, touchRecord.previousTimeStamp = timestampForTouch(touch)) : (touchRecord = {
      touchActive: !0,
      startPageX: touch.pageX,
      startPageY: touch.pageY,
      startTimeStamp: timestampForTouch(touch),
      currentPageX: touch.pageX,
      currentPageY: touch.pageY,
      currentTimeStamp: timestampForTouch(touch),
      previousPageX: touch.pageX,
      previousPageY: touch.pageY,
      previousTimeStamp: timestampForTouch(touch)
    }, touchBank[identifier] = touchRecord);
    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
  }

  function recordTouchMove(touch) {
    var touchRecord = touchBank[getTouchIdentifier(touch)];
    touchRecord ? (touchRecord.touchActive = !0, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch)) : console.error("Cannot record touch move without a touch start.\nTouch Move: %s\n", "Touch Bank: %s", printTouch(touch), printTouchBank());
  }

  function recordTouchEnd(touch) {
    var touchRecord = touchBank[getTouchIdentifier(touch)];
    touchRecord ? (touchRecord.touchActive = !1, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch)) : console.error("Cannot record touch end without a touch start.\nTouch End: %s\n", "Touch Bank: %s", printTouch(touch), printTouchBank());
  }

  function printTouch(touch) {
    return JSON.stringify({
      identifier: touch.identifier,
      pageX: touch.pageX,
      pageY: touch.pageY,
      timestamp: timestampForTouch(touch)
    });
  }

  function printTouchBank() {
    var printed = JSON.stringify(touchBank.slice(0, 20));
    20 < touchBank.length && (printed += " (original size: " + touchBank.length + ")");
    return printed;
  }

  var ResponderTouchHistoryStore = {
    recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {
      if (isMoveish(topLevelType)) nativeEvent.changedTouches.forEach(recordTouchMove);else if (isStartish(topLevelType)) nativeEvent.changedTouches.forEach(recordTouchStart), touchHistory.numberActiveTouches = nativeEvent.touches.length, 1 === touchHistory.numberActiveTouches && (touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier);else if ("topTouchEnd" === topLevelType || "topTouchCancel" === topLevelType) if (nativeEvent.changedTouches.forEach(recordTouchEnd), touchHistory.numberActiveTouches = nativeEvent.touches.length, 1 === touchHistory.numberActiveTouches) for (topLevelType = 0; topLevelType < touchBank.length; topLevelType++) {
        if (nativeEvent = touchBank[topLevelType], null != nativeEvent && nativeEvent.touchActive) {
          touchHistory.indexOfSingleActiveTouch = topLevelType;
          break;
        }
      }
    },
    touchHistory: touchHistory
  };

  function accumulate(current, next) {
    invariant(null != next, "accumulate(...): Accumulated items must be not be null or undefined.");
    return null == current ? next : Array.isArray(current) ? current.concat(next) : Array.isArray(next) ? [current].concat(next) : [current, next];
  }

  var responderInst = null,
      trackedTouchCount = 0;

  function changeResponder(nextResponderInst, blockHostResponder) {
    var oldResponderInst = responderInst;
    responderInst = nextResponderInst;
    if (null !== ResponderEventPlugin.GlobalResponderHandler) ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);
  }

  var eventTypes$1 = {
    startShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onStartShouldSetResponder",
        captured: "onStartShouldSetResponderCapture"
      },
      dependencies: startDependencies
    },
    scrollShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onScrollShouldSetResponder",
        captured: "onScrollShouldSetResponderCapture"
      },
      dependencies: ["topScroll"]
    },
    selectionChangeShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onSelectionChangeShouldSetResponder",
        captured: "onSelectionChangeShouldSetResponderCapture"
      },
      dependencies: ["topSelectionChange"]
    },
    moveShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onMoveShouldSetResponder",
        captured: "onMoveShouldSetResponderCapture"
      },
      dependencies: moveDependencies
    },
    responderStart: {
      registrationName: "onResponderStart",
      dependencies: startDependencies
    },
    responderMove: {
      registrationName: "onResponderMove",
      dependencies: moveDependencies
    },
    responderEnd: {
      registrationName: "onResponderEnd",
      dependencies: endDependencies
    },
    responderRelease: {
      registrationName: "onResponderRelease",
      dependencies: endDependencies
    },
    responderTerminationRequest: {
      registrationName: "onResponderTerminationRequest",
      dependencies: []
    },
    responderGrant: {
      registrationName: "onResponderGrant",
      dependencies: []
    },
    responderReject: {
      registrationName: "onResponderReject",
      dependencies: []
    },
    responderTerminate: {
      registrationName: "onResponderTerminate",
      dependencies: []
    }
  },
      ResponderEventPlugin = {
    _getResponder: function _getResponder() {
      return responderInst;
    },
    eventTypes: eventTypes$1,
    extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      if (isStartish(topLevelType)) trackedTouchCount += 1;else if ("topTouchEnd" === topLevelType || "topTouchCancel" === topLevelType) if (0 <= trackedTouchCount) --trackedTouchCount;else return console.error("Ended a touch event which was not counted in `trackedTouchCount`."), null;
      ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);

      if (targetInst && ("topScroll" === topLevelType && !nativeEvent.responderIgnoreScroll || 0 < trackedTouchCount && "topSelectionChange" === topLevelType || isStartish(topLevelType) || isMoveish(topLevelType))) {
        var JSCompiler_temp = isStartish(topLevelType) ? eventTypes$1.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes$1.moveShouldSetResponder : "topSelectionChange" === topLevelType ? eventTypes$1.selectionChangeShouldSetResponder : eventTypes$1.scrollShouldSetResponder;
        if (responderInst) b: {
          var JSCompiler_temp$jscomp$0 = responderInst;

          for (var depthA = 0, tempA = JSCompiler_temp$jscomp$0; tempA; tempA = getParent(tempA)) {
            depthA++;
          }

          tempA = 0;

          for (var tempB = targetInst; tempB; tempB = getParent(tempB)) {
            tempA++;
          }

          for (; 0 < depthA - tempA;) {
            JSCompiler_temp$jscomp$0 = getParent(JSCompiler_temp$jscomp$0), depthA--;
          }

          for (; 0 < tempA - depthA;) {
            targetInst = getParent(targetInst), tempA--;
          }

          for (; depthA--;) {
            if (JSCompiler_temp$jscomp$0 === targetInst || JSCompiler_temp$jscomp$0 === targetInst.alternate) break b;
            JSCompiler_temp$jscomp$0 = getParent(JSCompiler_temp$jscomp$0);
            targetInst = getParent(targetInst);
          }

          JSCompiler_temp$jscomp$0 = null;
        } else JSCompiler_temp$jscomp$0 = targetInst;
        targetInst = JSCompiler_temp$jscomp$0 === responderInst;
        JSCompiler_temp$jscomp$0 = ResponderSyntheticEvent.getPooled(JSCompiler_temp, JSCompiler_temp$jscomp$0, nativeEvent, nativeEventTarget);
        JSCompiler_temp$jscomp$0.touchHistory = ResponderTouchHistoryStore.touchHistory;
        targetInst ? forEachAccumulated(JSCompiler_temp$jscomp$0, accumulateTwoPhaseDispatchesSingleSkipTarget) : forEachAccumulated(JSCompiler_temp$jscomp$0, accumulateTwoPhaseDispatchesSingle);

        b: {
          JSCompiler_temp = JSCompiler_temp$jscomp$0._dispatchListeners;
          targetInst = JSCompiler_temp$jscomp$0._dispatchInstances;
          if (Array.isArray(JSCompiler_temp)) for (depthA = 0; depthA < JSCompiler_temp.length && !JSCompiler_temp$jscomp$0.isPropagationStopped(); depthA++) {
            if (JSCompiler_temp[depthA](JSCompiler_temp$jscomp$0, targetInst[depthA])) {
              JSCompiler_temp = targetInst[depthA];
              break b;
            }
          } else if (JSCompiler_temp && JSCompiler_temp(JSCompiler_temp$jscomp$0, targetInst)) {
            JSCompiler_temp = targetInst;
            break b;
          }
          JSCompiler_temp = null;
        }

        JSCompiler_temp$jscomp$0._dispatchInstances = null;
        JSCompiler_temp$jscomp$0._dispatchListeners = null;
        JSCompiler_temp$jscomp$0.isPersistent() || JSCompiler_temp$jscomp$0.constructor.release(JSCompiler_temp$jscomp$0);
        JSCompiler_temp && JSCompiler_temp !== responderInst ? (JSCompiler_temp$jscomp$0 = void 0, targetInst = ResponderSyntheticEvent.getPooled(eventTypes$1.responderGrant, JSCompiler_temp, nativeEvent, nativeEventTarget), targetInst.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(targetInst, accumulateDirectDispatchesSingle), depthA = !0 === executeDirectDispatch(targetInst), responderInst ? (tempA = ResponderSyntheticEvent.getPooled(eventTypes$1.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget), tempA.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(tempA, accumulateDirectDispatchesSingle), tempB = !tempA._dispatchListeners || executeDirectDispatch(tempA), tempA.isPersistent() || tempA.constructor.release(tempA), tempB ? (tempA = ResponderSyntheticEvent.getPooled(eventTypes$1.responderTerminate, responderInst, nativeEvent, nativeEventTarget), tempA.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(tempA, accumulateDirectDispatchesSingle), JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, [targetInst, tempA]), changeResponder(JSCompiler_temp, depthA)) : (JSCompiler_temp = ResponderSyntheticEvent.getPooled(eventTypes$1.responderReject, JSCompiler_temp, nativeEvent, nativeEventTarget), JSCompiler_temp.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(JSCompiler_temp, accumulateDirectDispatchesSingle), JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, JSCompiler_temp))) : (JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, targetInst), changeResponder(JSCompiler_temp, depthA)), JSCompiler_temp = JSCompiler_temp$jscomp$0) : JSCompiler_temp = null;
      } else JSCompiler_temp = null;

      JSCompiler_temp$jscomp$0 = responderInst && isStartish(topLevelType);
      targetInst = responderInst && isMoveish(topLevelType);
      depthA = responderInst && ("topTouchEnd" === topLevelType || "topTouchCancel" === topLevelType);
      if (JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0 ? eventTypes$1.responderStart : targetInst ? eventTypes$1.responderMove : depthA ? eventTypes$1.responderEnd : null) JSCompiler_temp$jscomp$0 = ResponderSyntheticEvent.getPooled(JSCompiler_temp$jscomp$0, responderInst, nativeEvent, nativeEventTarget), JSCompiler_temp$jscomp$0.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(JSCompiler_temp$jscomp$0, accumulateDirectDispatchesSingle), JSCompiler_temp = accumulate(JSCompiler_temp, JSCompiler_temp$jscomp$0);
      JSCompiler_temp$jscomp$0 = responderInst && "topTouchCancel" === topLevelType;
      if (topLevelType = responderInst && !JSCompiler_temp$jscomp$0 && ("topTouchEnd" === topLevelType || "topTouchCancel" === topLevelType)) a: {
        if ((topLevelType = nativeEvent.touches) && 0 !== topLevelType.length) for (targetInst = 0; targetInst < topLevelType.length; targetInst++) {
          if (depthA = topLevelType[targetInst].target, null !== depthA && void 0 !== depthA && 0 !== depthA) {
            tempA = getInstanceFromNode(depthA);

            b: {
              for (depthA = responderInst; tempA;) {
                if (depthA === tempA || depthA === tempA.alternate) {
                  depthA = !0;
                  break b;
                }

                tempA = getParent(tempA);
              }

              depthA = !1;
            }

            if (depthA) {
              topLevelType = !1;
              break a;
            }
          }
        }
        topLevelType = !0;
      }
      if (topLevelType = JSCompiler_temp$jscomp$0 ? eventTypes$1.responderTerminate : topLevelType ? eventTypes$1.responderRelease : null) nativeEvent = ResponderSyntheticEvent.getPooled(topLevelType, responderInst, nativeEvent, nativeEventTarget), nativeEvent.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(nativeEvent, accumulateDirectDispatchesSingle), JSCompiler_temp = accumulate(JSCompiler_temp, nativeEvent), changeResponder(null);
      return JSCompiler_temp;
    },
    GlobalResponderHandler: null,
    injection: {
      injectGlobalResponderHandler: function injectGlobalResponderHandler(GlobalResponderHandler) {
        ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;
      }
    }
  },
      customBubblingEventTypes$1 = ReactNativeViewConfigRegistry.customBubblingEventTypes,
      customDirectEventTypes$1 = ReactNativeViewConfigRegistry.customDirectEventTypes,
      ReactNativeBridgeEventPlugin = {
    eventTypes: ReactNativeViewConfigRegistry.eventTypes,
    extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      if (null == targetInst) return null;
      var bubbleDispatchConfig = customBubblingEventTypes$1[topLevelType],
          directDispatchConfig = customDirectEventTypes$1[topLevelType];
      invariant(bubbleDispatchConfig || directDispatchConfig, 'Unsupported top level event type "%s" dispatched', topLevelType);
      topLevelType = SyntheticEvent.getPooled(bubbleDispatchConfig || directDispatchConfig, targetInst, nativeEvent, nativeEventTarget);
      if (bubbleDispatchConfig) forEachAccumulated(topLevelType, accumulateTwoPhaseDispatchesSingle);else if (directDispatchConfig) forEachAccumulated(topLevelType, accumulateDirectDispatchesSingle);else return null;
      return topLevelType;
    }
  };
  injection.injectEventPluginOrder(["ResponderEventPlugin", "ReactNativeBridgeEventPlugin"]);
  injection.injectEventPluginsByName({
    ResponderEventPlugin: ResponderEventPlugin,
    ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin
  });
  var instanceCache = {},
      instanceProps = {};

  function getInstanceFromTag(tag) {
    return instanceCache[tag] || null;
  }

  var restoreTarget = null,
      restoreQueue = null;

  function restoreStateOfTarget(target) {
    if (target = getInstanceFromNode(target)) {
      invariant(!1, "setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
      var props = getFiberCurrentPropsFromNode(target.stateNode);
      null(target.stateNode, target.type, props);
    }
  }

  function _batchedUpdatesImpl(fn, bookkeeping) {
    return fn(bookkeeping);
  }

  function _flushInteractiveUpdatesImpl() {}

  var isBatching = !1;

  function batchedUpdates(fn, bookkeeping) {
    if (isBatching) return fn(bookkeeping);
    isBatching = !0;

    try {
      return _batchedUpdatesImpl(fn, bookkeeping);
    } finally {
      if (isBatching = !1, null !== restoreTarget || null !== restoreQueue) if (_flushInteractiveUpdatesImpl(), restoreTarget && (bookkeeping = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(bookkeeping), fn)) for (bookkeeping = 0; bookkeeping < fn.length; bookkeeping++) {
        restoreStateOfTarget(fn[bookkeeping]);
      }
    }
  }

  var EMPTY_NATIVE_EVENT = {};

  function _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {
    var nativeEvent = nativeEventParam || EMPTY_NATIVE_EVENT,
        inst = getInstanceFromTag(rootNodeID);
    batchedUpdates(function () {
      var events = nativeEvent.target;

      for (var events$jscomp$0 = null, i = 0; i < plugins.length; i++) {
        var possiblePlugin = plugins[i];
        possiblePlugin && (possiblePlugin = possiblePlugin.extractEvents(topLevelType, inst, nativeEvent, events)) && (events$jscomp$0 = accumulateInto(events$jscomp$0, possiblePlugin));
      }

      events = events$jscomp$0;
      null !== events && (eventQueue = accumulateInto(eventQueue, events));
      events = eventQueue;
      eventQueue = null;
      if (events && (forEachAccumulated(events, executeDispatchesAndReleaseTopLevel), invariant(!eventQueue, "processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented."), hasRethrowError)) throw events = rethrowError, hasRethrowError = !1, rethrowError = null, events;
    });
  }

  RCTEventEmitter.register({
    getListener: getListener,
    registrationNames: registrationNameModules,
    _receiveRootNodeIDEvent: _receiveRootNodeIDEvent,
    receiveEvent: function receiveEvent(rootNodeID, topLevelType, nativeEventParam) {
      _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam);
    },
    receiveTouches: function receiveTouches(eventTopLevelType, touches, changedIndices) {
      if ("topTouchEnd" === eventTopLevelType || "topTouchCancel" === eventTopLevelType) {
        var JSCompiler_temp = [];

        for (var i = 0; i < changedIndices.length; i++) {
          var index = changedIndices[i];
          JSCompiler_temp.push(touches[index]);
          touches[index] = null;
        }

        for (i = changedIndices = 0; i < touches.length; i++) {
          index = touches[i], null !== index && (touches[changedIndices++] = index);
        }

        touches.length = changedIndices;
      } else for (JSCompiler_temp = [], i = 0; i < changedIndices.length; i++) {
        JSCompiler_temp.push(touches[changedIndices[i]]);
      }

      for (changedIndices = 0; changedIndices < JSCompiler_temp.length; changedIndices++) {
        i = JSCompiler_temp[changedIndices];
        i.changedTouches = JSCompiler_temp;
        i.touches = touches;
        index = null;
        var target = i.target;
        null === target || void 0 === target || 1 > target || (index = target);

        _receiveRootNodeIDEvent(index, eventTopLevelType, i);
      }
    }
  });

  getFiberCurrentPropsFromNode = function getFiberCurrentPropsFromNode(stateNode) {
    return instanceProps[stateNode._nativeTag] || null;
  };

  getInstanceFromNode = getInstanceFromTag;

  getNodeFromInstance = function getNodeFromInstance(inst) {
    var tag = inst.stateNode._nativeTag;
    void 0 === tag && (tag = inst.stateNode.canonical._nativeTag);
    invariant(tag, "All native instances should have a tag.");
    return tag;
  };

  ResponderEventPlugin.injection.injectGlobalResponderHandler({
    onChange: function onChange(from, to, blockNativeResponder) {
      null !== to ? UIManager.setJSResponder(to.stateNode._nativeTag, blockNativeResponder) : UIManager.clearJSResponder();
    }
  });
  var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
      hasSymbol = "function" === typeof Symbol && (typeof Symbol === "function" ? Symbol.for : "@@for"),
      REACT_ELEMENT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.element") : 60103,
      REACT_PORTAL_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.portal") : 60106,
      REACT_FRAGMENT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.fragment") : 60107,
      REACT_STRICT_MODE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.strict_mode") : 60108,
      REACT_PROFILER_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.profiler") : 60114,
      REACT_PROVIDER_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.provider") : 60109,
      REACT_CONTEXT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.context") : 60110,
      REACT_CONCURRENT_MODE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.concurrent_mode") : 60111,
      REACT_FORWARD_REF_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.forward_ref") : 60112,
      REACT_SUSPENSE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.suspense") : 60113,
      REACT_MEMO_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.memo") : 60115,
      REACT_LAZY_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.lazy") : 60116,
      MAYBE_ITERATOR_SYMBOL = "function" === typeof Symbol && (typeof Symbol === "function" ? Symbol.iterator : "@@iterator");

  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }

  function getComponentName(type) {
    if (null == type) return null;
    if ("function" === typeof type) return type.displayName || type.name || null;
    if ("string" === typeof type) return type;

    switch (type) {
      case REACT_CONCURRENT_MODE_TYPE:
        return "ConcurrentMode";

      case REACT_FRAGMENT_TYPE:
        return "Fragment";

      case REACT_PORTAL_TYPE:
        return "Portal";

      case REACT_PROFILER_TYPE:
        return "Profiler";

      case REACT_STRICT_MODE_TYPE:
        return "StrictMode";

      case REACT_SUSPENSE_TYPE:
        return "Suspense";
    }

    if ("object" === typeof type) switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        return "Context.Consumer";

      case REACT_PROVIDER_TYPE:
        return "Context.Provider";

      case REACT_FORWARD_REF_TYPE:
        var innerType = type.render;
        innerType = innerType.displayName || innerType.name || "";
        return type.displayName || ("" !== innerType ? "ForwardRef(" + innerType + ")" : "ForwardRef");

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_LAZY_TYPE:
        if (type = 1 === type._status ? type._result : null) return getComponentName(type);
    }
    return null;
  }

  function isFiberMountedImpl(fiber) {
    var node = fiber;
    if (fiber.alternate) for (; node.return;) {
      node = node.return;
    } else {
      if (0 !== (node.effectTag & 2)) return 1;

      for (; node.return;) {
        if (node = node.return, 0 !== (node.effectTag & 2)) return 1;
      }
    }
    return 3 === node.tag ? 2 : 3;
  }

  function assertIsMounted(fiber) {
    invariant(2 === isFiberMountedImpl(fiber), "Unable to find node on an unmounted component.");
  }

  function findCurrentFiberUsingSlowPath(fiber) {
    var alternate = fiber.alternate;
    if (!alternate) return alternate = isFiberMountedImpl(fiber), invariant(3 !== alternate, "Unable to find node on an unmounted component."), 1 === alternate ? null : fiber;

    for (var a = fiber, b = alternate;;) {
      var parentA = a.return,
          parentB = parentA ? parentA.alternate : null;
      if (!parentA || !parentB) break;

      if (parentA.child === parentB.child) {
        for (var child = parentA.child; child;) {
          if (child === a) return assertIsMounted(parentA), fiber;
          if (child === b) return assertIsMounted(parentA), alternate;
          child = child.sibling;
        }

        invariant(!1, "Unable to find node on an unmounted component.");
      }

      if (a.return !== b.return) a = parentA, b = parentB;else {
        child = !1;

        for (var _child = parentA.child; _child;) {
          if (_child === a) {
            child = !0;
            a = parentA;
            b = parentB;
            break;
          }

          if (_child === b) {
            child = !0;
            b = parentA;
            a = parentB;
            break;
          }

          _child = _child.sibling;
        }

        if (!child) {
          for (_child = parentB.child; _child;) {
            if (_child === a) {
              child = !0;
              a = parentB;
              b = parentA;
              break;
            }

            if (_child === b) {
              child = !0;
              b = parentB;
              a = parentA;
              break;
            }

            _child = _child.sibling;
          }

          invariant(child, "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
        }
      }
      invariant(a.alternate === b, "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
    }

    invariant(3 === a.tag, "Unable to find node on an unmounted component.");
    return a.stateNode.current === a ? fiber : alternate;
  }

  function findCurrentHostFiber(parent) {
    parent = findCurrentFiberUsingSlowPath(parent);
    if (!parent) return null;

    for (var node = parent;;) {
      if (5 === node.tag || 6 === node.tag) return node;
      if (node.child) node.child.return = node, node = node.child;else {
        if (node === parent) break;

        for (; !node.sibling;) {
          if (!node.return || node.return === parent) return null;
          node = node.return;
        }

        node.sibling.return = node.return;
        node = node.sibling;
      }
    }

    return null;
  }

  var emptyObject = {},
      removedKeys = null,
      removedKeyCount = 0;

  function restoreDeletedValuesInNestedArray(updatePayload, node, validAttributes) {
    if (Array.isArray(node)) for (var i = node.length; i-- && 0 < removedKeyCount;) {
      restoreDeletedValuesInNestedArray(updatePayload, node[i], validAttributes);
    } else if (node && 0 < removedKeyCount) for (i in removedKeys) {
      if (removedKeys[i]) {
        var nextProp = node[i];

        if (void 0 !== nextProp) {
          var attributeConfig = validAttributes[i];

          if (attributeConfig) {
            "function" === typeof nextProp && (nextProp = !0);
            "undefined" === typeof nextProp && (nextProp = null);
            if ("object" !== typeof attributeConfig) updatePayload[i] = nextProp;else if ("function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process) nextProp = "function" === typeof attributeConfig.process ? attributeConfig.process(nextProp) : nextProp, updatePayload[i] = nextProp;
            removedKeys[i] = !1;
            removedKeyCount--;
          }
        }
      }
    }
  }

  function diffNestedProperty(updatePayload, prevProp, nextProp, validAttributes) {
    if (!updatePayload && prevProp === nextProp) return updatePayload;
    if (!prevProp || !nextProp) return nextProp ? addNestedProperty(updatePayload, nextProp, validAttributes) : prevProp ? clearNestedProperty(updatePayload, prevProp, validAttributes) : updatePayload;
    if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) return diffProperties(updatePayload, prevProp, nextProp, validAttributes);

    if (Array.isArray(prevProp) && Array.isArray(nextProp)) {
      var minLength = prevProp.length < nextProp.length ? prevProp.length : nextProp.length,
          i;

      for (i = 0; i < minLength; i++) {
        updatePayload = diffNestedProperty(updatePayload, prevProp[i], nextProp[i], validAttributes);
      }

      for (; i < prevProp.length; i++) {
        updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);
      }

      for (; i < nextProp.length; i++) {
        updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);
      }

      return updatePayload;
    }

    return Array.isArray(prevProp) ? diffProperties(updatePayload, flattenStyle(prevProp), nextProp, validAttributes) : diffProperties(updatePayload, prevProp, flattenStyle(nextProp), validAttributes);
  }

  function addNestedProperty(updatePayload, nextProp, validAttributes) {
    if (!nextProp) return updatePayload;
    if (!Array.isArray(nextProp)) return diffProperties(updatePayload, emptyObject, nextProp, validAttributes);

    for (var i = 0; i < nextProp.length; i++) {
      updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);
    }

    return updatePayload;
  }

  function clearNestedProperty(updatePayload, prevProp, validAttributes) {
    if (!prevProp) return updatePayload;
    if (!Array.isArray(prevProp)) return diffProperties(updatePayload, prevProp, emptyObject, validAttributes);

    for (var i = 0; i < prevProp.length; i++) {
      updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);
    }

    return updatePayload;
  }

  function diffProperties(updatePayload, prevProps, nextProps, validAttributes) {
    var attributeConfig, propKey;

    for (propKey in nextProps) {
      if (attributeConfig = validAttributes[propKey]) {
        var prevProp = prevProps[propKey];
        var nextProp = nextProps[propKey];
        "function" === typeof nextProp && (nextProp = !0, "function" === typeof prevProp && (prevProp = !0));
        "undefined" === typeof nextProp && (nextProp = null, "undefined" === typeof prevProp && (prevProp = null));
        removedKeys && (removedKeys[propKey] = !1);
        if (updatePayload && void 0 !== updatePayload[propKey]) {
          if ("object" !== typeof attributeConfig) updatePayload[propKey] = nextProp;else {
            if ("function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process) attributeConfig = "function" === typeof attributeConfig.process ? attributeConfig.process(nextProp) : nextProp, updatePayload[propKey] = attributeConfig;
          }
        } else if (prevProp !== nextProp) if ("object" !== typeof attributeConfig) ("object" !== typeof nextProp || null === nextProp || deepDiffer(prevProp, nextProp)) && ((updatePayload || (updatePayload = {}))[propKey] = nextProp);else if ("function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process) {
          if (void 0 === prevProp || ("function" === typeof attributeConfig.diff ? attributeConfig.diff(prevProp, nextProp) : "object" !== typeof nextProp || null === nextProp || deepDiffer(prevProp, nextProp))) attributeConfig = "function" === typeof attributeConfig.process ? attributeConfig.process(nextProp) : nextProp, (updatePayload || (updatePayload = {}))[propKey] = attributeConfig;
        } else removedKeys = null, removedKeyCount = 0, updatePayload = diffNestedProperty(updatePayload, prevProp, nextProp, attributeConfig), 0 < removedKeyCount && updatePayload && (restoreDeletedValuesInNestedArray(updatePayload, nextProp, attributeConfig), removedKeys = null);
      }
    }

    for (var _propKey in prevProps) {
      void 0 === nextProps[_propKey] && (!(attributeConfig = validAttributes[_propKey]) || updatePayload && void 0 !== updatePayload[_propKey] || (prevProp = prevProps[_propKey], void 0 !== prevProp && ("object" !== typeof attributeConfig || "function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process ? ((updatePayload || (updatePayload = {}))[_propKey] = null, removedKeys || (removedKeys = {}), removedKeys[_propKey] || (removedKeys[_propKey] = !0, removedKeyCount++)) : updatePayload = clearNestedProperty(updatePayload, prevProp, attributeConfig))));
    }

    return updatePayload;
  }

  function mountSafeCallback_NOT_REALLY_SAFE(context, callback) {
    return function () {
      if (callback && ("boolean" !== typeof context.__isMounted || context.__isMounted)) return callback.apply(context, arguments);
    };
  }

  var ReactNativeFiberHostComponent = function () {
    function ReactNativeFiberHostComponent(tag, viewConfig) {
      if (!(this instanceof ReactNativeFiberHostComponent)) throw new TypeError("Cannot call a class as a function");
      this._nativeTag = tag;
      this._children = [];
      this.viewConfig = viewConfig;
    }

    ReactNativeFiberHostComponent.prototype.blur = function () {
      TextInputState.blurTextInput(this._nativeTag);
    };

    ReactNativeFiberHostComponent.prototype.focus = function () {
      TextInputState.focusTextInput(this._nativeTag);
    };

    ReactNativeFiberHostComponent.prototype.measure = function (callback) {
      UIManager.measure(this._nativeTag, mountSafeCallback_NOT_REALLY_SAFE(this, callback));
    };

    ReactNativeFiberHostComponent.prototype.measureInWindow = function (callback) {
      UIManager.measureInWindow(this._nativeTag, mountSafeCallback_NOT_REALLY_SAFE(this, callback));
    };

    ReactNativeFiberHostComponent.prototype.measureLayout = function (relativeToNativeNode, onSuccess, onFail) {
      UIManager.measureLayout(this._nativeTag, relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
    };

    ReactNativeFiberHostComponent.prototype.setNativeProps = function (nativeProps) {
      nativeProps = diffProperties(null, emptyObject, nativeProps, this.viewConfig.validAttributes);
      null != nativeProps && UIManager.updateView(this._nativeTag, this.viewConfig.uiViewClassName, nativeProps);
    };

    return ReactNativeFiberHostComponent;
  }(),
      now$1 = "object" === typeof performance && "function" === typeof performance.now ? function () {
    return performance.now();
  } : function () {
    return Date.now();
  },
      scheduledCallback = null,
      frameDeadline = 0;

  function setTimeoutCallback() {
    frameDeadline = now$1() + 5;
    var callback = scheduledCallback;
    scheduledCallback = null;
    null !== callback && callback();
  }

  function shim$1() {
    invariant(!1, "The current renderer does not support hyration. This error is likely caused by a bug in React. Please file an issue.");
  }

  var UPDATE_SIGNAL = {},
      nextReactTag = 3;

  function allocateTag() {
    var tag = nextReactTag;
    1 === tag % 10 && (tag += 2);
    nextReactTag = tag + 2;
    return tag;
  }

  function recursivelyUncacheFiberNode(node) {
    if ("number" === typeof node) delete instanceCache[node], delete instanceProps[node];else {
      var tag = node._nativeTag;
      delete instanceCache[tag];
      delete instanceProps[tag];

      node._children.forEach(recursivelyUncacheFiberNode);
    }
  }

  function finalizeInitialChildren(parentInstance) {
    if (0 === parentInstance._children.length) return !1;

    var nativeTags = parentInstance._children.map(function (child) {
      return "number" === typeof child ? child : child._nativeTag;
    });

    UIManager.setChildren(parentInstance._nativeTag, nativeTags);
    return !1;
  }

  var scheduleTimeout = setTimeout,
      cancelTimeout = clearTimeout,
      BEFORE_SLASH_RE = /^(.*)[\\\/]/;

  function getStackByFiberInDevAndProd(workInProgress) {
    var info = "";

    do {
      a: switch (workInProgress.tag) {
        case 2:
        case 16:
        case 0:
        case 1:
        case 5:
        case 8:
        case 13:
          var owner = workInProgress._debugOwner,
              source = workInProgress._debugSource,
              name = getComponentName(workInProgress.type);
          var JSCompiler_inline_result = null;
          owner && (JSCompiler_inline_result = getComponentName(owner.type));
          owner = name;
          name = "";
          source ? name = " (at " + source.fileName.replace(BEFORE_SLASH_RE, "") + ":" + source.lineNumber + ")" : JSCompiler_inline_result && (name = " (created by " + JSCompiler_inline_result + ")");
          JSCompiler_inline_result = "\n    in " + (owner || "Unknown") + name;
          break a;

        default:
          JSCompiler_inline_result = "";
      }

      info += JSCompiler_inline_result;
      workInProgress = workInProgress.return;
    } while (workInProgress);

    return info;
  }

  new Set();
  var valueStack = [],
      index = -1;

  function pop(cursor) {
    0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
  }

  function push(cursor, value) {
    index++;
    valueStack[index] = cursor.current;
    cursor.current = value;
  }

  var emptyContextObject = {},
      contextStackCursor = {
    current: emptyContextObject
  },
      didPerformWorkStackCursor = {
    current: !1
  },
      previousContext = emptyContextObject;

  function getMaskedContext(workInProgress, unmaskedContext) {
    var contextTypes = workInProgress.type.contextTypes;
    if (!contextTypes) return emptyContextObject;
    var instance = workInProgress.stateNode;
    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) return instance.__reactInternalMemoizedMaskedChildContext;
    var context = {},
        key;

    for (key in contextTypes) {
      context[key] = unmaskedContext[key];
    }

    instance && (workInProgress = workInProgress.stateNode, workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext, workInProgress.__reactInternalMemoizedMaskedChildContext = context);
    return context;
  }

  function isContextProvider(type) {
    type = type.childContextTypes;
    return null !== type && void 0 !== type;
  }

  function popContext(fiber) {
    pop(didPerformWorkStackCursor, fiber);
    pop(contextStackCursor, fiber);
  }

  function popTopLevelContextObject(fiber) {
    pop(didPerformWorkStackCursor, fiber);
    pop(contextStackCursor, fiber);
  }

  function pushTopLevelContextObject(fiber, context, didChange) {
    invariant(contextStackCursor.current === emptyContextObject, "Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
    push(contextStackCursor, context, fiber);
    push(didPerformWorkStackCursor, didChange, fiber);
  }

  function processChildContext(fiber, type, parentContext) {
    var instance = fiber.stateNode;
    fiber = type.childContextTypes;
    if ("function" !== typeof instance.getChildContext) return parentContext;
    instance = instance.getChildContext();

    for (var contextKey in instance) {
      invariant(contextKey in fiber, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(type) || "Unknown", contextKey);
    }

    return _extends({}, parentContext, instance);
  }

  function pushContextProvider(workInProgress) {
    var instance = workInProgress.stateNode;
    instance = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
    previousContext = contextStackCursor.current;
    push(contextStackCursor, instance, workInProgress);
    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
    return !0;
  }

  function invalidateContextProvider(workInProgress, type, didChange) {
    var instance = workInProgress.stateNode;
    invariant(instance, "Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
    didChange ? (type = processChildContext(workInProgress, type, previousContext), instance.__reactInternalMemoizedMergedChildContext = type, pop(didPerformWorkStackCursor, workInProgress), pop(contextStackCursor, workInProgress), push(contextStackCursor, type, workInProgress)) : pop(didPerformWorkStackCursor, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  }

  var onCommitFiberRoot = null,
      onCommitFiberUnmount = null;

  function catchErrors(fn) {
    return function (arg) {
      try {
        return fn(arg);
      } catch (err) {}
    };
  }

  function injectInternals(internals) {
    if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
    var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (hook.isDisabled || !hook.supportsFiber) return !0;

    try {
      var rendererID = hook.inject(internals);
      onCommitFiberRoot = catchErrors(function (root) {
        return hook.onCommitFiberRoot(rendererID, root);
      });
      onCommitFiberUnmount = catchErrors(function (fiber) {
        return hook.onCommitFiberUnmount(rendererID, fiber);
      });
    } catch (err) {}

    return !0;
  }

  function FiberNode(tag, pendingProps, key, mode) {
    this.tag = tag;
    this.key = key;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = pendingProps;
    this.firstContextDependency = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = mode;
    this.effectTag = 0;
    this.lastEffect = this.firstEffect = this.nextEffect = null;
    this.childExpirationTime = this.expirationTime = 0;
    this.alternate = null;
  }

  function createFiber(tag, pendingProps, key, mode) {
    return new FiberNode(tag, pendingProps, key, mode);
  }

  function shouldConstruct(Component) {
    Component = Component.prototype;
    return !(!Component || !Component.isReactComponent);
  }

  function resolveLazyComponentTag(Component) {
    if ("function" === typeof Component) return shouldConstruct(Component) ? 1 : 0;

    if (void 0 !== Component && null !== Component) {
      Component = Component.$$typeof;
      if (Component === REACT_FORWARD_REF_TYPE) return 11;
      if (Component === REACT_MEMO_TYPE) return 14;
    }

    return 2;
  }

  function createWorkInProgress(current, pendingProps) {
    var workInProgress = current.alternate;
    null === workInProgress ? (workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.effectTag = 0, workInProgress.nextEffect = null, workInProgress.firstEffect = null, workInProgress.lastEffect = null);
    workInProgress.childExpirationTime = current.childExpirationTime;
    workInProgress.expirationTime = current.expirationTime;
    workInProgress.child = current.child;
    workInProgress.memoizedProps = current.memoizedProps;
    workInProgress.memoizedState = current.memoizedState;
    workInProgress.updateQueue = current.updateQueue;
    workInProgress.firstContextDependency = current.firstContextDependency;
    workInProgress.sibling = current.sibling;
    workInProgress.index = current.index;
    workInProgress.ref = current.ref;
    return workInProgress;
  }

  function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime) {
    var fiberTag = 2;
    owner = type;
    if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);else if ("string" === typeof type) fiberTag = 5;else a: switch (type) {
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);

      case REACT_CONCURRENT_MODE_TYPE:
        return createFiberFromMode(pendingProps, mode | 3, expirationTime, key);

      case REACT_STRICT_MODE_TYPE:
        return createFiberFromMode(pendingProps, mode | 2, expirationTime, key);

      case REACT_PROFILER_TYPE:
        return type = createFiber(12, pendingProps, key, mode | 4), type.elementType = REACT_PROFILER_TYPE, type.type = REACT_PROFILER_TYPE, type.expirationTime = expirationTime, type;

      case REACT_SUSPENSE_TYPE:
        return type = createFiber(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.type = REACT_SUSPENSE_TYPE, type.expirationTime = expirationTime, type;

      default:
        if ("object" === typeof type && null !== type) switch (type.$$typeof) {
          case REACT_PROVIDER_TYPE:
            fiberTag = 10;
            break a;

          case REACT_CONTEXT_TYPE:
            fiberTag = 9;
            break a;

          case REACT_FORWARD_REF_TYPE:
            fiberTag = 11;
            break a;

          case REACT_MEMO_TYPE:
            fiberTag = 14;
            break a;

          case REACT_LAZY_TYPE:
            fiberTag = 16;
            owner = null;
            break a;
        }
        invariant(!1, "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", null == type ? type : typeof type, "");
    }
    key = createFiber(fiberTag, pendingProps, key, mode);
    key.elementType = type;
    key.type = owner;
    key.expirationTime = expirationTime;
    return key;
  }

  function createFiberFromFragment(elements, mode, expirationTime, key) {
    elements = createFiber(7, elements, key, mode);
    elements.expirationTime = expirationTime;
    return elements;
  }

  function createFiberFromMode(pendingProps, mode, expirationTime, key) {
    pendingProps = createFiber(8, pendingProps, key, mode);
    mode = 0 === (mode & 1) ? REACT_STRICT_MODE_TYPE : REACT_CONCURRENT_MODE_TYPE;
    pendingProps.elementType = mode;
    pendingProps.type = mode;
    pendingProps.expirationTime = expirationTime;
    return pendingProps;
  }

  function createFiberFromText(content, mode, expirationTime) {
    content = createFiber(6, content, null, mode);
    content.expirationTime = expirationTime;
    return content;
  }

  function createFiberFromPortal(portal, mode, expirationTime) {
    mode = createFiber(4, null !== portal.children ? portal.children : [], portal.key, mode);
    mode.expirationTime = expirationTime;
    mode.stateNode = {
      containerInfo: portal.containerInfo,
      pendingChildren: null,
      implementation: portal.implementation
    };
    return mode;
  }

  function markPendingPriorityLevel(root, expirationTime) {
    root.didError = !1;
    var earliestPendingTime = root.earliestPendingTime;
    0 === earliestPendingTime ? root.earliestPendingTime = root.latestPendingTime = expirationTime : earliestPendingTime < expirationTime ? root.earliestPendingTime = expirationTime : root.latestPendingTime > expirationTime && (root.latestPendingTime = expirationTime);
    findNextExpirationTimeToWorkOn(expirationTime, root);
  }

  function markSuspendedPriorityLevel(root, suspendedTime) {
    root.didError = !1;
    var latestPingedTime = root.latestPingedTime;
    0 !== latestPingedTime && latestPingedTime >= suspendedTime && (root.latestPingedTime = 0);
    latestPingedTime = root.earliestPendingTime;
    var latestPendingTime = root.latestPendingTime;
    latestPingedTime === suspendedTime ? root.earliestPendingTime = latestPendingTime === suspendedTime ? root.latestPendingTime = 0 : latestPendingTime : latestPendingTime === suspendedTime && (root.latestPendingTime = latestPingedTime);
    latestPingedTime = root.earliestSuspendedTime;
    latestPendingTime = root.latestSuspendedTime;
    0 === latestPingedTime ? root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime : latestPingedTime < suspendedTime ? root.earliestSuspendedTime = suspendedTime : latestPendingTime > suspendedTime && (root.latestSuspendedTime = suspendedTime);
    findNextExpirationTimeToWorkOn(suspendedTime, root);
  }

  function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
    var earliestPendingTime = root.earliestPendingTime;
    root = root.earliestSuspendedTime;
    earliestPendingTime > renderExpirationTime && (renderExpirationTime = earliestPendingTime);
    root > renderExpirationTime && (renderExpirationTime = root);
    return renderExpirationTime;
  }

  function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
    var earliestSuspendedTime = root.earliestSuspendedTime,
        latestSuspendedTime = root.latestSuspendedTime,
        earliestPendingTime = root.earliestPendingTime,
        latestPingedTime = root.latestPingedTime;
    earliestPendingTime = 0 !== earliestPendingTime ? earliestPendingTime : latestPingedTime;
    0 === earliestPendingTime && (0 === completedExpirationTime || latestSuspendedTime < completedExpirationTime) && (earliestPendingTime = latestSuspendedTime);
    completedExpirationTime = earliestPendingTime;
    0 !== completedExpirationTime && earliestSuspendedTime > completedExpirationTime && (completedExpirationTime = earliestSuspendedTime);
    root.nextExpirationTimeToWorkOn = earliestPendingTime;
    root.expirationTime = completedExpirationTime;
  }

  var hasForceUpdate = !1;

  function createUpdateQueue(baseState) {
    return {
      baseState: baseState,
      firstUpdate: null,
      lastUpdate: null,
      firstCapturedUpdate: null,
      lastCapturedUpdate: null,
      firstEffect: null,
      lastEffect: null,
      firstCapturedEffect: null,
      lastCapturedEffect: null
    };
  }

  function cloneUpdateQueue(currentQueue) {
    return {
      baseState: currentQueue.baseState,
      firstUpdate: currentQueue.firstUpdate,
      lastUpdate: currentQueue.lastUpdate,
      firstCapturedUpdate: null,
      lastCapturedUpdate: null,
      firstEffect: null,
      lastEffect: null,
      firstCapturedEffect: null,
      lastCapturedEffect: null
    };
  }

  function createUpdate(expirationTime) {
    return {
      expirationTime: expirationTime,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
      nextEffect: null
    };
  }

  function appendUpdateToQueue(queue, update) {
    null === queue.lastUpdate ? queue.firstUpdate = queue.lastUpdate = update : (queue.lastUpdate.next = update, queue.lastUpdate = update);
  }

  function enqueueUpdate(fiber, update) {
    var alternate = fiber.alternate;

    if (null === alternate) {
      var queue1 = fiber.updateQueue;
      var queue2 = null;
      null === queue1 && (queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState));
    } else queue1 = fiber.updateQueue, queue2 = alternate.updateQueue, null === queue1 ? null === queue2 ? (queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState), queue2 = alternate.updateQueue = createUpdateQueue(alternate.memoizedState)) : queue1 = fiber.updateQueue = cloneUpdateQueue(queue2) : null === queue2 && (queue2 = alternate.updateQueue = cloneUpdateQueue(queue1));

    null === queue2 || queue1 === queue2 ? appendUpdateToQueue(queue1, update) : null === queue1.lastUpdate || null === queue2.lastUpdate ? (appendUpdateToQueue(queue1, update), appendUpdateToQueue(queue2, update)) : (appendUpdateToQueue(queue1, update), queue2.lastUpdate = update);
  }

  function enqueueCapturedUpdate(workInProgress, update) {
    var workInProgressQueue = workInProgress.updateQueue;
    workInProgressQueue = null === workInProgressQueue ? workInProgress.updateQueue = createUpdateQueue(workInProgress.memoizedState) : ensureWorkInProgressQueueIsAClone(workInProgress, workInProgressQueue);
    null === workInProgressQueue.lastCapturedUpdate ? workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update : (workInProgressQueue.lastCapturedUpdate.next = update, workInProgressQueue.lastCapturedUpdate = update);
  }

  function ensureWorkInProgressQueueIsAClone(workInProgress, queue) {
    var current = workInProgress.alternate;
    null !== current && queue === current.updateQueue && (queue = workInProgress.updateQueue = cloneUpdateQueue(queue));
    return queue;
  }

  function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
    switch (update.tag) {
      case 1:
        return workInProgress = update.payload, "function" === typeof workInProgress ? workInProgress.call(instance, prevState, nextProps) : workInProgress;

      case 3:
        workInProgress.effectTag = workInProgress.effectTag & -2049 | 64;

      case 0:
        workInProgress = update.payload;
        nextProps = "function" === typeof workInProgress ? workInProgress.call(instance, prevState, nextProps) : workInProgress;
        if (null === nextProps || void 0 === nextProps) break;
        return _extends({}, prevState, nextProps);

      case 2:
        hasForceUpdate = !0;
    }

    return prevState;
  }

  function processUpdateQueue(workInProgress, queue, props, instance, renderExpirationTime) {
    hasForceUpdate = !1;
    queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);

    for (var newBaseState = queue.baseState, newFirstUpdate = null, newExpirationTime = 0, update = queue.firstUpdate, resultState = newBaseState; null !== update;) {
      var updateExpirationTime = update.expirationTime;
      updateExpirationTime < renderExpirationTime ? (null === newFirstUpdate && (newFirstUpdate = update, newBaseState = resultState), newExpirationTime < updateExpirationTime && (newExpirationTime = updateExpirationTime)) : (resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance), null !== update.callback && (workInProgress.effectTag |= 32, update.nextEffect = null, null === queue.lastEffect ? queue.firstEffect = queue.lastEffect = update : (queue.lastEffect.nextEffect = update, queue.lastEffect = update)));
      update = update.next;
    }

    updateExpirationTime = null;

    for (update = queue.firstCapturedUpdate; null !== update;) {
      var _updateExpirationTime = update.expirationTime;
      _updateExpirationTime < renderExpirationTime ? (null === updateExpirationTime && (updateExpirationTime = update, null === newFirstUpdate && (newBaseState = resultState)), newExpirationTime < _updateExpirationTime && (newExpirationTime = _updateExpirationTime)) : (resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance), null !== update.callback && (workInProgress.effectTag |= 32, update.nextEffect = null, null === queue.lastCapturedEffect ? queue.firstCapturedEffect = queue.lastCapturedEffect = update : (queue.lastCapturedEffect.nextEffect = update, queue.lastCapturedEffect = update)));
      update = update.next;
    }

    null === newFirstUpdate && (queue.lastUpdate = null);
    null === updateExpirationTime ? queue.lastCapturedUpdate = null : workInProgress.effectTag |= 32;
    null === newFirstUpdate && null === updateExpirationTime && (newBaseState = resultState);
    queue.baseState = newBaseState;
    queue.firstUpdate = newFirstUpdate;
    queue.firstCapturedUpdate = updateExpirationTime;
    workInProgress.expirationTime = newExpirationTime;
    workInProgress.memoizedState = resultState;
  }

  function commitUpdateQueue(finishedWork, finishedQueue, instance) {
    null !== finishedQueue.firstCapturedUpdate && (null !== finishedQueue.lastUpdate && (finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate, finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate), finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null);
    commitUpdateEffects(finishedQueue.firstEffect, instance);
    finishedQueue.firstEffect = finishedQueue.lastEffect = null;
    commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);
    finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;
  }

  function commitUpdateEffects(effect, instance) {
    for (; null !== effect;) {
      var _callback3 = effect.callback;

      if (null !== _callback3) {
        effect.callback = null;
        var context = instance;
        invariant("function" === typeof _callback3, "Invalid argument passed as callback. Expected a function. Instead received: %s", _callback3);

        _callback3.call(context);
      }

      effect = effect.nextEffect;
    }
  }

  function createCapturedValue(value, source) {
    return {
      value: value,
      source: source,
      stack: getStackByFiberInDevAndProd(source)
    };
  }

  var valueCursor = {
    current: null
  },
      currentlyRenderingFiber = null,
      lastContextDependency = null,
      lastContextWithAllBitsObserved = null;

  function pushProvider(providerFiber, nextValue) {
    var context = providerFiber.type._context;
    push(valueCursor, context._currentValue, providerFiber);
    context._currentValue = nextValue;
  }

  function popProvider(providerFiber) {
    var currentValue = valueCursor.current;
    pop(valueCursor, providerFiber);
    providerFiber.type._context._currentValue = currentValue;
  }

  function prepareToReadContext(workInProgress) {
    currentlyRenderingFiber = workInProgress;
    lastContextWithAllBitsObserved = lastContextDependency = null;
    workInProgress.firstContextDependency = null;
  }

  function readContext(context, observedBits) {
    if (lastContextWithAllBitsObserved !== context && !1 !== observedBits && 0 !== observedBits) {
      if ("number" !== typeof observedBits || 1073741823 === observedBits) lastContextWithAllBitsObserved = context, observedBits = 1073741823;
      observedBits = {
        context: context,
        observedBits: observedBits,
        next: null
      };
      null === lastContextDependency ? (invariant(null !== currentlyRenderingFiber, "Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps."), currentlyRenderingFiber.firstContextDependency = lastContextDependency = observedBits) : lastContextDependency = lastContextDependency.next = observedBits;
    }

    return context._currentValue;
  }

  var NO_CONTEXT = {},
      contextStackCursor$1 = {
    current: NO_CONTEXT
  },
      contextFiberStackCursor = {
    current: NO_CONTEXT
  },
      rootInstanceStackCursor = {
    current: NO_CONTEXT
  };

  function requiredContext(c) {
    invariant(c !== NO_CONTEXT, "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
    return c;
  }

  function pushHostContainer(fiber, nextRootInstance) {
    push(rootInstanceStackCursor, nextRootInstance, fiber);
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor$1, NO_CONTEXT, fiber);
    pop(contextStackCursor$1, fiber);
    push(contextStackCursor$1, {
      isInAParentText: !1
    }, fiber);
  }

  function popHostContainer(fiber) {
    pop(contextStackCursor$1, fiber);
    pop(contextFiberStackCursor, fiber);
    pop(rootInstanceStackCursor, fiber);
  }

  function pushHostContext(fiber) {
    requiredContext(rootInstanceStackCursor.current);
    var context = requiredContext(contextStackCursor$1.current);
    var nextContext = fiber.type;
    nextContext = "AndroidTextInput" === nextContext || "RCTMultilineTextInputView" === nextContext || "RCTSinglelineTextInputView" === nextContext || "RCTText" === nextContext || "RCTVirtualText" === nextContext;
    nextContext = context.isInAParentText !== nextContext ? {
      isInAParentText: nextContext
    } : context;
    context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor$1, nextContext, fiber));
  }

  function popHostContext(fiber) {
    contextFiberStackCursor.current === fiber && (pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber));
  }

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  function is(x, y) {
    return x === y ? 0 !== x || 0 !== y || 1 / x === 1 / y : x !== x && y !== y;
  }

  function shallowEqual(objA, objB) {
    if (is(objA, objB)) return !0;
    if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB) return !1;
    var keysA = Object.keys(objA),
        keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return !1;

    for (keysB = 0; keysB < keysA.length; keysB++) {
      if (!hasOwnProperty.call(objB, keysA[keysB]) || !is(objA[keysA[keysB]], objB[keysA[keysB]])) return !1;
    }

    return !0;
  }

  function resolveDefaultProps(Component, baseProps) {
    if (Component && Component.defaultProps) {
      baseProps = _extends({}, baseProps);
      Component = Component.defaultProps;

      for (var propName in Component) {
        void 0 === baseProps[propName] && (baseProps[propName] = Component[propName]);
      }
    }

    return baseProps;
  }

  function readLazyComponentType(lazyComponent) {
    var result = lazyComponent._result;

    switch (lazyComponent._status) {
      case 1:
        return result;

      case 2:
        throw result;

      case 0:
        throw result;

      default:
        throw lazyComponent._status = 0, result = lazyComponent._ctor, result = result(), result.then(function (moduleObject) {
          0 === lazyComponent._status && (moduleObject = moduleObject.default, lazyComponent._status = 1, lazyComponent._result = moduleObject);
        }, function (error) {
          0 === lazyComponent._status && (lazyComponent._status = 2, lazyComponent._result = error);
        }), lazyComponent._result = result, result;
    }
  }

  var ReactCurrentOwner$4 = ReactSharedInternals.ReactCurrentOwner,
      emptyRefsObject = new React.Component().refs;

  function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
    ctor = workInProgress.memoizedState;
    getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
    getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : _extends({}, ctor, getDerivedStateFromProps);
    workInProgress.memoizedState = getDerivedStateFromProps;
    nextProps = workInProgress.updateQueue;
    null !== nextProps && 0 === workInProgress.expirationTime && (nextProps.baseState = getDerivedStateFromProps);
  }

  var classComponentUpdater = {
    isMounted: function isMounted(component) {
      return (component = component._reactInternalFiber) ? 2 === isFiberMountedImpl(component) : !1;
    },
    enqueueSetState: function enqueueSetState(inst, payload, callback) {
      inst = inst._reactInternalFiber;
      var currentTime = requestCurrentTime();
      currentTime = computeExpirationForFiber(currentTime, inst);
      var update = createUpdate(currentTime);
      update.payload = payload;
      void 0 !== callback && null !== callback && (update.callback = callback);
      flushPassiveEffects();
      enqueueUpdate(inst, update);
      scheduleWork(inst, currentTime);
    },
    enqueueReplaceState: function enqueueReplaceState(inst, payload, callback) {
      inst = inst._reactInternalFiber;
      var currentTime = requestCurrentTime();
      currentTime = computeExpirationForFiber(currentTime, inst);
      var update = createUpdate(currentTime);
      update.tag = 1;
      update.payload = payload;
      void 0 !== callback && null !== callback && (update.callback = callback);
      flushPassiveEffects();
      enqueueUpdate(inst, update);
      scheduleWork(inst, currentTime);
    },
    enqueueForceUpdate: function enqueueForceUpdate(inst, callback) {
      inst = inst._reactInternalFiber;
      var currentTime = requestCurrentTime();
      currentTime = computeExpirationForFiber(currentTime, inst);
      var update = createUpdate(currentTime);
      update.tag = 2;
      void 0 !== callback && null !== callback && (update.callback = callback);
      flushPassiveEffects();
      enqueueUpdate(inst, update);
      scheduleWork(inst, currentTime);
    }
  };

  function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
    workInProgress = workInProgress.stateNode;
    return "function" === typeof workInProgress.shouldComponentUpdate ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;
  }

  function constructClassInstance(workInProgress, ctor, props) {
    var isLegacyContextConsumer = !1,
        unmaskedContext = emptyContextObject;
    var context = ctor.contextType;
    "object" === typeof context && null !== context ? context = ReactCurrentOwner$4.currentDispatcher.readContext(context) : (unmaskedContext = isContextProvider(ctor) ? previousContext : contextStackCursor.current, isLegacyContextConsumer = ctor.contextTypes, context = (isLegacyContextConsumer = null !== isLegacyContextConsumer && void 0 !== isLegacyContextConsumer) ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject);
    ctor = new ctor(props, context);
    workInProgress.memoizedState = null !== ctor.state && void 0 !== ctor.state ? ctor.state : null;
    ctor.updater = classComponentUpdater;
    workInProgress.stateNode = ctor;
    ctor._reactInternalFiber = workInProgress;
    isLegacyContextConsumer && (workInProgress = workInProgress.stateNode, workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext, workInProgress.__reactInternalMemoizedMaskedChildContext = context);
    return ctor;
  }

  function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
    workInProgress = instance.state;
    "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
    "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
    instance.state !== workInProgress && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }

  function mountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
    var instance = workInProgress.stateNode;
    instance.props = newProps;
    instance.state = workInProgress.memoizedState;
    instance.refs = emptyRefsObject;
    var contextType = ctor.contextType;
    "object" === typeof contextType && null !== contextType ? instance.context = ReactCurrentOwner$4.currentDispatcher.readContext(contextType) : (contextType = isContextProvider(ctor) ? previousContext : contextStackCursor.current, instance.context = getMaskedContext(workInProgress, contextType));
    contextType = workInProgress.updateQueue;
    null !== contextType && (processUpdateQueue(workInProgress, contextType, newProps, instance, renderExpirationTime), instance.state = workInProgress.memoizedState);
    contextType = ctor.getDerivedStateFromProps;
    "function" === typeof contextType && (applyDerivedStateFromProps(workInProgress, ctor, contextType, newProps), instance.state = workInProgress.memoizedState);
    "function" === typeof ctor.getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate || "function" !== typeof instance.UNSAFE_componentWillMount && "function" !== typeof instance.componentWillMount || (ctor = instance.state, "function" === typeof instance.componentWillMount && instance.componentWillMount(), "function" === typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount(), ctor !== instance.state && classComponentUpdater.enqueueReplaceState(instance, instance.state, null), contextType = workInProgress.updateQueue, null !== contextType && (processUpdateQueue(workInProgress, contextType, newProps, instance, renderExpirationTime), instance.state = workInProgress.memoizedState));
    "function" === typeof instance.componentDidMount && (workInProgress.effectTag |= 4);
  }

  var isArray = Array.isArray;

  function coerceRef(returnFiber, current$$1, element) {
    returnFiber = element.ref;

    if (null !== returnFiber && "function" !== typeof returnFiber && "object" !== typeof returnFiber) {
      if (element._owner) {
        element = element._owner;
        var inst = void 0;
        element && (invariant(1 === element.tag, "Function components cannot have refs."), inst = element.stateNode);
        invariant(inst, "Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.", returnFiber);
        var stringRef = "" + returnFiber;
        if (null !== current$$1 && null !== current$$1.ref && "function" === typeof current$$1.ref && current$$1.ref._stringRef === stringRef) return current$$1.ref;

        current$$1 = function current$$1(value) {
          var refs = inst.refs;
          refs === emptyRefsObject && (refs = inst.refs = {});
          null === value ? delete refs[stringRef] : refs[stringRef] = value;
        };

        current$$1._stringRef = stringRef;
        return current$$1;
      }

      invariant("string" === typeof returnFiber, "Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
      invariant(element._owner, "Element ref was specified as a string (%s) but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://fb.me/react-refs-must-have-owner for more information.", returnFiber);
    }

    return returnFiber;
  }

  function throwOnInvalidObjectType(returnFiber, newChild) {
    "textarea" !== returnFiber.type && invariant(!1, "Objects are not valid as a React child (found: %s).%s", "[object Object]" === Object.prototype.toString.call(newChild) ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : newChild, "");
  }

  function ChildReconciler(shouldTrackSideEffects) {
    function deleteChild(returnFiber, childToDelete) {
      if (shouldTrackSideEffects) {
        var last = returnFiber.lastEffect;
        null !== last ? (last.nextEffect = childToDelete, returnFiber.lastEffect = childToDelete) : returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
        childToDelete.nextEffect = null;
        childToDelete.effectTag = 8;
      }
    }

    function deleteRemainingChildren(returnFiber, currentFirstChild) {
      if (!shouldTrackSideEffects) return null;

      for (; null !== currentFirstChild;) {
        deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      }

      return null;
    }

    function mapRemainingChildren(returnFiber, currentFirstChild) {
      for (returnFiber = new Map(); null !== currentFirstChild;) {
        null !== currentFirstChild.key ? returnFiber.set(currentFirstChild.key, currentFirstChild) : returnFiber.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      }

      return returnFiber;
    }

    function useFiber(fiber, pendingProps, expirationTime) {
      fiber = createWorkInProgress(fiber, pendingProps, expirationTime);
      fiber.index = 0;
      fiber.sibling = null;
      return fiber;
    }

    function placeChild(newFiber, lastPlacedIndex, newIndex) {
      newFiber.index = newIndex;
      if (!shouldTrackSideEffects) return lastPlacedIndex;
      newIndex = newFiber.alternate;
      if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.effectTag = 2, lastPlacedIndex) : newIndex;
      newFiber.effectTag = 2;
      return lastPlacedIndex;
    }

    function placeSingleChild(newFiber) {
      shouldTrackSideEffects && null === newFiber.alternate && (newFiber.effectTag = 2);
      return newFiber;
    }

    function updateTextNode(returnFiber, current$$1, textContent, expirationTime) {
      if (null === current$$1 || 6 !== current$$1.tag) return current$$1 = createFiberFromText(textContent, returnFiber.mode, expirationTime), current$$1.return = returnFiber, current$$1;
      current$$1 = useFiber(current$$1, textContent, expirationTime);
      current$$1.return = returnFiber;
      return current$$1;
    }

    function updateElement(returnFiber, current$$1, element, expirationTime) {
      if (null !== current$$1 && current$$1.elementType === element.type) return expirationTime = useFiber(current$$1, element.props, expirationTime), expirationTime.ref = coerceRef(returnFiber, current$$1, element), expirationTime.return = returnFiber, expirationTime;
      expirationTime = createFiberFromTypeAndProps(element.type, element.key, element.props, null, returnFiber.mode, expirationTime);
      expirationTime.ref = coerceRef(returnFiber, current$$1, element);
      expirationTime.return = returnFiber;
      return expirationTime;
    }

    function updatePortal(returnFiber, current$$1, portal, expirationTime) {
      if (null === current$$1 || 4 !== current$$1.tag || current$$1.stateNode.containerInfo !== portal.containerInfo || current$$1.stateNode.implementation !== portal.implementation) return current$$1 = createFiberFromPortal(portal, returnFiber.mode, expirationTime), current$$1.return = returnFiber, current$$1;
      current$$1 = useFiber(current$$1, portal.children || [], expirationTime);
      current$$1.return = returnFiber;
      return current$$1;
    }

    function updateFragment(returnFiber, current$$1, fragment, expirationTime, key) {
      if (null === current$$1 || 7 !== current$$1.tag) return current$$1 = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key), current$$1.return = returnFiber, current$$1;
      current$$1 = useFiber(current$$1, fragment, expirationTime);
      current$$1.return = returnFiber;
      return current$$1;
    }

    function createChild(returnFiber, newChild, expirationTime) {
      if ("string" === typeof newChild || "number" === typeof newChild) return newChild = createFiberFromText("" + newChild, returnFiber.mode, expirationTime), newChild.return = returnFiber, newChild;

      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return expirationTime = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, expirationTime), expirationTime.ref = coerceRef(returnFiber, null, newChild), expirationTime.return = returnFiber, expirationTime;

          case REACT_PORTAL_TYPE:
            return newChild = createFiberFromPortal(newChild, returnFiber.mode, expirationTime), newChild.return = returnFiber, newChild;
        }

        if (isArray(newChild) || getIteratorFn(newChild)) return newChild = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null), newChild.return = returnFiber, newChild;
        throwOnInvalidObjectType(returnFiber, newChild);
      }

      return null;
    }

    function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
      var key = null !== oldFiber ? oldFiber.key : null;
      if ("string" === typeof newChild || "number" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, expirationTime);

      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return newChild.key === key ? newChild.type === REACT_FRAGMENT_TYPE ? updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key) : updateElement(returnFiber, oldFiber, newChild, expirationTime) : null;

          case REACT_PORTAL_TYPE:
            return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, expirationTime) : null;
        }

        if (isArray(newChild) || getIteratorFn(newChild)) return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
        throwOnInvalidObjectType(returnFiber, newChild);
      }

      return null;
    }

    function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
      if ("string" === typeof newChild || "number" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, expirationTime);

      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, newChild.type === REACT_FRAGMENT_TYPE ? updateFragment(returnFiber, existingChildren, newChild.props.children, expirationTime, newChild.key) : updateElement(returnFiber, existingChildren, newChild, expirationTime);

          case REACT_PORTAL_TYPE:
            return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, expirationTime);
        }

        if (isArray(newChild) || getIteratorFn(newChild)) return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, expirationTime, null);
        throwOnInvalidObjectType(returnFiber, newChild);
      }

      return null;
    }

    function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
      for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);

        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }

        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }

      if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), resultingFirstChild;

      if (null === oldFiber) {
        for (; newIdx < newChildren.length; newIdx++) {
          if (oldFiber = createChild(returnFiber, newChildren[newIdx], expirationTime)) currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber;
        }

        return resultingFirstChild;
      }

      for (oldFiber = mapRemainingChildren(returnFiber, oldFiber); newIdx < newChildren.length; newIdx++) {
        if (nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], expirationTime)) shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber;
      }

      shouldTrackSideEffects && oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
      return resultingFirstChild;
    }

    function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
      var iteratorFn = getIteratorFn(newChildrenIterable);
      invariant("function" === typeof iteratorFn, "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
      newChildrenIterable = iteratorFn.call(newChildrenIterable);
      invariant(null != newChildrenIterable, "An iterable object provided no iterator.");

      for (var previousNewFiber = iteratorFn = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildrenIterable.next(); null !== oldFiber && !step.done; newIdx++, step = newChildrenIterable.next()) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);

        if (null === newFiber) {
          oldFiber || (oldFiber = nextOldFiber);
          break;
        }

        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? iteratorFn = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }

      if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), iteratorFn;

      if (null === oldFiber) {
        for (; !step.done; newIdx++, step = newChildrenIterable.next()) {
          step = createChild(returnFiber, step.value, expirationTime), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? iteratorFn = step : previousNewFiber.sibling = step, previousNewFiber = step);
        }

        return iteratorFn;
      }

      for (oldFiber = mapRemainingChildren(returnFiber, oldFiber); !step.done; newIdx++, step = newChildrenIterable.next()) {
        step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, expirationTime), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? iteratorFn = step : previousNewFiber.sibling = step, previousNewFiber = step);
      }

      shouldTrackSideEffects && oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
      return iteratorFn;
    }

    return function (returnFiber, currentFirstChild, newChild, expirationTime) {
      var isUnkeyedTopLevelFragment = "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key;
      isUnkeyedTopLevelFragment && (newChild = newChild.props.children);
      var isObject = "object" === typeof newChild && null !== newChild;
      if (isObject) switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          a: {
            isObject = newChild.key;

            for (isUnkeyedTopLevelFragment = currentFirstChild; null !== isUnkeyedTopLevelFragment;) {
              if (isUnkeyedTopLevelFragment.key === isObject) {
                if (7 === isUnkeyedTopLevelFragment.tag ? newChild.type === REACT_FRAGMENT_TYPE : isUnkeyedTopLevelFragment.elementType === newChild.type) {
                  deleteRemainingChildren(returnFiber, isUnkeyedTopLevelFragment.sibling);
                  currentFirstChild = useFiber(isUnkeyedTopLevelFragment, newChild.type === REACT_FRAGMENT_TYPE ? newChild.props.children : newChild.props, expirationTime);
                  currentFirstChild.ref = coerceRef(returnFiber, isUnkeyedTopLevelFragment, newChild);
                  currentFirstChild.return = returnFiber;
                  returnFiber = currentFirstChild;
                  break a;
                } else {
                  deleteRemainingChildren(returnFiber, isUnkeyedTopLevelFragment);
                  break;
                }
              } else deleteChild(returnFiber, isUnkeyedTopLevelFragment);
              isUnkeyedTopLevelFragment = isUnkeyedTopLevelFragment.sibling;
            }

            newChild.type === REACT_FRAGMENT_TYPE ? (currentFirstChild = createFiberFromFragment(newChild.props.children, returnFiber.mode, expirationTime, newChild.key), currentFirstChild.return = returnFiber, returnFiber = currentFirstChild) : (expirationTime = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, expirationTime), expirationTime.ref = coerceRef(returnFiber, currentFirstChild, newChild), expirationTime.return = returnFiber, returnFiber = expirationTime);
          }

          return placeSingleChild(returnFiber);

        case REACT_PORTAL_TYPE:
          a: {
            for (isUnkeyedTopLevelFragment = newChild.key; null !== currentFirstChild;) {
              if (currentFirstChild.key === isUnkeyedTopLevelFragment) {
                if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                  deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                  currentFirstChild = useFiber(currentFirstChild, newChild.children || [], expirationTime);
                  currentFirstChild.return = returnFiber;
                  returnFiber = currentFirstChild;
                  break a;
                } else {
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  break;
                }
              } else deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }

            currentFirstChild = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);
            currentFirstChild.return = returnFiber;
            returnFiber = currentFirstChild;
          }

          return placeSingleChild(returnFiber);
      }
      if ("string" === typeof newChild || "number" === typeof newChild) return newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), currentFirstChild = useFiber(currentFirstChild, newChild, expirationTime), currentFirstChild.return = returnFiber, returnFiber = currentFirstChild) : (deleteRemainingChildren(returnFiber, currentFirstChild), currentFirstChild = createFiberFromText(newChild, returnFiber.mode, expirationTime), currentFirstChild.return = returnFiber, returnFiber = currentFirstChild), placeSingleChild(returnFiber);
      if (isArray(newChild)) return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
      if (getIteratorFn(newChild)) return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
      isObject && throwOnInvalidObjectType(returnFiber, newChild);
      if ("undefined" === typeof newChild && !isUnkeyedTopLevelFragment) switch (returnFiber.tag) {
        case 1:
        case 0:
          expirationTime = returnFiber.type, invariant(!1, "%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.", expirationTime.displayName || expirationTime.name || "Component");
      }
      return deleteRemainingChildren(returnFiber, currentFirstChild);
    };
  }

  var reconcileChildFibers = ChildReconciler(!0),
      mountChildFibers = ChildReconciler(!1),
      hydrationParentFiber = null,
      nextHydratableInstance = null,
      isHydrating = !1;

  function tryHydrate(fiber, nextInstance) {
    switch (fiber.tag) {
      case 5:
        return nextInstance = shim$1(nextInstance, fiber.type, fiber.pendingProps), null !== nextInstance ? (fiber.stateNode = nextInstance, !0) : !1;

      case 6:
        return nextInstance = shim$1(nextInstance, fiber.pendingProps), null !== nextInstance ? (fiber.stateNode = nextInstance, !0) : !1;

      default:
        return !1;
    }
  }

  function tryToClaimNextHydratableInstance(fiber$jscomp$0) {
    if (isHydrating) {
      var nextInstance = nextHydratableInstance;

      if (nextInstance) {
        var firstAttemptedInstance = nextInstance;

        if (!tryHydrate(fiber$jscomp$0, nextInstance)) {
          nextInstance = shim$1(firstAttemptedInstance);

          if (!nextInstance || !tryHydrate(fiber$jscomp$0, nextInstance)) {
            fiber$jscomp$0.effectTag |= 2;
            isHydrating = !1;
            hydrationParentFiber = fiber$jscomp$0;
            return;
          }

          var returnFiber = hydrationParentFiber,
              fiber = createFiber(5, null, null, 0);
          fiber.elementType = "DELETED";
          fiber.type = "DELETED";
          fiber.stateNode = firstAttemptedInstance;
          fiber.return = returnFiber;
          fiber.effectTag = 8;
          null !== returnFiber.lastEffect ? (returnFiber.lastEffect.nextEffect = fiber, returnFiber.lastEffect = fiber) : returnFiber.firstEffect = returnFiber.lastEffect = fiber;
        }

        hydrationParentFiber = fiber$jscomp$0;
        nextHydratableInstance = shim$1(nextInstance);
      } else fiber$jscomp$0.effectTag |= 2, isHydrating = !1, hydrationParentFiber = fiber$jscomp$0;
    }
  }

  var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;

  function reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime) {
    workInProgress.child = null === current$$1 ? mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime) : reconcileChildFibers(workInProgress, current$$1.child, nextChildren, renderExpirationTime);
  }

  function updateForwardRef(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
    Component = Component.render;
    var ref = workInProgress.ref;
    prepareToReadContext(workInProgress, renderExpirationTime);
    nextProps = Component(nextProps, ref);
    workInProgress.effectTag |= 1;
    reconcileChildren(current$$1, workInProgress, nextProps, renderExpirationTime);
    return workInProgress.child;
  }

  function updateMemoComponent(current$$1, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {
    if (null === current$$1) {
      var type = Component.type;
      if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare) return workInProgress.tag = 15, workInProgress.type = type, updateSimpleMemoComponent(current$$1, workInProgress, type, nextProps, updateExpirationTime, renderExpirationTime);
      current$$1 = createFiberFromTypeAndProps(Component.type, null, nextProps, null, workInProgress.mode, renderExpirationTime);
      current$$1.ref = workInProgress.ref;
      current$$1.return = workInProgress;
      return workInProgress.child = current$$1;
    }

    type = current$$1.child;
    if (updateExpirationTime < renderExpirationTime && (updateExpirationTime = type.memoizedProps, Component = Component.compare, Component = null !== Component ? Component : shallowEqual, Component(updateExpirationTime, nextProps) && current$$1.ref === workInProgress.ref)) return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
    workInProgress.effectTag |= 1;
    current$$1 = createWorkInProgress(type, nextProps, renderExpirationTime);
    current$$1.ref = workInProgress.ref;
    current$$1.return = workInProgress;
    return workInProgress.child = current$$1;
  }

  function updateSimpleMemoComponent(current$$1, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {
    return null !== current$$1 && updateExpirationTime < renderExpirationTime && shallowEqual(current$$1.memoizedProps, nextProps) && current$$1.ref === workInProgress.ref ? bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime) : updateFunctionComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime);
  }

  function markRef(current$$1, workInProgress) {
    var ref = workInProgress.ref;
    if (null === current$$1 && null !== ref || null !== current$$1 && current$$1.ref !== ref) workInProgress.effectTag |= 128;
  }

  function updateFunctionComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
    var unmaskedContext = isContextProvider(Component) ? previousContext : contextStackCursor.current;
    unmaskedContext = getMaskedContext(workInProgress, unmaskedContext);
    prepareToReadContext(workInProgress, renderExpirationTime);
    Component = Component(nextProps, unmaskedContext);
    workInProgress.effectTag |= 1;
    reconcileChildren(current$$1, workInProgress, Component, renderExpirationTime);
    return workInProgress.child;
  }

  function updateClassComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
    if (isContextProvider(Component)) {
      var hasContext = !0;
      pushContextProvider(workInProgress);
    } else hasContext = !1;

    prepareToReadContext(workInProgress, renderExpirationTime);
    if (null === workInProgress.stateNode) null !== current$$1 && (current$$1.alternate = null, workInProgress.alternate = null, workInProgress.effectTag |= 2), constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime), mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime), nextProps = !0;else if (null === current$$1) {
      var instance = workInProgress.stateNode,
          oldProps = workInProgress.memoizedProps;
      instance.props = oldProps;
      var oldContext = instance.context,
          contextType = Component.contextType;
      "object" === typeof contextType && null !== contextType ? contextType = ReactCurrentOwner$4.currentDispatcher.readContext(contextType) : (contextType = isContextProvider(Component) ? previousContext : contextStackCursor.current, contextType = getMaskedContext(workInProgress, contextType));
      var getDerivedStateFromProps = Component.getDerivedStateFromProps,
          hasNewLifecycles = "function" === typeof getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate;
      hasNewLifecycles || "function" !== typeof instance.UNSAFE_componentWillReceiveProps && "function" !== typeof instance.componentWillReceiveProps || (oldProps !== nextProps || oldContext !== contextType) && callComponentWillReceiveProps(workInProgress, instance, nextProps, contextType);
      hasForceUpdate = !1;
      var oldState = workInProgress.memoizedState;
      oldContext = instance.state = oldState;
      var updateQueue = workInProgress.updateQueue;
      null !== updateQueue && (processUpdateQueue(workInProgress, updateQueue, nextProps, instance, renderExpirationTime), oldContext = workInProgress.memoizedState);
      oldProps !== nextProps || oldState !== oldContext || didPerformWorkStackCursor.current || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, nextProps), oldContext = workInProgress.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, oldProps, nextProps, oldState, oldContext, contextType)) ? (hasNewLifecycles || "function" !== typeof instance.UNSAFE_componentWillMount && "function" !== typeof instance.componentWillMount || ("function" === typeof instance.componentWillMount && instance.componentWillMount(), "function" === typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount()), "function" === typeof instance.componentDidMount && (workInProgress.effectTag |= 4)) : ("function" === typeof instance.componentDidMount && (workInProgress.effectTag |= 4), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), instance.props = nextProps, instance.state = oldContext, instance.context = contextType, nextProps = oldProps) : ("function" === typeof instance.componentDidMount && (workInProgress.effectTag |= 4), nextProps = !1);
    } else instance = workInProgress.stateNode, oldProps = workInProgress.memoizedProps, instance.props = workInProgress.type === workInProgress.elementType ? oldProps : resolveDefaultProps(workInProgress.type, oldProps), oldContext = instance.context, contextType = Component.contextType, "object" === typeof contextType && null !== contextType ? contextType = ReactCurrentOwner$4.currentDispatcher.readContext(contextType) : (contextType = isContextProvider(Component) ? previousContext : contextStackCursor.current, contextType = getMaskedContext(workInProgress, contextType)), getDerivedStateFromProps = Component.getDerivedStateFromProps, (hasNewLifecycles = "function" === typeof getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate) || "function" !== typeof instance.UNSAFE_componentWillReceiveProps && "function" !== typeof instance.componentWillReceiveProps || (oldProps !== nextProps || oldContext !== contextType) && callComponentWillReceiveProps(workInProgress, instance, nextProps, contextType), hasForceUpdate = !1, oldContext = workInProgress.memoizedState, oldState = instance.state = oldContext, updateQueue = workInProgress.updateQueue, null !== updateQueue && (processUpdateQueue(workInProgress, updateQueue, nextProps, instance, renderExpirationTime), oldState = workInProgress.memoizedState), oldProps !== nextProps || oldContext !== oldState || didPerformWorkStackCursor.current || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, nextProps), oldState = workInProgress.memoizedState), (getDerivedStateFromProps = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, oldProps, nextProps, oldContext, oldState, contextType)) ? (hasNewLifecycles || "function" !== typeof instance.UNSAFE_componentWillUpdate && "function" !== typeof instance.componentWillUpdate || ("function" === typeof instance.componentWillUpdate && instance.componentWillUpdate(nextProps, oldState, contextType), "function" === typeof instance.UNSAFE_componentWillUpdate && instance.UNSAFE_componentWillUpdate(nextProps, oldState, contextType)), "function" === typeof instance.componentDidUpdate && (workInProgress.effectTag |= 4), "function" === typeof instance.getSnapshotBeforeUpdate && (workInProgress.effectTag |= 256)) : ("function" !== typeof instance.componentDidUpdate || oldProps === current$$1.memoizedProps && oldContext === current$$1.memoizedState || (workInProgress.effectTag |= 4), "function" !== typeof instance.getSnapshotBeforeUpdate || oldProps === current$$1.memoizedProps && oldContext === current$$1.memoizedState || (workInProgress.effectTag |= 256), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldState), instance.props = nextProps, instance.state = oldState, instance.context = contextType, nextProps = getDerivedStateFromProps) : ("function" !== typeof instance.componentDidUpdate || oldProps === current$$1.memoizedProps && oldContext === current$$1.memoizedState || (workInProgress.effectTag |= 4), "function" !== typeof instance.getSnapshotBeforeUpdate || oldProps === current$$1.memoizedProps && oldContext === current$$1.memoizedState || (workInProgress.effectTag |= 256), nextProps = !1);
    return finishClassComponent(current$$1, workInProgress, Component, nextProps, hasContext, renderExpirationTime);
  }

  function finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime) {
    markRef(current$$1, workInProgress);
    var didCaptureError = 0 !== (workInProgress.effectTag & 64);
    if (!shouldUpdate && !didCaptureError) return hasContext && invalidateContextProvider(workInProgress, Component, !1), bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
    shouldUpdate = workInProgress.stateNode;
    ReactCurrentOwner$3.current = workInProgress;
    var nextChildren = didCaptureError && "function" !== typeof Component.getDerivedStateFromError ? null : shouldUpdate.render();
    workInProgress.effectTag |= 1;
    null !== current$$1 && didCaptureError ? (workInProgress.child = reconcileChildFibers(workInProgress, current$$1.child, null, renderExpirationTime), workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime)) : reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
    workInProgress.memoizedState = shouldUpdate.state;
    hasContext && invalidateContextProvider(workInProgress, Component, !0);
    return workInProgress.child;
  }

  function pushHostRootContext(workInProgress) {
    var root = workInProgress.stateNode;
    root.pendingContext ? pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context) : root.context && pushTopLevelContextObject(workInProgress, root.context, !1);
    pushHostContainer(workInProgress, root.containerInfo);
  }

  function updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime) {
    var mode = workInProgress.mode,
        nextProps = workInProgress.pendingProps,
        nextState = workInProgress.memoizedState;

    if (0 === (workInProgress.effectTag & 64)) {
      nextState = null;
      var nextDidTimeout = !1;
    } else nextState = {
      timedOutAt: null !== nextState ? nextState.timedOutAt : 0
    }, nextDidTimeout = !0, workInProgress.effectTag &= -65;

    null === current$$1 ? nextDidTimeout ? (nextDidTimeout = nextProps.fallback, nextProps = createFiberFromFragment(null, mode, 0, null), 0 === (workInProgress.mode & 1) && (nextProps.child = null !== workInProgress.memoizedState ? workInProgress.child.child : workInProgress.child), mode = createFiberFromFragment(nextDidTimeout, mode, renderExpirationTime, null), nextProps.sibling = mode, renderExpirationTime = nextProps, renderExpirationTime.return = mode.return = workInProgress) : renderExpirationTime = mode = mountChildFibers(workInProgress, null, nextProps.children, renderExpirationTime) : null !== current$$1.memoizedState ? (mode = current$$1.child, current$$1 = mode.sibling, nextDidTimeout ? (renderExpirationTime = nextProps.fallback, nextProps = createWorkInProgress(mode, mode.pendingProps, 0), nextProps.effectTag |= 2, 0 === (workInProgress.mode & 1) && (nextDidTimeout = null !== workInProgress.memoizedState ? workInProgress.child.child : workInProgress.child, nextDidTimeout !== mode.child && (nextProps.child = nextDidTimeout)), mode = nextProps.sibling = createWorkInProgress(current$$1, renderExpirationTime, current$$1.expirationTime), mode.effectTag |= 2, renderExpirationTime = nextProps, nextProps.childExpirationTime = 0, renderExpirationTime.return = mode.return = workInProgress) : renderExpirationTime = mode = reconcileChildFibers(workInProgress, mode.child, nextProps.children, renderExpirationTime)) : (current$$1 = current$$1.child, nextDidTimeout ? (nextDidTimeout = nextProps.fallback, nextProps = createFiberFromFragment(null, mode, 0, null), nextProps.effectTag |= 2, nextProps.child = current$$1, current$$1.return = nextProps, 0 === (workInProgress.mode & 1) && (nextProps.child = null !== workInProgress.memoizedState ? workInProgress.child.child : workInProgress.child), mode = nextProps.sibling = createFiberFromFragment(nextDidTimeout, mode, renderExpirationTime, null), mode.effectTag |= 2, renderExpirationTime = nextProps, nextProps.childExpirationTime = 0, renderExpirationTime.return = mode.return = workInProgress) : mode = renderExpirationTime = reconcileChildFibers(workInProgress, current$$1, nextProps.children, renderExpirationTime));
    workInProgress.memoizedState = nextState;
    workInProgress.child = renderExpirationTime;
    return mode;
  }

  function bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime) {
    null !== current$$1 && (workInProgress.firstContextDependency = current$$1.firstContextDependency);
    if (workInProgress.childExpirationTime < renderExpirationTime) return null;
    invariant(null === current$$1 || workInProgress.child === current$$1.child, "Resuming work not yet implemented.");

    if (null !== workInProgress.child) {
      current$$1 = workInProgress.child;
      renderExpirationTime = createWorkInProgress(current$$1, current$$1.pendingProps, current$$1.expirationTime);
      workInProgress.child = renderExpirationTime;

      for (renderExpirationTime.return = workInProgress; null !== current$$1.sibling;) {
        current$$1 = current$$1.sibling, renderExpirationTime = renderExpirationTime.sibling = createWorkInProgress(current$$1, current$$1.pendingProps, current$$1.expirationTime), renderExpirationTime.return = workInProgress;
      }

      renderExpirationTime.sibling = null;
    }

    return workInProgress.child;
  }

  function beginWork(current$$1, workInProgress, renderExpirationTime) {
    var updateExpirationTime = workInProgress.expirationTime;

    if (null !== current$$1 && current$$1.memoizedProps === workInProgress.pendingProps && !didPerformWorkStackCursor.current && updateExpirationTime < renderExpirationTime) {
      switch (workInProgress.tag) {
        case 3:
          pushHostRootContext(workInProgress);
          break;

        case 5:
          pushHostContext(workInProgress);
          break;

        case 1:
          isContextProvider(workInProgress.type) && pushContextProvider(workInProgress);
          break;

        case 4:
          pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
          break;

        case 10:
          pushProvider(workInProgress, workInProgress.memoizedProps.value);
          break;

        case 13:
          if (null !== workInProgress.memoizedState) {
            updateExpirationTime = workInProgress.child.childExpirationTime;
            if (0 !== updateExpirationTime && updateExpirationTime >= renderExpirationTime) return updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime);
            workInProgress = bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
            return null !== workInProgress ? workInProgress.sibling : null;
          }

      }

      return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
    }

    workInProgress.expirationTime = 0;

    switch (workInProgress.tag) {
      case 2:
        updateExpirationTime = workInProgress.elementType;
        null !== current$$1 && (current$$1.alternate = null, workInProgress.alternate = null, workInProgress.effectTag |= 2);
        current$$1 = workInProgress.pendingProps;
        var context = getMaskedContext(workInProgress, contextStackCursor.current);
        prepareToReadContext(workInProgress, renderExpirationTime);
        context = updateExpirationTime(current$$1, context);
        workInProgress.effectTag |= 1;

        if ("object" === typeof context && null !== context && "function" === typeof context.render && void 0 === context.$$typeof) {
          workInProgress.tag = 1;

          if (isContextProvider(updateExpirationTime)) {
            var hasContext = !0;
            pushContextProvider(workInProgress);
          } else hasContext = !1;

          workInProgress.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
          var getDerivedStateFromProps = updateExpirationTime.getDerivedStateFromProps;
          "function" === typeof getDerivedStateFromProps && applyDerivedStateFromProps(workInProgress, updateExpirationTime, getDerivedStateFromProps, current$$1);
          context.updater = classComponentUpdater;
          workInProgress.stateNode = context;
          context._reactInternalFiber = workInProgress;
          mountClassInstance(workInProgress, updateExpirationTime, current$$1, renderExpirationTime);
          workInProgress = finishClassComponent(null, workInProgress, updateExpirationTime, !0, hasContext, renderExpirationTime);
        } else workInProgress.tag = 0, reconcileChildren(null, workInProgress, context, renderExpirationTime), workInProgress = workInProgress.child;

        return workInProgress;

      case 16:
        context = workInProgress.elementType;
        null !== current$$1 && (current$$1.alternate = null, workInProgress.alternate = null, workInProgress.effectTag |= 2);
        hasContext = workInProgress.pendingProps;
        current$$1 = readLazyComponentType(context);
        workInProgress.type = current$$1;
        context = workInProgress.tag = resolveLazyComponentTag(current$$1);
        hasContext = resolveDefaultProps(current$$1, hasContext);
        getDerivedStateFromProps = void 0;

        switch (context) {
          case 0:
            getDerivedStateFromProps = updateFunctionComponent(null, workInProgress, current$$1, hasContext, renderExpirationTime);
            break;

          case 1:
            getDerivedStateFromProps = updateClassComponent(null, workInProgress, current$$1, hasContext, renderExpirationTime);
            break;

          case 11:
            getDerivedStateFromProps = updateForwardRef(null, workInProgress, current$$1, hasContext, renderExpirationTime);
            break;

          case 14:
            getDerivedStateFromProps = updateMemoComponent(null, workInProgress, current$$1, resolveDefaultProps(current$$1.type, hasContext), updateExpirationTime, renderExpirationTime);
            break;

          default:
            invariant(!1, "Element type is invalid. Received a promise that resolves to: %s. Promise elements must resolve to a class or function.", current$$1);
        }

        return getDerivedStateFromProps;

      case 0:
        return updateExpirationTime = workInProgress.type, context = workInProgress.pendingProps, context = workInProgress.elementType === updateExpirationTime ? context : resolveDefaultProps(updateExpirationTime, context), updateFunctionComponent(current$$1, workInProgress, updateExpirationTime, context, renderExpirationTime);

      case 1:
        return updateExpirationTime = workInProgress.type, context = workInProgress.pendingProps, context = workInProgress.elementType === updateExpirationTime ? context : resolveDefaultProps(updateExpirationTime, context), updateClassComponent(current$$1, workInProgress, updateExpirationTime, context, renderExpirationTime);

      case 3:
        return pushHostRootContext(workInProgress), updateExpirationTime = workInProgress.updateQueue, invariant(null !== updateExpirationTime, "If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue."), context = workInProgress.memoizedState, context = null !== context ? context.element : null, processUpdateQueue(workInProgress, updateExpirationTime, workInProgress.pendingProps, null, renderExpirationTime), updateExpirationTime = workInProgress.memoizedState.element, updateExpirationTime === context ? workInProgress = bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime) : (reconcileChildren(current$$1, workInProgress, updateExpirationTime, renderExpirationTime), workInProgress = workInProgress.child), workInProgress;

      case 5:
        return pushHostContext(workInProgress), null === current$$1 && tryToClaimNextHydratableInstance(workInProgress), updateExpirationTime = workInProgress.pendingProps.children, markRef(current$$1, workInProgress), reconcileChildren(current$$1, workInProgress, updateExpirationTime, renderExpirationTime), workInProgress = workInProgress.child, workInProgress;

      case 6:
        return null === current$$1 && tryToClaimNextHydratableInstance(workInProgress), null;

      case 13:
        return updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime);

      case 4:
        return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), updateExpirationTime = workInProgress.pendingProps, null === current$$1 ? workInProgress.child = reconcileChildFibers(workInProgress, null, updateExpirationTime, renderExpirationTime) : reconcileChildren(current$$1, workInProgress, updateExpirationTime, renderExpirationTime), workInProgress.child;

      case 11:
        return updateExpirationTime = workInProgress.type, context = workInProgress.pendingProps, context = workInProgress.elementType === updateExpirationTime ? context : resolveDefaultProps(updateExpirationTime, context), updateForwardRef(current$$1, workInProgress, updateExpirationTime, context, renderExpirationTime);

      case 7:
        return reconcileChildren(current$$1, workInProgress, workInProgress.pendingProps, renderExpirationTime), workInProgress.child;

      case 8:
        return reconcileChildren(current$$1, workInProgress, workInProgress.pendingProps.children, renderExpirationTime), workInProgress.child;

      case 12:
        return reconcileChildren(current$$1, workInProgress, workInProgress.pendingProps.children, renderExpirationTime), workInProgress.child;

      case 10:
        a: {
          updateExpirationTime = workInProgress.type._context;
          context = workInProgress.pendingProps;
          getDerivedStateFromProps = workInProgress.memoizedProps;
          hasContext = context.value;
          pushProvider(workInProgress, hasContext);

          if (null !== getDerivedStateFromProps) {
            var oldValue = getDerivedStateFromProps.value;
            hasContext = oldValue === hasContext && (0 !== oldValue || 1 / oldValue === 1 / hasContext) || oldValue !== oldValue && hasContext !== hasContext ? 0 : ("function" === typeof updateExpirationTime._calculateChangedBits ? updateExpirationTime._calculateChangedBits(oldValue, hasContext) : 1073741823) | 0;

            if (0 === hasContext) {
              if (getDerivedStateFromProps.children === context.children && !didPerformWorkStackCursor.current) {
                workInProgress = bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
                break a;
              }
            } else for (getDerivedStateFromProps = workInProgress.child, null !== getDerivedStateFromProps && (getDerivedStateFromProps.return = workInProgress); null !== getDerivedStateFromProps;) {
              oldValue = getDerivedStateFromProps.firstContextDependency;

              if (null !== oldValue) {
                do {
                  if (oldValue.context === updateExpirationTime && 0 !== (oldValue.observedBits & hasContext)) {
                    if (1 === getDerivedStateFromProps.tag) {
                      var nextFiber = createUpdate(renderExpirationTime);
                      nextFiber.tag = 2;
                      enqueueUpdate(getDerivedStateFromProps, nextFiber);
                    }

                    getDerivedStateFromProps.expirationTime < renderExpirationTime && (getDerivedStateFromProps.expirationTime = renderExpirationTime);
                    nextFiber = getDerivedStateFromProps.alternate;
                    null !== nextFiber && nextFiber.expirationTime < renderExpirationTime && (nextFiber.expirationTime = renderExpirationTime);

                    for (var node = getDerivedStateFromProps.return; null !== node;) {
                      nextFiber = node.alternate;
                      if (node.childExpirationTime < renderExpirationTime) node.childExpirationTime = renderExpirationTime, null !== nextFiber && nextFiber.childExpirationTime < renderExpirationTime && (nextFiber.childExpirationTime = renderExpirationTime);else if (null !== nextFiber && nextFiber.childExpirationTime < renderExpirationTime) nextFiber.childExpirationTime = renderExpirationTime;else break;
                      node = node.return;
                    }
                  }

                  nextFiber = getDerivedStateFromProps.child;
                  oldValue = oldValue.next;
                } while (null !== oldValue);
              } else nextFiber = 10 === getDerivedStateFromProps.tag ? getDerivedStateFromProps.type === workInProgress.type ? null : getDerivedStateFromProps.child : getDerivedStateFromProps.child;

              if (null !== nextFiber) nextFiber.return = getDerivedStateFromProps;else for (nextFiber = getDerivedStateFromProps; null !== nextFiber;) {
                if (nextFiber === workInProgress) {
                  nextFiber = null;
                  break;
                }

                getDerivedStateFromProps = nextFiber.sibling;

                if (null !== getDerivedStateFromProps) {
                  getDerivedStateFromProps.return = nextFiber.return;
                  nextFiber = getDerivedStateFromProps;
                  break;
                }

                nextFiber = nextFiber.return;
              }
              getDerivedStateFromProps = nextFiber;
            }
          }

          reconcileChildren(current$$1, workInProgress, context.children, renderExpirationTime);
          workInProgress = workInProgress.child;
        }

        return workInProgress;

      case 9:
        return context = workInProgress.type, hasContext = workInProgress.pendingProps, updateExpirationTime = hasContext.children, prepareToReadContext(workInProgress, renderExpirationTime), context = readContext(context, hasContext.unstable_observedBits), updateExpirationTime = updateExpirationTime(context), workInProgress.effectTag |= 1, reconcileChildren(current$$1, workInProgress, updateExpirationTime, renderExpirationTime), workInProgress.child;

      case 14:
        return context = workInProgress.type, hasContext = resolveDefaultProps(context.type, workInProgress.pendingProps), updateMemoComponent(current$$1, workInProgress, context, hasContext, updateExpirationTime, renderExpirationTime);

      case 15:
        return updateSimpleMemoComponent(current$$1, workInProgress, workInProgress.type, workInProgress.pendingProps, updateExpirationTime, renderExpirationTime);

      case 17:
        return updateExpirationTime = workInProgress.type, context = workInProgress.pendingProps, context = workInProgress.elementType === updateExpirationTime ? context : resolveDefaultProps(updateExpirationTime, context), null !== current$$1 && (current$$1.alternate = null, workInProgress.alternate = null, workInProgress.effectTag |= 2), workInProgress.tag = 1, isContextProvider(updateExpirationTime) ? (current$$1 = !0, pushContextProvider(workInProgress)) : current$$1 = !1, prepareToReadContext(workInProgress, renderExpirationTime), constructClassInstance(workInProgress, updateExpirationTime, context, renderExpirationTime), mountClassInstance(workInProgress, updateExpirationTime, context, renderExpirationTime), finishClassComponent(null, workInProgress, updateExpirationTime, !0, current$$1, renderExpirationTime);

      default:
        invariant(!1, "Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.");
    }
  }

  var appendAllChildren = void 0,
      updateHostContainer = void 0,
      updateHostComponent$1 = void 0,
      updateHostText$1 = void 0;

  appendAllChildren = function appendAllChildren(parent, workInProgress) {
    for (var node = workInProgress.child; null !== node;) {
      if (5 === node.tag || 6 === node.tag) parent._children.push(node.stateNode);else if (4 !== node.tag && null !== node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === workInProgress) break;

      for (; null === node.sibling;) {
        if (null === node.return || node.return === workInProgress) return;
        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  };

  updateHostContainer = function updateHostContainer() {};

  updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps) {
    current.memoizedProps !== newProps && (requiredContext(contextStackCursor$1.current), workInProgress.updateQueue = UPDATE_SIGNAL) && (workInProgress.effectTag |= 4);
  };

  updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {
    oldText !== newText && (workInProgress.effectTag |= 4);
  };

  function logCapturedError(capturedError) {
    var componentStack = capturedError.componentStack,
        error = capturedError.error;

    if (error instanceof Error) {
      capturedError = error.message;
      var name = error.name;

      try {
        error.message = (capturedError ? name + ": " + capturedError : name) + "\n\nThis error is located at:" + componentStack;
      } catch (e) {}
    } else error = "string" === typeof error ? Error(error + "\n\nThis error is located at:" + componentStack) : Error("Unspecified error at:" + componentStack);

    ExceptionsManager.handleException(error, !1);
  }

  function logError(boundary, errorInfo) {
    var source = errorInfo.source,
        stack = errorInfo.stack;
    null === stack && null !== source && (stack = getStackByFiberInDevAndProd(source));
    errorInfo = {
      componentName: null !== source ? getComponentName(source.type) : null,
      componentStack: null !== stack ? stack : "",
      error: errorInfo.value,
      errorBoundary: null,
      errorBoundaryName: null,
      errorBoundaryFound: !1,
      willRetry: !1
    };
    null !== boundary && 1 === boundary.tag && (errorInfo.errorBoundary = boundary.stateNode, errorInfo.errorBoundaryName = getComponentName(boundary.type), errorInfo.errorBoundaryFound = !0, errorInfo.willRetry = !0);

    try {
      logCapturedError(errorInfo);
    } catch (e) {
      setTimeout(function () {
        throw e;
      });
    }
  }

  function safelyDetachRef(current$$1) {
    var ref = current$$1.ref;
    if (null !== ref) if ("function" === typeof ref) try {
      ref(null);
    } catch (refError) {
      captureCommitPhaseError(current$$1, refError);
    } else ref.current = null;
  }

  function commitUnmount(current$$1$jscomp$0) {
    "function" === typeof onCommitFiberUnmount && onCommitFiberUnmount(current$$1$jscomp$0);

    switch (current$$1$jscomp$0.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        var updateQueue = current$$1$jscomp$0.updateQueue;

        if (null !== updateQueue && (updateQueue = updateQueue.lastEffect, null !== updateQueue)) {
          var effect = updateQueue = updateQueue.next;

          do {
            var destroy = effect.destroy;

            if (null !== destroy) {
              var current$$1 = current$$1$jscomp$0;

              try {
                destroy();
              } catch (error) {
                captureCommitPhaseError(current$$1, error);
              }
            }

            effect = effect.next;
          } while (effect !== updateQueue);
        }

        break;

      case 1:
        safelyDetachRef(current$$1$jscomp$0);
        updateQueue = current$$1$jscomp$0.stateNode;
        if ("function" === typeof updateQueue.componentWillUnmount) try {
          updateQueue.props = current$$1$jscomp$0.memoizedProps, updateQueue.state = current$$1$jscomp$0.memoizedState, updateQueue.componentWillUnmount();
        } catch (unmountError) {
          captureCommitPhaseError(current$$1$jscomp$0, unmountError);
        }
        break;

      case 5:
        safelyDetachRef(current$$1$jscomp$0);
        break;

      case 4:
        unmountHostComponents(current$$1$jscomp$0);
    }
  }

  function isHostParent(fiber) {
    return 5 === fiber.tag || 3 === fiber.tag || 4 === fiber.tag;
  }

  function commitPlacement(finishedWork) {
    a: {
      for (var parent = finishedWork.return; null !== parent;) {
        if (isHostParent(parent)) {
          var parentFiber = parent;
          break a;
        }

        parent = parent.return;
      }

      invariant(!1, "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
      parentFiber = void 0;
    }

    var isContainer = parent = void 0;

    switch (parentFiber.tag) {
      case 5:
        parent = parentFiber.stateNode;
        isContainer = !1;
        break;

      case 3:
        parent = parentFiber.stateNode.containerInfo;
        isContainer = !0;
        break;

      case 4:
        parent = parentFiber.stateNode.containerInfo;
        isContainer = !0;
        break;

      default:
        invariant(!1, "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
    }

    parentFiber.effectTag & 16 && (parentFiber.effectTag &= -17);

    a: b: for (parentFiber = finishedWork;;) {
      for (; null === parentFiber.sibling;) {
        if (null === parentFiber.return || isHostParent(parentFiber.return)) {
          parentFiber = null;
          break a;
        }

        parentFiber = parentFiber.return;
      }

      parentFiber.sibling.return = parentFiber.return;

      for (parentFiber = parentFiber.sibling; 5 !== parentFiber.tag && 6 !== parentFiber.tag;) {
        if (parentFiber.effectTag & 2) continue b;
        if (null === parentFiber.child || 4 === parentFiber.tag) continue b;else parentFiber.child.return = parentFiber, parentFiber = parentFiber.child;
      }

      if (!(parentFiber.effectTag & 2)) {
        parentFiber = parentFiber.stateNode;
        break a;
      }
    }

    for (var node = finishedWork;;) {
      if (5 === node.tag || 6 === node.tag) {
        if (parentFiber) {
          if (isContainer) invariant("number" !== typeof parent, "Container does not support insertBefore operation");else {
            var parentInstance = parent,
                child = node.stateNode,
                beforeChild = parentFiber,
                children = parentInstance._children,
                index = children.indexOf(child);
            0 <= index ? (children.splice(index, 1), beforeChild = children.indexOf(beforeChild), children.splice(beforeChild, 0, child), UIManager.manageChildren(parentInstance._nativeTag, [index], [beforeChild], [], [], [])) : (index = children.indexOf(beforeChild), children.splice(index, 0, child), UIManager.manageChildren(parentInstance._nativeTag, [], [], ["number" === typeof child ? child : child._nativeTag], [index], []));
          }
        } else isContainer ? (parentInstance = node.stateNode, UIManager.setChildren(parent, ["number" === typeof parentInstance ? parentInstance : parentInstance._nativeTag])) : (parentInstance = parent, child = node.stateNode, children = "number" === typeof child ? child : child._nativeTag, index = parentInstance._children, beforeChild = index.indexOf(child), 0 <= beforeChild ? (index.splice(beforeChild, 1), index.push(child), UIManager.manageChildren(parentInstance._nativeTag, [beforeChild], [index.length - 1], [], [], [])) : (index.push(child), UIManager.manageChildren(parentInstance._nativeTag, [], [], [children], [index.length - 1], [])));
      } else if (4 !== node.tag && null !== node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === finishedWork) break;

      for (; null === node.sibling;) {
        if (null === node.return || node.return === finishedWork) return;
        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  }

  function unmountHostComponents(current$$1) {
    for (var node = current$$1, currentParentIsValid = !1, currentParent = void 0, currentParentIsContainer = void 0;;) {
      if (!currentParentIsValid) {
        currentParentIsValid = node.return;

        a: for (;;) {
          invariant(null !== currentParentIsValid, "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");

          switch (currentParentIsValid.tag) {
            case 5:
              currentParent = currentParentIsValid.stateNode;
              currentParentIsContainer = !1;
              break a;

            case 3:
              currentParent = currentParentIsValid.stateNode.containerInfo;
              currentParentIsContainer = !0;
              break a;

            case 4:
              currentParent = currentParentIsValid.stateNode.containerInfo;
              currentParentIsContainer = !0;
              break a;
          }

          currentParentIsValid = currentParentIsValid.return;
        }

        currentParentIsValid = !0;
      }

      if (5 === node.tag || 6 === node.tag) {
        a: for (var root = node, node$jscomp$0 = root;;) {
          if (commitUnmount(node$jscomp$0), null !== node$jscomp$0.child && 4 !== node$jscomp$0.tag) node$jscomp$0.child.return = node$jscomp$0, node$jscomp$0 = node$jscomp$0.child;else {
            if (node$jscomp$0 === root) break;

            for (; null === node$jscomp$0.sibling;) {
              if (null === node$jscomp$0.return || node$jscomp$0.return === root) break a;
              node$jscomp$0 = node$jscomp$0.return;
            }

            node$jscomp$0.sibling.return = node$jscomp$0.return;
            node$jscomp$0 = node$jscomp$0.sibling;
          }
        }

        if (currentParentIsContainer) root = currentParent, recursivelyUncacheFiberNode(node.stateNode), UIManager.manageChildren(root, [], [], [], [], [0]);else {
          root = currentParent;
          var child = node.stateNode;
          recursivelyUncacheFiberNode(child);
          node$jscomp$0 = root._children;
          child = node$jscomp$0.indexOf(child);
          node$jscomp$0.splice(child, 1);
          UIManager.manageChildren(root._nativeTag, [], [], [], [], [child]);
        }
      } else if (4 === node.tag ? (currentParent = node.stateNode.containerInfo, currentParentIsContainer = !0) : commitUnmount(node), null !== node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === current$$1) break;

      for (; null === node.sibling;) {
        if (null === node.return || node.return === current$$1) return;
        node = node.return;
        4 === node.tag && (currentParentIsValid = !1);
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  }

  function commitWork(current$$1, finishedWork) {
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        break;

      case 1:
        break;

      case 5:
        var instance = finishedWork.stateNode;

        if (null != instance) {
          var newProps = finishedWork.memoizedProps;
          current$$1 = null !== current$$1 ? current$$1.memoizedProps : newProps;
          var updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;
          null !== updatePayload && (finishedWork = instance.viewConfig, instanceProps[instance._nativeTag] = newProps, newProps = diffProperties(null, current$$1, newProps, finishedWork.validAttributes), null != newProps && UIManager.updateView(instance._nativeTag, finishedWork.uiViewClassName, newProps));
        }

        break;

      case 6:
        invariant(null !== finishedWork.stateNode, "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
        UIManager.updateView(finishedWork.stateNode, "RCTRawText", {
          text: finishedWork.memoizedProps
        });
        break;

      case 3:
        break;

      case 12:
        break;

      case 13:
        newProps = finishedWork.memoizedState;
        current$$1 = finishedWork;
        null === newProps ? instance = !1 : (instance = !0, current$$1 = finishedWork.child, 0 === newProps.timedOutAt && (newProps.timedOutAt = requestCurrentTime()));
        if (null !== current$$1) a: for (newProps = finishedWork = current$$1;;) {
          if (5 === newProps.tag) {
            if (current$$1 = newProps.stateNode, instance) {
              updatePayload = current$$1.viewConfig;
              var updatePayload$jscomp$0 = diffProperties(null, emptyObject, {
                style: {
                  display: "none"
                }
              }, updatePayload.validAttributes);
              UIManager.updateView(current$$1._nativeTag, updatePayload.uiViewClassName, updatePayload$jscomp$0);
            } else {
              current$$1 = newProps.stateNode;
              updatePayload$jscomp$0 = newProps.memoizedProps;
              updatePayload = current$$1.viewConfig;

              var prevProps = _extends({}, updatePayload$jscomp$0, {
                style: [updatePayload$jscomp$0.style, {
                  display: "none"
                }]
              });

              updatePayload$jscomp$0 = diffProperties(null, prevProps, updatePayload$jscomp$0, updatePayload.validAttributes);
              UIManager.updateView(current$$1._nativeTag, updatePayload.uiViewClassName, updatePayload$jscomp$0);
            }
          } else {
            if (6 === newProps.tag) throw Error("Not yet implemented.");

            if (null !== newProps.child) {
              newProps.child.return = newProps;
              newProps = newProps.child;
              continue;
            }
          }
          if (newProps === finishedWork) break a;

          for (; null === newProps.sibling;) {
            if (null === newProps.return || newProps.return === finishedWork) break a;
            newProps = newProps.return;
          }

          newProps.sibling.return = newProps.return;
          newProps = newProps.sibling;
        }
        break;

      case 17:
        break;

      default:
        invariant(!1, "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
  }

  function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
    expirationTime = createUpdate(expirationTime);
    expirationTime.tag = 3;
    expirationTime.payload = {
      element: null
    };
    var error = errorInfo.value;

    expirationTime.callback = function () {
      onUncaughtError(error);
      logError(fiber, errorInfo);
    };

    return expirationTime;
  }

  function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
    expirationTime = createUpdate(expirationTime);
    expirationTime.tag = 3;
    var getDerivedStateFromError = fiber.type.getDerivedStateFromError;

    if ("function" === typeof getDerivedStateFromError) {
      var error$jscomp$0 = errorInfo.value;

      expirationTime.payload = function () {
        return getDerivedStateFromError(error$jscomp$0);
      };
    }

    var inst = fiber.stateNode;
    null !== inst && "function" === typeof inst.componentDidCatch && (expirationTime.callback = function () {
      "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
      var error = errorInfo.value,
          stack = errorInfo.stack;
      logError(fiber, errorInfo);
      this.componentDidCatch(error, {
        componentStack: null !== stack ? stack : ""
      });
    });
    return expirationTime;
  }

  function unwindWork(workInProgress) {
    switch (workInProgress.tag) {
      case 1:
        isContextProvider(workInProgress.type) && popContext(workInProgress);
        var effectTag = workInProgress.effectTag;
        return effectTag & 2048 ? (workInProgress.effectTag = effectTag & -2049 | 64, workInProgress) : null;

      case 3:
        return popHostContainer(workInProgress), popTopLevelContextObject(workInProgress), effectTag = workInProgress.effectTag, invariant(0 === (effectTag & 64), "The root failed to unmount after an error. This is likely a bug in React. Please file an issue."), workInProgress.effectTag = effectTag & -2049 | 64, workInProgress;

      case 5:
        return popHostContext(workInProgress), null;

      case 13:
        return effectTag = workInProgress.effectTag, effectTag & 2048 ? (workInProgress.effectTag = effectTag & -2049 | 64, workInProgress) : null;

      case 4:
        return popHostContainer(workInProgress), null;

      case 10:
        return popProvider(workInProgress), null;

      default:
        return null;
    }
  }

  var DispatcherWithoutHooks = {
    readContext: readContext
  },
      ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
      isWorking = !1,
      nextUnitOfWork = null,
      nextRoot = null,
      nextRenderExpirationTime = 0,
      nextLatestAbsoluteTimeoutMs = -1,
      nextRenderDidError = !1,
      nextEffect = null,
      isCommitting$1 = !1,
      passiveEffectCallbackHandle = null,
      passiveEffectCallback = null,
      legacyErrorBoundariesThatAlreadyFailed = null;

  function resetStack() {
    if (null !== nextUnitOfWork) for (var interruptedWork = nextUnitOfWork.return; null !== interruptedWork;) {
      var interruptedWork$jscomp$0 = interruptedWork;

      switch (interruptedWork$jscomp$0.tag) {
        case 1:
          var childContextTypes = interruptedWork$jscomp$0.type.childContextTypes;
          null !== childContextTypes && void 0 !== childContextTypes && popContext(interruptedWork$jscomp$0);
          break;

        case 3:
          popHostContainer(interruptedWork$jscomp$0);
          popTopLevelContextObject(interruptedWork$jscomp$0);
          break;

        case 5:
          popHostContext(interruptedWork$jscomp$0);
          break;

        case 4:
          popHostContainer(interruptedWork$jscomp$0);
          break;

        case 10:
          popProvider(interruptedWork$jscomp$0);
      }

      interruptedWork = interruptedWork.return;
    }
    nextRoot = null;
    nextRenderExpirationTime = 0;
    nextLatestAbsoluteTimeoutMs = -1;
    nextRenderDidError = !1;
    nextUnitOfWork = null;
  }

  function flushPassiveEffects() {
    null !== passiveEffectCallback && (scheduler.unstable_cancelCallback(passiveEffectCallbackHandle), passiveEffectCallback());
  }

  function completeUnitOfWork(workInProgress) {
    for (;;) {
      var current$$1 = workInProgress.alternate,
          returnFiber = workInProgress.return,
          siblingFiber = workInProgress.sibling;

      if (0 === (workInProgress.effectTag & 1024)) {
        nextUnitOfWork = workInProgress;

        a: {
          var current = current$$1;
          current$$1 = workInProgress;
          var renderExpirationTime = nextRenderExpirationTime,
              newProps = current$$1.pendingProps;

          switch (current$$1.tag) {
            case 2:
              break;

            case 16:
              break;

            case 15:
            case 0:
              break;

            case 1:
              isContextProvider(current$$1.type) && popContext(current$$1);
              break;

            case 3:
              popHostContainer(current$$1);
              popTopLevelContextObject(current$$1);
              newProps = current$$1.stateNode;
              newProps.pendingContext && (newProps.context = newProps.pendingContext, newProps.pendingContext = null);
              if (null === current || null === current.child) current$$1.effectTag &= -3;
              updateHostContainer(current$$1);
              break;

            case 5:
              popHostContext(current$$1);
              renderExpirationTime = requiredContext(rootInstanceStackCursor.current);
              var type = current$$1.type;
              if (null !== current && null != current$$1.stateNode) updateHostComponent$1(current, current$$1, type, newProps, renderExpirationTime), current.ref !== current$$1.ref && (current$$1.effectTag |= 128);else if (newProps) {
                current = requiredContext(contextStackCursor$1.current);
                var internalInstanceHandle = current$$1,
                    tag = allocateTag(),
                    viewConfig = ReactNativeViewConfigRegistry.get(type);
                invariant("RCTView" !== type || !current.isInAParentText, "Nesting of <View> within <Text> is not currently supported.");
                var updatePayload = diffProperties(null, emptyObject, newProps, viewConfig.validAttributes);
                UIManager.createView(tag, viewConfig.uiViewClassName, renderExpirationTime, updatePayload);
                viewConfig = new ReactNativeFiberHostComponent(tag, viewConfig);
                instanceCache[tag] = internalInstanceHandle;
                instanceProps[tag] = newProps;
                appendAllChildren(viewConfig, current$$1, !1, !1);
                finalizeInitialChildren(viewConfig, type, newProps, renderExpirationTime, current) && (current$$1.effectTag |= 4);
                current$$1.stateNode = viewConfig;
                null !== current$$1.ref && (current$$1.effectTag |= 128);
              } else invariant(null !== current$$1.stateNode, "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              break;

            case 6:
              current && null != current$$1.stateNode ? updateHostText$1(current, current$$1, current.memoizedProps, newProps) : ("string" !== typeof newProps && invariant(null !== current$$1.stateNode, "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."), current = requiredContext(rootInstanceStackCursor.current), type = requiredContext(contextStackCursor$1.current), renderExpirationTime = current$$1, invariant(type.isInAParentText, "Text strings must be rendered within a <Text> component."), type = allocateTag(), UIManager.createView(type, "RCTRawText", current, {
                text: newProps
              }), instanceCache[type] = current$$1, renderExpirationTime.stateNode = type);
              break;

            case 11:
              break;

            case 13:
              newProps = current$$1.memoizedState;

              if (0 !== (current$$1.effectTag & 64)) {
                current$$1.expirationTime = renderExpirationTime;
                nextUnitOfWork = current$$1;
                break a;
              }

              newProps = null !== newProps;
              type = null !== current && null !== current.memoizedState;
              null !== current && !newProps && type && (current = current.child.sibling, null !== current && reconcileChildFibers(current$$1, current, null, renderExpirationTime));
              if (newProps !== type || 0 === (current$$1.effectTag & 1) && newProps) current$$1.effectTag |= 4;
              break;

            case 7:
              break;

            case 8:
              break;

            case 12:
              break;

            case 4:
              popHostContainer(current$$1);
              updateHostContainer(current$$1);
              break;

            case 10:
              popProvider(current$$1);
              break;

            case 9:
              break;

            case 14:
              break;

            case 17:
              isContextProvider(current$$1.type) && popContext(current$$1);
              break;

            default:
              invariant(!1, "Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.");
          }

          nextUnitOfWork = null;
        }

        current$$1 = workInProgress;

        if (1 === nextRenderExpirationTime || 1 !== current$$1.childExpirationTime) {
          newProps = 0;

          for (renderExpirationTime = current$$1.child; null !== renderExpirationTime;) {
            type = renderExpirationTime.expirationTime, current = renderExpirationTime.childExpirationTime, type > newProps && (newProps = type), current > newProps && (newProps = current), renderExpirationTime = renderExpirationTime.sibling;
          }

          current$$1.childExpirationTime = newProps;
        }

        if (null !== nextUnitOfWork) return nextUnitOfWork;
        null !== returnFiber && 0 === (returnFiber.effectTag & 1024) && (null === returnFiber.firstEffect && (returnFiber.firstEffect = workInProgress.firstEffect), null !== workInProgress.lastEffect && (null !== returnFiber.lastEffect && (returnFiber.lastEffect.nextEffect = workInProgress.firstEffect), returnFiber.lastEffect = workInProgress.lastEffect), 1 < workInProgress.effectTag && (null !== returnFiber.lastEffect ? returnFiber.lastEffect.nextEffect = workInProgress : returnFiber.firstEffect = workInProgress, returnFiber.lastEffect = workInProgress));
      } else {
        workInProgress = unwindWork(workInProgress, nextRenderExpirationTime);
        if (null !== workInProgress) return workInProgress.effectTag &= 1023, workInProgress;
        null !== returnFiber && (returnFiber.firstEffect = returnFiber.lastEffect = null, returnFiber.effectTag |= 1024);
      }

      if (null !== siblingFiber) return siblingFiber;
      if (null !== returnFiber) workInProgress = returnFiber;else break;
    }

    return null;
  }

  function performUnitOfWork(workInProgress) {
    var next = beginWork(workInProgress.alternate, workInProgress, nextRenderExpirationTime);
    workInProgress.memoizedProps = workInProgress.pendingProps;
    null === next && (next = completeUnitOfWork(workInProgress));
    ReactCurrentOwner$2.current = null;
    return next;
  }

  function renderRoot(root$jscomp$0, isYieldy) {
    invariant(!isWorking, "renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.");
    flushPassiveEffects();
    isWorking = !0;
    ReactCurrentOwner$2.currentDispatcher = DispatcherWithoutHooks;
    var expirationTime = root$jscomp$0.nextExpirationTimeToWorkOn;
    if (expirationTime !== nextRenderExpirationTime || root$jscomp$0 !== nextRoot || null === nextUnitOfWork) resetStack(), nextRoot = root$jscomp$0, nextRenderExpirationTime = expirationTime, nextUnitOfWork = createWorkInProgress(nextRoot.current, null, nextRenderExpirationTime), root$jscomp$0.pendingCommitExpirationTime = 0;
    var didFatal = !1;

    do {
      try {
        if (isYieldy) for (; null !== nextUnitOfWork && !shouldYieldToRenderer();) {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        } else for (; null !== nextUnitOfWork;) {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      } catch (thrownValue) {
        if (lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null, null === nextUnitOfWork) didFatal = !0, onUncaughtError(thrownValue);else {
          invariant(null !== nextUnitOfWork, "Failed to replay rendering after an error. This is likely caused by a bug in React. Please file an issue with a reproducing case to help us find it.");
          var sourceFiber = nextUnitOfWork,
              returnFiber = sourceFiber.return;
          if (null === returnFiber) didFatal = !0, onUncaughtError(thrownValue);else {
            a: {
              var root = root$jscomp$0,
                  returnFiber$jscomp$0 = returnFiber,
                  sourceFiber$jscomp$0 = sourceFiber,
                  value = thrownValue;
              returnFiber = nextRenderExpirationTime;
              sourceFiber$jscomp$0.effectTag |= 1024;
              sourceFiber$jscomp$0.firstEffect = sourceFiber$jscomp$0.lastEffect = null;

              if (null !== value && "object" === typeof value && "function" === typeof value.then) {
                var thenable = value;
                value = returnFiber$jscomp$0;
                var earliestTimeoutMs = -1,
                    startTimeMs = -1;

                do {
                  if (13 === value.tag) {
                    var current$$1 = value.alternate;

                    if (null !== current$$1 && (current$$1 = current$$1.memoizedState, null !== current$$1)) {
                      startTimeMs = 10 * (1073741822 - current$$1.timedOutAt);
                      break;
                    }

                    current$$1 = value.pendingProps.maxDuration;
                    if ("number" === typeof current$$1) if (0 >= current$$1) earliestTimeoutMs = 0;else if (-1 === earliestTimeoutMs || current$$1 < earliestTimeoutMs) earliestTimeoutMs = current$$1;
                  }

                  value = value.return;
                } while (null !== value);

                value = returnFiber$jscomp$0;

                do {
                  if (current$$1 = 13 === value.tag) current$$1 = void 0 === value.memoizedProps.fallback ? !1 : null === value.memoizedState;

                  if (current$$1) {
                    returnFiber$jscomp$0 = retrySuspendedRoot.bind(null, root, value, sourceFiber$jscomp$0, 0 === (value.mode & 1) ? 1073741823 : returnFiber);
                    thenable.then(returnFiber$jscomp$0, returnFiber$jscomp$0);

                    if (0 === (value.mode & 1)) {
                      value.effectTag |= 64;
                      reconcileChildren(sourceFiber$jscomp$0.alternate, sourceFiber$jscomp$0, null, returnFiber);
                      sourceFiber$jscomp$0.effectTag &= -1025;
                      sourceFiber$jscomp$0.effectTag &= -933;
                      1 === sourceFiber$jscomp$0.tag && null === sourceFiber$jscomp$0.alternate && (sourceFiber$jscomp$0.tag = 17);
                      sourceFiber$jscomp$0.expirationTime = returnFiber;
                      break a;
                    }

                    -1 === earliestTimeoutMs ? root = 1073741823 : (-1 === startTimeMs && (startTimeMs = 10 * (1073741822 - findEarliestOutstandingPriorityLevel(root, returnFiber)) - 5e3), root = startTimeMs + earliestTimeoutMs);
                    0 <= root && nextLatestAbsoluteTimeoutMs < root && (nextLatestAbsoluteTimeoutMs = root);
                    value.effectTag |= 2048;
                    value.expirationTime = returnFiber;
                    break a;
                  }

                  value = value.return;
                } while (null !== value);

                value = Error((getComponentName(sourceFiber$jscomp$0.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." + getStackByFiberInDevAndProd(sourceFiber$jscomp$0));
              }

              nextRenderDidError = !0;
              value = createCapturedValue(value, sourceFiber$jscomp$0);
              root = returnFiber$jscomp$0;

              do {
                switch (root.tag) {
                  case 3:
                    sourceFiber$jscomp$0 = value;
                    root.effectTag |= 2048;
                    root.expirationTime = returnFiber;
                    returnFiber = createRootErrorUpdate(root, sourceFiber$jscomp$0, returnFiber);
                    enqueueCapturedUpdate(root, returnFiber);
                    break a;

                  case 1:
                    if (sourceFiber$jscomp$0 = value, returnFiber$jscomp$0 = root.type, thenable = root.stateNode, 0 === (root.effectTag & 64) && ("function" === typeof returnFiber$jscomp$0.getDerivedStateFromError || null !== thenable && "function" === typeof thenable.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(thenable)))) {
                      root.effectTag |= 2048;
                      root.expirationTime = returnFiber;
                      returnFiber = createClassErrorUpdate(root, sourceFiber$jscomp$0, returnFiber);
                      enqueueCapturedUpdate(root, returnFiber);
                      break a;
                    }

                }

                root = root.return;
              } while (null !== root);
            }

            nextUnitOfWork = completeUnitOfWork(sourceFiber);
            continue;
          }
        }
      }

      break;
    } while (1);

    isWorking = !1;
    lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = ReactCurrentOwner$2.currentDispatcher = null;
    if (didFatal) nextRoot = null, root$jscomp$0.finishedWork = null;else if (null !== nextUnitOfWork) root$jscomp$0.finishedWork = null;else {
      didFatal = root$jscomp$0.current.alternate;
      invariant(null !== didFatal, "Finished root should have a work-in-progress. This error is likely caused by a bug in React. Please file an issue.");
      nextRoot = null;

      if (nextRenderDidError) {
        sourceFiber = root$jscomp$0.latestPendingTime;
        returnFiber = root$jscomp$0.latestSuspendedTime;
        root = root$jscomp$0.latestPingedTime;

        if (0 !== sourceFiber && sourceFiber < expirationTime || 0 !== returnFiber && returnFiber < expirationTime || 0 !== root && root < expirationTime) {
          markSuspendedPriorityLevel(root$jscomp$0, expirationTime);
          onSuspend(root$jscomp$0, didFatal, expirationTime, root$jscomp$0.expirationTime, -1);
          return;
        }

        if (!root$jscomp$0.didError && isYieldy) {
          root$jscomp$0.didError = !0;
          expirationTime = root$jscomp$0.nextExpirationTimeToWorkOn = expirationTime;
          isYieldy = root$jscomp$0.expirationTime = 1073741823;
          onSuspend(root$jscomp$0, didFatal, expirationTime, isYieldy, -1);
          return;
        }
      }

      isYieldy && -1 !== nextLatestAbsoluteTimeoutMs ? (markSuspendedPriorityLevel(root$jscomp$0, expirationTime), isYieldy = 10 * (1073741822 - findEarliestOutstandingPriorityLevel(root$jscomp$0, expirationTime)), isYieldy < nextLatestAbsoluteTimeoutMs && (nextLatestAbsoluteTimeoutMs = isYieldy), isYieldy = 10 * (1073741822 - requestCurrentTime()), isYieldy = nextLatestAbsoluteTimeoutMs - isYieldy, onSuspend(root$jscomp$0, didFatal, expirationTime, root$jscomp$0.expirationTime, 0 > isYieldy ? 0 : isYieldy)) : (root$jscomp$0.pendingCommitExpirationTime = expirationTime, root$jscomp$0.finishedWork = didFatal);
    }
  }

  function captureCommitPhaseError(sourceFiber, value) {
    for (var fiber = sourceFiber.return; null !== fiber;) {
      switch (fiber.tag) {
        case 1:
          var instance = fiber.stateNode;

          if ("function" === typeof fiber.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
            sourceFiber = createCapturedValue(value, sourceFiber);
            sourceFiber = createClassErrorUpdate(fiber, sourceFiber, 1073741823);
            enqueueUpdate(fiber, sourceFiber);
            scheduleWork(fiber, 1073741823);
            return;
          }

          break;

        case 3:
          sourceFiber = createCapturedValue(value, sourceFiber);
          sourceFiber = createRootErrorUpdate(fiber, sourceFiber, 1073741823);
          enqueueUpdate(fiber, sourceFiber);
          scheduleWork(fiber, 1073741823);
          return;
      }

      fiber = fiber.return;
    }

    3 === sourceFiber.tag && (fiber = createCapturedValue(value, sourceFiber), fiber = createRootErrorUpdate(sourceFiber, fiber, 1073741823), enqueueUpdate(sourceFiber, fiber), scheduleWork(sourceFiber, 1073741823));
  }

  function computeExpirationForFiber(currentTime, fiber) {
    isWorking ? currentTime = isCommitting$1 ? 1073741823 : nextRenderExpirationTime : fiber.mode & 1 ? (currentTime = isBatchingInteractiveUpdates ? 1073741822 - 10 * (((1073741822 - currentTime + 15) / 10 | 0) + 1) : 1073741822 - 25 * (((1073741822 - currentTime + 500) / 25 | 0) + 1), null !== nextRoot && currentTime === nextRenderExpirationTime && --currentTime) : currentTime = 1073741823;
    isBatchingInteractiveUpdates && (0 === lowestPriorityPendingInteractiveExpirationTime || currentTime < lowestPriorityPendingInteractiveExpirationTime) && (lowestPriorityPendingInteractiveExpirationTime = currentTime);
    return currentTime;
  }

  function retrySuspendedRoot(root, boundaryFiber, sourceFiber, suspendedTime) {
    var retryTime = root.earliestSuspendedTime;
    var latestSuspendedTime = root.latestSuspendedTime;

    if (0 !== retryTime && suspendedTime <= retryTime && suspendedTime >= latestSuspendedTime) {
      latestSuspendedTime = retryTime = suspendedTime;
      root.didError = !1;
      var latestPingedTime = root.latestPingedTime;
      if (0 === latestPingedTime || latestPingedTime > latestSuspendedTime) root.latestPingedTime = latestSuspendedTime;
      findNextExpirationTimeToWorkOn(latestSuspendedTime, root);
    } else retryTime = requestCurrentTime(), retryTime = computeExpirationForFiber(retryTime, boundaryFiber), markPendingPriorityLevel(root, retryTime);

    0 !== (boundaryFiber.mode & 1) && root === nextRoot && nextRenderExpirationTime === suspendedTime && (nextRoot = null);
    scheduleWorkToRoot(boundaryFiber, retryTime);
    0 === (boundaryFiber.mode & 1) && (scheduleWorkToRoot(sourceFiber, retryTime), 1 === sourceFiber.tag && null !== sourceFiber.stateNode && (boundaryFiber = createUpdate(retryTime), boundaryFiber.tag = 2, enqueueUpdate(sourceFiber, boundaryFiber)));
    sourceFiber = root.expirationTime;
    0 !== sourceFiber && requestWork(root, sourceFiber);
  }

  function scheduleWorkToRoot(fiber, expirationTime) {
    fiber.expirationTime < expirationTime && (fiber.expirationTime = expirationTime);
    var alternate = fiber.alternate;
    null !== alternate && alternate.expirationTime < expirationTime && (alternate.expirationTime = expirationTime);
    var node = fiber.return,
        root = null;
    if (null === node && 3 === fiber.tag) root = fiber.stateNode;else for (; null !== node;) {
      alternate = node.alternate;
      node.childExpirationTime < expirationTime && (node.childExpirationTime = expirationTime);
      null !== alternate && alternate.childExpirationTime < expirationTime && (alternate.childExpirationTime = expirationTime);

      if (null === node.return && 3 === node.tag) {
        root = node.stateNode;
        break;
      }

      node = node.return;
    }
    return null === root ? null : root;
  }

  function scheduleWork(fiber, expirationTime) {
    fiber = scheduleWorkToRoot(fiber, expirationTime);
    null !== fiber && (!isWorking && 0 !== nextRenderExpirationTime && expirationTime > nextRenderExpirationTime && resetStack(), markPendingPriorityLevel(fiber, expirationTime), isWorking && !isCommitting$1 && nextRoot === fiber || requestWork(fiber, fiber.expirationTime), nestedUpdateCount > NESTED_UPDATE_LIMIT && (nestedUpdateCount = 0, invariant(!1, "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.")));
  }

  var firstScheduledRoot = null,
      lastScheduledRoot = null,
      callbackExpirationTime = 0,
      callbackID = void 0,
      isRendering = !1,
      nextFlushedRoot = null,
      nextFlushedExpirationTime = 0,
      lowestPriorityPendingInteractiveExpirationTime = 0,
      hasUnhandledError = !1,
      unhandledError = null,
      isBatchingUpdates = !1,
      isUnbatchingUpdates = !1,
      isBatchingInteractiveUpdates = !1,
      completedBatches = null,
      originalStartTimeMs = now$1(),
      currentRendererTime = 1073741822 - (originalStartTimeMs / 10 | 0),
      currentSchedulerTime = currentRendererTime,
      NESTED_UPDATE_LIMIT = 50,
      nestedUpdateCount = 0,
      lastCommittedRootDuringThisBatch = null;

  function recomputeCurrentRendererTime() {
    currentRendererTime = 1073741822 - ((now$1() - originalStartTimeMs) / 10 | 0);
  }

  function scheduleCallbackWithExpirationTime(root, expirationTime) {
    if (0 !== callbackExpirationTime) {
      if (expirationTime < callbackExpirationTime) return;
      null !== callbackID && (root = callbackID, scheduledCallback = null, clearTimeout(root));
    }

    callbackExpirationTime = expirationTime;
    now$1();
    scheduledCallback = performAsyncWork;
    callbackID = setTimeout(setTimeoutCallback, 1);
  }

  function onSuspend(root, finishedWork, suspendedExpirationTime, rootExpirationTime, msUntilTimeout) {
    root.expirationTime = rootExpirationTime;
    0 !== msUntilTimeout || shouldYieldToRenderer() ? 0 < msUntilTimeout && (root.timeoutHandle = scheduleTimeout(onTimeout.bind(null, root, finishedWork, suspendedExpirationTime), msUntilTimeout)) : (root.pendingCommitExpirationTime = suspendedExpirationTime, root.finishedWork = finishedWork);
  }

  function onTimeout(root, finishedWork, suspendedExpirationTime) {
    root.pendingCommitExpirationTime = suspendedExpirationTime;
    root.finishedWork = finishedWork;
    recomputeCurrentRendererTime();
    currentSchedulerTime = currentRendererTime;
    invariant(!isRendering, "work.commit(): Cannot commit while already rendering. This likely means you attempted to commit from inside a lifecycle method.");
    nextFlushedRoot = root;
    nextFlushedExpirationTime = suspendedExpirationTime;
    performWorkOnRoot(root, suspendedExpirationTime, !1);
    performWork(1073741823, !1);
  }

  function requestCurrentTime() {
    if (isRendering) return currentSchedulerTime;
    findHighestPriorityRoot();
    if (0 === nextFlushedExpirationTime || 1 === nextFlushedExpirationTime) recomputeCurrentRendererTime(), currentSchedulerTime = currentRendererTime;
    return currentSchedulerTime;
  }

  function requestWork(root, expirationTime) {
    null === root.nextScheduledRoot ? (root.expirationTime = expirationTime, null === lastScheduledRoot ? (firstScheduledRoot = lastScheduledRoot = root, root.nextScheduledRoot = root) : (lastScheduledRoot = lastScheduledRoot.nextScheduledRoot = root, lastScheduledRoot.nextScheduledRoot = firstScheduledRoot)) : expirationTime > root.expirationTime && (root.expirationTime = expirationTime);
    isRendering || (isBatchingUpdates ? isUnbatchingUpdates && (nextFlushedRoot = root, nextFlushedExpirationTime = 1073741823, performWorkOnRoot(root, 1073741823, !1)) : 1073741823 === expirationTime ? performWork(1073741823, !1) : scheduleCallbackWithExpirationTime(root, expirationTime));
  }

  function findHighestPriorityRoot() {
    var highestPriorityWork = 0,
        highestPriorityRoot = null;
    if (null !== lastScheduledRoot) for (var previousScheduledRoot = lastScheduledRoot, root = firstScheduledRoot; null !== root;) {
      var remainingExpirationTime = root.expirationTime;

      if (0 === remainingExpirationTime) {
        invariant(null !== previousScheduledRoot && null !== lastScheduledRoot, "Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.");

        if (root === root.nextScheduledRoot) {
          firstScheduledRoot = lastScheduledRoot = root.nextScheduledRoot = null;
          break;
        } else if (root === firstScheduledRoot) firstScheduledRoot = remainingExpirationTime = root.nextScheduledRoot, lastScheduledRoot.nextScheduledRoot = remainingExpirationTime, root.nextScheduledRoot = null;else if (root === lastScheduledRoot) {
          lastScheduledRoot = previousScheduledRoot;
          lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
          root.nextScheduledRoot = null;
          break;
        } else previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot, root.nextScheduledRoot = null;

        root = previousScheduledRoot.nextScheduledRoot;
      } else {
        remainingExpirationTime > highestPriorityWork && (highestPriorityWork = remainingExpirationTime, highestPriorityRoot = root);
        if (root === lastScheduledRoot) break;
        if (1073741823 === highestPriorityWork) break;
        previousScheduledRoot = root;
        root = root.nextScheduledRoot;
      }
    }
    nextFlushedRoot = highestPriorityRoot;
    nextFlushedExpirationTime = highestPriorityWork;
  }

  var didYield = !1;

  function shouldYieldToRenderer() {
    return didYield ? !0 : frameDeadline <= now$1() ? didYield = !0 : !1;
  }

  function performAsyncWork() {
    try {
      if (!shouldYieldToRenderer() && null !== firstScheduledRoot) {
        recomputeCurrentRendererTime();
        var root = firstScheduledRoot;

        do {
          var expirationTime = root.expirationTime;
          0 !== expirationTime && currentRendererTime <= expirationTime && (root.nextExpirationTimeToWorkOn = currentRendererTime);
          root = root.nextScheduledRoot;
        } while (root !== firstScheduledRoot);
      }

      performWork(0, !0);
    } finally {
      didYield = !1;
    }
  }

  function performWork(minExpirationTime, isYieldy) {
    findHighestPriorityRoot();
    if (isYieldy) for (recomputeCurrentRendererTime(), currentSchedulerTime = currentRendererTime; null !== nextFlushedRoot && 0 !== nextFlushedExpirationTime && minExpirationTime <= nextFlushedExpirationTime && !(didYield && currentRendererTime > nextFlushedExpirationTime);) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, currentRendererTime > nextFlushedExpirationTime), findHighestPriorityRoot(), recomputeCurrentRendererTime(), currentSchedulerTime = currentRendererTime;
    } else for (; null !== nextFlushedRoot && 0 !== nextFlushedExpirationTime && minExpirationTime <= nextFlushedExpirationTime;) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, !1), findHighestPriorityRoot();
    }
    isYieldy && (callbackExpirationTime = 0, callbackID = null);
    0 !== nextFlushedExpirationTime && scheduleCallbackWithExpirationTime(nextFlushedRoot, nextFlushedExpirationTime);
    nestedUpdateCount = 0;
    lastCommittedRootDuringThisBatch = null;
    if (null !== completedBatches) for (minExpirationTime = completedBatches, completedBatches = null, isYieldy = 0; isYieldy < minExpirationTime.length; isYieldy++) {
      var batch = minExpirationTime[isYieldy];

      try {
        batch._onComplete();
      } catch (error) {
        hasUnhandledError || (hasUnhandledError = !0, unhandledError = error);
      }
    }
    if (hasUnhandledError) throw minExpirationTime = unhandledError, unhandledError = null, hasUnhandledError = !1, minExpirationTime;
  }

  function performWorkOnRoot(root, expirationTime, isYieldy) {
    invariant(!isRendering, "performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.");
    isRendering = !0;

    if (isYieldy) {
      var _finishedWork = root.finishedWork;
      null !== _finishedWork ? completeRoot(root, _finishedWork, expirationTime) : (root.finishedWork = null, _finishedWork = root.timeoutHandle, -1 !== _finishedWork && (root.timeoutHandle = -1, cancelTimeout(_finishedWork)), renderRoot(root, isYieldy), _finishedWork = root.finishedWork, null !== _finishedWork && (shouldYieldToRenderer() ? root.finishedWork = _finishedWork : completeRoot(root, _finishedWork, expirationTime)));
    } else _finishedWork = root.finishedWork, null !== _finishedWork ? completeRoot(root, _finishedWork, expirationTime) : (root.finishedWork = null, _finishedWork = root.timeoutHandle, -1 !== _finishedWork && (root.timeoutHandle = -1, cancelTimeout(_finishedWork)), renderRoot(root, isYieldy), _finishedWork = root.finishedWork, null !== _finishedWork && completeRoot(root, _finishedWork, expirationTime));

    isRendering = !1;
  }

  function completeRoot(root, finishedWork$jscomp$0, expirationTime) {
    var firstBatch = root.firstBatch;

    if (null !== firstBatch && firstBatch._expirationTime >= expirationTime && (null === completedBatches ? completedBatches = [firstBatch] : completedBatches.push(firstBatch), firstBatch._defer)) {
      root.finishedWork = finishedWork$jscomp$0;
      root.expirationTime = 0;
      return;
    }

    root.finishedWork = null;
    root === lastCommittedRootDuringThisBatch ? nestedUpdateCount++ : (lastCommittedRootDuringThisBatch = root, nestedUpdateCount = 0);
    isCommitting$1 = isWorking = !0;
    invariant(root.current !== finishedWork$jscomp$0, "Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.");
    expirationTime = root.pendingCommitExpirationTime;
    invariant(0 !== expirationTime, "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
    root.pendingCommitExpirationTime = 0;
    firstBatch = finishedWork$jscomp$0.expirationTime;
    var childExpirationTimeBeforeCommit = finishedWork$jscomp$0.childExpirationTime;
    firstBatch = childExpirationTimeBeforeCommit > firstBatch ? childExpirationTimeBeforeCommit : firstBatch;
    root.didError = !1;
    0 === firstBatch ? (root.earliestPendingTime = 0, root.latestPendingTime = 0, root.earliestSuspendedTime = 0, root.latestSuspendedTime = 0, root.latestPingedTime = 0) : (childExpirationTimeBeforeCommit = root.latestPendingTime, 0 !== childExpirationTimeBeforeCommit && (childExpirationTimeBeforeCommit > firstBatch ? root.earliestPendingTime = root.latestPendingTime = 0 : root.earliestPendingTime > firstBatch && (root.earliestPendingTime = root.latestPendingTime)), childExpirationTimeBeforeCommit = root.earliestSuspendedTime, 0 === childExpirationTimeBeforeCommit ? markPendingPriorityLevel(root, firstBatch) : firstBatch < root.latestSuspendedTime ? (root.earliestSuspendedTime = 0, root.latestSuspendedTime = 0, root.latestPingedTime = 0, markPendingPriorityLevel(root, firstBatch)) : firstBatch > childExpirationTimeBeforeCommit && markPendingPriorityLevel(root, firstBatch));
    findNextExpirationTimeToWorkOn(0, root);
    ReactCurrentOwner$2.current = null;
    1 < finishedWork$jscomp$0.effectTag ? null !== finishedWork$jscomp$0.lastEffect ? (finishedWork$jscomp$0.lastEffect.nextEffect = finishedWork$jscomp$0, firstBatch = finishedWork$jscomp$0.firstEffect) : firstBatch = finishedWork$jscomp$0 : firstBatch = finishedWork$jscomp$0.firstEffect;

    for (nextEffect = firstBatch; null !== nextEffect;) {
      childExpirationTimeBeforeCommit = !1;
      var error = void 0;

      try {
        for (; null !== nextEffect;) {
          if (nextEffect.effectTag & 256) a: {
            var current$$1 = nextEffect.alternate,
                finishedWork = nextEffect;

            switch (finishedWork.tag) {
              case 0:
              case 11:
              case 15:
                break a;

              case 1:
                if (finishedWork.effectTag & 256 && null !== current$$1) {
                  var prevProps = current$$1.memoizedProps,
                      prevState = current$$1.memoizedState,
                      instance = finishedWork.stateNode,
                      snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                  instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                }

                break a;

              case 3:
              case 5:
              case 6:
              case 4:
              case 17:
                break a;

              default:
                invariant(!1, "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          nextEffect = nextEffect.nextEffect;
        }
      } catch (e) {
        childExpirationTimeBeforeCommit = !0, error = e;
      }

      childExpirationTimeBeforeCommit && (invariant(null !== nextEffect, "Should have next effect. This error is likely caused by a bug in React. Please file an issue."), captureCommitPhaseError(nextEffect, error), null !== nextEffect && (nextEffect = nextEffect.nextEffect));
    }

    for (nextEffect = firstBatch; null !== nextEffect;) {
      current$$1 = !1;
      prevProps = void 0;

      try {
        for (; null !== nextEffect;) {
          var effectTag = nextEffect.effectTag;

          if (effectTag & 128) {
            var current$$1$jscomp$0 = nextEffect.alternate;

            if (null !== current$$1$jscomp$0) {
              var currentRef = current$$1$jscomp$0.ref;
              null !== currentRef && ("function" === typeof currentRef ? currentRef(null) : currentRef.current = null);
            }
          }

          switch (effectTag & 14) {
            case 2:
              commitPlacement(nextEffect);
              nextEffect.effectTag &= -3;
              break;

            case 6:
              commitPlacement(nextEffect);
              nextEffect.effectTag &= -3;
              commitWork(nextEffect.alternate, nextEffect);
              break;

            case 4:
              commitWork(nextEffect.alternate, nextEffect);
              break;

            case 8:
              prevState = nextEffect, unmountHostComponents(prevState), prevState.return = null, prevState.child = null, prevState.alternate && (prevState.alternate.child = null, prevState.alternate.return = null);
          }

          nextEffect = nextEffect.nextEffect;
        }
      } catch (e) {
        current$$1 = !0, prevProps = e;
      }

      current$$1 && (invariant(null !== nextEffect, "Should have next effect. This error is likely caused by a bug in React. Please file an issue."), captureCommitPhaseError(nextEffect, prevProps), null !== nextEffect && (nextEffect = nextEffect.nextEffect));
    }

    root.current = finishedWork$jscomp$0;

    for (nextEffect = firstBatch; null !== nextEffect;) {
      effectTag = !1;
      current$$1$jscomp$0 = void 0;

      try {
        for (currentRef = expirationTime; null !== nextEffect;) {
          var effectTag$jscomp$0 = nextEffect.effectTag;

          if (effectTag$jscomp$0 & 36) {
            var current$$1$jscomp$1 = nextEffect.alternate;
            current$$1 = nextEffect;
            prevProps = currentRef;

            switch (current$$1.tag) {
              case 0:
              case 11:
              case 15:
                break;

              case 1:
                var instance$jscomp$0 = current$$1.stateNode;
                if (current$$1.effectTag & 4) if (null === current$$1$jscomp$1) instance$jscomp$0.componentDidMount();else {
                  var prevProps$jscomp$0 = current$$1.elementType === current$$1.type ? current$$1$jscomp$1.memoizedProps : resolveDefaultProps(current$$1.type, current$$1$jscomp$1.memoizedProps);
                  instance$jscomp$0.componentDidUpdate(prevProps$jscomp$0, current$$1$jscomp$1.memoizedState, instance$jscomp$0.__reactInternalSnapshotBeforeUpdate);
                }
                var updateQueue = current$$1.updateQueue;
                null !== updateQueue && commitUpdateQueue(current$$1, updateQueue, instance$jscomp$0, prevProps);
                break;

              case 3:
                var _updateQueue = current$$1.updateQueue;

                if (null !== _updateQueue) {
                  prevState = null;
                  if (null !== current$$1.child) switch (current$$1.child.tag) {
                    case 5:
                      prevState = current$$1.child.stateNode;
                      break;

                    case 1:
                      prevState = current$$1.child.stateNode;
                  }
                  commitUpdateQueue(current$$1, _updateQueue, prevState, prevProps);
                }

                break;

              case 5:
                break;

              case 6:
                break;

              case 4:
                break;

              case 12:
                break;

              case 13:
                break;

              case 17:
                break;

              default:
                invariant(!1, "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
          }

          if (effectTag$jscomp$0 & 128) {
            var ref = nextEffect.ref;

            if (null !== ref) {
              var instance$jscomp$1 = nextEffect.stateNode;

              switch (nextEffect.tag) {
                case 5:
                  var instanceToUse = instance$jscomp$1;
                  break;

                default:
                  instanceToUse = instance$jscomp$1;
              }

              "function" === typeof ref ? ref(instanceToUse) : ref.current = instanceToUse;
            }
          }

          nextEffect = nextEffect.nextEffect;
        }
      } catch (e) {
        effectTag = !0, current$$1$jscomp$0 = e;
      }

      effectTag && (invariant(null !== nextEffect, "Should have next effect. This error is likely caused by a bug in React. Please file an issue."), captureCommitPhaseError(nextEffect, current$$1$jscomp$0), null !== nextEffect && (nextEffect = nextEffect.nextEffect));
    }

    isWorking = isCommitting$1 = !1;
    "function" === typeof onCommitFiberRoot && onCommitFiberRoot(finishedWork$jscomp$0.stateNode);
    effectTag$jscomp$0 = finishedWork$jscomp$0.expirationTime;
    finishedWork$jscomp$0 = finishedWork$jscomp$0.childExpirationTime;
    finishedWork$jscomp$0 = finishedWork$jscomp$0 > effectTag$jscomp$0 ? finishedWork$jscomp$0 : effectTag$jscomp$0;
    0 === finishedWork$jscomp$0 && (legacyErrorBoundariesThatAlreadyFailed = null);
    root.expirationTime = finishedWork$jscomp$0;
    root.finishedWork = null;
  }

  function onUncaughtError(error) {
    invariant(null !== nextFlushedRoot, "Should be working on a root. This error is likely caused by a bug in React. Please file an issue.");
    nextFlushedRoot.expirationTime = 0;
    hasUnhandledError || (hasUnhandledError = !0, unhandledError = error);
  }

  function findHostInstance$1(component) {
    var fiber = component._reactInternalFiber;
    void 0 === fiber && ("function" === typeof component.render ? invariant(!1, "Unable to find node on an unmounted component.") : invariant(!1, "Argument appears to not be a ReactComponent. Keys: %s", Object.keys(component)));
    component = findCurrentHostFiber(fiber);
    return null === component ? null : component.stateNode;
  }

  function updateContainer(element, container, parentComponent, callback) {
    var current$$1 = container.current,
        currentTime = requestCurrentTime();
    current$$1 = computeExpirationForFiber(currentTime, current$$1);
    currentTime = container.current;

    a: if (parentComponent) {
      parentComponent = parentComponent._reactInternalFiber;

      b: {
        invariant(2 === isFiberMountedImpl(parentComponent) && 1 === parentComponent.tag, "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var parentContext = parentComponent;

        do {
          switch (parentContext.tag) {
            case 3:
              parentContext = parentContext.stateNode.context;
              break b;

            case 1:
              if (isContextProvider(parentContext.type)) {
                parentContext = parentContext.stateNode.__reactInternalMemoizedMergedChildContext;
                break b;
              }

          }

          parentContext = parentContext.return;
        } while (null !== parentContext);

        invariant(!1, "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
        parentContext = void 0;
      }

      if (1 === parentComponent.tag) {
        var Component = parentComponent.type;

        if (isContextProvider(Component)) {
          parentComponent = processChildContext(parentComponent, Component, parentContext);
          break a;
        }
      }

      parentComponent = parentContext;
    } else parentComponent = emptyContextObject;

    null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
    container = callback;
    callback = createUpdate(current$$1);
    callback.payload = {
      element: element
    };
    container = void 0 === container ? null : container;
    null !== container && (callback.callback = container);
    flushPassiveEffects();
    enqueueUpdate(currentTime, callback);
    scheduleWork(currentTime, current$$1);
    return current$$1;
  }

  function _createPortal(children, containerInfo, implementation) {
    var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return {
      $$typeof: REACT_PORTAL_TYPE,
      key: null == key ? null : "" + key,
      children: children,
      containerInfo: containerInfo,
      implementation: implementation
    };
  }

  function _inherits(subClass, superClass) {
    if ("function" !== typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    });
    superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
  }

  var getInspectorDataForViewTag = void 0;

  getInspectorDataForViewTag = function getInspectorDataForViewTag() {
    invariant(!1, "getInspectorDataForViewTag() is not available in production");
  };

  function findNodeHandle(componentOrHandle) {
    if (null == componentOrHandle) return null;
    if ("number" === typeof componentOrHandle) return componentOrHandle;
    if (componentOrHandle._nativeTag) return componentOrHandle._nativeTag;
    if (componentOrHandle.canonical && componentOrHandle.canonical._nativeTag) return componentOrHandle.canonical._nativeTag;
    componentOrHandle = findHostInstance$1(componentOrHandle);
    return null == componentOrHandle ? componentOrHandle : componentOrHandle.canonical ? componentOrHandle.canonical._nativeTag : componentOrHandle._nativeTag;
  }

  _batchedUpdatesImpl = function _batchedUpdatesImpl(fn, a) {
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = !0;

    try {
      return fn(a);
    } finally {
      (isBatchingUpdates = previousIsBatchingUpdates) || isRendering || performWork(1073741823, !1);
    }
  };

  _flushInteractiveUpdatesImpl = function _flushInteractiveUpdatesImpl() {
    isRendering || 0 === lowestPriorityPendingInteractiveExpirationTime || (performWork(lowestPriorityPendingInteractiveExpirationTime, !1), lowestPriorityPendingInteractiveExpirationTime = 0);
  };

  var roots = new Map(),
      ReactNativeRenderer = {
    NativeComponent: function (findNodeHandle, findHostInstance) {
      return function (_React$Component) {
        function ReactNativeComponent() {
          if (!(this instanceof ReactNativeComponent)) throw new TypeError("Cannot call a class as a function");

          var call = _React$Component.apply(this, arguments);

          if (!this) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return !call || "object" !== typeof call && "function" !== typeof call ? this : call;
        }

        _inherits(ReactNativeComponent, _React$Component);

        ReactNativeComponent.prototype.blur = function () {
          TextInputState.blurTextInput(findNodeHandle(this));
        };

        ReactNativeComponent.prototype.focus = function () {
          TextInputState.focusTextInput(findNodeHandle(this));
        };

        ReactNativeComponent.prototype.measure = function (callback) {
          UIManager.measure(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
        };

        ReactNativeComponent.prototype.measureInWindow = function (callback) {
          UIManager.measureInWindow(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
        };

        ReactNativeComponent.prototype.measureLayout = function (relativeToNativeNode, onSuccess, onFail) {
          UIManager.measureLayout(findNodeHandle(this), relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
        };

        ReactNativeComponent.prototype.setNativeProps = function (nativeProps) {
          var maybeInstance = void 0;

          try {
            maybeInstance = findHostInstance(this);
          } catch (error) {}

          if (null != maybeInstance) {
            var viewConfig = maybeInstance.viewConfig || maybeInstance.canonical.viewConfig;
            nativeProps = diffProperties(null, emptyObject, nativeProps, viewConfig.validAttributes);
            null != nativeProps && UIManager.updateView(maybeInstance._nativeTag, viewConfig.uiViewClassName, nativeProps);
          }
        };

        return ReactNativeComponent;
      }(React.Component);
    }(findNodeHandle, findHostInstance$1),
    findNodeHandle: findNodeHandle,
    render: function render(element, containerTag, callback) {
      var root = roots.get(containerTag);

      if (!root) {
        root = createFiber(3, null, null, 0);
        var root$jscomp$0 = {
          current: root,
          containerInfo: containerTag,
          pendingChildren: null,
          earliestPendingTime: 0,
          latestPendingTime: 0,
          earliestSuspendedTime: 0,
          latestSuspendedTime: 0,
          latestPingedTime: 0,
          didError: !1,
          pendingCommitExpirationTime: 0,
          finishedWork: null,
          timeoutHandle: -1,
          context: null,
          pendingContext: null,
          hydrate: !1,
          nextExpirationTimeToWorkOn: 0,
          expirationTime: 0,
          firstBatch: null,
          nextScheduledRoot: null
        };
        root = root.stateNode = root$jscomp$0;
        roots.set(containerTag, root);
      }

      updateContainer(element, root, null, callback);

      a: if (element = root.current, element.child) switch (element.child.tag) {
        case 5:
          element = element.child.stateNode;
          break a;

        default:
          element = element.child.stateNode;
      } else element = null;

      return element;
    },
    unmountComponentAtNode: function unmountComponentAtNode(containerTag) {
      var root = roots.get(containerTag);
      root && updateContainer(null, root, null, function () {
        roots.delete(containerTag);
      });
    },
    unmountComponentAtNodeAndRemoveContainer: function unmountComponentAtNodeAndRemoveContainer(containerTag) {
      ReactNativeRenderer.unmountComponentAtNode(containerTag);
      UIManager.removeRootView(containerTag);
    },
    createPortal: function createPortal(children, containerTag) {
      return _createPortal(children, containerTag, null, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
    },
    unstable_batchedUpdates: batchedUpdates,
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
      NativeMethodsMixin: function (findNodeHandle, findHostInstance) {
        return {
          measure: function measure(callback) {
            UIManager.measure(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          },
          measureInWindow: function measureInWindow(callback) {
            UIManager.measureInWindow(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          },
          measureLayout: function measureLayout(relativeToNativeNode, onSuccess, onFail) {
            UIManager.measureLayout(findNodeHandle(this), relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
          },
          setNativeProps: function setNativeProps(nativeProps) {
            var maybeInstance = void 0;

            try {
              maybeInstance = findHostInstance(this);
            } catch (error) {}

            if (null != maybeInstance) {
              var viewConfig = maybeInstance.viewConfig;
              nativeProps = diffProperties(null, emptyObject, nativeProps, viewConfig.validAttributes);
              null != nativeProps && UIManager.updateView(maybeInstance._nativeTag, viewConfig.uiViewClassName, nativeProps);
            }
          },
          focus: function focus() {
            TextInputState.focusTextInput(findNodeHandle(this));
          },
          blur: function blur() {
            TextInputState.blurTextInput(findNodeHandle(this));
          }
        };
      }(findNodeHandle, findHostInstance$1),
      computeComponentStackForErrorReporting: function computeComponentStackForErrorReporting(reactTag) {
        return (reactTag = getInstanceFromTag(reactTag)) ? getStackByFiberInDevAndProd(reactTag) : "";
      }
    }
  };

  (function (devToolsConfig) {
    var _findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
    return injectInternals(_extends({}, devToolsConfig, {
      findHostInstanceByFiber: function findHostInstanceByFiber(fiber) {
        fiber = findCurrentHostFiber(fiber);
        return null === fiber ? null : fiber.stateNode;
      },
      findFiberByHostInstance: function findFiberByHostInstance(instance) {
        return _findFiberByHostInstance ? _findFiberByHostInstance(instance) : null;
      }
    }));
  })({
    findFiberByHostInstance: getInstanceFromTag,
    getInspectorDataForViewTag: getInspectorDataForViewTag,
    bundleType: 0,
    version: "16.6.1",
    rendererPackageName: "react-native-renderer"
  });

  var ReactNativeRenderer$2 = {
    default: ReactNativeRenderer
  },
      ReactNativeRenderer$3 = ReactNativeRenderer$2 && ReactNativeRenderer || ReactNativeRenderer$2;
  module.exports = ReactNativeRenderer$3.default || ReactNativeRenderer$3;
},267,[112,180,257,145,258,109,259,174,260,264,188],"node_modules\\react-native\\Libraries\\Renderer\\oss\\ReactNativeRenderer-prod.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var createReactNativeComponentClass = _$$_REQUIRE(_dependencyMap[0], "createReactNativeComponentClass");

  var getNativeComponentAttributes = _$$_REQUIRE(_dependencyMap[1], "getNativeComponentAttributes");

  var requireNativeComponent = function requireNativeComponent(uiViewClassName) {
    return createReactNativeComponentClass(uiViewClassName, function () {
      return getNativeComponentAttributes(uiViewClassName);
    });
  };

  module.exports = requireNativeComponent;
},268,[269,270],"node_modules\\react-native\\Libraries\\ReactNative\\requireNativeComponent.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _require = _$$_REQUIRE(_dependencyMap[0], "ReactNativeViewConfigRegistry"),
      register = _require.register;

  var createReactNativeComponentClass = function createReactNativeComponentClass(name, callback) {
    return register(name, callback);
  };

  module.exports = createReactNativeComponentClass;
},269,[257],"node_modules\\react-native\\Libraries\\Renderer\\shims\\createReactNativeComponentClass.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread");

  var ReactNativeStyleAttributes = _$$_REQUIRE(_dependencyMap[2], "ReactNativeStyleAttributes");

  var UIManager = _$$_REQUIRE(_dependencyMap[3], "UIManager");

  var insetsDiffer = _$$_REQUIRE(_dependencyMap[4], "insetsDiffer");

  var matricesDiffer = _$$_REQUIRE(_dependencyMap[5], "matricesDiffer");

  var pointsDiffer = _$$_REQUIRE(_dependencyMap[6], "pointsDiffer");

  var processColor = _$$_REQUIRE(_dependencyMap[7], "processColor");

  var resolveAssetSource = _$$_REQUIRE(_dependencyMap[8], "resolveAssetSource");

  var sizesDiffer = _$$_REQUIRE(_dependencyMap[9], "sizesDiffer");

  var invariant = _$$_REQUIRE(_dependencyMap[10], "fbjs/lib/invariant");

  var warning = _$$_REQUIRE(_dependencyMap[11], "fbjs/lib/warning");

  function getNativeComponentAttributes(uiViewClassName) {
    var viewConfig = UIManager[uiViewClassName];
    invariant(viewConfig != null && viewConfig.NativeProps != null, 'requireNativeComponent: "%s" was not found in the UIManager.', uiViewClassName);
    var baseModuleName = viewConfig.baseModuleName,
        bubblingEventTypes = viewConfig.bubblingEventTypes,
        directEventTypes = viewConfig.directEventTypes;
    var nativeProps = viewConfig.NativeProps;

    while (baseModuleName) {
      var baseModule = UIManager[baseModuleName];

      if (!baseModule) {
        warning(false, 'Base module "%s" does not exist', baseModuleName);
        baseModuleName = null;
      } else {
        bubblingEventTypes = _objectSpread({}, baseModule.bubblingEventTypes, bubblingEventTypes);
        directEventTypes = _objectSpread({}, baseModule.directEventTypes, directEventTypes);
        nativeProps = _objectSpread({}, baseModule.NativeProps, nativeProps);
        baseModuleName = baseModule.baseModuleName;
      }
    }

    var validAttributes = {};

    for (var key in nativeProps) {
      var typeName = nativeProps[key];
      var diff = getDifferForType(typeName);
      var process = getProcessorForType(typeName);
      validAttributes[key] = diff == null && process == null ? true : {
        diff: diff,
        process: process
      };
    }

    validAttributes.style = ReactNativeStyleAttributes;

    _extends(viewConfig, {
      uiViewClassName: uiViewClassName,
      validAttributes: validAttributes,
      bubblingEventTypes: bubblingEventTypes,
      directEventTypes: directEventTypes
    });

    if (!hasAttachedDefaultEventTypes) {
      attachDefaultEventTypes(viewConfig);
      hasAttachedDefaultEventTypes = true;
    }

    return viewConfig;
  }

  var hasAttachedDefaultEventTypes = false;

  function attachDefaultEventTypes(viewConfig) {
    if (UIManager.ViewManagerNames) {
      viewConfig = merge(viewConfig, UIManager.getDefaultEventTypes());
    } else {
      viewConfig.bubblingEventTypes = merge(viewConfig.bubblingEventTypes, UIManager.genericBubblingEventTypes);
      viewConfig.directEventTypes = merge(viewConfig.directEventTypes, UIManager.genericDirectEventTypes);
    }
  }

  function merge(destination, source) {
    if (!source) {
      return destination;
    }

    if (!destination) {
      return source;
    }

    for (var key in source) {
      if (!source.hasOwnProperty(key)) {
        continue;
      }

      var sourceValue = source[key];

      if (destination.hasOwnProperty(key)) {
        var destinationValue = destination[key];

        if (typeof sourceValue === 'object' && typeof destinationValue === 'object') {
          sourceValue = merge(destinationValue, sourceValue);
        }
      }

      destination[key] = sourceValue;
    }

    return destination;
  }

  function getDifferForType(typeName) {
    switch (typeName) {
      case 'CATransform3D':
        return matricesDiffer;

      case 'CGPoint':
        return pointsDiffer;

      case 'CGSize':
        return sizesDiffer;

      case 'UIEdgeInsets':
        return insetsDiffer;
    }

    return null;
  }

  function getProcessorForType(typeName) {
    switch (typeName) {
      case 'CGColor':
      case 'UIColor':
        return processColor;

      case 'CGColorArray':
      case 'UIColorArray':
        return processColorArray;

      case 'CGImage':
      case 'UIImage':
      case 'RCTImageSource':
        return resolveAssetSource;

      case 'Color':
        return processColor;

      case 'ColorArray':
        return processColorArray;
    }

    return null;
  }

  function processColorArray(colors) {
    return colors == null ? null : colors.map(processColor);
  }

  module.exports = getNativeComponentAttributes;
},270,[112,148,154,145,271,272,273,169,274,172,117,211],"node_modules\\react-native\\Libraries\\ReactNative\\getNativeComponentAttributes.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var dummyInsets = {
    top: undefined,
    left: undefined,
    right: undefined,
    bottom: undefined
  };

  var insetsDiffer = function insetsDiffer(one, two) {
    one = one || dummyInsets;
    two = two || dummyInsets;
    return one !== two && (one.top !== two.top || one.left !== two.left || one.right !== two.right || one.bottom !== two.bottom);
  };

  module.exports = insetsDiffer;
},271,[],"node_modules\\react-native\\Libraries\\Utilities\\differ\\insetsDiffer.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var matricesDiffer = function matricesDiffer(one, two) {
    if (one === two) {
      return false;
    }

    return !one || !two || one[12] !== two[12] || one[13] !== two[13] || one[14] !== two[14] || one[5] !== two[5] || one[10] !== two[10] || one[1] !== two[1] || one[2] !== two[2] || one[3] !== two[3] || one[4] !== two[4] || one[6] !== two[6] || one[7] !== two[7] || one[8] !== two[8] || one[9] !== two[9] || one[11] !== two[11] || one[15] !== two[15];
  };

  module.exports = matricesDiffer;
},272,[],"node_modules\\react-native\\Libraries\\Utilities\\differ\\matricesDiffer.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var dummyPoint = {
    x: undefined,
    y: undefined
  };

  var pointsDiffer = function pointsDiffer(one, two) {
    one = one || dummyPoint;
    two = two || dummyPoint;
    return one !== two && (one.x !== two.x || one.y !== two.y);
  };

  module.exports = pointsDiffer;
},273,[],"node_modules\\react-native\\Libraries\\Utilities\\differ\\pointsDiffer.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var AssetRegistry = _$$_REQUIRE(_dependencyMap[0], "AssetRegistry");

  var AssetSourceResolver = _$$_REQUIRE(_dependencyMap[1], "AssetSourceResolver");

  var _customSourceTransformer, _serverURL, _scriptURL;

  var _sourceCodeScriptURL;

  function getSourceCodeScriptURL() {
    if (_sourceCodeScriptURL) {
      return _sourceCodeScriptURL;
    }

    var sourceCode = global.nativeExtensions && global.nativeExtensions.SourceCode;

    if (!sourceCode) {
      var NativeModules = _$$_REQUIRE(_dependencyMap[2], "NativeModules");

      sourceCode = NativeModules && NativeModules.SourceCode;
    }

    _sourceCodeScriptURL = sourceCode.scriptURL;
    return _sourceCodeScriptURL;
  }

  function getDevServerURL() {
    if (_serverURL === undefined) {
      var sourceCodeScriptURL = getSourceCodeScriptURL();
      var match = sourceCodeScriptURL && sourceCodeScriptURL.match(/^https?:\/\/.*?\//);

      if (match) {
        _serverURL = match[0];
      } else {
        _serverURL = null;
      }
    }

    return _serverURL;
  }

  function _coerceLocalScriptURL(scriptURL) {
    if (scriptURL) {
      if (scriptURL.startsWith('assets://')) {
        return null;
      }

      scriptURL = scriptURL.substring(0, scriptURL.lastIndexOf('/') + 1);

      if (!scriptURL.includes('://')) {
        scriptURL = 'file://' + scriptURL;
      }
    }

    return scriptURL;
  }

  function getScriptURL() {
    if (_scriptURL === undefined) {
      _scriptURL = _coerceLocalScriptURL(getSourceCodeScriptURL());
    }

    return _scriptURL;
  }

  function setCustomSourceTransformer(transformer) {
    _customSourceTransformer = transformer;
  }

  function resolveAssetSource(source) {
    if (typeof source === 'object') {
      return source;
    }

    var asset = AssetRegistry.getAssetByID(source);

    if (!asset) {
      return null;
    }

    var resolver = new AssetSourceResolver(getDevServerURL(), getScriptURL(), asset);

    if (_customSourceTransformer) {
      return _customSourceTransformer(resolver);
    }

    return resolver.defaultAsset();
  }

  module.exports = resolveAssetSource;
  module.exports.pickScale = AssetSourceResolver.pickScale;
  module.exports.setCustomSourceTransformer = setCustomSourceTransformer;
},274,[275,276,119],"node_modules\\react-native\\Libraries\\Image\\resolveAssetSource.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var assets = [];

  function registerAsset(asset) {
    return assets.push(asset);
  }

  function getAssetByID(assetId) {
    return assets[assetId - 1];
  }

  module.exports = {
    registerAsset: registerAsset,
    getAssetByID: getAssetByID
  };
},275,[],"node_modules\\react-native\\Libraries\\Image\\AssetRegistry.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/defineProperty");

  var PixelRatio = _$$_REQUIRE(_dependencyMap[3], "PixelRatio");

  var Platform = _$$_REQUIRE(_dependencyMap[4], "Platform");

  var assetPathUtils = _$$_REQUIRE(_dependencyMap[5], "../../local-cli/bundle/assetPathUtils");

  var invariant = _$$_REQUIRE(_dependencyMap[6], "fbjs/lib/invariant");

  function getScaledAssetPath(asset) {
    var scale = AssetSourceResolver.pickScale(asset.scales, PixelRatio.get());
    var scaleSuffix = scale === 1 ? '' : '@' + scale + 'x';
    var assetDir = assetPathUtils.getBasePath(asset);
    return assetDir + '/' + asset.name + scaleSuffix + '.' + asset.type;
  }

  function getAssetPathInDrawableFolder(asset) {
    var scale = AssetSourceResolver.pickScale(asset.scales, PixelRatio.get());
    var drawbleFolder = assetPathUtils.getAndroidResourceFolderName(asset, scale);
    var fileName = assetPathUtils.getAndroidResourceIdentifier(asset);
    return drawbleFolder + '/' + fileName + '.' + asset.type;
  }

  var AssetSourceResolver = function () {
    function AssetSourceResolver(serverUrl, jsbundleUrl, asset) {
      _classCallCheck(this, AssetSourceResolver);

      _defineProperty(this, "serverUrl", void 0);

      _defineProperty(this, "jsbundleUrl", void 0);

      _defineProperty(this, "asset", void 0);

      this.serverUrl = serverUrl;
      this.jsbundleUrl = jsbundleUrl;
      this.asset = asset;
    }

    _createClass(AssetSourceResolver, [{
      key: "isLoadedFromServer",
      value: function isLoadedFromServer() {
        return !!this.serverUrl;
      }
    }, {
      key: "isLoadedFromFileSystem",
      value: function isLoadedFromFileSystem() {
        return !!(this.jsbundleUrl && this.jsbundleUrl.startsWith('file://'));
      }
    }, {
      key: "defaultAsset",
      value: function defaultAsset() {
        if (this.isLoadedFromServer()) {
          return this.assetServerURL();
        }

        if (Platform.OS === 'android') {
          return this.isLoadedFromFileSystem() ? this.drawableFolderInBundle() : this.resourceIdentifierWithoutScale();
        } else {
          return this.scaledAssetURLNearBundle();
        }
      }
    }, {
      key: "assetServerURL",
      value: function assetServerURL() {
        invariant(!!this.serverUrl, 'need server to load from');
        return this.fromSource(this.serverUrl + getScaledAssetPath(this.asset) + '?platform=' + Platform.OS + '&hash=' + this.asset.hash);
      }
    }, {
      key: "scaledAssetPath",
      value: function scaledAssetPath() {
        return this.fromSource(getScaledAssetPath(this.asset));
      }
    }, {
      key: "scaledAssetURLNearBundle",
      value: function scaledAssetURLNearBundle() {
        var path = this.jsbundleUrl || 'file://';
        return this.fromSource(path + getScaledAssetPath(this.asset));
      }
    }, {
      key: "resourceIdentifierWithoutScale",
      value: function resourceIdentifierWithoutScale() {
        invariant(Platform.OS === 'android', 'resource identifiers work on Android');
        return this.fromSource(assetPathUtils.getAndroidResourceIdentifier(this.asset));
      }
    }, {
      key: "drawableFolderInBundle",
      value: function drawableFolderInBundle() {
        var path = this.jsbundleUrl || 'file://';
        return this.fromSource(path + getAssetPathInDrawableFolder(this.asset));
      }
    }, {
      key: "fromSource",
      value: function fromSource(source) {
        return {
          __packager_asset: true,
          width: this.asset.width,
          height: this.asset.height,
          uri: source,
          scale: AssetSourceResolver.pickScale(this.asset.scales, PixelRatio.get())
        };
      }
    }], [{
      key: "pickScale",
      value: function pickScale(scales, deviceScale) {
        for (var i = 0; i < scales.length; i++) {
          if (scales[i] >= deviceScale) {
            return scales[i];
          }
        }

        return scales[scales.length - 1] || 1;
      }
    }]);

    return AssetSourceResolver;
  }();

  module.exports = AssetSourceResolver;
},276,[24,25,32,151,146,277,117],"node_modules\\react-native\\Libraries\\Image\\AssetSourceResolver.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function getAndroidAssetSuffix(scale) {
    switch (scale) {
      case 0.75:
        return 'ldpi';

      case 1:
        return 'mdpi';

      case 1.5:
        return 'hdpi';

      case 2:
        return 'xhdpi';

      case 3:
        return 'xxhdpi';

      case 4:
        return 'xxxhdpi';
    }

    throw new Error('no such scale');
  }

  var drawableFileTypes = new Set(['gif', 'jpeg', 'jpg', 'png', 'svg', 'webp', 'xml']);

  function getAndroidResourceFolderName(asset, scale) {
    if (!drawableFileTypes.has(asset.type)) {
      return 'raw';
    }

    var suffix = getAndroidAssetSuffix(scale);

    if (!suffix) {
      throw new Error("Don't know which android drawable suffix to use for asset: " + JSON.stringify(asset));
    }

    var androidFolder = 'drawable-' + suffix;
    return androidFolder;
  }

  function getAndroidResourceIdentifier(asset) {
    var folderPath = getBasePath(asset);
    return (folderPath + '/' + asset.name).toLowerCase().replace(/\//g, '_').replace(/([^a-z0-9_])/g, '').replace(/^assets_/, '');
  }

  function getBasePath(asset) {
    var basePath = asset.httpServerLocation;

    if (basePath[0] === '/') {
      basePath = basePath.substr(1);
    }

    return basePath;
  }

  module.exports = {
    getAndroidAssetSuffix: getAndroidAssetSuffix,
    getAndroidResourceFolderName: getAndroidResourceFolderName,
    getAndroidResourceIdentifier: getAndroidResourceIdentifier,
    getBasePath: getBasePath
  };
},277,[],"node_modules\\react-native\\local-cli\\bundle\\assetPathUtils.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\ProgressBarAndroid\\ProgressBarAndroid.android.js";

  var React = _$$_REQUIRE(_dependencyMap[1], "React");

  var requireNativeComponent = _$$_REQUIRE(_dependencyMap[2], "requireNativeComponent");

  var AndroidProgressBar = requireNativeComponent('AndroidProgressBar');

  var ProgressBarAndroid = function ProgressBarAndroid(props, forwardedRef) {
    return React.createElement(AndroidProgressBar, _extends({}, props, {
      ref: forwardedRef,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 89
      }
    }));
  };

  var ProgressBarAndroidToExport = React.forwardRef(ProgressBarAndroid);
  ProgressBarAndroidToExport.defaultProps = {
    styleAttr: 'Normal',
    indeterminate: true,
    animating: true
  };
  module.exports = ProgressBarAndroidToExport;
},278,[112,149,268],"node_modules\\react-native\\Libraries\\Components\\ProgressBarAndroid\\ProgressBarAndroid.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\ART\\ReactNativeART.js";
  var _components = {
    Surface: {
      displayName: "Surface"
    },
    Group: {
      displayName: "Group"
    },
    ClippingRectangle: {
      displayName: "ClippingRectangle"
    },
    Shape: {
      displayName: "Shape"
    },
    Text: {
      displayName: "Text"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\ART\\ReactNativeART.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var Color = _$$_REQUIRE(_dependencyMap[9], "art/core/color");

  var Path = _$$_REQUIRE(_dependencyMap[10], "ARTSerializablePath");

  var Transform = _$$_REQUIRE(_dependencyMap[11], "art/core/transform");

  var React = _$$_REQUIRE(_dependencyMap[12], "React");

  var PropTypes = _$$_REQUIRE(_dependencyMap[13], "prop-types");

  var ReactNativeViewAttributes = _$$_REQUIRE(_dependencyMap[14], "ReactNativeViewAttributes");

  var createReactNativeComponentClass = _$$_REQUIRE(_dependencyMap[15], "createReactNativeComponentClass");

  var merge = _$$_REQUIRE(_dependencyMap[16], "merge");

  var invariant = _$$_REQUIRE(_dependencyMap[17], "fbjs/lib/invariant");

  function arrayDiffer(a, b) {
    if (a == null || b == null) {
      return true;
    }

    if (a.length !== b.length) {
      return true;
    }

    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return true;
      }
    }

    return false;
  }

  function fontAndLinesDiffer(a, b) {
    if (a === b) {
      return false;
    }

    if (a.font !== b.font) {
      if (a.font === null) {
        return true;
      }

      if (b.font === null) {
        return true;
      }

      if (a.font.fontFamily !== b.font.fontFamily || a.font.fontSize !== b.font.fontSize || a.font.fontWeight !== b.font.fontWeight || a.font.fontStyle !== b.font.fontStyle) {
        return true;
      }
    }

    return arrayDiffer(a.lines, b.lines);
  }

  var SurfaceViewAttributes = merge(ReactNativeViewAttributes.UIView, {});
  var NodeAttributes = {
    transform: {
      diff: arrayDiffer
    },
    opacity: true
  };
  var GroupAttributes = merge(NodeAttributes, {
    clipping: {
      diff: arrayDiffer
    }
  });
  var RenderableAttributes = merge(NodeAttributes, {
    fill: {
      diff: arrayDiffer
    },
    stroke: {
      diff: arrayDiffer
    },
    strokeWidth: true,
    strokeCap: true,
    strokeJoin: true,
    strokeDash: {
      diff: arrayDiffer
    }
  });
  var ShapeAttributes = merge(RenderableAttributes, {
    d: {
      diff: arrayDiffer
    }
  });
  var TextAttributes = merge(RenderableAttributes, {
    alignment: true,
    frame: {
      diff: fontAndLinesDiffer
    },
    path: {
      diff: arrayDiffer
    }
  });
  var NativeSurfaceView = createReactNativeComponentClass('ARTSurfaceView', function () {
    return {
      validAttributes: SurfaceViewAttributes,
      uiViewClassName: 'ARTSurfaceView'
    };
  });
  var NativeGroup = createReactNativeComponentClass('ARTGroup', function () {
    return {
      validAttributes: GroupAttributes,
      uiViewClassName: 'ARTGroup'
    };
  });
  var NativeShape = createReactNativeComponentClass('ARTShape', function () {
    return {
      validAttributes: ShapeAttributes,
      uiViewClassName: 'ARTShape'
    };
  });
  var NativeText = createReactNativeComponentClass('ARTText', function () {
    return {
      validAttributes: TextAttributes,
      uiViewClassName: 'ARTText'
    };
  });

  function childrenAsString(children) {
    if (!children) {
      return '';
    }

    if (typeof children === 'string') {
      return children;
    }

    if (children.length) {
      return children.join('\n');
    }

    return '';
  }

  var Surface = function (_React$Component) {
    _inherits(Surface, _React$Component);

    function Surface() {
      _classCallCheck(this, Surface);

      return _possibleConstructorReturn(this, _getPrototypeOf(Surface).apply(this, arguments));
    }

    _createClass(Surface, [{
      key: "getChildContext",
      value: function getChildContext() {
        return {
          isInSurface: true
        };
      }
    }, {
      key: "render",
      value: function render() {
        var height = extractNumber(this.props.height, 0);
        var width = extractNumber(this.props.width, 0);
        return React.createElement(NativeSurfaceView, {
          style: [this.props.style, {
            height: height,
            width: width
          }],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 157
          }
        }, this.props.children);
      }
    }]);

    return Surface;
  }(React.Component);

  _defineProperty(Surface, "childContextTypes", {
    isInSurface: PropTypes.bool
  });

  Surface = _wrapComponent("Surface")(Surface);

  function extractNumber(value, defaultValue) {
    if (value == null) {
      return defaultValue;
    }

    return +value;
  }

  var pooledTransform = new Transform();

  function extractTransform(props) {
    var scaleX = props.scaleX != null ? props.scaleX : props.scale != null ? props.scale : 1;
    var scaleY = props.scaleY != null ? props.scaleY : props.scale != null ? props.scale : 1;
    pooledTransform.transformTo(1, 0, 0, 1, 0, 0).move(props.x || 0, props.y || 0).rotate(props.rotation || 0, props.originX, props.originY).scale(scaleX, scaleY, props.originX, props.originY);

    if (props.transform != null) {
      pooledTransform.transform(props.transform);
    }

    return [pooledTransform.xx, pooledTransform.yx, pooledTransform.xy, pooledTransform.yy, pooledTransform.x, pooledTransform.y];
  }

  function extractOpacity(props) {
    if (props.visible === false) {
      return 0;
    }

    if (props.opacity == null) {
      return 1;
    }

    return +props.opacity;
  }

  var Group = function (_React$Component2) {
    _inherits(Group, _React$Component2);

    function Group() {
      _classCallCheck(this, Group);

      return _possibleConstructorReturn(this, _getPrototypeOf(Group).apply(this, arguments));
    }

    _createClass(Group, [{
      key: "render",
      value: function render() {
        var props = this.props;
        invariant(this.context.isInSurface, 'ART: <Group /> must be a child of a <Surface />');
        return React.createElement(NativeGroup, {
          opacity: extractOpacity(props),
          transform: extractTransform(props),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 232
          }
        }, this.props.children);
      }
    }]);

    return Group;
  }(React.Component);

  _defineProperty(Group, "contextTypes", {
    isInSurface: PropTypes.bool.isRequired
  });

  Group = _wrapComponent("Group")(Group);

  var ClippingRectangle = function (_React$Component3) {
    _inherits(ClippingRectangle, _React$Component3);

    function ClippingRectangle() {
      _classCallCheck(this, ClippingRectangle);

      return _possibleConstructorReturn(this, _getPrototypeOf(ClippingRectangle).apply(this, arguments));
    }

    _createClass(ClippingRectangle, [{
      key: "render",
      value: function render() {
        var props = this.props;
        var x = extractNumber(props.x, 0);
        var y = extractNumber(props.y, 0);
        var w = extractNumber(props.width, 0);
        var h = extractNumber(props.height, 0);
        var clipping = [x, y, w, h];
        var propsExcludingXAndY = merge(props);
        delete propsExcludingXAndY.x;
        delete propsExcludingXAndY.y;
        return React.createElement(NativeGroup, {
          clipping: clipping,
          opacity: extractOpacity(props),
          transform: extractTransform(propsExcludingXAndY),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 254
          }
        }, this.props.children);
      }
    }]);

    return ClippingRectangle;
  }(React.Component);

  ClippingRectangle = _wrapComponent("ClippingRectangle")(ClippingRectangle);
  var SOLID_COLOR = 0;
  var LINEAR_GRADIENT = 1;
  var RADIAL_GRADIENT = 2;
  var PATTERN = 3;

  function insertColorIntoArray(color, targetArray, atIndex) {
    var c = new Color(color);
    targetArray[atIndex + 0] = c.red / 255;
    targetArray[atIndex + 1] = c.green / 255;
    targetArray[atIndex + 2] = c.blue / 255;
    targetArray[atIndex + 3] = c.alpha;
  }

  function insertColorsIntoArray(stops, targetArray, atIndex) {
    var i = 0;

    if ('length' in stops) {
      while (i < stops.length) {
        insertColorIntoArray(stops[i], targetArray, atIndex + i * 4);
        i++;
      }
    } else {
      for (var offset in stops) {
        insertColorIntoArray(stops[offset], targetArray, atIndex + i * 4);
        i++;
      }
    }

    return atIndex + i * 4;
  }

  function insertOffsetsIntoArray(stops, targetArray, atIndex, multi, reverse) {
    var offsetNumber;
    var i = 0;

    if ('length' in stops) {
      while (i < stops.length) {
        offsetNumber = i / (stops.length - 1) * multi;
        targetArray[atIndex + i] = reverse ? 1 - offsetNumber : offsetNumber;
        i++;
      }
    } else {
      for (var offsetString in stops) {
        offsetNumber = +offsetString * multi;
        targetArray[atIndex + i] = reverse ? 1 - offsetNumber : offsetNumber;
        i++;
      }
    }

    return atIndex + i;
  }

  function insertColorStopsIntoArray(stops, targetArray, atIndex) {
    var lastIndex = insertColorsIntoArray(stops, targetArray, atIndex);
    insertOffsetsIntoArray(stops, targetArray, lastIndex, 1, false);
  }

  function insertDoubleColorStopsIntoArray(stops, targetArray, atIndex) {
    var lastIndex = insertColorsIntoArray(stops, targetArray, atIndex);
    lastIndex = insertColorsIntoArray(stops, targetArray, lastIndex);
    lastIndex = insertOffsetsIntoArray(stops, targetArray, lastIndex, 0.5, false);
    insertOffsetsIntoArray(stops, targetArray, lastIndex, 0.5, true);
  }

  function applyBoundingBoxToBrushData(brushData, props) {
    var type = brushData[0];
    var width = +props.width;
    var height = +props.height;

    if (type === LINEAR_GRADIENT) {
      brushData[1] *= width;
      brushData[2] *= height;
      brushData[3] *= width;
      brushData[4] *= height;
    } else if (type === RADIAL_GRADIENT) {
      brushData[1] *= width;
      brushData[2] *= height;
      brushData[3] *= width;
      brushData[4] *= height;
      brushData[5] *= width;
      brushData[6] *= height;
    } else if (type === PATTERN) {}
  }

  function extractBrush(colorOrBrush, props) {
    if (colorOrBrush == null) {
      return null;
    }

    if (colorOrBrush._brush) {
      if (colorOrBrush._bb) {
        applyBoundingBoxToBrushData(colorOrBrush._brush, props);
        colorOrBrush._bb = false;
      }

      return colorOrBrush._brush;
    }

    var c = new Color(colorOrBrush);
    return [SOLID_COLOR, c.red / 255, c.green / 255, c.blue / 255, c.alpha];
  }

  function extractColor(color) {
    if (color == null) {
      return null;
    }

    var c = new Color(color);
    return [c.red / 255, c.green / 255, c.blue / 255, c.alpha];
  }

  function extractStrokeCap(strokeCap) {
    switch (strokeCap) {
      case 'butt':
        return 0;

      case 'square':
        return 2;

      default:
        return 1;
    }
  }

  function extractStrokeJoin(strokeJoin) {
    switch (strokeJoin) {
      case 'miter':
        return 0;

      case 'bevel':
        return 2;

      default:
        return 1;
    }
  }

  var Shape = function (_React$Component4) {
    _inherits(Shape, _React$Component4);

    function Shape() {
      _classCallCheck(this, Shape);

      return _possibleConstructorReturn(this, _getPrototypeOf(Shape).apply(this, arguments));
    }

    _createClass(Shape, [{
      key: "render",
      value: function render() {
        var props = this.props;
        var path = props.d || childrenAsString(props.children);
        var d = (path instanceof Path ? path : new Path(path)).toJSON();
        return React.createElement(NativeShape, {
          fill: extractBrush(props.fill, props),
          opacity: extractOpacity(props),
          stroke: extractColor(props.stroke),
          strokeCap: extractStrokeCap(props.strokeCap),
          strokeDash: props.strokeDash || null,
          strokeJoin: extractStrokeJoin(props.strokeJoin),
          strokeWidth: extractNumber(props.strokeWidth, 1),
          transform: extractTransform(props),
          d: d,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 408
          }
        });
      }
    }]);

    return Shape;
  }(React.Component);

  Shape = _wrapComponent("Shape")(Shape);
  var cachedFontObjectsFromString = {};
  var fontFamilyPrefix = /^[\s"']*/;
  var fontFamilySuffix = /[\s"']*$/;

  function extractSingleFontFamily(fontFamilyString) {
    return fontFamilyString.split(',')[0].replace(fontFamilyPrefix, '').replace(fontFamilySuffix, '');
  }

  function parseFontString(font) {
    if (cachedFontObjectsFromString.hasOwnProperty(font)) {
      return cachedFontObjectsFromString[font];
    }

    var regexp = /^\s*((?:(?:normal|bold|italic)\s+)*)(?:(\d+(?:\.\d+)?)[ptexm\%]*(?:\s*\/.*?)?\s+)?\s*\"?([^\"]*)/i;
    var match = regexp.exec(font);

    if (!match) {
      return null;
    }

    var fontFamily = extractSingleFontFamily(match[3]);
    var fontSize = +match[2] || 12;
    var isBold = /bold/.exec(match[1]);
    var isItalic = /italic/.exec(match[1]);
    cachedFontObjectsFromString[font] = {
      fontFamily: fontFamily,
      fontSize: fontSize,
      fontWeight: isBold ? 'bold' : 'normal',
      fontStyle: isItalic ? 'italic' : 'normal'
    };
    return cachedFontObjectsFromString[font];
  }

  function extractFont(font) {
    if (font == null) {
      return null;
    }

    if (typeof font === 'string') {
      return parseFontString(font);
    }

    var fontFamily = extractSingleFontFamily(font.fontFamily);
    var fontSize = +font.fontSize || 12;
    var fontWeight = font.fontWeight != null ? font.fontWeight.toString() : '400';
    return {
      fontFamily: fontFamily,
      fontSize: fontSize,
      fontWeight: fontWeight,
      fontStyle: font.fontStyle
    };
  }

  var newLine = /\n/g;

  function extractFontAndLines(font, text) {
    return {
      font: extractFont(font),
      lines: text.split(newLine)
    };
  }

  function extractAlignment(alignment) {
    switch (alignment) {
      case 'right':
        return 1;

      case 'center':
        return 2;

      default:
        return 0;
    }
  }

  var Text = function (_React$Component5) {
    _inherits(Text, _React$Component5);

    function Text() {
      _classCallCheck(this, Text);

      return _possibleConstructorReturn(this, _getPrototypeOf(Text).apply(this, arguments));
    }

    _createClass(Text, [{
      key: "render",
      value: function render() {
        var props = this.props;
        var path = props.path;
        var textPath = path ? (path instanceof Path ? path : new Path(path)).toJSON() : null;
        var textFrame = extractFontAndLines(props.font, childrenAsString(props.children));
        return React.createElement(NativeText, {
          fill: extractBrush(props.fill, props),
          opacity: extractOpacity(props),
          stroke: extractColor(props.stroke),
          strokeCap: extractStrokeCap(props.strokeCap),
          strokeDash: props.strokeDash || null,
          strokeJoin: extractStrokeJoin(props.strokeJoin),
          strokeWidth: extractNumber(props.strokeWidth, 1),
          transform: extractTransform(props),
          alignment: extractAlignment(props.alignment),
          frame: textFrame,
          path: textPath,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 510
          }
        });
      }
    }]);

    return Text;
  }(React.Component);

  Text = _wrapComponent("Text")(Text);

  function LinearGradient(stops, x1, y1, x2, y2) {
    var type = LINEAR_GRADIENT;

    if (arguments.length < 5) {
      var angle = (x1 == null ? 270 : x1) * Math.PI / 180;
      var x = Math.cos(angle);
      var y = -Math.sin(angle);
      var l = (Math.abs(x) + Math.abs(y)) / 2;
      x *= l;
      y *= l;
      x1 = 0.5 - x;
      x2 = 0.5 + x;
      y1 = 0.5 - y;
      y2 = 0.5 + y;
      this._bb = true;
    } else {
      this._bb = false;
    }

    var brushData = [type, +x1, +y1, +x2, +y2];
    insertColorStopsIntoArray(stops, brushData, 5);
    this._brush = brushData;
  }

  function RadialGradient(stops, fx, fy, rx, ry, cx, cy) {
    if (ry == null) {
      ry = rx;
    }

    if (cx == null) {
      cx = fx;
    }

    if (cy == null) {
      cy = fy;
    }

    if (fx == null) {
      fx = fy = rx = ry = cx = cy = 0.5;
      this._bb = true;
    } else {
      this._bb = false;
    }

    var brushData = [RADIAL_GRADIENT, +fx, +fy, +rx * 2, +ry * 2, +cx, +cy];
    insertDoubleColorStopsIntoArray(stops, brushData, 7);
    this._brush = brushData;
  }

  function Pattern(url, width, height, left, top) {
    this._brush = [PATTERN, url, +left || 0, +top || 0, +width, +height];
  }

  var ReactART = {
    LinearGradient: LinearGradient,
    RadialGradient: RadialGradient,
    Pattern: Pattern,
    Transform: Transform,
    Path: Path,
    Surface: Surface,
    Group: Group,
    ClippingRectangle: ClippingRectangle,
    Shape: Shape,
    Text: Text
  };
  module.exports = ReactART;
},279,[23,24,25,26,29,30,32,109,280,434,435,438,149,161,439,269,440,117],"node_modules\\react-native\\Libraries\\ART\\ReactNativeART.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });

  var _slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i['return']) _i['return']();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if ((typeof Symbol === "function" ? Symbol.iterator : "@@iterator") in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError('Invalid attempt to destructure non-iterable instance');
      }
    };
  }();

  exports['default'] = proxyReactComponents;

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }

  var _reactProxy = _$$_REQUIRE(_dependencyMap[0], "react-proxy");

  var _globalWindow = _$$_REQUIRE(_dependencyMap[1], "global/window");

  var _globalWindow2 = _interopRequireDefault(_globalWindow);

  var componentProxies = undefined;

  if (_globalWindow2['default'].__reactComponentProxies) {
    componentProxies = _globalWindow2['default'].__reactComponentProxies;
  } else {
    componentProxies = {};
    Object.defineProperty(_globalWindow2['default'], '__reactComponentProxies', {
      configurable: true,
      enumerable: false,
      writable: false,
      value: componentProxies
    });
  }

  function proxyReactComponents(_ref) {
    var filename = _ref.filename;
    var components = _ref.components;
    var imports = _ref.imports;
    var locals = _ref.locals;

    var _imports = _slicedToArray(imports, 1);

    var React = _imports[0];

    var _locals = _slicedToArray(locals, 1);

    var hot = _locals[0].hot;

    if (!React.Component) {
      throw new Error('imports[0] for react-transform-hmr does not look like React.');
    }

    if (!hot || typeof hot.accept !== 'function') {
      throw new Error('locals[0] does not appear to be a `module` object with Hot Module ' + 'replacement API enabled. You should disable react-transform-hmr in ' + 'production by using `env` section in Babel configuration. See the ' + 'example in README: https://github.com/gaearon/react-transform-hmr');
    }

    if (Object.keys(components).some(function (key) {
      return !components[key].isInFunction;
    })) {
      hot.accept(function (err) {
        if (err) {
          console.warn('[React Transform HMR] There was an error updating ' + filename + ':');
          console.error(err);
        }
      });
    }

    var forceUpdate = (0, _reactProxy.getForceUpdate)(React);
    return function wrapWithProxy(ReactClass, uniqueId) {
      var _components$uniqueId = components[uniqueId];
      var _components$uniqueId$isInFunction = _components$uniqueId.isInFunction;
      var isInFunction = _components$uniqueId$isInFunction === undefined ? false : _components$uniqueId$isInFunction;
      var _components$uniqueId$displayName = _components$uniqueId.displayName;
      var displayName = _components$uniqueId$displayName === undefined ? uniqueId : _components$uniqueId$displayName;

      if (isInFunction) {
        return ReactClass;
      }

      var globalUniqueId = filename + '$' + uniqueId;

      if (componentProxies[globalUniqueId]) {
        (function () {
          console.info('[React Transform HMR] Patching ' + displayName);
          var instances = componentProxies[globalUniqueId].update(ReactClass);
          setTimeout(function () {
            return instances.forEach(forceUpdate);
          });
        })();
      } else {
        componentProxies[globalUniqueId] = (0, _reactProxy.createProxy)(ReactClass);
      }

      return componentProxies[globalUniqueId].get();
    };
  }

  module.exports = exports['default'];
},280,[281,433],"node_modules\\react-transform-hmr\\lib\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getForceUpdate = exports.createProxy = undefined;

  var _supportsProtoAssignment = _$$_REQUIRE(_dependencyMap[0], "./supportsProtoAssignment");

  var _supportsProtoAssignment2 = _interopRequireDefault(_supportsProtoAssignment);

  var _createClassProxy = _$$_REQUIRE(_dependencyMap[1], "./createClassProxy");

  var _createClassProxy2 = _interopRequireDefault(_createClassProxy);

  var _reactDeepForceUpdate = _$$_REQUIRE(_dependencyMap[2], "react-deep-force-update");

  var _reactDeepForceUpdate2 = _interopRequireDefault(_reactDeepForceUpdate);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  if (!(0, _supportsProtoAssignment2.default)()) {
    console.warn('This JavaScript environment does not support __proto__. ' + 'This means that react-proxy is unable to proxy React components. ' + 'Features that rely on react-proxy, such as react-transform-hmr, ' + 'will not function as expected.');
  }

  exports.createProxy = _createClassProxy2.default;
  exports.getForceUpdate = _reactDeepForceUpdate2.default;
},281,[282,283,432],"node_modules\\react-proxy\\modules\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = supportsProtoAssignment;
  var x = {};
  var y = {
    supports: true
  };

  try {
    x.__proto__ = y;
  } catch (err) {}

  function supportsProtoAssignment() {
    return x.supports || false;
  }

  ;
},282,[],"node_modules\\react-proxy\\modules\\supportsProtoAssignment.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var _slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if ((typeof Symbol === "function" ? Symbol.iterator : "@@iterator") in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  exports.default = proxyClass;
  exports.default = createClassProxy;

  var _find = _$$_REQUIRE(_dependencyMap[0], "lodash/find");

  var _find2 = _interopRequireDefault(_find);

  var _createPrototypeProxy = _$$_REQUIRE(_dependencyMap[1], "./createPrototypeProxy");

  var _createPrototypeProxy2 = _interopRequireDefault(_createPrototypeProxy);

  var _bindAutoBindMethods = _$$_REQUIRE(_dependencyMap[2], "./bindAutoBindMethods");

  var _bindAutoBindMethods2 = _interopRequireDefault(_bindAutoBindMethods);

  var _deleteUnknownAutoBindMethods = _$$_REQUIRE(_dependencyMap[3], "./deleteUnknownAutoBindMethods");

  var _deleteUnknownAutoBindMethods2 = _interopRequireDefault(_deleteUnknownAutoBindMethods);

  var _supportsProtoAssignment = _$$_REQUIRE(_dependencyMap[4], "./supportsProtoAssignment");

  var _supportsProtoAssignment2 = _interopRequireDefault(_supportsProtoAssignment);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return Array.from(arr);
    }
  }

  var RESERVED_STATICS = ['length', 'name', 'arguments', 'caller', 'prototype', 'toString'];

  function isEqualDescriptor(a, b) {
    if (!a && !b) {
      return true;
    }

    if (!a || !b) {
      return false;
    }

    for (var key in a) {
      if (a[key] !== b[key]) {
        return false;
      }
    }

    return true;
  }

  var allProxies = [];

  function findProxy(Component) {
    var pair = (0, _find2.default)(allProxies, function (_ref) {
      var _ref2 = _slicedToArray(_ref, 1);

      var key = _ref2[0];
      return key === Component;
    });
    return pair ? pair[1] : null;
  }

  function addProxy(Component, proxy) {
    allProxies.push([Component, proxy]);
  }

  function proxyClass(InitialComponent) {
    var existingProxy = findProxy(InitialComponent);

    if (existingProxy) {
      return existingProxy;
    }

    var prototypeProxy = (0, _createPrototypeProxy2.default)();
    var CurrentComponent = undefined;
    var ProxyComponent = undefined;
    var staticDescriptors = {};

    function wasStaticModifiedByUser(key) {
      var currentDescriptor = Object.getOwnPropertyDescriptor(ProxyComponent, key);
      return !isEqualDescriptor(staticDescriptors[key], currentDescriptor);
    }

    function instantiate(factory, context, params) {
      var component = factory();

      try {
        return component.apply(context, params);
      } catch (err) {
        (function () {
          var instance = new (Function.prototype.bind.apply(component, [null].concat(_toConsumableArray(params))))();
          Object.keys(instance).forEach(function (key) {
            if (RESERVED_STATICS.indexOf(key) > -1) {
              return;
            }

            context[key] = instance[key];
          });
        })();
      }
    }

    try {
      ProxyComponent = new Function('factory', 'instantiate', 'return function ' + (InitialComponent.name || 'ProxyComponent') + '() {\n         return instantiate(factory, this, arguments);\n      }')(function () {
        return CurrentComponent;
      }, instantiate);
    } catch (err) {
      ProxyComponent = function ProxyComponent() {
        return instantiate(function () {
          return CurrentComponent;
        }, this, arguments);
      };
    }

    ProxyComponent.prototype = prototypeProxy.get();

    ProxyComponent.toString = function toString() {
      return CurrentComponent.toString();
    };

    function update(NextComponent) {
      if (typeof NextComponent !== 'function') {
        throw new Error('Expected a constructor.');
      }

      var existingProxy = findProxy(NextComponent);

      if (existingProxy) {
        return update(existingProxy.__getCurrent());
      }

      CurrentComponent = NextComponent;
      var mountedInstances = prototypeProxy.update(NextComponent.prototype);
      ProxyComponent.prototype.constructor = ProxyComponent;
      ProxyComponent.__proto__ = NextComponent.__proto__;
      Object.getOwnPropertyNames(NextComponent).forEach(function (key) {
        if (RESERVED_STATICS.indexOf(key) > -1) {
          return;
        }

        var staticDescriptor = _extends({}, Object.getOwnPropertyDescriptor(NextComponent, key), {
          configurable: true
        });

        if (!wasStaticModifiedByUser(key)) {
          Object.defineProperty(ProxyComponent, key, staticDescriptor);
          staticDescriptors[key] = staticDescriptor;
        }
      });
      Object.getOwnPropertyNames(ProxyComponent).forEach(function (key) {
        if (RESERVED_STATICS.indexOf(key) > -1) {
          return;
        }

        if (NextComponent.hasOwnProperty(key)) {
          return;
        }

        var descriptor = Object.getOwnPropertyDescriptor(ProxyComponent, key);

        if (descriptor && !descriptor.configurable) {
          return;
        }

        if (!wasStaticModifiedByUser(key)) {
          delete ProxyComponent[key];
          delete staticDescriptors[key];
        }
      });
      ProxyComponent.displayName = NextComponent.displayName || NextComponent.name;
      mountedInstances.forEach(_bindAutoBindMethods2.default);
      mountedInstances.forEach(_deleteUnknownAutoBindMethods2.default);
      return mountedInstances;
    }

    ;

    function get() {
      return ProxyComponent;
    }

    function getCurrent() {
      return CurrentComponent;
    }

    update(InitialComponent);
    var proxy = {
      get: get,
      update: update
    };
    addProxy(ProxyComponent, proxy);
    Object.defineProperty(proxy, '__getCurrent', {
      configurable: false,
      writable: false,
      enumerable: false,
      value: getCurrent
    });
    return proxy;
  }

  function createFallback(Component) {
    var CurrentComponent = Component;
    return {
      get: function get() {
        return CurrentComponent;
      },
      update: function update(NextComponent) {
        CurrentComponent = NextComponent;
      }
    };
  }

  function createClassProxy(Component) {
    return Component.__proto__ && (0, _supportsProtoAssignment2.default)() ? proxyClass(Component) : createFallback(Component);
  }
},283,[284,405,430,431,282],"node_modules\\react-proxy\\modules\\createClassProxy.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var createFind = _$$_REQUIRE(_dependencyMap[0], "./_createFind"),
      findIndex = _$$_REQUIRE(_dependencyMap[1], "./findIndex");

  var find = createFind(findIndex);
  module.exports = find;
},284,[285,400],"node_modules\\lodash\\find.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseIteratee = _$$_REQUIRE(_dependencyMap[0], "./_baseIteratee"),
      isArrayLike = _$$_REQUIRE(_dependencyMap[1], "./isArrayLike"),
      keys = _$$_REQUIRE(_dependencyMap[2], "./keys");

  function createFind(findIndexFunc) {
    return function (collection, predicate, fromIndex) {
      var iterable = Object(collection);

      if (!isArrayLike(collection)) {
        var iteratee = baseIteratee(predicate, 3);
        collection = keys(collection);

        predicate = function predicate(key) {
          return iteratee(iterable[key], key, iterable);
        };
      }

      var index = findIndexFunc(collection, predicate, fromIndex);
      return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
    };
  }

  module.exports = createFind;
},285,[286,371,353],"node_modules\\lodash\\_createFind.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseMatches = _$$_REQUIRE(_dependencyMap[0], "./_baseMatches"),
      baseMatchesProperty = _$$_REQUIRE(_dependencyMap[1], "./_baseMatchesProperty"),
      identity = _$$_REQUIRE(_dependencyMap[2], "./identity"),
      isArray = _$$_REQUIRE(_dependencyMap[3], "./isArray"),
      property = _$$_REQUIRE(_dependencyMap[4], "./property");

  function baseIteratee(value) {
    if (typeof value == 'function') {
      return value;
    }

    if (value == null) {
      return identity;
    }

    if (typeof value == 'object') {
      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }

    return property(value);
  }

  module.exports = baseIteratee;
},286,[287,380,396,349,397],"node_modules\\lodash\\_baseIteratee.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseIsMatch = _$$_REQUIRE(_dependencyMap[0], "./_baseIsMatch"),
      getMatchData = _$$_REQUIRE(_dependencyMap[1], "./_getMatchData"),
      matchesStrictComparable = _$$_REQUIRE(_dependencyMap[2], "./_matchesStrictComparable");

  function baseMatches(source) {
    var matchData = getMatchData(source);

    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }

    return function (object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }

  module.exports = baseMatches;
},287,[288,377,379],"node_modules\\lodash\\_baseMatches.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Stack = _$$_REQUIRE(_dependencyMap[0], "./_Stack"),
      baseIsEqual = _$$_REQUIRE(_dependencyMap[1], "./_baseIsEqual");

  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }

    object = Object(object);

    while (index--) {
      var data = matchData[index];

      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }

    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack();

        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }

        if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
          return false;
        }
      }
    }

    return true;
  }

  module.exports = baseIsMatch;
},288,[289,333],"node_modules\\lodash\\_baseIsMatch.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var ListCache = _$$_REQUIRE(_dependencyMap[0], "./_ListCache"),
      stackClear = _$$_REQUIRE(_dependencyMap[1], "./_stackClear"),
      stackDelete = _$$_REQUIRE(_dependencyMap[2], "./_stackDelete"),
      stackGet = _$$_REQUIRE(_dependencyMap[3], "./_stackGet"),
      stackHas = _$$_REQUIRE(_dependencyMap[4], "./_stackHas"),
      stackSet = _$$_REQUIRE(_dependencyMap[5], "./_stackSet");

  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }

  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  module.exports = Stack;
},289,[290,298,299,300,301,302],"node_modules\\lodash\\_Stack.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var listCacheClear = _$$_REQUIRE(_dependencyMap[0], "./_listCacheClear"),
      listCacheDelete = _$$_REQUIRE(_dependencyMap[1], "./_listCacheDelete"),
      listCacheGet = _$$_REQUIRE(_dependencyMap[2], "./_listCacheGet"),
      listCacheHas = _$$_REQUIRE(_dependencyMap[3], "./_listCacheHas"),
      listCacheSet = _$$_REQUIRE(_dependencyMap[4], "./_listCacheSet");

  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  module.exports = ListCache;
},290,[291,292,295,296,297],"node_modules\\lodash\\_ListCache.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  module.exports = listCacheClear;
},291,[],"node_modules\\lodash\\_listCacheClear.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var assocIndexOf = _$$_REQUIRE(_dependencyMap[0], "./_assocIndexOf");

  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;

  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    --this.size;
    return true;
  }

  module.exports = listCacheDelete;
},292,[293],"node_modules\\lodash\\_listCacheDelete.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var eq = _$$_REQUIRE(_dependencyMap[0], "./eq");

  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }

  module.exports = assocIndexOf;
},293,[294],"node_modules\\lodash\\_assocIndexOf.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  module.exports = eq;
},294,[],"node_modules\\lodash\\eq.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var assocIndexOf = _$$_REQUIRE(_dependencyMap[0], "./_assocIndexOf");

  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }

  module.exports = listCacheGet;
},295,[293],"node_modules\\lodash\\_listCacheGet.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var assocIndexOf = _$$_REQUIRE(_dependencyMap[0], "./_assocIndexOf");

  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  module.exports = listCacheHas;
},296,[293],"node_modules\\lodash\\_listCacheHas.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var assocIndexOf = _$$_REQUIRE(_dependencyMap[0], "./_assocIndexOf");

  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  }

  module.exports = listCacheSet;
},297,[293],"node_modules\\lodash\\_listCacheSet.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var ListCache = _$$_REQUIRE(_dependencyMap[0], "./_ListCache");

  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }

  module.exports = stackClear;
},298,[290],"node_modules\\lodash\\_stackClear.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);
    this.size = data.size;
    return result;
  }

  module.exports = stackDelete;
},299,[],"node_modules\\lodash\\_stackDelete.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function stackGet(key) {
    return this.__data__.get(key);
  }

  module.exports = stackGet;
},300,[],"node_modules\\lodash\\_stackGet.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function stackHas(key) {
    return this.__data__.has(key);
  }

  module.exports = stackHas;
},301,[],"node_modules\\lodash\\_stackHas.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var ListCache = _$$_REQUIRE(_dependencyMap[0], "./_ListCache"),
      Map = _$$_REQUIRE(_dependencyMap[1], "./_Map"),
      MapCache = _$$_REQUIRE(_dependencyMap[2], "./_MapCache");

  var LARGE_ARRAY_SIZE = 200;

  function stackSet(key, value) {
    var data = this.__data__;

    if (data instanceof ListCache) {
      var pairs = data.__data__;

      if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }

      data = this.__data__ = new MapCache(pairs);
    }

    data.set(key, value);
    this.size = data.size;
    return this;
  }

  module.exports = stackSet;
},302,[290,303,318],"node_modules\\lodash\\_stackSet.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var getNative = _$$_REQUIRE(_dependencyMap[0], "./_getNative"),
      root = _$$_REQUIRE(_dependencyMap[1], "./_root");

  var Map = getNative(root, 'Map');
  module.exports = Map;
},303,[304,309],"node_modules\\lodash\\_Map.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseIsNative = _$$_REQUIRE(_dependencyMap[0], "./_baseIsNative"),
      getValue = _$$_REQUIRE(_dependencyMap[1], "./_getValue");

  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  module.exports = getNative;
},304,[305,317],"node_modules\\lodash\\_getNative.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var isFunction = _$$_REQUIRE(_dependencyMap[0], "./isFunction"),
      isMasked = _$$_REQUIRE(_dependencyMap[1], "./_isMasked"),
      isObject = _$$_REQUIRE(_dependencyMap[2], "./isObject"),
      toSource = _$$_REQUIRE(_dependencyMap[3], "./_toSource");

  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype,
      objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }

    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  module.exports = baseIsNative;
},305,[306,314,313,316],"node_modules\\lodash\\_baseIsNative.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseGetTag = _$$_REQUIRE(_dependencyMap[0], "./_baseGetTag"),
      isObject = _$$_REQUIRE(_dependencyMap[1], "./isObject");

  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }

    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  module.exports = isFunction;
},306,[307,313],"node_modules\\lodash\\isFunction.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Symbol = _$$_REQUIRE(_dependencyMap[0], "./_Symbol"),
      getRawTag = _$$_REQUIRE(_dependencyMap[1], "./_getRawTag"),
      objectToString = _$$_REQUIRE(_dependencyMap[2], "./_objectToString");

  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';
  var symToStringTag = Symbol ? typeof Symbol === "function" ? Symbol.toStringTag : "@@toStringTag" : undefined;

  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }

  module.exports = baseGetTag;
},307,[308,311,312],"node_modules\\lodash\\_baseGetTag.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var root = _$$_REQUIRE(_dependencyMap[0], "./_root");

  var Symbol = root.Symbol;
  module.exports = Symbol;
},308,[309],"node_modules\\lodash\\_Symbol.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var freeGlobal = _$$_REQUIRE(_dependencyMap[0], "./_freeGlobal");

  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function('return this')();
  module.exports = root;
},309,[310],"node_modules\\lodash\\_root.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
  module.exports = freeGlobal;
},310,[],"node_modules\\lodash\\_freeGlobal.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Symbol = _$$_REQUIRE(_dependencyMap[0], "./_Symbol");

  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol ? typeof Symbol === "function" ? Symbol.toStringTag : "@@toStringTag" : undefined;

  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }

    return result;
  }

  module.exports = getRawTag;
},311,[308],"node_modules\\lodash\\_getRawTag.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;

  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  module.exports = objectToString;
},312,[],"node_modules\\lodash\\_objectToString.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  module.exports = isObject;
},313,[],"node_modules\\lodash\\isObject.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var coreJsData = _$$_REQUIRE(_dependencyMap[0], "./_coreJsData");

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  module.exports = isMasked;
},314,[315],"node_modules\\lodash\\_isMasked.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var root = _$$_REQUIRE(_dependencyMap[0], "./_root");

  var coreJsData = root['__core-js_shared__'];
  module.exports = coreJsData;
},315,[309],"node_modules\\lodash\\_coreJsData.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;

  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }

  module.exports = toSource;
},316,[],"node_modules\\lodash\\_toSource.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  module.exports = getValue;
},317,[],"node_modules\\lodash\\_getValue.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var mapCacheClear = _$$_REQUIRE(_dependencyMap[0], "./_mapCacheClear"),
      mapCacheDelete = _$$_REQUIRE(_dependencyMap[1], "./_mapCacheDelete"),
      mapCacheGet = _$$_REQUIRE(_dependencyMap[2], "./_mapCacheGet"),
      mapCacheHas = _$$_REQUIRE(_dependencyMap[3], "./_mapCacheHas"),
      mapCacheSet = _$$_REQUIRE(_dependencyMap[4], "./_mapCacheSet");

  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  module.exports = MapCache;
},318,[319,327,330,331,332],"node_modules\\lodash\\_MapCache.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Hash = _$$_REQUIRE(_dependencyMap[0], "./_Hash"),
      ListCache = _$$_REQUIRE(_dependencyMap[1], "./_ListCache"),
      Map = _$$_REQUIRE(_dependencyMap[2], "./_Map");

  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map || ListCache)(),
      'string': new Hash()
    };
  }

  module.exports = mapCacheClear;
},319,[320,290,303],"node_modules\\lodash\\_mapCacheClear.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var hashClear = _$$_REQUIRE(_dependencyMap[0], "./_hashClear"),
      hashDelete = _$$_REQUIRE(_dependencyMap[1], "./_hashDelete"),
      hashGet = _$$_REQUIRE(_dependencyMap[2], "./_hashGet"),
      hashHas = _$$_REQUIRE(_dependencyMap[3], "./_hashHas"),
      hashSet = _$$_REQUIRE(_dependencyMap[4], "./_hashSet");

  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  module.exports = Hash;
},320,[321,323,324,325,326],"node_modules\\lodash\\_Hash.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var nativeCreate = _$$_REQUIRE(_dependencyMap[0], "./_nativeCreate");

  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }

  module.exports = hashClear;
},321,[322],"node_modules\\lodash\\_hashClear.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var getNative = _$$_REQUIRE(_dependencyMap[0], "./_getNative");

  var nativeCreate = getNative(Object, 'create');
  module.exports = nativeCreate;
},322,[304],"node_modules\\lodash\\_nativeCreate.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  module.exports = hashDelete;
},323,[],"node_modules\\lodash\\_hashDelete.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var nativeCreate = _$$_REQUIRE(_dependencyMap[0], "./_nativeCreate");

  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function hashGet(key) {
    var data = this.__data__;

    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }

  module.exports = hashGet;
},324,[322],"node_modules\\lodash\\_hashGet.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var nativeCreate = _$$_REQUIRE(_dependencyMap[0], "./_nativeCreate");

  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }

  module.exports = hashHas;
},325,[322],"node_modules\\lodash\\_hashHas.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var nativeCreate = _$$_REQUIRE(_dependencyMap[0], "./_nativeCreate");

  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }

  module.exports = hashSet;
},326,[322],"node_modules\\lodash\\_hashSet.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var getMapData = _$$_REQUIRE(_dependencyMap[0], "./_getMapData");

  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  module.exports = mapCacheDelete;
},327,[328],"node_modules\\lodash\\_mapCacheDelete.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var isKeyable = _$$_REQUIRE(_dependencyMap[0], "./_isKeyable");

  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  module.exports = getMapData;
},328,[329],"node_modules\\lodash\\_getMapData.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  module.exports = isKeyable;
},329,[],"node_modules\\lodash\\_isKeyable.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var getMapData = _$$_REQUIRE(_dependencyMap[0], "./_getMapData");

  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  module.exports = mapCacheGet;
},330,[328],"node_modules\\lodash\\_mapCacheGet.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var getMapData = _$$_REQUIRE(_dependencyMap[0], "./_getMapData");

  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  module.exports = mapCacheHas;
},331,[328],"node_modules\\lodash\\_mapCacheHas.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var getMapData = _$$_REQUIRE(_dependencyMap[0], "./_getMapData");

  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  module.exports = mapCacheSet;
},332,[328],"node_modules\\lodash\\_mapCacheSet.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseIsEqualDeep = _$$_REQUIRE(_dependencyMap[0], "./_baseIsEqualDeep"),
      isObjectLike = _$$_REQUIRE(_dependencyMap[1], "./isObjectLike");

  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }

    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }

    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  module.exports = baseIsEqual;
},333,[334,358],"node_modules\\lodash\\_baseIsEqual.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Stack = _$$_REQUIRE(_dependencyMap[0], "./_Stack"),
      equalArrays = _$$_REQUIRE(_dependencyMap[1], "./_equalArrays"),
      equalByTag = _$$_REQUIRE(_dependencyMap[2], "./_equalByTag"),
      equalObjects = _$$_REQUIRE(_dependencyMap[3], "./_equalObjects"),
      getTag = _$$_REQUIRE(_dependencyMap[4], "./_getTag"),
      isArray = _$$_REQUIRE(_dependencyMap[5], "./isArray"),
      isBuffer = _$$_REQUIRE(_dependencyMap[6], "./isBuffer"),
      isTypedArray = _$$_REQUIRE(_dependencyMap[7], "./isTypedArray");

  var COMPARE_PARTIAL_FLAG = 1;
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      objectTag = '[object Object]';
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = objIsArr ? arrayTag : getTag(object),
        othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }

      objIsArr = true;
      objIsObj = false;
    }

    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }

    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }

    if (!isSameTag) {
      return false;
    }

    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  module.exports = baseIsEqualDeep;
},334,[289,335,341,345,372,349,359,362],"node_modules\\lodash\\_baseIsEqualDeep.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var SetCache = _$$_REQUIRE(_dependencyMap[0], "./_SetCache"),
      arraySome = _$$_REQUIRE(_dependencyMap[1], "./_arraySome"),
      cacheHas = _$$_REQUIRE(_dependencyMap[2], "./_cacheHas");

  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }

    var stacked = stack.get(array);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var index = -1,
        result = true,
        seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array);

    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }

      if (compared !== undefined) {
        if (compared) {
          continue;
        }

        result = false;
        break;
      }

      if (seen) {
        if (!arraySome(other, function (othValue, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }

    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  module.exports = equalArrays;
},335,[336,339,340],"node_modules\\lodash\\_equalArrays.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var MapCache = _$$_REQUIRE(_dependencyMap[0], "./_MapCache"),
      setCacheAdd = _$$_REQUIRE(_dependencyMap[1], "./_setCacheAdd"),
      setCacheHas = _$$_REQUIRE(_dependencyMap[2], "./_setCacheHas");

  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();

    while (++index < length) {
      this.add(values[index]);
    }
  }

  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  module.exports = SetCache;
},336,[318,337,338],"node_modules\\lodash\\_SetCache.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);

    return this;
  }

  module.exports = setCacheAdd;
},337,[],"node_modules\\lodash\\_setCacheAdd.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  module.exports = setCacheHas;
},338,[],"node_modules\\lodash\\_setCacheHas.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }

    return false;
  }

  module.exports = arraySome;
},339,[],"node_modules\\lodash\\_arraySome.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  module.exports = cacheHas;
},340,[],"node_modules\\lodash\\_cacheHas.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Symbol = _$$_REQUIRE(_dependencyMap[0], "./_Symbol"),
      Uint8Array = _$$_REQUIRE(_dependencyMap[1], "./_Uint8Array"),
      eq = _$$_REQUIRE(_dependencyMap[2], "./eq"),
      equalArrays = _$$_REQUIRE(_dependencyMap[3], "./_equalArrays"),
      mapToArray = _$$_REQUIRE(_dependencyMap[4], "./_mapToArray"),
      setToArray = _$$_REQUIRE(_dependencyMap[5], "./_setToArray");

  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;
  var boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]';
  var symbolProto = Symbol ? typeof Symbol === "function" ? Symbol.prototype : "@@prototype" : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }

        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }

        return true;

      case boolTag:
      case dateTag:
      case numberTag:
        return eq(+object, +other);

      case errorTag:
        return object.name == other.name && object.message == other.message;

      case regexpTag:
      case stringTag:
        return object == other + '';

      case mapTag:
        var convert = mapToArray;

      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        }

        var stacked = stack.get(object);

        if (stacked) {
          return stacked == other;
        }

        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }

    }

    return false;
  }

  module.exports = equalByTag;
},341,[308,342,294,335,343,344],"node_modules\\lodash\\_equalByTag.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var root = _$$_REQUIRE(_dependencyMap[0], "./_root");

  var Uint8Array = root.Uint8Array;
  module.exports = Uint8Array;
},342,[309],"node_modules\\lodash\\_Uint8Array.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  module.exports = mapToArray;
},343,[],"node_modules\\lodash\\_mapToArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }

  module.exports = setToArray;
},344,[],"node_modules\\lodash\\_setToArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var getAllKeys = _$$_REQUIRE(_dependencyMap[0], "./_getAllKeys");

  var COMPARE_PARTIAL_FLAG = 1;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        objProps = getAllKeys(object),
        objLength = objProps.length,
        othProps = getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }

    var index = objLength;

    while (index--) {
      var key = objProps[index];

      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }

    var stacked = stack.get(object);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;

    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }

      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }

      skipCtor || (skipCtor = key == 'constructor');
    }

    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }

    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  module.exports = equalObjects;
},345,[346],"node_modules\\lodash\\_equalObjects.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseGetAllKeys = _$$_REQUIRE(_dependencyMap[0], "./_baseGetAllKeys"),
      getSymbols = _$$_REQUIRE(_dependencyMap[1], "./_getSymbols"),
      keys = _$$_REQUIRE(_dependencyMap[2], "./keys");

  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }

  module.exports = getAllKeys;
},346,[347,350,353],"node_modules\\lodash\\_getAllKeys.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var arrayPush = _$$_REQUIRE(_dependencyMap[0], "./_arrayPush"),
      isArray = _$$_REQUIRE(_dependencyMap[1], "./isArray");

  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  module.exports = baseGetAllKeys;
},347,[348,349],"node_modules\\lodash\\_baseGetAllKeys.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }

    return array;
  }

  module.exports = arrayPush;
},348,[],"node_modules\\lodash\\_arrayPush.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var isArray = Array.isArray;
  module.exports = isArray;
},349,[],"node_modules\\lodash\\isArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var arrayFilter = _$$_REQUIRE(_dependencyMap[0], "./_arrayFilter"),
      stubArray = _$$_REQUIRE(_dependencyMap[1], "./stubArray");

  var objectProto = Object.prototype;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
    if (object == null) {
      return [];
    }

    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function (symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  module.exports = getSymbols;
},350,[351,352],"node_modules\\lodash\\_getSymbols.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }

    return result;
  }

  module.exports = arrayFilter;
},351,[],"node_modules\\lodash\\_arrayFilter.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function stubArray() {
    return [];
  }

  module.exports = stubArray;
},352,[],"node_modules\\lodash\\stubArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var arrayLikeKeys = _$$_REQUIRE(_dependencyMap[0], "./_arrayLikeKeys"),
      baseKeys = _$$_REQUIRE(_dependencyMap[1], "./_baseKeys"),
      isArrayLike = _$$_REQUIRE(_dependencyMap[2], "./isArrayLike");

  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  module.exports = keys;
},353,[354,367,371],"node_modules\\lodash\\keys.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseTimes = _$$_REQUIRE(_dependencyMap[0], "./_baseTimes"),
      isArguments = _$$_REQUIRE(_dependencyMap[1], "./isArguments"),
      isArray = _$$_REQUIRE(_dependencyMap[2], "./isArray"),
      isBuffer = _$$_REQUIRE(_dependencyMap[3], "./isBuffer"),
      isIndex = _$$_REQUIRE(_dependencyMap[4], "./_isIndex"),
      isTypedArray = _$$_REQUIRE(_dependencyMap[5], "./isTypedArray");

  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value),
        isArg = !isArr && isArguments(value),
        isBuff = !isArr && !isArg && isBuffer(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }

  module.exports = arrayLikeKeys;
},354,[355,356,349,359,361,362],"node_modules\\lodash\\_arrayLikeKeys.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }

  module.exports = baseTimes;
},355,[],"node_modules\\lodash\\_baseTimes.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseIsArguments = _$$_REQUIRE(_dependencyMap[0], "./_baseIsArguments"),
      isObjectLike = _$$_REQUIRE(_dependencyMap[1], "./isObjectLike");

  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var isArguments = baseIsArguments(function () {
    return arguments;
  }()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
  };
  module.exports = isArguments;
},356,[357,358],"node_modules\\lodash\\isArguments.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseGetTag = _$$_REQUIRE(_dependencyMap[0], "./_baseGetTag"),
      isObjectLike = _$$_REQUIRE(_dependencyMap[1], "./isObjectLike");

  var argsTag = '[object Arguments]';

  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }

  module.exports = baseIsArguments;
},357,[307,358],"node_modules\\lodash\\_baseIsArguments.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  module.exports = isObjectLike;
},358,[],"node_modules\\lodash\\isObjectLike.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var root = _$$_REQUIRE(_dependencyMap[0], "./_root"),
      stubFalse = _$$_REQUIRE(_dependencyMap[1], "./stubFalse");

  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root.Buffer : undefined;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
  var isBuffer = nativeIsBuffer || stubFalse;
  module.exports = isBuffer;
},359,[309,360],"node_modules\\lodash\\isBuffer.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function stubFalse() {
    return false;
  }

  module.exports = stubFalse;
},360,[],"node_modules\\lodash\\stubFalse.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  module.exports = isIndex;
},361,[],"node_modules\\lodash\\_isIndex.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseIsTypedArray = _$$_REQUIRE(_dependencyMap[0], "./_baseIsTypedArray"),
      baseUnary = _$$_REQUIRE(_dependencyMap[1], "./_baseUnary"),
      nodeUtil = _$$_REQUIRE(_dependencyMap[2], "./_nodeUtil");

  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  module.exports = isTypedArray;
},362,[363,365,366],"node_modules\\lodash\\isTypedArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseGetTag = _$$_REQUIRE(_dependencyMap[0], "./_baseGetTag"),
      isLength = _$$_REQUIRE(_dependencyMap[1], "./isLength"),
      isObjectLike = _$$_REQUIRE(_dependencyMap[2], "./isObjectLike");

  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  module.exports = baseIsTypedArray;
},363,[307,364,358],"node_modules\\lodash\\_baseIsTypedArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var MAX_SAFE_INTEGER = 9007199254740991;

  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  module.exports = isLength;
},364,[],"node_modules\\lodash\\isLength.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }

  module.exports = baseUnary;
},365,[],"node_modules\\lodash\\_baseUnary.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var freeGlobal = _$$_REQUIRE(_dependencyMap[0], "./_freeGlobal");

  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;

  var nodeUtil = function () {
    try {
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }();

  module.exports = nodeUtil;
},366,[310],"node_modules\\lodash\\_nodeUtil.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var isPrototype = _$$_REQUIRE(_dependencyMap[0], "./_isPrototype"),
      nativeKeys = _$$_REQUIRE(_dependencyMap[1], "./_nativeKeys");

  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }

    var result = [];

    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }

    return result;
  }

  module.exports = baseKeys;
},367,[368,369],"node_modules\\lodash\\_baseKeys.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var objectProto = Object.prototype;

  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
  }

  module.exports = isPrototype;
},368,[],"node_modules\\lodash\\_isPrototype.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var overArg = _$$_REQUIRE(_dependencyMap[0], "./_overArg");

  var nativeKeys = overArg(Object.keys, Object);
  module.exports = nativeKeys;
},369,[370],"node_modules\\lodash\\_nativeKeys.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  module.exports = overArg;
},370,[],"node_modules\\lodash\\_overArg.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var isFunction = _$$_REQUIRE(_dependencyMap[0], "./isFunction"),
      isLength = _$$_REQUIRE(_dependencyMap[1], "./isLength");

  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  module.exports = isArrayLike;
},371,[306,364],"node_modules\\lodash\\isArrayLike.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var DataView = _$$_REQUIRE(_dependencyMap[0], "./_DataView"),
      Map = _$$_REQUIRE(_dependencyMap[1], "./_Map"),
      Promise = _$$_REQUIRE(_dependencyMap[2], "./_Promise"),
      Set = _$$_REQUIRE(_dependencyMap[3], "./_Set"),
      WeakMap = _$$_REQUIRE(_dependencyMap[4], "./_WeakMap"),
      baseGetTag = _$$_REQUIRE(_dependencyMap[5], "./_baseGetTag"),
      toSource = _$$_REQUIRE(_dependencyMap[6], "./_toSource");

  var mapTag = '[object Map]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      setTag = '[object Set]',
      weakMapTag = '[object WeakMap]';
  var dataViewTag = '[object DataView]';
  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise),
      setCtorString = toSource(Set),
      weakMapCtorString = toSource(WeakMap);
  var getTag = baseGetTag;

  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function getTag(value) {
      var result = baseGetTag(value),
          Ctor = result == objectTag ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;

          case mapCtorString:
            return mapTag;

          case promiseCtorString:
            return promiseTag;

          case setCtorString:
            return setTag;

          case weakMapCtorString:
            return weakMapTag;
        }
      }

      return result;
    };
  }

  module.exports = getTag;
},372,[373,303,374,375,376,307,316],"node_modules\\lodash\\_getTag.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var getNative = _$$_REQUIRE(_dependencyMap[0], "./_getNative"),
      root = _$$_REQUIRE(_dependencyMap[1], "./_root");

  var DataView = getNative(root, 'DataView');
  module.exports = DataView;
},373,[304,309],"node_modules\\lodash\\_DataView.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var getNative = _$$_REQUIRE(_dependencyMap[0], "./_getNative"),
      root = _$$_REQUIRE(_dependencyMap[1], "./_root");

  var Promise = getNative(root, 'Promise');
  module.exports = Promise;
},374,[304,309],"node_modules\\lodash\\_Promise.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var getNative = _$$_REQUIRE(_dependencyMap[0], "./_getNative"),
      root = _$$_REQUIRE(_dependencyMap[1], "./_root");

  var Set = getNative(root, 'Set');
  module.exports = Set;
},375,[304,309],"node_modules\\lodash\\_Set.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var getNative = _$$_REQUIRE(_dependencyMap[0], "./_getNative"),
      root = _$$_REQUIRE(_dependencyMap[1], "./_root");

  var WeakMap = getNative(root, 'WeakMap');
  module.exports = WeakMap;
},376,[304,309],"node_modules\\lodash\\_WeakMap.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var isStrictComparable = _$$_REQUIRE(_dependencyMap[0], "./_isStrictComparable"),
      keys = _$$_REQUIRE(_dependencyMap[1], "./keys");

  function getMatchData(object) {
    var result = keys(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];
      result[length] = [key, value, isStrictComparable(value)];
    }

    return result;
  }

  module.exports = getMatchData;
},377,[378,353],"node_modules\\lodash\\_getMatchData.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var isObject = _$$_REQUIRE(_dependencyMap[0], "./isObject");

  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }

  module.exports = isStrictComparable;
},378,[313],"node_modules\\lodash\\_isStrictComparable.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function matchesStrictComparable(key, srcValue) {
    return function (object) {
      if (object == null) {
        return false;
      }

      return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
  }

  module.exports = matchesStrictComparable;
},379,[],"node_modules\\lodash\\_matchesStrictComparable.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseIsEqual = _$$_REQUIRE(_dependencyMap[0], "./_baseIsEqual"),
      get = _$$_REQUIRE(_dependencyMap[1], "./get"),
      hasIn = _$$_REQUIRE(_dependencyMap[2], "./hasIn"),
      isKey = _$$_REQUIRE(_dependencyMap[3], "./_isKey"),
      isStrictComparable = _$$_REQUIRE(_dependencyMap[4], "./_isStrictComparable"),
      matchesStrictComparable = _$$_REQUIRE(_dependencyMap[5], "./_matchesStrictComparable"),
      toKey = _$$_REQUIRE(_dependencyMap[6], "./_toKey");

  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }

    return function (object) {
      var objValue = get(object, path);
      return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }

  module.exports = baseMatchesProperty;
},380,[333,381,393,384,378,379,392],"node_modules\\lodash\\_baseMatchesProperty.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseGet = _$$_REQUIRE(_dependencyMap[0], "./_baseGet");

  function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  module.exports = get;
},381,[382],"node_modules\\lodash\\get.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var castPath = _$$_REQUIRE(_dependencyMap[0], "./_castPath"),
      toKey = _$$_REQUIRE(_dependencyMap[1], "./_toKey");

  function baseGet(object, path) {
    path = castPath(path, object);
    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }

    return index && index == length ? object : undefined;
  }

  module.exports = baseGet;
},382,[383,392],"node_modules\\lodash\\_baseGet.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var isArray = _$$_REQUIRE(_dependencyMap[0], "./isArray"),
      isKey = _$$_REQUIRE(_dependencyMap[1], "./_isKey"),
      stringToPath = _$$_REQUIRE(_dependencyMap[2], "./_stringToPath"),
      toString = _$$_REQUIRE(_dependencyMap[3], "./toString");

  function castPath(value, object) {
    if (isArray(value)) {
      return value;
    }

    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }

  module.exports = castPath;
},383,[349,384,386,389],"node_modules\\lodash\\_castPath.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var isArray = _$$_REQUIRE(_dependencyMap[0], "./isArray"),
      isSymbol = _$$_REQUIRE(_dependencyMap[1], "./isSymbol");

  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;

  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }

    var type = typeof value;

    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
      return true;
    }

    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }

  module.exports = isKey;
},384,[349,385],"node_modules\\lodash\\_isKey.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseGetTag = _$$_REQUIRE(_dependencyMap[0], "./_baseGetTag"),
      isObjectLike = _$$_REQUIRE(_dependencyMap[1], "./isObjectLike");

  var symbolTag = '[object Symbol]';

  function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }

  module.exports = isSymbol;
},385,[307,358],"node_modules\\lodash\\isSymbol.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var memoizeCapped = _$$_REQUIRE(_dependencyMap[0], "./_memoizeCapped");

  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function (string) {
    var result = [];

    if (string.charCodeAt(0) === 46) {
        result.push('');
      }

    string.replace(rePropName, function (match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });
  module.exports = stringToPath;
},386,[387],"node_modules\\lodash\\_stringToPath.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var memoize = _$$_REQUIRE(_dependencyMap[0], "./memoize");

  var MAX_MEMOIZE_SIZE = 500;

  function memoizeCapped(func) {
    var result = memoize(func, function (key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }

      return key;
    });
    var cache = result.cache;
    return result;
  }

  module.exports = memoizeCapped;
},387,[388],"node_modules\\lodash\\_memoizeCapped.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var MapCache = _$$_REQUIRE(_dependencyMap[0], "./_MapCache");

  var FUNC_ERROR_TEXT = 'Expected a function';

  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    var memoized = function memoized() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }

      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };

    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }

  memoize.Cache = MapCache;
  module.exports = memoize;
},388,[318],"node_modules\\lodash\\memoize.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseToString = _$$_REQUIRE(_dependencyMap[0], "./_baseToString");

  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  module.exports = toString;
},389,[390],"node_modules\\lodash\\toString.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Symbol = _$$_REQUIRE(_dependencyMap[0], "./_Symbol"),
      arrayMap = _$$_REQUIRE(_dependencyMap[1], "./_arrayMap"),
      isArray = _$$_REQUIRE(_dependencyMap[2], "./isArray"),
      isSymbol = _$$_REQUIRE(_dependencyMap[3], "./isSymbol");

  var INFINITY = 1 / 0;
  var symbolProto = Symbol ? typeof Symbol === "function" ? Symbol.prototype : "@@prototype" : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }

    if (isArray(value)) {
      return arrayMap(value, baseToString) + '';
    }

    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  module.exports = baseToString;
},390,[308,391,349,385],"node_modules\\lodash\\_baseToString.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }

    return result;
  }

  module.exports = arrayMap;
},391,[],"node_modules\\lodash\\_arrayMap.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var isSymbol = _$$_REQUIRE(_dependencyMap[0], "./isSymbol");

  var INFINITY = 1 / 0;

  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  module.exports = toKey;
},392,[385],"node_modules\\lodash\\_toKey.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseHasIn = _$$_REQUIRE(_dependencyMap[0], "./_baseHasIn"),
      hasPath = _$$_REQUIRE(_dependencyMap[1], "./_hasPath");

  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }

  module.exports = hasIn;
},393,[394,395],"node_modules\\lodash\\hasIn.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  module.exports = baseHasIn;
},394,[],"node_modules\\lodash\\_baseHasIn.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var castPath = _$$_REQUIRE(_dependencyMap[0], "./_castPath"),
      isArguments = _$$_REQUIRE(_dependencyMap[1], "./isArguments"),
      isArray = _$$_REQUIRE(_dependencyMap[2], "./isArray"),
      isIndex = _$$_REQUIRE(_dependencyMap[3], "./_isIndex"),
      isLength = _$$_REQUIRE(_dependencyMap[4], "./isLength"),
      toKey = _$$_REQUIRE(_dependencyMap[5], "./_toKey");

  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);
    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = toKey(path[index]);

      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }

      object = object[key];
    }

    if (result || ++index != length) {
      return result;
    }

    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
  }

  module.exports = hasPath;
},395,[383,356,349,361,364,392],"node_modules\\lodash\\_hasPath.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function identity(value) {
    return value;
  }

  module.exports = identity;
},396,[],"node_modules\\lodash\\identity.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseProperty = _$$_REQUIRE(_dependencyMap[0], "./_baseProperty"),
      basePropertyDeep = _$$_REQUIRE(_dependencyMap[1], "./_basePropertyDeep"),
      isKey = _$$_REQUIRE(_dependencyMap[2], "./_isKey"),
      toKey = _$$_REQUIRE(_dependencyMap[3], "./_toKey");

  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }

  module.exports = property;
},397,[398,399,384,392],"node_modules\\lodash\\property.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function baseProperty(key) {
    return function (object) {
      return object == null ? undefined : object[key];
    };
  }

  module.exports = baseProperty;
},398,[],"node_modules\\lodash\\_baseProperty.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseGet = _$$_REQUIRE(_dependencyMap[0], "./_baseGet");

  function basePropertyDeep(path) {
    return function (object) {
      return baseGet(object, path);
    };
  }

  module.exports = basePropertyDeep;
},399,[382],"node_modules\\lodash\\_basePropertyDeep.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseFindIndex = _$$_REQUIRE(_dependencyMap[0], "./_baseFindIndex"),
      baseIteratee = _$$_REQUIRE(_dependencyMap[1], "./_baseIteratee"),
      toInteger = _$$_REQUIRE(_dependencyMap[2], "./toInteger");

  var nativeMax = Math.max;

  function findIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;

    if (!length) {
      return -1;
    }

    var index = fromIndex == null ? 0 : toInteger(fromIndex);

    if (index < 0) {
      index = nativeMax(length + index, 0);
    }

    return baseFindIndex(array, baseIteratee(predicate, 3), index);
  }

  module.exports = findIndex;
},400,[401,286,402],"node_modules\\lodash\\findIndex.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }

    return -1;
  }

  module.exports = baseFindIndex;
},401,[],"node_modules\\lodash\\_baseFindIndex.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var toFinite = _$$_REQUIRE(_dependencyMap[0], "./toFinite");

  function toInteger(value) {
    var result = toFinite(value),
        remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }

  module.exports = toInteger;
},402,[403],"node_modules\\lodash\\toInteger.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var toNumber = _$$_REQUIRE(_dependencyMap[0], "./toNumber");

  var INFINITY = 1 / 0,
      MAX_INTEGER = 1.7976931348623157e+308;

  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }

    value = toNumber(value);

    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }

    return value === value ? value : 0;
  }

  module.exports = toFinite;
},403,[404],"node_modules\\lodash\\toFinite.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var isObject = _$$_REQUIRE(_dependencyMap[0], "./isObject"),
      isSymbol = _$$_REQUIRE(_dependencyMap[1], "./isSymbol");

  var NAN = 0 / 0;
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;

  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol(value)) {
      return NAN;
    }

    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }

  module.exports = toNumber;
},404,[313,385],"node_modules\\lodash\\toNumber.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createPrototypeProxy;

  var _assign = _$$_REQUIRE(_dependencyMap[0], "lodash/assign");

  var _assign2 = _interopRequireDefault(_assign);

  var _difference = _$$_REQUIRE(_dependencyMap[1], "lodash/difference");

  var _difference2 = _interopRequireDefault(_difference);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function createPrototypeProxy() {
    var proxy = {};
    var current = null;
    var mountedInstances = [];

    function proxyToString(name) {
      return function toString() {
        if (typeof current[name] === 'function') {
          return current[name].toString();
        } else {
          return '<method was deleted>';
        }
      };
    }

    function proxyMethod(name) {
      var proxiedMethod = function proxiedMethod() {
        if (typeof current[name] === 'function') {
          return current[name].apply(this, arguments);
        }
      };

      (0, _assign2.default)(proxiedMethod, current[name]);
      proxiedMethod.toString = proxyToString(name);
      return proxiedMethod;
    }

    function proxiedComponentDidMount() {
      mountedInstances.push(this);

      if (typeof current.componentDidMount === 'function') {
        return current.componentDidMount.apply(this, arguments);
      }
    }

    proxiedComponentDidMount.toString = proxyToString('componentDidMount');

    function proxiedComponentWillUnmount() {
      var index = mountedInstances.indexOf(this);

      if (index !== -1) {
        mountedInstances.splice(index, 1);
      }

      if (typeof current.componentWillUnmount === 'function') {
        return current.componentWillUnmount.apply(this, arguments);
      }
    }

    proxiedComponentWillUnmount.toString = proxyToString('componentWillUnmount');

    function defineProxyProperty(name, descriptor) {
      Object.defineProperty(proxy, name, descriptor);
    }

    function defineProxyPropertyWithValue(name, value) {
      var _ref = Object.getOwnPropertyDescriptor(current, name) || {};

      var _ref$enumerable = _ref.enumerable;
      var enumerable = _ref$enumerable === undefined ? false : _ref$enumerable;
      var _ref$writable = _ref.writable;
      var writable = _ref$writable === undefined ? true : _ref$writable;
      defineProxyProperty(name, {
        configurable: true,
        enumerable: enumerable,
        writable: writable,
        value: value
      });
    }

    function createAutoBindMap() {
      if (!current.__reactAutoBindMap) {
        return;
      }

      var __reactAutoBindMap = {};

      for (var name in current.__reactAutoBindMap) {
        if (typeof proxy[name] === 'function' && current.__reactAutoBindMap.hasOwnProperty(name)) {
          __reactAutoBindMap[name] = proxy[name];
        }
      }

      return __reactAutoBindMap;
    }

    function createAutoBindPairs() {
      var __reactAutoBindPairs = [];

      for (var i = 0; i < current.__reactAutoBindPairs.length; i += 2) {
        var name = current.__reactAutoBindPairs[i];
        var method = proxy[name];

        if (typeof method === 'function') {
          __reactAutoBindPairs.push(name, method);
        }
      }

      return __reactAutoBindPairs;
    }

    function update(next) {
      current = next;
      var currentNames = Object.getOwnPropertyNames(current);
      var previousName = Object.getOwnPropertyNames(proxy);
      var removedNames = (0, _difference2.default)(previousName, currentNames);
      removedNames.forEach(function (name) {
        delete proxy[name];
      });
      currentNames.forEach(function (name) {
        var descriptor = Object.getOwnPropertyDescriptor(current, name);

        if (typeof descriptor.value === 'function') {
          defineProxyPropertyWithValue(name, proxyMethod(name));
        } else {
          defineProxyProperty(name, descriptor);
        }
      });
      defineProxyPropertyWithValue('componentDidMount', proxiedComponentDidMount);
      defineProxyPropertyWithValue('componentWillUnmount', proxiedComponentWillUnmount);

      if (current.hasOwnProperty('__reactAutoBindMap')) {
        defineProxyPropertyWithValue('__reactAutoBindMap', createAutoBindMap());
      }

      if (current.hasOwnProperty('__reactAutoBindPairs')) {
        defineProxyPropertyWithValue('__reactAutoBindPairs', createAutoBindPairs());
      }

      proxy.__proto__ = next;
      return mountedInstances;
    }

    function get() {
      return proxy;
    }

    return {
      update: update,
      get: get
    };
  }

  ;
},405,[406,420],"node_modules\\react-proxy\\modules\\createPrototypeProxy.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var assignValue = _$$_REQUIRE(_dependencyMap[0], "./_assignValue"),
      copyObject = _$$_REQUIRE(_dependencyMap[1], "./_copyObject"),
      createAssigner = _$$_REQUIRE(_dependencyMap[2], "./_createAssigner"),
      isArrayLike = _$$_REQUIRE(_dependencyMap[3], "./isArrayLike"),
      isPrototype = _$$_REQUIRE(_dependencyMap[4], "./_isPrototype"),
      keys = _$$_REQUIRE(_dependencyMap[5], "./keys");

  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var assign = createAssigner(function (object, source) {
    if (isPrototype(source) || isArrayLike(source)) {
      copyObject(source, keys(source), object);
      return;
    }

    for (var key in source) {
      if (hasOwnProperty.call(source, key)) {
        assignValue(object, key, source[key]);
      }
    }
  });
  module.exports = assign;
},406,[407,410,411,371,368,353],"node_modules\\lodash\\assign.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseAssignValue = _$$_REQUIRE(_dependencyMap[0], "./_baseAssignValue"),
      eq = _$$_REQUIRE(_dependencyMap[1], "./eq");

  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function assignValue(object, key, value) {
    var objValue = object[key];

    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }

  module.exports = assignValue;
},407,[408,294],"node_modules\\lodash\\_assignValue.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var defineProperty = _$$_REQUIRE(_dependencyMap[0], "./_defineProperty");

  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty) {
      defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  module.exports = baseAssignValue;
},408,[409],"node_modules\\lodash\\_baseAssignValue.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var getNative = _$$_REQUIRE(_dependencyMap[0], "./_getNative");

  var defineProperty = function () {
    try {
      var func = getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }();

  module.exports = defineProperty;
},409,[304],"node_modules\\lodash\\_defineProperty.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var assignValue = _$$_REQUIRE(_dependencyMap[0], "./_assignValue"),
      baseAssignValue = _$$_REQUIRE(_dependencyMap[1], "./_baseAssignValue");

  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }

      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }

    return object;
  }

  module.exports = copyObject;
},410,[407,408],"node_modules\\lodash\\_copyObject.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseRest = _$$_REQUIRE(_dependencyMap[0], "./_baseRest"),
      isIterateeCall = _$$_REQUIRE(_dependencyMap[1], "./_isIterateeCall");

  function createAssigner(assigner) {
    return baseRest(function (object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined,
          guard = length > 2 ? sources[2] : undefined;
      customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }

      object = Object(object);

      while (++index < length) {
        var source = sources[index];

        if (source) {
          assigner(object, source, index, customizer);
        }
      }

      return object;
    });
  }

  module.exports = createAssigner;
},411,[412,419],"node_modules\\lodash\\_createAssigner.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var identity = _$$_REQUIRE(_dependencyMap[0], "./identity"),
      overRest = _$$_REQUIRE(_dependencyMap[1], "./_overRest"),
      setToString = _$$_REQUIRE(_dependencyMap[2], "./_setToString");

  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + '');
  }

  module.exports = baseRest;
},412,[396,413,415],"node_modules\\lodash\\_baseRest.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var apply = _$$_REQUIRE(_dependencyMap[0], "./_apply");

  var nativeMax = Math.max;

  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function () {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }

      index = -1;
      var otherArgs = Array(start + 1);

      while (++index < start) {
        otherArgs[index] = args[index];
      }

      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }

  module.exports = overRest;
},413,[414],"node_modules\\lodash\\_overRest.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);

      case 1:
        return func.call(thisArg, args[0]);

      case 2:
        return func.call(thisArg, args[0], args[1]);

      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }

    return func.apply(thisArg, args);
  }

  module.exports = apply;
},414,[],"node_modules\\lodash\\_apply.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseSetToString = _$$_REQUIRE(_dependencyMap[0], "./_baseSetToString"),
      shortOut = _$$_REQUIRE(_dependencyMap[1], "./_shortOut");

  var setToString = shortOut(baseSetToString);
  module.exports = setToString;
},415,[416,418],"node_modules\\lodash\\_setToString.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var constant = _$$_REQUIRE(_dependencyMap[0], "./constant"),
      defineProperty = _$$_REQUIRE(_dependencyMap[1], "./_defineProperty"),
      identity = _$$_REQUIRE(_dependencyMap[2], "./identity");

  var baseSetToString = !defineProperty ? identity : function (func, string) {
    return defineProperty(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant(string),
      'writable': true
    });
  };
  module.exports = baseSetToString;
},416,[417,409,396],"node_modules\\lodash\\_baseSetToString.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function constant(value) {
    return function () {
      return value;
    };
  }

  module.exports = constant;
},417,[],"node_modules\\lodash\\constant.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var HOT_COUNT = 800,
      HOT_SPAN = 16;
  var nativeNow = Date.now;

  function shortOut(func) {
    var count = 0,
        lastCalled = 0;
    return function () {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;

      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }

      return func.apply(undefined, arguments);
    };
  }

  module.exports = shortOut;
},418,[],"node_modules\\lodash\\_shortOut.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var eq = _$$_REQUIRE(_dependencyMap[0], "./eq"),
      isArrayLike = _$$_REQUIRE(_dependencyMap[1], "./isArrayLike"),
      isIndex = _$$_REQUIRE(_dependencyMap[2], "./_isIndex"),
      isObject = _$$_REQUIRE(_dependencyMap[3], "./isObject");

  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }

    var type = typeof index;

    if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
      return eq(object[index], value);
    }

    return false;
  }

  module.exports = isIterateeCall;
},419,[294,371,361,313],"node_modules\\lodash\\_isIterateeCall.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseDifference = _$$_REQUIRE(_dependencyMap[0], "./_baseDifference"),
      baseFlatten = _$$_REQUIRE(_dependencyMap[1], "./_baseFlatten"),
      baseRest = _$$_REQUIRE(_dependencyMap[2], "./_baseRest"),
      isArrayLikeObject = _$$_REQUIRE(_dependencyMap[3], "./isArrayLikeObject");

  var difference = baseRest(function (array, values) {
    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
  });
  module.exports = difference;
},420,[421,427,412,429],"node_modules\\lodash\\difference.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var SetCache = _$$_REQUIRE(_dependencyMap[0], "./_SetCache"),
      arrayIncludes = _$$_REQUIRE(_dependencyMap[1], "./_arrayIncludes"),
      arrayIncludesWith = _$$_REQUIRE(_dependencyMap[2], "./_arrayIncludesWith"),
      arrayMap = _$$_REQUIRE(_dependencyMap[3], "./_arrayMap"),
      baseUnary = _$$_REQUIRE(_dependencyMap[4], "./_baseUnary"),
      cacheHas = _$$_REQUIRE(_dependencyMap[5], "./_cacheHas");

  var LARGE_ARRAY_SIZE = 200;

  function baseDifference(array, values, iteratee, comparator) {
    var index = -1,
        includes = arrayIncludes,
        isCommon = true,
        length = array.length,
        result = [],
        valuesLength = values.length;

    if (!length) {
      return result;
    }

    if (iteratee) {
      values = arrayMap(values, baseUnary(iteratee));
    }

    if (comparator) {
      includes = arrayIncludesWith;
      isCommon = false;
    } else if (values.length >= LARGE_ARRAY_SIZE) {
      includes = cacheHas;
      isCommon = false;
      values = new SetCache(values);
    }

    outer: while (++index < length) {
      var value = array[index],
          computed = iteratee == null ? value : iteratee(value);
      value = comparator || value !== 0 ? value : 0;

      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;

        while (valuesIndex--) {
          if (values[valuesIndex] === computed) {
            continue outer;
          }
        }

        result.push(value);
      } else if (!includes(values, computed, comparator)) {
        result.push(value);
      }
    }

    return result;
  }

  module.exports = baseDifference;
},421,[336,422,426,391,365,340],"node_modules\\lodash\\_baseDifference.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseIndexOf = _$$_REQUIRE(_dependencyMap[0], "./_baseIndexOf");

  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  module.exports = arrayIncludes;
},422,[423],"node_modules\\lodash\\_arrayIncludes.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseFindIndex = _$$_REQUIRE(_dependencyMap[0], "./_baseFindIndex"),
      baseIsNaN = _$$_REQUIRE(_dependencyMap[1], "./_baseIsNaN"),
      strictIndexOf = _$$_REQUIRE(_dependencyMap[2], "./_strictIndexOf");

  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  module.exports = baseIndexOf;
},423,[401,424,425],"node_modules\\lodash\\_baseIndexOf.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function baseIsNaN(value) {
    return value !== value;
  }

  module.exports = baseIsNaN;
},424,[],"node_modules\\lodash\\_baseIsNaN.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }

    return -1;
  }

  module.exports = strictIndexOf;
},425,[],"node_modules\\lodash\\_strictIndexOf.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }

    return false;
  }

  module.exports = arrayIncludesWith;
},426,[],"node_modules\\lodash\\_arrayIncludesWith.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var arrayPush = _$$_REQUIRE(_dependencyMap[0], "./_arrayPush"),
      isFlattenable = _$$_REQUIRE(_dependencyMap[1], "./_isFlattenable");

  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];

      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }

    return result;
  }

  module.exports = baseFlatten;
},427,[348,428],"node_modules\\lodash\\_baseFlatten.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Symbol = _$$_REQUIRE(_dependencyMap[0], "./_Symbol"),
      isArguments = _$$_REQUIRE(_dependencyMap[1], "./isArguments"),
      isArray = _$$_REQUIRE(_dependencyMap[2], "./isArray");

  var spreadableSymbol = Symbol ? typeof Symbol === "function" ? Symbol.isConcatSpreadable : "@@isConcatSpreadable" : undefined;

  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }

  module.exports = isFlattenable;
},428,[308,356,349],"node_modules\\lodash\\_isFlattenable.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var isArrayLike = _$$_REQUIRE(_dependencyMap[0], "./isArrayLike"),
      isObjectLike = _$$_REQUIRE(_dependencyMap[1], "./isObjectLike");

  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }

  module.exports = isArrayLikeObject;
},429,[371,358],"node_modules\\lodash\\isArrayLikeObject.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = bindAutoBindMethods;

  function bindAutoBindMethod(component, method) {
    var boundMethod = method.bind(component);
    boundMethod.__reactBoundContext = component;
    boundMethod.__reactBoundMethod = method;
    boundMethod.__reactBoundArguments = null;
    var componentName = component.constructor.displayName,
        _bind = boundMethod.bind;

    boundMethod.bind = function (newThis) {
      var args = Array.prototype.slice.call(arguments, 1);

      if (newThis !== component && newThis !== null) {
        console.warn('bind(): React component methods may only be bound to the ' + 'component instance. See ' + componentName);
      } else if (!args.length) {
        console.warn('bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See ' + componentName);
        return boundMethod;
      }

      var reboundMethod = _bind.apply(boundMethod, arguments);

      reboundMethod.__reactBoundContext = component;
      reboundMethod.__reactBoundMethod = method;
      reboundMethod.__reactBoundArguments = args;
      return reboundMethod;
    };

    return boundMethod;
  }

  function bindAutoBindMethodsFromMap(component) {
    for (var autoBindKey in component.__reactAutoBindMap) {
      if (!component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
        return;
      }

      if (component.hasOwnProperty(autoBindKey) && component[autoBindKey].__reactBoundContext === component) {
        continue;
      }

      var method = component.__reactAutoBindMap[autoBindKey];
      component[autoBindKey] = bindAutoBindMethod(component, method);
    }
  }

  function bindAutoBindMethods(component) {
    if (component.__reactAutoBindPairs) {
      bindAutoBindMethodsFromArray(component);
    } else if (component.__reactAutoBindMap) {
      bindAutoBindMethodsFromMap(component);
    }
  }

  function bindAutoBindMethodsFromArray(component) {
    var pairs = component.__reactAutoBindPairs;

    if (!pairs) {
      return;
    }

    for (var i = 0; i < pairs.length; i += 2) {
      var autoBindKey = pairs[i];

      if (component.hasOwnProperty(autoBindKey) && component[autoBindKey].__reactBoundContext === component) {
        continue;
      }

      var method = pairs[i + 1];
      component[autoBindKey] = bindAutoBindMethod(component, method);
    }
  }
},430,[],"node_modules\\react-proxy\\modules\\bindAutoBindMethods.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = deleteUnknownAutoBindMethods;

  function shouldDeleteClassicInstanceMethod(component, name) {
    if (component.__reactAutoBindMap && component.__reactAutoBindMap.hasOwnProperty(name)) {
      return false;
    }

    if (component.__reactAutoBindPairs && component.__reactAutoBindPairs.indexOf(name) >= 0) {
      return false;
    }

    if (component[name].__reactBoundArguments !== null) {
      return false;
    }

    return true;
  }

  function shouldDeleteModernInstanceMethod(component, name) {
    var prototype = component.constructor.prototype;
    var prototypeDescriptor = Object.getOwnPropertyDescriptor(prototype, name);

    if (!prototypeDescriptor || !prototypeDescriptor.get) {
      return false;
    }

    if (prototypeDescriptor.get().length !== component[name].length) {
      return false;
    }

    return true;
  }

  function shouldDeleteInstanceMethod(component, name) {
    var descriptor = Object.getOwnPropertyDescriptor(component, name);

    if (typeof descriptor.value !== 'function') {
      return;
    }

    if (component.__reactAutoBindMap || component.__reactAutoBindPairs) {
      return shouldDeleteClassicInstanceMethod(component, name);
    } else {
      return shouldDeleteModernInstanceMethod(component, name);
    }
  }

  function deleteUnknownAutoBindMethods(component) {
    var names = Object.getOwnPropertyNames(component);
    names.forEach(function (name) {
      if (shouldDeleteInstanceMethod(component, name)) {
        delete component[name];
      }
    });
  }
},431,[],"node_modules\\react-proxy\\modules\\deleteUnknownAutoBindMethods.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  exports.__esModule = true;
  exports['default'] = getForceUpdate;

  function traverseRenderedChildren(internalInstance, callback, argument) {
    callback(internalInstance, argument);

    if (internalInstance._renderedComponent) {
      traverseRenderedChildren(internalInstance._renderedComponent, callback, argument);
    } else {
      for (var key in internalInstance._renderedChildren) {
        if (internalInstance._renderedChildren.hasOwnProperty(key)) {
          traverseRenderedChildren(internalInstance._renderedChildren[key], callback, argument);
        }
      }
    }
  }

  function setPendingForceUpdate(internalInstance) {
    if (internalInstance._pendingForceUpdate === false) {
      internalInstance._pendingForceUpdate = true;
    }
  }

  function forceUpdateIfPending(internalInstance, React) {
    if (internalInstance._pendingForceUpdate === true) {
      var publicInstance = internalInstance._instance;
      React.Component.prototype.forceUpdate.call(publicInstance);
    }
  }

  function deepForceUpdateStack(instance, React) {
    var internalInstance = instance._reactInternalInstance;
    traverseRenderedChildren(internalInstance, setPendingForceUpdate);
    traverseRenderedChildren(internalInstance, forceUpdateIfPending, React);
  }

  function deepForceUpdate(instance, React) {
    var root = instance._reactInternalFiber || instance._reactInternalInstance;

    if (typeof root.tag !== 'number') {
      return deepForceUpdateStack(instance, React);
    }

    var node = root;

    while (true) {
      if (node.stateNode !== null && typeof node.type === 'function') {
        var publicInstance = node.stateNode;
        var updater = publicInstance.updater;

        if (typeof publicInstance.forceUpdate === 'function') {
          publicInstance.forceUpdate();
        } else if (updater && typeof updater.enqueueForceUpdate === 'function') {
          updater.enqueueForceUpdate(publicInstance);
        }
      }

      if (node.child) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }

      if (node === root) {
        return undefined;
      }

      while (!node.sibling) {
        if (!node['return'] || node['return'] === root) {
          return undefined;
        }

        node = node['return'];
      }

      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function getForceUpdate(React) {
    return function (instance) {
      deepForceUpdate(instance, React);
    };
  }

  module.exports = exports['default'];
},432,[],"node_modules\\react-deep-force-update\\lib\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var win;

  if (typeof window !== "undefined") {
    win = window;
  } else if (typeof global !== "undefined") {
    win = global;
  } else if (typeof self !== "undefined") {
    win = self;
  } else {
    win = {};
  }

  module.exports = win;
},433,[],"node_modules\\global\\window.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var colors = {
    maroon: '#800000',
    red: '#ff0000',
    orange: '#ffA500',
    yellow: '#ffff00',
    olive: '#808000',
    purple: '#800080',
    fuchsia: "#ff00ff",
    white: '#ffffff',
    lime: '#00ff00',
    green: '#008000',
    navy: '#000080',
    blue: '#0000ff',
    aqua: '#00ffff',
    teal: '#008080',
    black: '#000000',
    silver: '#c0c0c0',
    gray: '#808080'
  };

  var map = function map(array, fn) {
    var results = [];

    for (var i = 0, l = array.length; i < l; i++) {
      results[i] = fn(array[i], i);
    }

    return results;
  };

  var Color = function Color(color, type) {
    if (color.isColor) {
      this.red = color.red;
      this.green = color.green;
      this.blue = color.blue;
      this.alpha = color.alpha;
    } else {
      var namedColor = colors[color];

      if (namedColor) {
        color = namedColor;
        type = 'hex';
      }

      switch (typeof color) {
        case 'string':
          if (!type) type = (type = color.match(/^rgb|^hsb|^hsl/)) ? type[0] : 'hex';
          break;

        case 'object':
          type = type || 'rgb';
          color = color.toString();
          break;

        case 'number':
          type = 'hex';
          color = color.toString(16);
          break;
      }

      color = Color['parse' + type.toUpperCase()](color);
      this.red = color[0];
      this.green = color[1];
      this.blue = color[2];
      this.alpha = color[3];
    }

    this.isColor = true;
  };

  var limit = function limit(number, min, max) {
    return Math.min(max, Math.max(min, number));
  };

  var listMatch = /([-.\d]+\%?)\s*,\s*([-.\d]+\%?)\s*,\s*([-.\d]+\%?)\s*,?\s*([-.\d]*\%?)/;
  var hexMatch = /^#?([a-f0-9]{1,2})([a-f0-9]{1,2})([a-f0-9]{1,2})([a-f0-9]{0,2})$/i;

  Color.parseRGB = function (color) {
    return map(color.match(listMatch).slice(1), function (bit, i) {
      if (bit) bit = parseFloat(bit) * (bit[bit.length - 1] == '%' ? 2.55 : 1);
      return i < 3 ? Math.round((bit %= 256) < 0 ? bit + 256 : bit) : limit(bit === '' ? 1 : Number(bit), 0, 1);
    });
  };

  Color.parseHEX = function (color) {
    if (color.length == 1) color = color + color + color;
    return map(color.match(hexMatch).slice(1), function (bit, i) {
      if (i == 3) return bit ? parseInt(bit, 16) / 255 : 1;
      return parseInt(bit.length == 1 ? bit + bit : bit, 16);
    });
  };

  Color.parseHSB = function (color) {
    var hsb = map(color.match(listMatch).slice(1), function (bit, i) {
      if (bit) bit = parseFloat(bit);
      if (i === 0) return Math.round((bit %= 360) < 0 ? bit + 360 : bit);else if (i < 3) return limit(Math.round(bit), 0, 100);else return limit(bit === '' ? 1 : Number(bit), 0, 1);
    });
    var a = hsb[3];
    var br = Math.round(hsb[2] / 100 * 255);
    if (hsb[1] == 0) return [br, br, br, a];
    var hue = hsb[0];
    var f = hue % 60;
    var p = Math.round(hsb[2] * (100 - hsb[1]) / 10000 * 255);
    var q = Math.round(hsb[2] * (6000 - hsb[1] * f) / 600000 * 255);
    var t = Math.round(hsb[2] * (6000 - hsb[1] * (60 - f)) / 600000 * 255);

    switch (Math.floor(hue / 60)) {
      case 0:
        return [br, t, p, a];

      case 1:
        return [q, br, p, a];

      case 2:
        return [p, br, t, a];

      case 3:
        return [p, q, br, a];

      case 4:
        return [t, p, br, a];

      default:
        return [br, p, q, a];
    }
  };

  Color.parseHSL = function (color) {
    var hsb = map(color.match(listMatch).slice(1), function (bit, i) {
      if (bit) bit = parseFloat(bit);
      if (i === 0) return Math.round((bit %= 360) < 0 ? bit + 360 : bit);else if (i < 3) return limit(Math.round(bit), 0, 100);else return limit(bit === '' ? 1 : Number(bit), 0, 1);
    });
    var h = hsb[0] / 60;
    var s = hsb[1] / 100;
    var l = hsb[2] / 100;
    var a = hsb[3];
    var c = (1 - Math.abs(2 * l - 1)) * s;
    var x = c * (1 - Math.abs(h % 2 - 1));
    var m = l - c / 2;
    var p = Math.round((c + m) * 255);
    var q = Math.round((x + m) * 255);
    var t = Math.round(m * 255);

    switch (Math.floor(h)) {
      case 0:
        return [p, q, t, a];

      case 1:
        return [q, p, t, a];

      case 2:
        return [t, p, q, a];

      case 3:
        return [t, q, p, a];

      case 4:
        return [q, t, p, a];

      default:
        return [p, t, q, a];
    }
  };

  var toString = function toString(type, array) {
    if (array[3] != 1) type += 'a';else array.pop();
    return type + '(' + array.join(', ') + ')';
  };

  Color.prototype = {
    toHSB: function toHSB(array) {
      var red = this.red,
          green = this.green,
          blue = this.blue,
          alpha = this.alpha;
      var max = Math.max(red, green, blue),
          min = Math.min(red, green, blue),
          delta = max - min;
      var hue = 0,
          saturation = delta != 0 ? delta / max : 0,
          brightness = max / 255;

      if (saturation) {
        var rr = (max - red) / delta,
            gr = (max - green) / delta,
            br = (max - blue) / delta;
        hue = red == max ? br - gr : green == max ? 2 + rr - br : 4 + gr - rr;
        if ((hue /= 6) < 0) hue++;
      }

      var hsb = [Math.round(hue * 360), Math.round(saturation * 100), Math.round(brightness * 100), alpha];
      return array ? hsb : toString('hsb', hsb);
    },
    toHSL: function toHSL(array) {
      var red = this.red,
          green = this.green,
          blue = this.blue,
          alpha = this.alpha;
      var max = Math.max(red, green, blue),
          min = Math.min(red, green, blue),
          delta = max - min;
      var hue = 0,
          saturation = delta != 0 ? delta / (255 - Math.abs(max + min - 255)) : 0,
          lightness = (max + min) / 512;

      if (saturation) {
        var rr = (max - red) / delta,
            gr = (max - green) / delta,
            br = (max - blue) / delta;
        hue = red == max ? br - gr : green == max ? 2 + rr - br : 4 + gr - rr;
        if ((hue /= 6) < 0) hue++;
      }

      var hsl = [Math.round(hue * 360), Math.round(saturation * 100), Math.round(lightness * 100), alpha];
      return array ? hsl : toString('hsl', hsl);
    },
    toHEX: function toHEX(array) {
      var a = this.alpha;
      var alpha = (a = Math.round(a * 255).toString(16)).length == 1 ? a + a : a;
      var hex = map([this.red, this.green, this.blue], function (bit) {
        bit = bit.toString(16);
        return bit.length == 1 ? '0' + bit : bit;
      });
      return array ? hex.concat(alpha) : '#' + hex.join('') + (alpha == 'ff' ? '' : alpha);
    },
    toRGB: function toRGB(array) {
      var rgb = [this.red, this.green, this.blue, this.alpha];
      return array ? rgb : toString('rgb', rgb);
    }
  };
  Color.prototype.toString = Color.prototype.toRGB;

  Color.hex = function (hex) {
    return new Color(hex, 'hex');
  };

  if (this.hex == null) this.hex = Color.hex;

  Color.hsb = function (h, s, b, a) {
    return new Color([h || 0, s || 0, b || 0, a == null ? 1 : a], 'hsb');
  };

  if (this.hsb == null) this.hsb = Color.hsb;

  Color.hsl = function (h, s, l, a) {
    return new Color([h || 0, s || 0, l || 0, a == null ? 1 : a], 'hsl');
  };

  if (this.hsl == null) this.hsl = Color.hsl;

  Color.rgb = function (r, g, b, a) {
    return new Color([r || 0, g || 0, b || 0, a == null ? 1 : a], 'rgb');
  };

  if (this.rgb == null) this.rgb = Color.rgb;

  Color.detach = function (color) {
    color = new Color(color);
    return [Color.rgb(color.red, color.green, color.blue).toString(), color.alpha];
  };

  module.exports = Color;
},434,[],"node_modules\\art\\core\\color.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Class = _$$_REQUIRE(_dependencyMap[0], "art/core/class.js");

  var Path = _$$_REQUIRE(_dependencyMap[1], "art/core/path.js");

  var MOVE_TO = 0;
  var CLOSE = 1;
  var LINE_TO = 2;
  var CURVE_TO = 3;
  var ARC = 4;
  var SerializablePath = Class(Path, {
    initialize: function initialize(path) {
      this.reset();

      if (path instanceof SerializablePath) {
        this.path = path.path.slice(0);
      } else if (path) {
        if (path.applyToPath) {
          path.applyToPath(this);
        } else {
          this.push(path);
        }
      }
    },
    onReset: function onReset() {
      this.path = [];
    },
    onMove: function onMove(sx, sy, x, y) {
      this.path.push(MOVE_TO, x, y);
    },
    onLine: function onLine(sx, sy, x, y) {
      this.path.push(LINE_TO, x, y);
    },
    onBezierCurve: function onBezierCurve(sx, sy, p1x, p1y, p2x, p2y, x, y) {
      this.path.push(CURVE_TO, p1x, p1y, p2x, p2y, x, y);
    },
    _arcToBezier: Path.prototype.onArc,
    onArc: function onArc(sx, sy, ex, ey, cx, cy, rx, ry, sa, ea, ccw, rotation) {
      if (rx !== ry || rotation) {
        return this._arcToBezier(sx, sy, ex, ey, cx, cy, rx, ry, sa, ea, ccw, rotation);
      }

      this.path.push(ARC, cx, cy, rx, sa, ea, ccw ? 0 : 1);
    },
    onClose: function onClose() {
      this.path.push(CLOSE);
    },
    toJSON: function toJSON() {
      return this.path;
    }
  });
  module.exports = SerializablePath;
},435,[436,437],"node_modules\\react-native\\Libraries\\ART\\ARTSerializablePath.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = function (mixins) {
    var proto = {};

    for (var i = 0, l = arguments.length; i < l; i++) {
      var mixin = arguments[i];
      if (typeof mixin == 'function') mixin = mixin.prototype;

      for (var key in mixin) {
        proto[key] = mixin[key];
      }
    }

    if (!proto.initialize) proto.initialize = function () {};

    proto.constructor = function (a, b, c, d, e, f, g, h) {
      return new proto.initialize(a, b, c, d, e, f, g, h);
    };

    proto.constructor.prototype = proto.initialize.prototype = proto;
    return proto.constructor;
  };
},436,[],"node_modules\\art\\core\\class.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Class = _$$_REQUIRE(_dependencyMap[0], "./class");

  module.exports = Class({
    initialize: function initialize(path) {
      this.reset().push(path);
    },
    push: function push() {
      var p = Array.prototype.join.call(arguments, ' ').match(/[a-df-z]|[\-+]?(?:[\d\.]e[\-+]?|[^\s\-+,a-z])+/ig);
      if (!p) return this;
      var last,
          cmd = p[0],
          i = 1;

      while (cmd) {
        switch (cmd) {
          case 'm':
            this.move(p[i++], p[i++]);
            break;

          case 'l':
            this.line(p[i++], p[i++]);
            break;

          case 'c':
            this.curve(p[i++], p[i++], p[i++], p[i++], p[i++], p[i++]);
            break;

          case 's':
            this.curve(p[i++], p[i++], null, null, p[i++], p[i++]);
            break;

          case 'q':
            this.curve(p[i++], p[i++], p[i++], p[i++]);
            break;

          case 't':
            this.curve(p[i++], p[i++]);
            break;

          case 'a':
            this.arc(p[i + 5], p[i + 6], p[i], p[i + 1], p[i + 3], !+p[i + 4], p[i + 2]);
            i += 7;
            break;

          case 'h':
            this.line(p[i++], 0);
            break;

          case 'v':
            this.line(0, p[i++]);
            break;

          case 'M':
            this.moveTo(p[i++], p[i++]);
            break;

          case 'L':
            this.lineTo(p[i++], p[i++]);
            break;

          case 'C':
            this.curveTo(p[i++], p[i++], p[i++], p[i++], p[i++], p[i++]);
            break;

          case 'S':
            this.curveTo(p[i++], p[i++], null, null, p[i++], p[i++]);
            break;

          case 'Q':
            this.curveTo(p[i++], p[i++], p[i++], p[i++]);
            break;

          case 'T':
            this.curveTo(p[i++], p[i++]);
            break;

          case 'A':
            this.arcTo(p[i + 5], p[i + 6], p[i], p[i + 1], p[i + 3], !+p[i + 4], p[i + 2]);
            i += 7;
            break;

          case 'H':
            this.lineTo(p[i++], this.penY);
            break;

          case 'V':
            this.lineTo(this.penX, p[i++]);
            break;

          case 'Z':
          case 'z':
            this.close();
            break;

          default:
            cmd = last;
            i--;
            continue;
        }

        last = cmd;
        if (last == 'm') last = 'l';else if (last == 'M') last = 'L';
        cmd = p[i++];
      }

      return this;
    },
    reset: function reset() {
      this.penX = this.penY = 0;
      this.penDownX = this.penDownY = null;
      this._pivotX = this._pivotY = 0;
      this.onReset();
      return this;
    },
    move: function move(x, y) {
      this.onMove(this.penX, this.penY, this._pivotX = this.penX += +x, this._pivotY = this.penY += +y);
      return this;
    },
    moveTo: function moveTo(x, y) {
      this.onMove(this.penX, this.penY, this._pivotX = this.penX = +x, this._pivotY = this.penY = +y);
      return this;
    },
    line: function line(x, y) {
      return this.lineTo(this.penX + +x, this.penY + +y);
    },
    lineTo: function lineTo(x, y) {
      if (this.penDownX == null) {
        this.penDownX = this.penX;
        this.penDownY = this.penY;
      }

      this.onLine(this.penX, this.penY, this._pivotX = this.penX = +x, this._pivotY = this.penY = +y);
      return this;
    },
    curve: function curve(c1x, c1y, c2x, c2y, ex, ey) {
      var x = this.penX,
          y = this.penY;
      return this.curveTo(x + +c1x, y + +c1y, c2x == null ? null : x + +c2x, c2y == null ? null : y + +c2y, ex == null ? null : x + +ex, ey == null ? null : y + +ey);
    },
    curveTo: function curveTo(c1x, c1y, c2x, c2y, ex, ey) {
      var x = this.penX,
          y = this.penY;

      if (c2x == null) {
        c2x = +c1x;
        c2y = +c1y;
        c1x = x * 2 - (this._pivotX || 0);
        c1y = y * 2 - (this._pivotY || 0);
      }

      if (ex == null) {
        this._pivotX = +c1x;
        this._pivotY = +c1y;
        ex = +c2x;
        ey = +c2y;
        c2x = (ex + +c1x * 2) / 3;
        c2y = (ey + +c1y * 2) / 3;
        c1x = (x + +c1x * 2) / 3;
        c1y = (y + +c1y * 2) / 3;
      } else {
        this._pivotX = +c2x;
        this._pivotY = +c2y;
      }

      if (this.penDownX == null) {
        this.penDownX = x;
        this.penDownY = y;
      }

      this.onBezierCurve(x, y, +c1x, +c1y, +c2x, +c2y, this.penX = +ex, this.penY = +ey);
      return this;
    },
    arc: function arc(x, y, rx, ry, outer, counterClockwise, rotation) {
      return this.arcTo(this.penX + +x, this.penY + +y, rx, ry, outer, counterClockwise, rotation);
    },
    arcTo: function arcTo(x, y, rx, ry, outer, counterClockwise, rotation) {
      ry = Math.abs(+ry || +rx || +y - this.penY);
      rx = Math.abs(+rx || +x - this.penX);
      if (!rx || !ry || x == this.penX && y == this.penY) return this.lineTo(x, y);
      var tX = this.penX,
          tY = this.penY,
          clockwise = !+counterClockwise,
          large = !!+outer;
      var rad = rotation ? rotation * Math.PI / 180 : 0,
          cos = Math.cos(rad),
          sin = Math.sin(rad);
      x -= tX;
      y -= tY;
      var cx = cos * x / 2 + sin * y / 2,
          cy = -sin * x / 2 + cos * y / 2,
          rxry = rx * rx * ry * ry,
          rycx = ry * ry * cx * cx,
          rxcy = rx * rx * cy * cy,
          a = rxry - rxcy - rycx;

      if (a < 0) {
        a = Math.sqrt(1 - a / rxry);
        rx *= a;
        ry *= a;
        cx = x / 2;
        cy = y / 2;
      } else {
        a = Math.sqrt(a / (rxcy + rycx));
        if (large == clockwise) a = -a;
        var cxd = -a * cy * rx / ry,
            cyd = a * cx * ry / rx;
        cx = cos * cxd - sin * cyd + x / 2;
        cy = sin * cxd + cos * cyd + y / 2;
      }

      var xx = cos / rx,
          yx = sin / rx,
          xy = -sin / ry,
          yy = cos / ry;
      var sa = Math.atan2(xy * -cx + yy * -cy, xx * -cx + yx * -cy),
          ea = Math.atan2(xy * (x - cx) + yy * (y - cy), xx * (x - cx) + yx * (y - cy));
      cx += tX;
      cy += tY;
      x += tX;
      y += tY;

      if (this.penDownX == null) {
        this.penDownX = this.penX;
        this.penDownY = this.penY;
      }

      this.onArc(tX, tY, this._pivotX = this.penX = x, this._pivotY = this.penY = y, cx, cy, rx, ry, sa, ea, !clockwise, rotation);
      return this;
    },
    counterArc: function counterArc(x, y, rx, ry, outer) {
      return this.arc(x, y, rx, ry, outer, true);
    },
    counterArcTo: function counterArcTo(x, y, rx, ry, outer) {
      return this.arcTo(x, y, rx, ry, outer, true);
    },
    close: function close() {
      if (this.penDownX != null) {
        this.onClose(this.penX, this.penY, this.penX = this.penDownX, this.penY = this.penDownY);
        this.penDownX = null;
      }

      return this;
    },
    onReset: function onReset() {},
    onMove: function onMove(sx, sy, ex, ey) {},
    onLine: function onLine(sx, sy, ex, ey) {
      this.onBezierCurve(sx, sy, sx, sy, ex, ey, ex, ey);
    },
    onBezierCurve: function onBezierCurve(sx, sy, c1x, c1y, c2x, c2y, ex, ey) {
      var gx = ex - sx,
          gy = ey - sy,
          g = gx * gx + gy * gy,
          v1,
          v2,
          cx,
          cy,
          u;
      cx = c1x - sx;
      cy = c1y - sy;
      u = cx * gx + cy * gy;

      if (u > g) {
        cx -= gx;
        cy -= gy;
      } else if (u > 0 && g != 0) {
        cx -= u / g * gx;
        cy -= u / g * gy;
      }

      v1 = cx * cx + cy * cy;
      cx = c2x - sx;
      cy = c2y - sy;
      u = cx * gx + cy * gy;

      if (u > g) {
        cx -= gx;
        cy -= gy;
      } else if (u > 0 && g != 0) {
        cx -= u / g * gx;
        cy -= u / g * gy;
      }

      v2 = cx * cx + cy * cy;

      if (v1 < 0.01 && v2 < 0.01) {
        this.onLine(sx, sy, ex, ey);
        return;
      }

      if (isNaN(v1) || isNaN(v2)) {
        throw new Error('Bad input');
      }

      var s1x = (c1x + c2x) * 0.5,
          s1y = (c1y + c2y) * 0.5,
          l1x = (c1x + sx) * 0.5,
          l1y = (c1y + sy) * 0.5,
          l2x = (l1x + s1x) * 0.5,
          l2y = (l1y + s1y) * 0.5,
          r2x = (ex + c2x) * 0.5,
          r2y = (ey + c2y) * 0.5,
          r1x = (r2x + s1x) * 0.5,
          r1y = (r2y + s1y) * 0.5,
          l2r1x = (l2x + r1x) * 0.5,
          l2r1y = (l2y + r1y) * 0.5;
      this.onBezierCurve(sx, sy, l1x, l1y, l2x, l2y, l2r1x, l2r1y);
      this.onBezierCurve(l2r1x, l2r1y, r1x, r1y, r2x, r2y, ex, ey);
    },
    onArc: function onArc(sx, sy, ex, ey, cx, cy, rx, ry, sa, ea, ccw, rotation) {
      var rad = rotation ? rotation * Math.PI / 180 : 0,
          cos = Math.cos(rad),
          sin = Math.sin(rad),
          xx = cos * rx,
          yx = -sin * ry,
          xy = sin * rx,
          yy = cos * ry;
      var arc = ea - sa;
      if (arc < 0 && !ccw) arc += Math.PI * 2;else if (arc > 0 && ccw) arc -= Math.PI * 2;
      var n = Math.ceil(Math.abs(arc / (Math.PI / 2))),
          step = arc / n,
          k = 4 / 3 * Math.tan(step / 4);
      var x = Math.cos(sa),
          y = Math.sin(sa);

      for (var i = 0; i < n; i++) {
        var cp1x = x - k * y,
            cp1y = y + k * x;
        sa += step;
        x = Math.cos(sa);
        y = Math.sin(sa);
        var cp2x = x + k * y,
            cp2y = y - k * x;
        this.onBezierCurve(sx, sy, cx + xx * cp1x + yx * cp1y, cy + xy * cp1x + yy * cp1y, cx + xx * cp2x + yx * cp2y, cy + xy * cp2x + yy * cp2y, sx = cx + xx * x + yx * y, sy = cy + xy * x + yy * y);
      }
    },
    onClose: function onClose(sx, sy, ex, ey) {
      this.onLine(sx, sy, ex, ey);
    }
  });
},437,[436],"node_modules\\art\\core\\path.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Class = _$$_REQUIRE(_dependencyMap[0], "./class");

  function Transform(xx, yx, xy, yy, x, y) {
    if (xx && typeof xx == 'object') {
      yx = xx.yx;
      yy = xx.yy;
      y = xx.y;
      xy = xx.xy;
      x = xx.x;
      xx = xx.xx;
    }

    this.xx = xx == null ? 1 : xx;
    this.yx = yx || 0;
    this.xy = xy || 0;
    this.yy = yy == null ? 1 : yy;
    this.x = (x == null ? this.x : x) || 0;
    this.y = (y == null ? this.y : y) || 0;

    this._transform();

    return this;
  }

  ;
  module.exports = Class({
    initialize: Transform,
    _transform: function _transform() {},
    xx: 1,
    yx: 0,
    x: 0,
    xy: 0,
    yy: 1,
    y: 0,
    transform: function transform(xx, yx, xy, yy, x, y) {
      var m = this;

      if (xx && typeof xx == 'object') {
        yx = xx.yx;
        yy = xx.yy;
        y = xx.y;
        xy = xx.xy;
        x = xx.x;
        xx = xx.xx;
      }

      if (!x) x = 0;
      if (!y) y = 0;
      return this.transformTo(m.xx * xx + m.xy * yx, m.yx * xx + m.yy * yx, m.xx * xy + m.xy * yy, m.yx * xy + m.yy * yy, m.xx * x + m.xy * y + m.x, m.yx * x + m.yy * y + m.y);
    },
    transformTo: Transform,
    translate: function translate(x, y) {
      return this.transform(1, 0, 0, 1, x, y);
    },
    move: function move(x, y) {
      this.x += x || 0;
      this.y += y || 0;

      this._transform();

      return this;
    },
    scale: function scale(x, y) {
      if (y == null) y = x;
      return this.transform(x, 0, 0, y, 0, 0);
    },
    rotate: function rotate(deg, x, y) {
      if (x == null || y == null) {
        x = (this.left || 0) + (this.width || 0) / 2;
        y = (this.top || 0) + (this.height || 0) / 2;
      }

      var rad = deg * Math.PI / 180,
          sin = Math.sin(rad),
          cos = Math.cos(rad);
      this.transform(1, 0, 0, 1, x, y);
      var m = this;
      return this.transformTo(cos * m.xx - sin * m.yx, sin * m.xx + cos * m.yx, cos * m.xy - sin * m.yy, sin * m.xy + cos * m.yy, m.x, m.y).transform(1, 0, 0, 1, -x, -y);
    },
    moveTo: function moveTo(x, y) {
      var m = this;
      return this.transformTo(m.xx, m.yx, m.xy, m.yy, x, y);
    },
    rotateTo: function rotateTo(deg, x, y) {
      var m = this;
      var flip = m.yx / m.xx > m.yy / m.xy ? -1 : 1;
      if (m.xx < 0 ? m.xy >= 0 : m.xy < 0) flip = -flip;
      return this.rotate(deg - Math.atan2(flip * m.yx, flip * m.xx) * 180 / Math.PI, x, y);
    },
    scaleTo: function scaleTo(x, y) {
      var m = this;
      var h = Math.sqrt(m.xx * m.xx + m.yx * m.yx);
      m.xx /= h;
      m.yx /= h;
      h = Math.sqrt(m.yy * m.yy + m.xy * m.xy);
      m.yy /= h;
      m.xy /= h;
      return this.scale(x, y);
    },
    resizeTo: function resizeTo(width, height) {
      var w = this.width,
          h = this.height;
      if (!w || !h) return this;
      return this.scaleTo(width / w, height / h);
    },
    inversePoint: function inversePoint(x, y) {
      var a = this.xx,
          b = this.yx,
          c = this.xy,
          d = this.yy,
          e = this.x,
          f = this.y;
      var det = b * c - a * d;
      if (det == 0) return null;
      return {
        x: (d * (e - x) + c * (y - f)) / det,
        y: (a * (f - y) + b * (x - e)) / det
      };
    },
    point: function point(x, y) {
      var m = this;
      return {
        x: m.xx * x + m.xy * y + m.x,
        y: m.yx * x + m.yy * y + m.y
      };
    }
  });
},438,[436],"node_modules\\art\\core\\transform.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var ReactNativeStyleAttributes = _$$_REQUIRE(_dependencyMap[1], "ReactNativeStyleAttributes");

  var ReactNativeViewAttributes = {};
  ReactNativeViewAttributes.UIView = {
    pointerEvents: true,
    accessible: true,
    accessibilityActions: true,
    accessibilityLabel: true,
    accessibilityComponentType: true,
    accessibilityLiveRegion: true,
    accessibilityRole: true,
    accessibilityStates: true,
    accessibilityTraits: true,
    accessibilityHint: true,
    importantForAccessibility: true,
    nativeID: true,
    testID: true,
    renderToHardwareTextureAndroid: true,
    shouldRasterizeIOS: true,
    onLayout: true,
    onAccessibilityAction: true,
    onAccessibilityTap: true,
    onMagicTap: true,
    collapsable: true,
    needsOffscreenAlphaCompositing: true,
    style: ReactNativeStyleAttributes
  };
  ReactNativeViewAttributes.RCTView = _objectSpread({}, ReactNativeViewAttributes.UIView, {
    removeClippedSubviews: true
  });
  module.exports = ReactNativeViewAttributes;
},439,[148,154],"node_modules\\react-native\\Libraries\\Components\\View\\ReactNativeViewAttributes.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var mergeInto = _$$_REQUIRE(_dependencyMap[0], "mergeInto");

  var merge = function merge(one, two) {
    var result = {};
    mergeInto(result, one);
    mergeInto(result, two);
    return result;
  };

  module.exports = merge;
},440,[441],"node_modules\\react-native\\Libraries\\vendor\\core\\merge.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var mergeHelpers = _$$_REQUIRE(_dependencyMap[0], "mergeHelpers");

  var checkMergeObjectArg = mergeHelpers.checkMergeObjectArg;
  var checkMergeIntoObjectArg = mergeHelpers.checkMergeIntoObjectArg;

  function mergeInto(one, two) {
    checkMergeIntoObjectArg(one);

    if (two != null) {
      checkMergeObjectArg(two);

      for (var key in two) {
        if (!two.hasOwnProperty(key)) {
          continue;
        }

        one[key] = two[key];
      }
    }
  }

  module.exports = mergeInto;
},441,[442],"node_modules\\react-native\\Libraries\\vendor\\core\\mergeInto.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var invariant = _$$_REQUIRE(_dependencyMap[0], "fbjs/lib/invariant");

  var MAX_MERGE_DEPTH = 36;

  var isTerminal = function isTerminal(o) {
    return typeof o !== 'object' || o instanceof Date || o === null;
  };

  var mergeHelpers = {
    MAX_MERGE_DEPTH: MAX_MERGE_DEPTH,
    isTerminal: isTerminal,
    normalizeMergeArg: function normalizeMergeArg(arg) {
      return arg === undefined || arg === null ? {} : arg;
    },
    checkMergeArrayArgs: function checkMergeArrayArgs(one, two) {
      invariant(Array.isArray(one) && Array.isArray(two), 'Tried to merge arrays, instead got %s and %s.', one, two);
    },
    checkMergeObjectArgs: function checkMergeObjectArgs(one, two) {
      mergeHelpers.checkMergeObjectArg(one);
      mergeHelpers.checkMergeObjectArg(two);
    },
    checkMergeObjectArg: function checkMergeObjectArg(arg) {
      invariant(!isTerminal(arg) && !Array.isArray(arg), 'Tried to merge an object, instead got %s.', arg);
    },
    checkMergeIntoObjectArg: function checkMergeIntoObjectArg(arg) {
      invariant((!isTerminal(arg) || typeof arg === 'function') && !Array.isArray(arg), 'Tried to merge into an object, instead got %s.', arg);
    },
    checkMergeLevel: function checkMergeLevel(level) {
      invariant(level < MAX_MERGE_DEPTH, 'Maximum deep merge depth exceeded. You may be attempting to merge ' + 'circular structures in an unsupported way.');
    },
    checkArrayStrategy: function checkArrayStrategy(strategy) {
      invariant(strategy === undefined || strategy in mergeHelpers.ArrayStrategies, 'You must provide an array strategy to deep merge functions to ' + 'instruct the deep merge how to resolve merging two arrays.');
    },
    ArrayStrategies: {
      Clobber: 'Clobber',
      Concat: 'Concat',
      IndexByIndex: 'IndexByIndex'
    }
  };
  module.exports = mergeHelpers;
},442,[117],"node_modules\\react-native\\Libraries\\vendor\\core\\mergeHelpers.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\Button.js";
  var _components = {
    Button: {
      displayName: "Button"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\Button.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var ColorPropType = _$$_REQUIRE(_dependencyMap[9], "ColorPropType");

  var Platform = _$$_REQUIRE(_dependencyMap[10], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[11], "React");

  var PropTypes = _$$_REQUIRE(_dependencyMap[12], "prop-types");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[13], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[14], "Text");

  var TouchableNativeFeedback = _$$_REQUIRE(_dependencyMap[15], "TouchableNativeFeedback");

  var TouchableOpacity = _$$_REQUIRE(_dependencyMap[16], "TouchableOpacity");

  var View = _$$_REQUIRE(_dependencyMap[17], "View");

  var invariant = _$$_REQUIRE(_dependencyMap[18], "fbjs/lib/invariant");

  var Button = function (_React$Component) {
    _inherits(Button, _React$Component);

    function Button() {
      _classCallCheck(this, Button);

      return _possibleConstructorReturn(this, _getPrototypeOf(Button).apply(this, arguments));
    }

    _createClass(Button, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            accessibilityLabel = _this$props.accessibilityLabel,
            color = _this$props.color,
            onPress = _this$props.onPress,
            title = _this$props.title,
            hasTVPreferredFocus = _this$props.hasTVPreferredFocus,
            disabled = _this$props.disabled,
            testID = _this$props.testID;
        var buttonStyles = [styles.button];
        var textStyles = [styles.text];

        if (color) {
          if (Platform.OS === 'ios') {
            textStyles.push({
              color: color
            });
          } else {
            buttonStyles.push({
              backgroundColor: color
            });
          }
        }

        var accessibilityStates = [];

        if (disabled) {
          buttonStyles.push(styles.buttonDisabled);
          textStyles.push(styles.textDisabled);
          accessibilityStates.push('disabled');
        }

        invariant(typeof title === 'string', 'The title prop of a Button must be a string');
        var formattedTitle = Platform.OS === 'android' ? title.toUpperCase() : title;
        var Touchable = Platform.OS === 'android' ? TouchableNativeFeedback : TouchableOpacity;
        return React.createElement(Touchable, {
          accessibilityLabel: accessibilityLabel,
          accessibilityRole: "button",
          accessibilityStates: accessibilityStates,
          hasTVPreferredFocus: hasTVPreferredFocus,
          testID: testID,
          disabled: disabled,
          onPress: onPress,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 127
          }
        }, React.createElement(View, {
          style: buttonStyles,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 135
          }
        }, React.createElement(Text, {
          style: textStyles,
          disabled: disabled,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 136
          }
        }, formattedTitle)));
      }
    }]);

    return Button;
  }(React.Component);

  _defineProperty(Button, "propTypes", {
    title: PropTypes.string.isRequired,
    accessibilityLabel: PropTypes.string,
    color: ColorPropType,
    disabled: PropTypes.bool,
    hasTVPreferredFocus: PropTypes.bool,
    onPress: PropTypes.func.isRequired,
    testID: PropTypes.string
  });

  Button = _wrapComponent("Button")(Button);
  var styles = StyleSheet.create({
    button: Platform.select({
      ios: {},
      android: {
        elevation: 4,
        backgroundColor: '#2196F3',
        borderRadius: 2
      }
    }),
    text: Platform.select({
      ios: {
        color: '#007AFF',
        textAlign: 'center',
        padding: 8,
        fontSize: 18
      },
      android: {
        color: 'white',
        textAlign: 'center',
        padding: 8,
        fontWeight: '500'
      }
    }),
    buttonDisabled: Platform.select({
      ios: {},
      android: {
        elevation: 0,
        backgroundColor: '#dfdfdf'
      }
    }),
    textDisabled: Platform.select({
      ios: {
        color: '#cdcdcd'
      },
      android: {
        color: '#a1a1a1'
      }
    })
  });
  module.exports = Button;
},443,[23,24,25,26,29,30,32,109,280,156,146,149,161,150,444,456,467,175,117],"node_modules\\react-native\\Libraries\\Components\\Button.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/defineProperty");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/objectSpread");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Text\\Text.js";
  var _components = {
    TouchableText: {
      displayName: "TouchableText"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Text\\Text.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var React = _$$_REQUIRE(_dependencyMap[12], "React");

  var ReactNativeViewAttributes = _$$_REQUIRE(_dependencyMap[13], "ReactNativeViewAttributes");

  var TextAncestor = _$$_REQUIRE(_dependencyMap[14], "TextAncestor");

  var TextPropTypes = _$$_REQUIRE(_dependencyMap[15], "TextPropTypes");

  var Touchable = _$$_REQUIRE(_dependencyMap[16], "Touchable");

  var UIManager = _$$_REQUIRE(_dependencyMap[17], "UIManager");

  var createReactNativeComponentClass = _$$_REQUIRE(_dependencyMap[18], "createReactNativeComponentClass");

  var nullthrows = _$$_REQUIRE(_dependencyMap[19], "fbjs/lib/nullthrows");

  var processColor = _$$_REQUIRE(_dependencyMap[20], "processColor");

  var PRESS_RECT_OFFSET = {
    top: 20,
    left: 20,
    right: 20,
    bottom: 30
  };
  var viewConfig = {
    validAttributes: _objectSpread({}, ReactNativeViewAttributes.UIView, {
      isHighlighted: true,
      numberOfLines: true,
      ellipsizeMode: true,
      allowFontScaling: true,
      disabled: true,
      selectable: true,
      selectionColor: true,
      adjustsFontSizeToFit: true,
      minimumFontScale: true,
      textBreakStrategy: true,
      onTextLayout: true
    }),
    directEventTypes: {
      topTextLayout: {
        registrationName: 'onTextLayout'
      }
    },
    uiViewClassName: 'RCTText'
  };

  var TouchableText = function (_React$Component) {
    _inherits(TouchableText, _React$Component);

    function TouchableText() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, TouchableText);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TouchableText)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "touchableGetPressRectOffset", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "touchableHandleActivePressIn", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "touchableHandleActivePressOut", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "touchableHandleLongPress", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "touchableHandlePress", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "touchableHandleResponderGrant", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "touchableHandleResponderMove", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "touchableHandleResponderRelease", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "touchableHandleResponderTerminate", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "touchableHandleResponderTerminationRequest", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", _objectSpread({}, Touchable.Mixin.touchableGetInitialState(), {
        isHighlighted: false,
        createResponderHandlers: _this._createResponseHandlers.bind(_assertThisInitialized(_assertThisInitialized(_this))),
        responseHandlers: null
      }));

      return _this;
    }

    _createClass(TouchableText, [{
      key: "render",
      value: function render() {
        var props = this.props;

        if (isTouchable(props)) {
          props = _objectSpread({}, props, this.state.responseHandlers, {
            isHighlighted: this.state.isHighlighted
          });
        }

        if (props.selectionColor != null) {
          props = _objectSpread({}, props, {
            selectionColor: processColor(props.selectionColor)
          });
        }

        if (__DEV__) {
          if (Touchable.TOUCH_TARGET_DEBUG && props.onPress != null) {
            props = _objectSpread({}, props, {
              style: [props.style, {
                color: 'magenta'
              }]
            });
          }
        }

        return React.createElement(TextAncestor.Consumer, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 145
          }
        }, function (hasTextAncestor) {
          return hasTextAncestor ? React.createElement(RCTVirtualText, _extends({}, props, {
            ref: props.forwardedRef,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 148
            }
          })) : React.createElement(TextAncestor.Provider, {
            value: true,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 150
            }
          }, React.createElement(RCTText, _extends({}, props, {
            ref: props.forwardedRef,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 151
            }
          })));
        });
      }
    }, {
      key: "_createResponseHandlers",
      value: function _createResponseHandlers() {
        var _this2 = this;

        return {
          onStartShouldSetResponder: function onStartShouldSetResponder() {
            var onStartShouldSetResponder = _this2.props.onStartShouldSetResponder;
            var shouldSetResponder = (onStartShouldSetResponder == null ? false : onStartShouldSetResponder()) || isTouchable(_this2.props);

            if (shouldSetResponder) {
              _this2._attachTouchHandlers();
            }

            return shouldSetResponder;
          },
          onResponderGrant: function onResponderGrant(event, dispatchID) {
            nullthrows(_this2.touchableHandleResponderGrant)(event, dispatchID);

            if (_this2.props.onResponderGrant != null) {
              _this2.props.onResponderGrant.call(_this2, event, dispatchID);
            }
          },
          onResponderMove: function onResponderMove(event) {
            nullthrows(_this2.touchableHandleResponderMove)(event);

            if (_this2.props.onResponderMove != null) {
              _this2.props.onResponderMove.call(_this2, event);
            }
          },
          onResponderRelease: function onResponderRelease(event) {
            nullthrows(_this2.touchableHandleResponderRelease)(event);

            if (_this2.props.onResponderRelease != null) {
              _this2.props.onResponderRelease.call(_this2, event);
            }
          },
          onResponderTerminate: function onResponderTerminate(event) {
            nullthrows(_this2.touchableHandleResponderTerminate)(event);

            if (_this2.props.onResponderTerminate != null) {
              _this2.props.onResponderTerminate.call(_this2, event);
            }
          },
          onResponderTerminationRequest: function onResponderTerminationRequest() {
            var onResponderTerminationRequest = _this2.props.onResponderTerminationRequest;

            if (!nullthrows(_this2.touchableHandleResponderTerminationRequest)()) {
              return false;
            }

            if (onResponderTerminationRequest == null) {
              return true;
            }

            return onResponderTerminationRequest();
          }
        };
      }
    }, {
      key: "_attachTouchHandlers",
      value: function _attachTouchHandlers() {
        var _this3 = this;

        if (this.touchableGetPressRectOffset != null) {
          return;
        }

        for (var key in Touchable.Mixin) {
          if (typeof Touchable.Mixin[key] === 'function') {
            this[key] = Touchable.Mixin[key].bind(this);
          }
        }

        this.touchableHandleActivePressIn = function () {
          if (!_this3.props.suppressHighlighting && isTouchable(_this3.props)) {
            _this3.setState({
              isHighlighted: true
            });
          }
        };

        this.touchableHandleActivePressOut = function () {
          if (!_this3.props.suppressHighlighting && isTouchable(_this3.props)) {
            _this3.setState({
              isHighlighted: false
            });
          }
        };

        this.touchableHandlePress = function (event) {
          if (_this3.props.onPress != null) {
            _this3.props.onPress(event);
          }
        };

        this.touchableHandleLongPress = function (event) {
          if (_this3.props.onLongPress != null) {
            _this3.props.onLongPress(event);
          }
        };

        this.touchableGetPressRectOffset = function () {
          return _this3.props.pressRetentionOffset == null ? PRESS_RECT_OFFSET : _this3.props.pressRetentionOffset;
        };
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(nextProps, prevState) {
        return prevState.responseHandlers == null && isTouchable(nextProps) ? _objectSpread({}, prevState, {
          responseHandlers: prevState.createResponderHandlers()
        }) : null;
      }
    }]);

    return TouchableText;
  }(React.Component);

  _defineProperty(TouchableText, "defaultProps", {
    accessible: true,
    allowFontScaling: true,
    ellipsizeMode: 'tail'
  });

  _defineProperty(TouchableText, "viewConfig", viewConfig);

  TouchableText = _wrapComponent("TouchableText")(TouchableText);

  var isTouchable = function isTouchable(props) {
    return props.onPress != null || props.onLongPress != null || props.onStartShouldSetResponder != null;
  };

  var RCTText = createReactNativeComponentClass(viewConfig.uiViewClassName, function () {
    return viewConfig;
  });
  var RCTVirtualText = UIManager.RCTVirtualText == null ? RCTText : createReactNativeComponentClass('RCTVirtualText', function () {
    return {
      validAttributes: _objectSpread({}, ReactNativeViewAttributes.UIView, {
        isHighlighted: true
      }),
      uiViewClassName: 'RCTVirtualText'
    };
  });

  var Text = function Text(props, forwardedRef) {
    return React.createElement(TouchableText, _extends({}, props, {
      forwardedRef: forwardedRef,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 274
      }
    }));
  };

  var TextToExport = React.forwardRef(Text);
  TextToExport.displayName = 'Text';
  TextToExport.propTypes = TextPropTypes;
  module.exports = TextToExport;
},444,[23,112,24,25,26,29,30,28,32,148,109,280,149,439,176,445,449,145,269,455,169],"node_modules\\react-native\\Libraries\\Text\\Text.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var ColorPropType = _$$_REQUIRE(_dependencyMap[0], "ColorPropType");

  var EdgeInsetsPropType = _$$_REQUIRE(_dependencyMap[1], "EdgeInsetsPropType");

  var PropTypes = _$$_REQUIRE(_dependencyMap[2], "prop-types");

  var StyleSheetPropType = _$$_REQUIRE(_dependencyMap[3], "StyleSheetPropType");

  var TextStylePropTypes = _$$_REQUIRE(_dependencyMap[4], "TextStylePropTypes");

  var stylePropType = StyleSheetPropType(TextStylePropTypes);
  module.exports = {
    ellipsizeMode: PropTypes.oneOf(['head', 'middle', 'tail', 'clip']),
    numberOfLines: PropTypes.number,
    textBreakStrategy: PropTypes.oneOf(['simple', 'highQuality', 'balanced']),
    onLayout: PropTypes.func,
    onPress: PropTypes.func,
    onLongPress: PropTypes.func,
    pressRetentionOffset: EdgeInsetsPropType,
    selectable: PropTypes.bool,
    selectionColor: ColorPropType,
    suppressHighlighting: PropTypes.bool,
    style: stylePropType,
    testID: PropTypes.string,
    nativeID: PropTypes.string,
    allowFontScaling: PropTypes.bool,
    accessible: PropTypes.bool,
    adjustsFontSizeToFit: PropTypes.bool,
    minimumFontScale: PropTypes.number,
    disabled: PropTypes.bool
  };
},445,[156,446,161,447,167],"node_modules\\react-native\\Libraries\\Text\\TextPropTypes.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var PropTypes = _$$_REQUIRE(_dependencyMap[0], "prop-types");

  var EdgeInsetsPropType = PropTypes.shape({
    top: PropTypes.number,
    left: PropTypes.number,
    bottom: PropTypes.number,
    right: PropTypes.number
  });
  module.exports = EdgeInsetsPropType;
},446,[161],"node_modules\\react-native\\Libraries\\StyleSheet\\EdgeInsetsPropType.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var createStrictShapeTypeChecker = _$$_REQUIRE(_dependencyMap[0], "createStrictShapeTypeChecker");

  var flattenStyle = _$$_REQUIRE(_dependencyMap[1], "flattenStyle");

  function StyleSheetPropType(shape) {
    var shapePropType = createStrictShapeTypeChecker(shape);
    return function (props, propName, componentName, location) {
      var newProps = props;

      if (props[propName]) {
        newProps = {};
        newProps[propName] = flattenStyle(props[propName]);
      }

      for (var _len = arguments.length, rest = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
        rest[_key - 4] = arguments[_key];
      }

      return shapePropType.apply(void 0, [newProps, propName, componentName, location].concat(rest));
    };
  }

  module.exports = StyleSheetPropType;
},447,[448,174],"node_modules\\react-native\\Libraries\\StyleSheet\\StyleSheetPropType.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var invariant = _$$_REQUIRE(_dependencyMap[0], "fbjs/lib/invariant");

  var merge = _$$_REQUIRE(_dependencyMap[1], "merge");

  function createStrictShapeTypeChecker(shapeTypes) {
    function checkType(isRequired, props, propName, componentName, location) {
      if (!props[propName]) {
        if (isRequired) {
          invariant(false, "Required object `" + propName + "` was not specified in " + ("`" + componentName + "`."));
        }

        return;
      }

      var propValue = props[propName];
      var propType = typeof propValue;
      var locationName = location || '(unknown)';

      if (propType !== 'object') {
        invariant(false, "Invalid " + locationName + " `" + propName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
      }

      var allKeys = merge(props[propName], shapeTypes);

      for (var _len = arguments.length, rest = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
        rest[_key - 5] = arguments[_key];
      }

      for (var _key2 in allKeys) {
        var checker = shapeTypes[_key2];

        if (!checker) {
          invariant(false, "Invalid props." + propName + " key `" + _key2 + "` supplied to `" + componentName + "`." + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
        }

        var error = checker.apply(void 0, [propValue, _key2, componentName, location].concat(rest));

        if (error) {
          invariant(false, error.message + '\nBad object: ' + JSON.stringify(props[propName], null, '  '));
        }
      }
    }

    function chainedCheckType(props, propName, componentName, location) {
      for (var _len2 = arguments.length, rest = new Array(_len2 > 4 ? _len2 - 4 : 0), _key3 = 4; _key3 < _len2; _key3++) {
        rest[_key3 - 4] = arguments[_key3];
      }

      return checkType.apply(void 0, [false, props, propName, componentName, location].concat(rest));
    }

    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
  }

  module.exports = createStrictShapeTypeChecker;
},448,[117,440],"node_modules\\react-native\\Libraries\\Utilities\\createStrictShapeTypeChecker.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\Touchable\\Touchable.js";

  var BoundingDimensions = _$$_REQUIRE(_dependencyMap[1], "BoundingDimensions");

  var Platform = _$$_REQUIRE(_dependencyMap[2], "Platform");

  var Position = _$$_REQUIRE(_dependencyMap[3], "Position");

  var React = _$$_REQUIRE(_dependencyMap[4], "React");

  var ReactNative = _$$_REQUIRE(_dependencyMap[5], "ReactNative");

  var TVEventHandler = _$$_REQUIRE(_dependencyMap[6], "TVEventHandler");

  var TouchEventUtils = _$$_REQUIRE(_dependencyMap[7], "fbjs/lib/TouchEventUtils");

  var UIManager = _$$_REQUIRE(_dependencyMap[8], "UIManager");

  var View = _$$_REQUIRE(_dependencyMap[9], "View");

  var keyMirror = _$$_REQUIRE(_dependencyMap[10], "fbjs/lib/keyMirror");

  var normalizeColor = _$$_REQUIRE(_dependencyMap[11], "normalizeColor");

  var States = keyMirror({
    NOT_RESPONDER: null,
    RESPONDER_INACTIVE_PRESS_IN: null,
    RESPONDER_INACTIVE_PRESS_OUT: null,
    RESPONDER_ACTIVE_PRESS_IN: null,
    RESPONDER_ACTIVE_PRESS_OUT: null,
    RESPONDER_ACTIVE_LONG_PRESS_IN: null,
    RESPONDER_ACTIVE_LONG_PRESS_OUT: null,
    ERROR: null
  });
  var IsActive = {
    RESPONDER_ACTIVE_PRESS_OUT: true,
    RESPONDER_ACTIVE_PRESS_IN: true
  };
  var IsPressingIn = {
    RESPONDER_INACTIVE_PRESS_IN: true,
    RESPONDER_ACTIVE_PRESS_IN: true,
    RESPONDER_ACTIVE_LONG_PRESS_IN: true
  };
  var IsLongPressingIn = {
    RESPONDER_ACTIVE_LONG_PRESS_IN: true
  };
  var Signals = keyMirror({
    DELAY: null,
    RESPONDER_GRANT: null,
    RESPONDER_RELEASE: null,
    RESPONDER_TERMINATED: null,
    ENTER_PRESS_RECT: null,
    LEAVE_PRESS_RECT: null,
    LONG_PRESS_DETECTED: null
  });
  var Transitions = {
    NOT_RESPONDER: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,
      RESPONDER_RELEASE: States.ERROR,
      RESPONDER_TERMINATED: States.ERROR,
      ENTER_PRESS_RECT: States.ERROR,
      LEAVE_PRESS_RECT: States.ERROR,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_INACTIVE_PRESS_IN: {
      DELAY: States.RESPONDER_ACTIVE_PRESS_IN,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_INACTIVE_PRESS_OUT: {
      DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_ACTIVE_PRESS_IN: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN
    },
    RESPONDER_ACTIVE_PRESS_OUT: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_ACTIVE_LONG_PRESS_IN: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,
      LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN
    },
    RESPONDER_ACTIVE_LONG_PRESS_OUT: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    error: {
      DELAY: States.NOT_RESPONDER,
      RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.NOT_RESPONDER,
      LEAVE_PRESS_RECT: States.NOT_RESPONDER,
      LONG_PRESS_DETECTED: States.NOT_RESPONDER
    }
  };
  var HIGHLIGHT_DELAY_MS = 130;
  var PRESS_EXPAND_PX = 20;
  var LONG_PRESS_THRESHOLD = 500;
  var LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;
  var LONG_PRESS_ALLOWED_MOVEMENT = 10;
  var TouchableMixin = {
    componentDidMount: function componentDidMount() {
      if (!Platform.isTV) {
        return;
      }

      this._tvEventHandler = new TVEventHandler();

      this._tvEventHandler.enable(this, function (cmp, evt) {
        var myTag = ReactNative.findNodeHandle(cmp);
        evt.dispatchConfig = {};

        if (myTag === evt.tag) {
          if (evt.eventType === 'focus') {
            cmp.touchableHandleFocus(evt);
          } else if (evt.eventType === 'blur') {
            cmp.touchableHandleBlur(evt);
          } else if (evt.eventType === 'select') {
            cmp.touchableHandlePress && !cmp.props.disabled && cmp.touchableHandlePress(evt);
          }
        }
      });
    },
    componentWillUnmount: function componentWillUnmount() {
      if (this._tvEventHandler) {
        this._tvEventHandler.disable();

        delete this._tvEventHandler;
      }

      this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);
      this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);
      this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);
    },
    touchableGetInitialState: function touchableGetInitialState() {
      return {
        touchable: {
          touchState: undefined,
          responderID: null
        }
      };
    },
    touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {
      return !this.props.rejectResponderTermination;
    },
    touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {
      return !this.props.disabled;
    },
    touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {
      return true;
    },
    touchableHandleResponderGrant: function touchableHandleResponderGrant(e) {
      var dispatchID = e.currentTarget;
      e.persist();
      this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);
      this.pressOutDelayTimeout = null;
      this.state.touchable.touchState = States.NOT_RESPONDER;
      this.state.touchable.responderID = dispatchID;

      this._receiveSignal(Signals.RESPONDER_GRANT, e);

      var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;
      delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;

      if (delayMS !== 0) {
        this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);
      } else {
        this._handleDelay(e);
      }

      var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;
      longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;
      this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);
    },
    touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {
      this._receiveSignal(Signals.RESPONDER_RELEASE, e);
    },
    touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {
      this._receiveSignal(Signals.RESPONDER_TERMINATED, e);
    },
    touchableHandleResponderMove: function touchableHandleResponderMove(e) {
      if (this.state.touchable.touchState === States.RESPONDER_INACTIVE_PRESS_IN) {
        return;
      }

      if (!this.state.touchable.positionOnActivate) {
        return;
      }

      var positionOnActivate = this.state.touchable.positionOnActivate;
      var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;
      var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : {
        left: PRESS_EXPAND_PX,
        right: PRESS_EXPAND_PX,
        top: PRESS_EXPAND_PX,
        bottom: PRESS_EXPAND_PX
      };
      var pressExpandLeft = pressRectOffset.left;
      var pressExpandTop = pressRectOffset.top;
      var pressExpandRight = pressRectOffset.right;
      var pressExpandBottom = pressRectOffset.bottom;
      var hitSlop = this.touchableGetHitSlop ? this.touchableGetHitSlop() : null;

      if (hitSlop) {
        pressExpandLeft += hitSlop.left;
        pressExpandTop += hitSlop.top;
        pressExpandRight += hitSlop.right;
        pressExpandBottom += hitSlop.bottom;
      }

      var touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);
      var pageX = touch && touch.pageX;
      var pageY = touch && touch.pageY;

      if (this.pressInLocation) {
        var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);

        if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {
          this._cancelLongPressDelayTimeout();
        }
      }

      var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;

      if (isTouchWithinActive) {
        this._receiveSignal(Signals.ENTER_PRESS_RECT, e);

        var curState = this.state.touchable.touchState;

        if (curState === States.RESPONDER_INACTIVE_PRESS_IN) {
          this._cancelLongPressDelayTimeout();
        }
      } else {
        this._cancelLongPressDelayTimeout();

        this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);
      }
    },
    touchableHandleFocus: function touchableHandleFocus(e) {
      this.props.onFocus && this.props.onFocus(e);
    },
    touchableHandleBlur: function touchableHandleBlur(e) {
      this.props.onBlur && this.props.onBlur(e);
    },
    _remeasureMetricsOnActivation: function _remeasureMetricsOnActivation() {
      var tag = this.state.touchable.responderID;

      if (tag == null) {
        return;
      }

      UIManager.measure(tag, this._handleQueryLayout);
    },
    _handleQueryLayout: function _handleQueryLayout(l, t, w, h, globalX, globalY) {
      if (!l && !t && !w && !h && !globalX && !globalY) {
        return;
      }

      this.state.touchable.positionOnActivate && Position.release(this.state.touchable.positionOnActivate);
      this.state.touchable.dimensionsOnActivate && BoundingDimensions.release(this.state.touchable.dimensionsOnActivate);
      this.state.touchable.positionOnActivate = Position.getPooled(globalX, globalY);
      this.state.touchable.dimensionsOnActivate = BoundingDimensions.getPooled(w, h);
    },
    _handleDelay: function _handleDelay(e) {
      this.touchableDelayTimeout = null;

      this._receiveSignal(Signals.DELAY, e);
    },
    _handleLongDelay: function _handleLongDelay(e) {
      this.longPressDelayTimeout = null;
      var curState = this.state.touchable.touchState;

      if (curState !== States.RESPONDER_ACTIVE_PRESS_IN && curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {
        console.error('Attempted to transition from state `' + curState + '` to `' + States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' + 'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');
      } else {
        this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);
      }
    },
    _receiveSignal: function _receiveSignal(signal, e) {
      var responderID = this.state.touchable.responderID;
      var curState = this.state.touchable.touchState;
      var nextState = Transitions[curState] && Transitions[curState][signal];

      if (!responderID && signal === Signals.RESPONDER_RELEASE) {
        return;
      }

      if (!nextState) {
        throw new Error('Unrecognized signal `' + signal + '` or state `' + curState + '` for Touchable responder `' + responderID + '`');
      }

      if (nextState === States.ERROR) {
        throw new Error('Touchable cannot transition from `' + curState + '` to `' + signal + '` for responder `' + responderID + '`');
      }

      if (curState !== nextState) {
        this._performSideEffectsForTransition(curState, nextState, signal, e);

        this.state.touchable.touchState = nextState;
      }
    },
    _cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {
      this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);
      this.longPressDelayTimeout = null;
    },
    _isHighlight: function _isHighlight(state) {
      return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;
    },
    _savePressInLocation: function _savePressInLocation(e) {
      var touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);
      var pageX = touch && touch.pageX;
      var pageY = touch && touch.pageY;
      var locationX = touch && touch.locationX;
      var locationY = touch && touch.locationY;
      this.pressInLocation = {
        pageX: pageX,
        pageY: pageY,
        locationX: locationX,
        locationY: locationY
      };
    },
    _getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {
      var deltaX = aX - bX;
      var deltaY = aY - bY;
      return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    },
    _performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {
      var curIsHighlight = this._isHighlight(curState);

      var newIsHighlight = this._isHighlight(nextState);

      var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;

      if (isFinalSignal) {
        this._cancelLongPressDelayTimeout();
      }

      if (!IsActive[curState] && IsActive[nextState]) {
        this._remeasureMetricsOnActivation();
      }

      if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {
        this.touchableHandleLongPress && this.touchableHandleLongPress(e);
      }

      if (newIsHighlight && !curIsHighlight) {
        this._startHighlight(e);
      } else if (!newIsHighlight && curIsHighlight) {
        this._endHighlight(e);
      }

      if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {
        var hasLongPressHandler = !!this.props.onLongPress;
        var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && (!hasLongPressHandler || !this.touchableLongPressCancelsPress());
        var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;

        if (shouldInvokePress && this.touchableHandlePress) {
          if (!newIsHighlight && !curIsHighlight) {
            this._startHighlight(e);

            this._endHighlight(e);
          }

          if (Platform.OS === 'android') {
            this._playTouchSound();
          }

          this.touchableHandlePress(e);
        }
      }

      this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);
      this.touchableDelayTimeout = null;
    },
    _playTouchSound: function _playTouchSound() {
      UIManager.playTouchSound();
    },
    _startHighlight: function _startHighlight(e) {
      this._savePressInLocation(e);

      this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);
    },
    _endHighlight: function _endHighlight(e) {
      var _this = this;

      if (this.touchableHandleActivePressOut) {
        if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {
          this.pressOutDelayTimeout = setTimeout(function () {
            _this.touchableHandleActivePressOut(e);
          }, this.touchableGetPressOutDelayMS());
        } else {
          this.touchableHandleActivePressOut(e);
        }
      }
    }
  };
  var Touchable = {
    Mixin: TouchableMixin,
    TOUCH_TARGET_DEBUG: false,
    renderDebugView: function renderDebugView(_ref) {
      var color = _ref.color,
          hitSlop = _ref.hitSlop;

      if (!Touchable.TOUCH_TARGET_DEBUG) {
        return null;
      }

      if (!__DEV__) {
        throw Error('Touchable.TOUCH_TARGET_DEBUG should not be enabled in prod!');
      }

      var debugHitSlopStyle = {};
      hitSlop = hitSlop || {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };

      for (var key in hitSlop) {
        debugHitSlopStyle[key] = -hitSlop[key];
      }

      var hexColor = '#' + ('00000000' + normalizeColor(color).toString(16)).substr(-8);
      return React.createElement(View, {
        pointerEvents: "none",
        style: _objectSpread({
          position: 'absolute',
          borderColor: hexColor.slice(0, -2) + '55',
          borderWidth: 1,
          borderStyle: 'dashed',
          backgroundColor: hexColor.slice(0, -2) + '0F'
        }, debugHitSlopStyle),
        __source: {
          fileName: _jsxFileName,
          lineNumber: 859
        }
      });
    }
  };
  module.exports = Touchable;
},449,[148,450,146,452,149,178,453,454,145,175,159,157],"node_modules\\react-native\\Libraries\\Components\\Touchable\\Touchable.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var PooledClass = _$$_REQUIRE(_dependencyMap[0], "PooledClass");

  var twoArgumentPooler = PooledClass.twoArgumentPooler;

  function BoundingDimensions(width, height) {
    this.width = width;
    this.height = height;
  }

  BoundingDimensions.prototype.destructor = function () {
    this.width = null;
    this.height = null;
  };

  BoundingDimensions.getPooledFromElement = function (element) {
    return BoundingDimensions.getPooled(element.offsetWidth, element.offsetHeight);
  };

  PooledClass.addPoolingTo(BoundingDimensions, twoArgumentPooler);
  module.exports = BoundingDimensions;
},450,[451],"node_modules\\react-native\\Libraries\\Components\\Touchable\\BoundingDimensions.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var invariant = _$$_REQUIRE(_dependencyMap[0], "fbjs/lib/invariant");

  var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
    var Klass = this;

    if (Klass.instancePool.length) {
      var _instance = Klass.instancePool.pop();

      Klass.call(_instance, copyFieldsFrom);
      return _instance;
    } else {
      return new Klass(copyFieldsFrom);
    }
  };

  var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
    var Klass = this;

    if (Klass.instancePool.length) {
      var _instance2 = Klass.instancePool.pop();

      Klass.call(_instance2, a1, a2);
      return _instance2;
    } else {
      return new Klass(a1, a2);
    }
  };

  var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
    var Klass = this;

    if (Klass.instancePool.length) {
      var _instance3 = Klass.instancePool.pop();

      Klass.call(_instance3, a1, a2, a3);
      return _instance3;
    } else {
      return new Klass(a1, a2, a3);
    }
  };

  var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
    var Klass = this;

    if (Klass.instancePool.length) {
      var _instance4 = Klass.instancePool.pop();

      Klass.call(_instance4, a1, a2, a3, a4);
      return _instance4;
    } else {
      return new Klass(a1, a2, a3, a4);
    }
  };

  var standardReleaser = function standardReleaser(instance) {
    var Klass = this;
    invariant(instance instanceof Klass, 'Trying to release an instance into a pool of a different type.');
    instance.destructor();

    if (Klass.instancePool.length < Klass.poolSize) {
      Klass.instancePool.push(instance);
    }
  };

  var DEFAULT_POOL_SIZE = 10;
  var DEFAULT_POOLER = oneArgumentPooler;

  var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
    var NewKlass = CopyConstructor;
    NewKlass.instancePool = [];
    NewKlass.getPooled = pooler || DEFAULT_POOLER;

    if (!NewKlass.poolSize) {
      NewKlass.poolSize = DEFAULT_POOL_SIZE;
    }

    NewKlass.release = standardReleaser;
    return NewKlass;
  };

  var PooledClass = {
    addPoolingTo: addPoolingTo,
    oneArgumentPooler: oneArgumentPooler,
    twoArgumentPooler: twoArgumentPooler,
    threeArgumentPooler: threeArgumentPooler,
    fourArgumentPooler: fourArgumentPooler
  };
  module.exports = PooledClass;
},451,[117],"node_modules\\react-native\\Libraries\\Components\\Touchable\\PooledClass.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var PooledClass = _$$_REQUIRE(_dependencyMap[0], "PooledClass");

  var twoArgumentPooler = PooledClass.twoArgumentPooler;

  function Position(left, top) {
    this.left = left;
    this.top = top;
  }

  Position.prototype.destructor = function () {
    this.left = null;
    this.top = null;
  };

  PooledClass.addPoolingTo(Position, twoArgumentPooler);
  module.exports = Position;
},452,[451],"node_modules\\react-native\\Libraries\\Components\\Touchable\\Position.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Platform = _$$_REQUIRE(_dependencyMap[0], "Platform");

  var TVNavigationEventEmitter = _$$_REQUIRE(_dependencyMap[1], "NativeModules").TVNavigationEventEmitter;

  var NativeEventEmitter = _$$_REQUIRE(_dependencyMap[2], "NativeEventEmitter");

  function TVEventHandler() {
    this.__nativeTVNavigationEventListener = null;
    this.__nativeTVNavigationEventEmitter = null;
  }

  TVEventHandler.prototype.enable = function (component, callback) {
    if (Platform.OS === 'ios' && !TVNavigationEventEmitter) {
      return;
    }

    this.__nativeTVNavigationEventEmitter = new NativeEventEmitter(TVNavigationEventEmitter);
    this.__nativeTVNavigationEventListener = this.__nativeTVNavigationEventEmitter.addListener('onHWKeyEvent', function (data) {
      if (callback) {
        callback(component, data);
      }
    });
  };

  TVEventHandler.prototype.disable = function () {
    if (this.__nativeTVNavigationEventListener) {
      this.__nativeTVNavigationEventListener.remove();

      delete this.__nativeTVNavigationEventListener;
    }

    if (this.__nativeTVNavigationEventEmitter) {
      delete this.__nativeTVNavigationEventEmitter;
    }
  };

  module.exports = TVEventHandler;
},453,[146,119,219],"node_modules\\react-native\\Libraries\\Components\\AppleTV\\TVEventHandler.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var TouchEventUtils = {
    extractSingleTouch: function extractSingleTouch(nativeEvent) {
      var touches = nativeEvent.touches;
      var changedTouches = nativeEvent.changedTouches;
      var hasTouches = touches && touches.length > 0;
      var hasChangedTouches = changedTouches && changedTouches.length > 0;
      return !hasTouches && hasChangedTouches ? changedTouches[0] : hasTouches ? touches[0] : nativeEvent;
    }
  };
  module.exports = TouchEventUtils;
},454,[],"node_modules\\fbjs\\lib\\TouchEventUtils.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var nullthrows = function nullthrows(x) {
    if (x != null) {
      return x;
    }

    throw new Error("Got unexpected null or undefined");
  };

  module.exports = nullthrows;
},455,[],"node_modules\\fbjs\\lib\\nullthrows.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _defineProperty = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/defineProperty");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread");

  var Platform = _$$_REQUIRE(_dependencyMap[2], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[3], "React");

  var PropTypes = _$$_REQUIRE(_dependencyMap[4], "prop-types");

  var ReactNative = _$$_REQUIRE(_dependencyMap[5], "ReactNative");

  var Touchable = _$$_REQUIRE(_dependencyMap[6], "Touchable");

  var TouchableWithoutFeedback = _$$_REQUIRE(_dependencyMap[7], "TouchableWithoutFeedback");

  var UIManager = _$$_REQUIRE(_dependencyMap[8], "UIManager");

  var View = _$$_REQUIRE(_dependencyMap[9], "View");

  var createReactClass = _$$_REQUIRE(_dependencyMap[10], "create-react-class");

  var ensurePositiveDelayProps = _$$_REQUIRE(_dependencyMap[11], "ensurePositiveDelayProps");

  var processColor = _$$_REQUIRE(_dependencyMap[12], "processColor");

  var rippleBackgroundPropType = PropTypes.shape({
    type: PropTypes.oneOf(['RippleAndroid']),
    color: PropTypes.number,
    borderless: PropTypes.bool
  });
  var themeAttributeBackgroundPropType = PropTypes.shape({
    type: PropTypes.oneOf(['ThemeAttrAndroid']),
    attribute: PropTypes.string.isRequired
  });
  var backgroundPropType = PropTypes.oneOfType([rippleBackgroundPropType, themeAttributeBackgroundPropType]);
  var PRESS_RETENTION_OFFSET = {
    top: 20,
    left: 20,
    right: 20,
    bottom: 30
  };
  var TouchableNativeFeedback = createReactClass({
    displayName: 'TouchableNativeFeedback',
    propTypes: _objectSpread({}, TouchableWithoutFeedback.propTypes, {
      background: backgroundPropType,
      hasTVPreferredFocus: PropTypes.bool,
      useForeground: PropTypes.bool
    }),
    statics: {
      SelectableBackground: function SelectableBackground() {
        return {
          type: 'ThemeAttrAndroid',
          attribute: 'selectableItemBackground'
        };
      },
      SelectableBackgroundBorderless: function SelectableBackgroundBorderless() {
        return {
          type: 'ThemeAttrAndroid',
          attribute: 'selectableItemBackgroundBorderless'
        };
      },
      Ripple: function Ripple(color, borderless) {
        return {
          type: 'RippleAndroid',
          color: processColor(color),
          borderless: borderless
        };
      },
      canUseNativeForeground: function canUseNativeForeground() {
        return Platform.OS === 'android' && Platform.Version >= 23;
      }
    },
    mixins: [Touchable.Mixin],
    getDefaultProps: function getDefaultProps() {
      return {
        background: this.SelectableBackground()
      };
    },
    getInitialState: function getInitialState() {
      return this.touchableGetInitialState();
    },
    componentDidMount: function componentDidMount() {
      ensurePositiveDelayProps(this.props);
    },
    UNSAFE_componentWillReceiveProps: function UNSAFE_componentWillReceiveProps(nextProps) {
      ensurePositiveDelayProps(nextProps);
    },
    touchableHandleActivePressIn: function touchableHandleActivePressIn(e) {
      this.props.onPressIn && this.props.onPressIn(e);

      this._dispatchPressedStateChange(true);

      if (this.pressInLocation) {
        this._dispatchHotspotUpdate(this.pressInLocation.locationX, this.pressInLocation.locationY);
      }
    },
    touchableHandleActivePressOut: function touchableHandleActivePressOut(e) {
      this.props.onPressOut && this.props.onPressOut(e);

      this._dispatchPressedStateChange(false);
    },
    touchableHandlePress: function touchableHandlePress(e) {
      this.props.onPress && this.props.onPress(e);
    },
    touchableHandleLongPress: function touchableHandleLongPress(e) {
      this.props.onLongPress && this.props.onLongPress(e);
    },
    touchableGetPressRectOffset: function touchableGetPressRectOffset() {
      return this.props.pressRetentionOffset || PRESS_RETENTION_OFFSET;
    },
    touchableGetHitSlop: function touchableGetHitSlop() {
      return this.props.hitSlop;
    },
    touchableGetHighlightDelayMS: function touchableGetHighlightDelayMS() {
      return this.props.delayPressIn;
    },
    touchableGetLongPressDelayMS: function touchableGetLongPressDelayMS() {
      return this.props.delayLongPress;
    },
    touchableGetPressOutDelayMS: function touchableGetPressOutDelayMS() {
      return this.props.delayPressOut;
    },
    _handleResponderMove: function _handleResponderMove(e) {
      this.touchableHandleResponderMove(e);

      this._dispatchHotspotUpdate(e.nativeEvent.locationX, e.nativeEvent.locationY);
    },
    _dispatchHotspotUpdate: function _dispatchHotspotUpdate(destX, destY) {
      UIManager.dispatchViewManagerCommand(ReactNative.findNodeHandle(this), UIManager.RCTView.Commands.hotspotUpdate, [destX || 0, destY || 0]);
    },
    _dispatchPressedStateChange: function _dispatchPressedStateChange(pressed) {
      UIManager.dispatchViewManagerCommand(ReactNative.findNodeHandle(this), UIManager.RCTView.Commands.setPressed, [pressed]);
    },
    render: function render() {
      var _objectSpread2;

      var child = React.Children.only(this.props.children);
      var children = child.props.children;

      if (Touchable.TOUCH_TARGET_DEBUG && child.type === View) {
        if (!Array.isArray(children)) {
          children = [children];
        }

        children.push(Touchable.renderDebugView({
          color: 'brown',
          hitSlop: this.props.hitSlop
        }));
      }

      if (this.props.useForeground && !TouchableNativeFeedback.canUseNativeForeground()) {
        console.warn('Requested foreground ripple, but it is not available on this version of Android. ' + 'Consider calling TouchableNativeFeedback.canUseNativeForeground() and using a different ' + 'Touchable if the result is false.');
      }

      var drawableProp = this.props.useForeground && TouchableNativeFeedback.canUseNativeForeground() ? 'nativeForegroundAndroid' : 'nativeBackgroundAndroid';

      var childProps = _objectSpread({}, child.props, (_objectSpread2 = {}, _defineProperty(_objectSpread2, drawableProp, this.props.background), _defineProperty(_objectSpread2, "accessible", this.props.accessible !== false), _defineProperty(_objectSpread2, "accessibilityLabel", this.props.accessibilityLabel), _defineProperty(_objectSpread2, "accessibilityRole", this.props.accessibilityRole), _defineProperty(_objectSpread2, "accessibilityStates", this.props.accessibilityStates), _defineProperty(_objectSpread2, "children", children), _defineProperty(_objectSpread2, "testID", this.props.testID), _defineProperty(_objectSpread2, "onLayout", this.props.onLayout), _defineProperty(_objectSpread2, "hitSlop", this.props.hitSlop), _defineProperty(_objectSpread2, "isTVSelectable", true), _defineProperty(_objectSpread2, "hasTVPreferredFocus", this.props.hasTVPreferredFocus), _defineProperty(_objectSpread2, "onStartShouldSetResponder", this.touchableHandleStartShouldSetResponder), _defineProperty(_objectSpread2, "onResponderTerminationRequest", this.touchableHandleResponderTerminationRequest), _defineProperty(_objectSpread2, "onResponderGrant", this.touchableHandleResponderGrant), _defineProperty(_objectSpread2, "onResponderMove", this._handleResponderMove), _defineProperty(_objectSpread2, "onResponderRelease", this.touchableHandleResponderRelease), _defineProperty(_objectSpread2, "onResponderTerminate", this.touchableHandleResponderTerminate), _objectSpread2));

      return React.cloneElement(child, childProps);
    }
  });
  module.exports = TouchableNativeFeedback;
},456,[32,148,146,149,161,178,449,457,145,175,459,465,169],"node_modules\\react-native\\Libraries\\Components\\Touchable\\TouchableNativeFeedback.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var EdgeInsetsPropType = _$$_REQUIRE(_dependencyMap[0], "EdgeInsetsPropType");

  var React = _$$_REQUIRE(_dependencyMap[1], "React");

  var PropTypes = _$$_REQUIRE(_dependencyMap[2], "prop-types");

  var TimerMixin = _$$_REQUIRE(_dependencyMap[3], "react-timer-mixin");

  var Touchable = _$$_REQUIRE(_dependencyMap[4], "Touchable");

  var View = _$$_REQUIRE(_dependencyMap[5], "View");

  var createReactClass = _$$_REQUIRE(_dependencyMap[6], "create-react-class");

  var ensurePositiveDelayProps = _$$_REQUIRE(_dependencyMap[7], "ensurePositiveDelayProps");

  var warning = _$$_REQUIRE(_dependencyMap[8], "fbjs/lib/warning");

  var _require = _$$_REQUIRE(_dependencyMap[9], "ViewAccessibility"),
      AccessibilityComponentTypes = _require.AccessibilityComponentTypes,
      AccessibilityRoles = _require.AccessibilityRoles,
      AccessibilityStates = _require.AccessibilityStates,
      AccessibilityTraits = _require.AccessibilityTraits;

  var PRESS_RETENTION_OFFSET = {
    top: 20,
    left: 20,
    right: 20,
    bottom: 30
  };
  var TouchableWithoutFeedback = createReactClass({
    displayName: 'TouchableWithoutFeedback',
    mixins: [TimerMixin, Touchable.Mixin],
    propTypes: {
      accessible: PropTypes.bool,
      accessibilityLabel: PropTypes.node,
      accessibilityHint: PropTypes.string,
      accessibilityComponentType: PropTypes.oneOf(AccessibilityComponentTypes),
      accessibilityRole: PropTypes.oneOf(AccessibilityRoles),
      accessibilityStates: PropTypes.arrayOf(PropTypes.oneOf(AccessibilityStates)),
      accessibilityTraits: PropTypes.oneOfType([PropTypes.oneOf(AccessibilityTraits), PropTypes.arrayOf(PropTypes.oneOf(AccessibilityTraits))]),
      onFocus: PropTypes.func,
      onBlur: PropTypes.func,
      disabled: PropTypes.bool,
      onPress: PropTypes.func,
      onPressIn: PropTypes.func,
      onPressOut: PropTypes.func,
      onLayout: PropTypes.func,
      onLongPress: PropTypes.func,
      nativeID: PropTypes.string,
      testID: PropTypes.string,
      delayPressIn: PropTypes.number,
      delayPressOut: PropTypes.number,
      delayLongPress: PropTypes.number,
      pressRetentionOffset: EdgeInsetsPropType,
      hitSlop: EdgeInsetsPropType
    },
    getInitialState: function getInitialState() {
      return this.touchableGetInitialState();
    },
    componentDidMount: function componentDidMount() {
      ensurePositiveDelayProps(this.props);
    },
    UNSAFE_componentWillReceiveProps: function UNSAFE_componentWillReceiveProps(nextProps) {
      ensurePositiveDelayProps(nextProps);
    },
    touchableHandlePress: function touchableHandlePress(e) {
      this.props.onPress && this.props.onPress(e);
    },
    touchableHandleActivePressIn: function touchableHandleActivePressIn(e) {
      this.props.onPressIn && this.props.onPressIn(e);
    },
    touchableHandleActivePressOut: function touchableHandleActivePressOut(e) {
      this.props.onPressOut && this.props.onPressOut(e);
    },
    touchableHandleLongPress: function touchableHandleLongPress(e) {
      this.props.onLongPress && this.props.onLongPress(e);
    },
    touchableGetPressRectOffset: function touchableGetPressRectOffset() {
      return this.props.pressRetentionOffset || PRESS_RETENTION_OFFSET;
    },
    touchableGetHitSlop: function touchableGetHitSlop() {
      return this.props.hitSlop;
    },
    touchableGetHighlightDelayMS: function touchableGetHighlightDelayMS() {
      return this.props.delayPressIn || 0;
    },
    touchableGetLongPressDelayMS: function touchableGetLongPressDelayMS() {
      return this.props.delayLongPress === 0 ? 0 : this.props.delayLongPress || 500;
    },
    touchableGetPressOutDelayMS: function touchableGetPressOutDelayMS() {
      return this.props.delayPressOut || 0;
    },
    render: function render() {
      var child = React.Children.only(this.props.children);
      var children = child.props.children;

      if (Touchable.TOUCH_TARGET_DEBUG && child.type === View) {
        children = React.Children.toArray(children);
        children.push(Touchable.renderDebugView({
          color: 'red',
          hitSlop: this.props.hitSlop
        }));
      }

      return React.cloneElement(child, {
        accessible: this.props.accessible !== false,
        accessibilityLabel: this.props.accessibilityLabel,
        accessibilityHint: this.props.accessibilityHint,
        accessibilityComponentType: this.props.accessibilityComponentType,
        accessibilityRole: this.props.accessibilityRole,
        accessibilityStates: this.props.accessibilityStates,
        accessibilityTraits: this.props.accessibilityTraits,
        nativeID: this.props.nativeID,
        testID: this.props.testID,
        onLayout: this.props.onLayout,
        hitSlop: this.props.hitSlop,
        onStartShouldSetResponder: this.touchableHandleStartShouldSetResponder,
        onResponderTerminationRequest: this.touchableHandleResponderTerminationRequest,
        onResponderGrant: this.touchableHandleResponderGrant,
        onResponderMove: this.touchableHandleResponderMove,
        onResponderRelease: this.touchableHandleResponderRelease,
        onResponderTerminate: this.touchableHandleResponderTerminate,
        children: children
      });
    }
  });
  module.exports = TouchableWithoutFeedback;
},457,[446,149,161,458,449,175,459,465,211,466],"node_modules\\react-native\\Libraries\\Components\\Touchable\\TouchableWithoutFeedback.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var GLOBAL = typeof window === 'undefined' ? global : window;

  var setter = function setter(_setter, _clearer, array) {
    return function (callback, delta) {
      var id = _setter(function () {
        _clearer.call(this, id);

        callback.apply(this, arguments);
      }.bind(this), delta);

      if (!this[array]) {
        this[array] = [id];
      } else {
        this[array].push(id);
      }

      return id;
    };
  };

  var clearer = function clearer(_clearer, array) {
    return function (id) {
      if (this[array]) {
        var index = this[array].indexOf(id);

        if (index !== -1) {
          this[array].splice(index, 1);
        }
      }

      _clearer(id);
    };
  };

  var _timeouts = 'TimerMixin_timeouts';

  var _clearTimeout = clearer(GLOBAL.clearTimeout, _timeouts);

  var _setTimeout = setter(GLOBAL.setTimeout, _clearTimeout, _timeouts);

  var _intervals = 'TimerMixin_intervals';

  var _clearInterval = clearer(GLOBAL.clearInterval, _intervals);

  var _setInterval = setter(GLOBAL.setInterval, function () {}, _intervals);

  var _immediates = 'TimerMixin_immediates';

  var _clearImmediate = clearer(GLOBAL.clearImmediate, _immediates);

  var _setImmediate = setter(GLOBAL.setImmediate, _clearImmediate, _immediates);

  var _rafs = 'TimerMixin_rafs';

  var _cancelAnimationFrame = clearer(GLOBAL.cancelAnimationFrame, _rafs);

  var _requestAnimationFrame = setter(GLOBAL.requestAnimationFrame, _cancelAnimationFrame, _rafs);

  var TimerMixin = {
    componentWillUnmount: function componentWillUnmount() {
      this[_timeouts] && this[_timeouts].forEach(function (id) {
        GLOBAL.clearTimeout(id);
      });
      this[_timeouts] = null;
      this[_intervals] && this[_intervals].forEach(function (id) {
        GLOBAL.clearInterval(id);
      });
      this[_intervals] = null;
      this[_immediates] && this[_immediates].forEach(function (id) {
        GLOBAL.clearImmediate(id);
      });
      this[_immediates] = null;
      this[_rafs] && this[_rafs].forEach(function (id) {
        GLOBAL.cancelAnimationFrame(id);
      });
      this[_rafs] = null;
    },
    setTimeout: _setTimeout,
    clearTimeout: _clearTimeout,
    setInterval: _setInterval,
    clearInterval: _clearInterval,
    setImmediate: _setImmediate,
    clearImmediate: _clearImmediate,
    requestAnimationFrame: _requestAnimationFrame,
    cancelAnimationFrame: _cancelAnimationFrame
  };
  module.exports = TimerMixin;
},458,[],"node_modules\\react-timer-mixin\\TimerMixin.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var React = _$$_REQUIRE(_dependencyMap[0], "react");

  var factory = _$$_REQUIRE(_dependencyMap[1], "./factory");

  if (typeof React === 'undefined') {
    throw Error('create-react-class could not find the React object. If you are using script tags, ' + 'make sure that React is being loaded before create-react-class.');
  }

  var ReactNoopUpdateQueue = new React.Component().updater;
  module.exports = factory(React.Component, React.isValidElement, ReactNoopUpdateQueue);
},459,[109,460],"node_modules\\create-react-class\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _assign = _$$_REQUIRE(_dependencyMap[0], "object-assign");

  var emptyObject = _$$_REQUIRE(_dependencyMap[1], "fbjs/lib/emptyObject");

  var _invariant = _$$_REQUIRE(_dependencyMap[2], "fbjs/lib/invariant");

  if (process.env.NODE_ENV !== 'production') {
    var warning = _$$_REQUIRE(_dependencyMap[3], "fbjs/lib/warning");
  }

  var MIXINS_KEY = 'mixins';

  function identity(fn) {
    return fn;
  }

  var ReactPropTypeLocationNames;

  if (process.env.NODE_ENV !== 'production') {
    ReactPropTypeLocationNames = {
      prop: 'prop',
      context: 'context',
      childContext: 'child context'
    };
  } else {
    ReactPropTypeLocationNames = {};
  }

  function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
    var injectedMixins = [];
    var ReactClassInterface = {
      mixins: 'DEFINE_MANY',
      statics: 'DEFINE_MANY',
      propTypes: 'DEFINE_MANY',
      contextTypes: 'DEFINE_MANY',
      childContextTypes: 'DEFINE_MANY',
      getDefaultProps: 'DEFINE_MANY_MERGED',
      getInitialState: 'DEFINE_MANY_MERGED',
      getChildContext: 'DEFINE_MANY_MERGED',
      render: 'DEFINE_ONCE',
      componentWillMount: 'DEFINE_MANY',
      componentDidMount: 'DEFINE_MANY',
      componentWillReceiveProps: 'DEFINE_MANY',
      shouldComponentUpdate: 'DEFINE_ONCE',
      componentWillUpdate: 'DEFINE_MANY',
      componentDidUpdate: 'DEFINE_MANY',
      componentWillUnmount: 'DEFINE_MANY',
      UNSAFE_componentWillMount: 'DEFINE_MANY',
      UNSAFE_componentWillReceiveProps: 'DEFINE_MANY',
      UNSAFE_componentWillUpdate: 'DEFINE_MANY',
      updateComponent: 'OVERRIDE_BASE'
    };
    var ReactClassStaticInterface = {
      getDerivedStateFromProps: 'DEFINE_MANY_MERGED'
    };
    var RESERVED_SPEC_KEYS = {
      displayName: function displayName(Constructor, _displayName) {
        Constructor.displayName = _displayName;
      },
      mixins: function mixins(Constructor, _mixins) {
        if (_mixins) {
          for (var i = 0; i < _mixins.length; i++) {
            mixSpecIntoComponent(Constructor, _mixins[i]);
          }
        }
      },
      childContextTypes: function childContextTypes(Constructor, _childContextTypes) {
        if (process.env.NODE_ENV !== 'production') {
          validateTypeDef(Constructor, _childContextTypes, 'childContext');
        }

        Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, _childContextTypes);
      },
      contextTypes: function contextTypes(Constructor, _contextTypes) {
        if (process.env.NODE_ENV !== 'production') {
          validateTypeDef(Constructor, _contextTypes, 'context');
        }

        Constructor.contextTypes = _assign({}, Constructor.contextTypes, _contextTypes);
      },
      getDefaultProps: function getDefaultProps(Constructor, _getDefaultProps) {
        if (Constructor.getDefaultProps) {
          Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, _getDefaultProps);
        } else {
          Constructor.getDefaultProps = _getDefaultProps;
        }
      },
      propTypes: function propTypes(Constructor, _propTypes) {
        if (process.env.NODE_ENV !== 'production') {
          validateTypeDef(Constructor, _propTypes, 'prop');
        }

        Constructor.propTypes = _assign({}, Constructor.propTypes, _propTypes);
      },
      statics: function statics(Constructor, _statics) {
        mixStaticSpecIntoComponent(Constructor, _statics);
      },
      autobind: function autobind() {}
    };

    function validateTypeDef(Constructor, typeDef, location) {
      for (var propName in typeDef) {
        if (typeDef.hasOwnProperty(propName)) {
          if (process.env.NODE_ENV !== 'production') {
            warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName);
          }
        }
      }
    }

    function validateMethodOverride(isAlreadyDefined, name) {
      var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

      if (ReactClassMixin.hasOwnProperty(name)) {
        _invariant(specPolicy === 'OVERRIDE_BASE', 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name);
      }

      if (isAlreadyDefined) {
        _invariant(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED', 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name);
      }
    }

    function mixSpecIntoComponent(Constructor, spec) {
      if (!spec) {
        if (process.env.NODE_ENV !== 'production') {
          var typeofSpec = typeof spec;
          var isMixinValid = typeofSpec === 'object' && spec !== null;

          if (process.env.NODE_ENV !== 'production') {
            warning(isMixinValid, "%s: You're attempting to include a mixin that is either null " + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec);
          }
        }

        return;
      }

      _invariant(typeof spec !== 'function', "ReactClass: You're attempting to " + 'use a component class or function as a mixin. Instead, just use a ' + 'regular object.');

      _invariant(!isValidElement(spec), "ReactClass: You're attempting to " + 'use a component as a mixin. Instead, just use a regular object.');

      var proto = Constructor.prototype;
      var autoBindPairs = proto.__reactAutoBindPairs;

      if (spec.hasOwnProperty(MIXINS_KEY)) {
        RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
      }

      for (var name in spec) {
        if (!spec.hasOwnProperty(name)) {
          continue;
        }

        if (name === MIXINS_KEY) {
          continue;
        }

        var property = spec[name];
        var isAlreadyDefined = proto.hasOwnProperty(name);
        validateMethodOverride(isAlreadyDefined, name);

        if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
          RESERVED_SPEC_KEYS[name](Constructor, property);
        } else {
          var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
          var isFunction = typeof property === 'function';
          var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

          if (shouldAutoBind) {
            autoBindPairs.push(name, property);
            proto[name] = property;
          } else {
            if (isAlreadyDefined) {
              var specPolicy = ReactClassInterface[name];

              _invariant(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY'), 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name);

              if (specPolicy === 'DEFINE_MANY_MERGED') {
                proto[name] = createMergedResultFunction(proto[name], property);
              } else if (specPolicy === 'DEFINE_MANY') {
                proto[name] = createChainedFunction(proto[name], property);
              }
            } else {
              proto[name] = property;

              if (process.env.NODE_ENV !== 'production') {
                if (typeof property === 'function' && spec.displayName) {
                  proto[name].displayName = spec.displayName + '_' + name;
                }
              }
            }
          }
        }
      }
    }

    function mixStaticSpecIntoComponent(Constructor, statics) {
      if (!statics) {
        return;
      }

      for (var name in statics) {
        var property = statics[name];

        if (!statics.hasOwnProperty(name)) {
          continue;
        }

        var isReserved = name in RESERVED_SPEC_KEYS;

        _invariant(!isReserved, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name);

        var isAlreadyDefined = name in Constructor;

        if (isAlreadyDefined) {
          var specPolicy = ReactClassStaticInterface.hasOwnProperty(name) ? ReactClassStaticInterface[name] : null;

          _invariant(specPolicy === 'DEFINE_MANY_MERGED', 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name);

          Constructor[name] = createMergedResultFunction(Constructor[name], property);
          return;
        }

        Constructor[name] = property;
      }
    }

    function mergeIntoWithNoDuplicateKeys(one, two) {
      _invariant(one && two && typeof one === 'object' && typeof two === 'object', 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.');

      for (var key in two) {
        if (two.hasOwnProperty(key)) {
          _invariant(one[key] === undefined, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key);

          one[key] = two[key];
        }
      }

      return one;
    }

    function createMergedResultFunction(one, two) {
      return function mergedResult() {
        var a = one.apply(this, arguments);
        var b = two.apply(this, arguments);

        if (a == null) {
          return b;
        } else if (b == null) {
          return a;
        }

        var c = {};
        mergeIntoWithNoDuplicateKeys(c, a);
        mergeIntoWithNoDuplicateKeys(c, b);
        return c;
      };
    }

    function createChainedFunction(one, two) {
      return function chainedFunction() {
        one.apply(this, arguments);
        two.apply(this, arguments);
      };
    }

    function bindAutoBindMethod(component, method) {
      var boundMethod = method.bind(component);

      if (process.env.NODE_ENV !== 'production') {
        boundMethod.__reactBoundContext = component;
        boundMethod.__reactBoundMethod = method;
        boundMethod.__reactBoundArguments = null;
        var componentName = component.constructor.displayName;
        var _bind = boundMethod.bind;

        boundMethod.bind = function (newThis) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          if (newThis !== component && newThis !== null) {
            if (process.env.NODE_ENV !== 'production') {
              warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName);
            }
          } else if (!args.length) {
            if (process.env.NODE_ENV !== 'production') {
              warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName);
            }

            return boundMethod;
          }

          var reboundMethod = _bind.apply(boundMethod, arguments);

          reboundMethod.__reactBoundContext = component;
          reboundMethod.__reactBoundMethod = method;
          reboundMethod.__reactBoundArguments = args;
          return reboundMethod;
        };
      }

      return boundMethod;
    }

    function bindAutoBindMethods(component) {
      var pairs = component.__reactAutoBindPairs;

      for (var i = 0; i < pairs.length; i += 2) {
        var autoBindKey = pairs[i];
        var method = pairs[i + 1];
        component[autoBindKey] = bindAutoBindMethod(component, method);
      }
    }

    var IsMountedPreMixin = {
      componentDidMount: function componentDidMount() {
        this.__isMounted = true;
      }
    };
    var IsMountedPostMixin = {
      componentWillUnmount: function componentWillUnmount() {
        this.__isMounted = false;
      }
    };
    var ReactClassMixin = {
      replaceState: function replaceState(newState, callback) {
        this.updater.enqueueReplaceState(this, newState, callback);
      },
      isMounted: function isMounted() {
        if (process.env.NODE_ENV !== 'production') {
          warning(this.__didWarnIsMounted, '%s: isMounted is deprecated. Instead, make sure to clean up ' + 'subscriptions and pending requests in componentWillUnmount to ' + 'prevent memory leaks.', this.constructor && this.constructor.displayName || this.name || 'Component');
          this.__didWarnIsMounted = true;
        }

        return !!this.__isMounted;
      }
    };

    var ReactClassComponent = function ReactClassComponent() {};

    _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

    function createClass(spec) {
      var Constructor = identity(function (props, context, updater) {
        if (process.env.NODE_ENV !== 'production') {
          warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory');
        }

        if (this.__reactAutoBindPairs.length) {
          bindAutoBindMethods(this);
        }

        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
        this.state = null;
        var initialState = this.getInitialState ? this.getInitialState() : null;

        if (process.env.NODE_ENV !== 'production') {
          if (initialState === undefined && this.getInitialState._isMockFunction) {
            initialState = null;
          }
        }

        _invariant(typeof initialState === 'object' && !Array.isArray(initialState), '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent');

        this.state = initialState;
      });
      Constructor.prototype = new ReactClassComponent();
      Constructor.prototype.constructor = Constructor;
      Constructor.prototype.__reactAutoBindPairs = [];
      injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
      mixSpecIntoComponent(Constructor, IsMountedPreMixin);
      mixSpecIntoComponent(Constructor, spec);
      mixSpecIntoComponent(Constructor, IsMountedPostMixin);

      if (Constructor.getDefaultProps) {
        Constructor.defaultProps = Constructor.getDefaultProps();
      }

      if (process.env.NODE_ENV !== 'production') {
        if (Constructor.getDefaultProps) {
          Constructor.getDefaultProps.isReactClassApproved = {};
        }

        if (Constructor.prototype.getInitialState) {
          Constructor.prototype.getInitialState.isReactClassApproved = {};
        }
      }

      _invariant(Constructor.prototype.render, 'createClass(...): Class specification must implement a `render` method.');

      if (process.env.NODE_ENV !== 'production') {
        warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component');
        warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component');
        warning(!Constructor.prototype.UNSAFE_componentWillRecieveProps, '%s has a method called UNSAFE_componentWillRecieveProps(). ' + 'Did you mean UNSAFE_componentWillReceiveProps()?', spec.displayName || 'A component');
      }

      for (var methodName in ReactClassInterface) {
        if (!Constructor.prototype[methodName]) {
          Constructor.prototype[methodName] = null;
        }
      }

      return Constructor;
    }

    return createClass;
  }

  module.exports = factory;
},460,[111,461,462,463],"node_modules\\create-react-class\\factory.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var emptyObject = {};

  if (process.env.NODE_ENV !== 'production') {
    Object.freeze(emptyObject);
  }

  module.exports = emptyObject;
},461,[],"node_modules\\create-react-class\\node_modules\\fbjs\\lib\\emptyObject.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var validateFormat = function validateFormat(format) {};

  if (process.env.NODE_ENV !== 'production') {
    validateFormat = function validateFormat(format) {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    };
  }

  function invariant(condition, format, a, b, c, d, e, f) {
    validateFormat(format);

    if (!condition) {
      var error;

      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1;
      throw error;
    }
  }

  module.exports = invariant;
},462,[],"node_modules\\create-react-class\\node_modules\\fbjs\\lib\\invariant.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var emptyFunction = _$$_REQUIRE(_dependencyMap[0], "./emptyFunction");

  var warning = emptyFunction;

  if (process.env.NODE_ENV !== 'production') {
    var printWarning = function printWarning(format) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });

      if (typeof console !== 'undefined') {
        console.error(message);
      }

      try {
        throw new Error(message);
      } catch (x) {}
    };

    warning = function warning(condition, format) {
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }

      if (format.indexOf('Failed Composite propType: ') === 0) {
        return;
      }

      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        printWarning.apply(undefined, [format].concat(args));
      }
    };
  }

  module.exports = warning;
},463,[464],"node_modules\\create-react-class\\node_modules\\fbjs\\lib\\warning.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  function makeEmptyFunction(arg) {
    return function () {
      return arg;
    };
  }

  var emptyFunction = function emptyFunction() {};

  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);

  emptyFunction.thatReturnsThis = function () {
    return this;
  };

  emptyFunction.thatReturnsArgument = function (arg) {
    return arg;
  };

  module.exports = emptyFunction;
},464,[],"node_modules\\create-react-class\\node_modules\\fbjs\\lib\\emptyFunction.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var invariant = _$$_REQUIRE(_dependencyMap[0], "fbjs/lib/invariant");

  var ensurePositiveDelayProps = function ensurePositiveDelayProps(props) {
    invariant(!(props.delayPressIn < 0 || props.delayPressOut < 0 || props.delayLongPress < 0), 'Touchable components cannot have negative delay properties');
  };

  module.exports = ensurePositiveDelayProps;
},465,[117],"node_modules\\react-native\\Libraries\\Components\\Touchable\\ensurePositiveDelayProps.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = {
    AccessibilityTraits: ['none', 'button', 'link', 'header', 'search', 'image', 'selected', 'plays', 'key', 'text', 'summary', 'disabled', 'frequentUpdates', 'startsMedia', 'adjustable', 'allowsDirectInteraction', 'pageTurn'],
    AccessibilityComponentTypes: ['none', 'button', 'radiobutton_checked', 'radiobutton_unchecked'],
    AccessibilityRoles: ['none', 'button', 'link', 'search', 'image', 'keyboardkey', 'text', 'adjustable', 'imagebutton', 'header', 'summary'],
    AccessibilityStates: ['selected', 'disabled']
  };
},466,[],"node_modules\\react-native\\Libraries\\Components\\View\\ViewAccessibility.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\Touchable\\TouchableOpacity.js";

  var Animated = _$$_REQUIRE(_dependencyMap[1], "Animated");

  var Easing = _$$_REQUIRE(_dependencyMap[2], "Easing");

  var NativeMethodsMixin = _$$_REQUIRE(_dependencyMap[3], "NativeMethodsMixin");

  var React = _$$_REQUIRE(_dependencyMap[4], "React");

  var PropTypes = _$$_REQUIRE(_dependencyMap[5], "prop-types");

  var TimerMixin = _$$_REQUIRE(_dependencyMap[6], "react-timer-mixin");

  var Touchable = _$$_REQUIRE(_dependencyMap[7], "Touchable");

  var TouchableWithoutFeedback = _$$_REQUIRE(_dependencyMap[8], "TouchableWithoutFeedback");

  var createReactClass = _$$_REQUIRE(_dependencyMap[9], "create-react-class");

  var ensurePositiveDelayProps = _$$_REQUIRE(_dependencyMap[10], "ensurePositiveDelayProps");

  var flattenStyle = _$$_REQUIRE(_dependencyMap[11], "flattenStyle");

  var PRESS_RETENTION_OFFSET = {
    top: 20,
    left: 20,
    right: 20,
    bottom: 30
  };
  var TouchableOpacity = createReactClass({
    displayName: 'TouchableOpacity',
    mixins: [TimerMixin, Touchable.Mixin, NativeMethodsMixin],
    propTypes: _objectSpread({}, TouchableWithoutFeedback.propTypes, {
      activeOpacity: PropTypes.number,
      hasTVPreferredFocus: PropTypes.bool,
      tvParallaxProperties: PropTypes.object
    }),
    getDefaultProps: function getDefaultProps() {
      return {
        activeOpacity: 0.2
      };
    },
    getInitialState: function getInitialState() {
      return _objectSpread({}, this.touchableGetInitialState(), {
        anim: new Animated.Value(this._getChildStyleOpacityWithDefault())
      });
    },
    componentDidMount: function componentDidMount() {
      ensurePositiveDelayProps(this.props);
    },
    UNSAFE_componentWillReceiveProps: function UNSAFE_componentWillReceiveProps(nextProps) {
      ensurePositiveDelayProps(nextProps);
    },
    componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
      if (this.props.disabled !== prevProps.disabled) {
        this._opacityInactive(250);
      }
    },
    setOpacityTo: function setOpacityTo(value, duration) {
      Animated.timing(this.state.anim, {
        toValue: value,
        duration: duration,
        easing: Easing.inOut(Easing.quad),
        useNativeDriver: true
      }).start();
    },
    touchableHandleActivePressIn: function touchableHandleActivePressIn(e) {
      if (e.dispatchConfig.registrationName === 'onResponderGrant') {
        this._opacityActive(0);
      } else {
        this._opacityActive(150);
      }

      this.props.onPressIn && this.props.onPressIn(e);
    },
    touchableHandleActivePressOut: function touchableHandleActivePressOut(e) {
      this._opacityInactive(250);

      this.props.onPressOut && this.props.onPressOut(e);
    },
    touchableHandlePress: function touchableHandlePress(e) {
      this.props.onPress && this.props.onPress(e);
    },
    touchableHandleLongPress: function touchableHandleLongPress(e) {
      this.props.onLongPress && this.props.onLongPress(e);
    },
    touchableGetPressRectOffset: function touchableGetPressRectOffset() {
      return this.props.pressRetentionOffset || PRESS_RETENTION_OFFSET;
    },
    touchableGetHitSlop: function touchableGetHitSlop() {
      return this.props.hitSlop;
    },
    touchableGetHighlightDelayMS: function touchableGetHighlightDelayMS() {
      return this.props.delayPressIn || 0;
    },
    touchableGetLongPressDelayMS: function touchableGetLongPressDelayMS() {
      return this.props.delayLongPress === 0 ? 0 : this.props.delayLongPress || 500;
    },
    touchableGetPressOutDelayMS: function touchableGetPressOutDelayMS() {
      return this.props.delayPressOut;
    },
    _opacityActive: function _opacityActive(duration) {
      this.setOpacityTo(this.props.activeOpacity, duration);
    },
    _opacityInactive: function _opacityInactive(duration) {
      this.setOpacityTo(this._getChildStyleOpacityWithDefault(), duration);
    },
    _getChildStyleOpacityWithDefault: function _getChildStyleOpacityWithDefault() {
      var childStyle = flattenStyle(this.props.style) || {};
      return childStyle.opacity == undefined ? 1 : childStyle.opacity;
    },
    render: function render() {
      return React.createElement(Animated.View, {
        accessible: this.props.accessible !== false,
        accessibilityLabel: this.props.accessibilityLabel,
        accessibilityHint: this.props.accessibilityHint,
        accessibilityRole: this.props.accessibilityRole,
        accessibilityStates: this.props.accessibilityStates,
        style: [this.props.style, {
          opacity: this.state.anim
        }],
        nativeID: this.props.nativeID,
        testID: this.props.testID,
        onLayout: this.props.onLayout,
        isTVSelectable: true,
        hasTVPreferredFocus: this.props.hasTVPreferredFocus,
        tvParallaxProperties: this.props.tvParallaxProperties,
        hitSlop: this.props.hitSlop,
        onStartShouldSetResponder: this.touchableHandleStartShouldSetResponder,
        onResponderTerminationRequest: this.touchableHandleResponderTerminationRequest,
        onResponderGrant: this.touchableHandleResponderGrant,
        onResponderMove: this.touchableHandleResponderMove,
        onResponderRelease: this.touchableHandleResponderRelease,
        onResponderTerminate: this.touchableHandleResponderTerminate,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 256
        }
      }, this.props.children, Touchable.renderDebugView({
        color: 'cyan',
        hitSlop: this.props.hitSlop
      }));
    }
  });
  module.exports = TouchableOpacity;
},467,[148,468,494,527,149,161,458,449,457,459,465,174],"node_modules\\react-native\\Libraries\\Components\\Touchable\\TouchableOpacity.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var AnimatedImplementation = _$$_REQUIRE(_dependencyMap[1], "AnimatedImplementation");

  var FlatList = _$$_REQUIRE(_dependencyMap[2], "FlatList");

  var Image = _$$_REQUIRE(_dependencyMap[3], "Image");

  var ScrollView = _$$_REQUIRE(_dependencyMap[4], "ScrollView");

  var SectionList = _$$_REQUIRE(_dependencyMap[5], "SectionList");

  var Text = _$$_REQUIRE(_dependencyMap[6], "Text");

  var View = _$$_REQUIRE(_dependencyMap[7], "View");

  module.exports = _objectSpread({}, AnimatedImplementation, {
    View: AnimatedImplementation.createAnimatedComponent(View),
    Text: AnimatedImplementation.createAnimatedComponent(Text),
    Image: AnimatedImplementation.createAnimatedComponent(Image),
    ScrollView: AnimatedImplementation.createAnimatedComponent(ScrollView),
    FlatList: AnimatedImplementation.createAnimatedComponent(FlatList),
    SectionList: AnimatedImplementation.createAnimatedComponent(SectionList)
  });
},468,[148,469,497,521,503,525,444,175],"node_modules\\react-native\\Libraries\\Animated\\src\\Animated.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var _require = _$$_REQUIRE(_dependencyMap[1], "./AnimatedEvent"),
      AnimatedEvent = _require.AnimatedEvent,
      attachNativeEvent = _require.attachNativeEvent;

  var AnimatedAddition = _$$_REQUIRE(_dependencyMap[2], "./nodes/AnimatedAddition");

  var AnimatedDiffClamp = _$$_REQUIRE(_dependencyMap[3], "./nodes/AnimatedDiffClamp");

  var AnimatedDivision = _$$_REQUIRE(_dependencyMap[4], "./nodes/AnimatedDivision");

  var AnimatedInterpolation = _$$_REQUIRE(_dependencyMap[5], "./nodes/AnimatedInterpolation");

  var AnimatedModulo = _$$_REQUIRE(_dependencyMap[6], "./nodes/AnimatedModulo");

  var AnimatedMultiplication = _$$_REQUIRE(_dependencyMap[7], "./nodes/AnimatedMultiplication");

  var AnimatedNode = _$$_REQUIRE(_dependencyMap[8], "./nodes/AnimatedNode");

  var AnimatedProps = _$$_REQUIRE(_dependencyMap[9], "./nodes/AnimatedProps");

  var AnimatedSubtraction = _$$_REQUIRE(_dependencyMap[10], "./nodes/AnimatedSubtraction");

  var AnimatedTracking = _$$_REQUIRE(_dependencyMap[11], "./nodes/AnimatedTracking");

  var AnimatedValue = _$$_REQUIRE(_dependencyMap[12], "./nodes/AnimatedValue");

  var AnimatedValueXY = _$$_REQUIRE(_dependencyMap[13], "./nodes/AnimatedValueXY");

  var DecayAnimation = _$$_REQUIRE(_dependencyMap[14], "./animations/DecayAnimation");

  var SpringAnimation = _$$_REQUIRE(_dependencyMap[15], "./animations/SpringAnimation");

  var TimingAnimation = _$$_REQUIRE(_dependencyMap[16], "./animations/TimingAnimation");

  var createAnimatedComponent = _$$_REQUIRE(_dependencyMap[17], "./createAnimatedComponent");

  var add = function add(a, b) {
    return new AnimatedAddition(a, b);
  };

  var subtract = function subtract(a, b) {
    return new AnimatedSubtraction(a, b);
  };

  var divide = function divide(a, b) {
    return new AnimatedDivision(a, b);
  };

  var multiply = function multiply(a, b) {
    return new AnimatedMultiplication(a, b);
  };

  var modulo = function modulo(a, modulus) {
    return new AnimatedModulo(a, modulus);
  };

  var diffClamp = function diffClamp(a, min, max) {
    return new AnimatedDiffClamp(a, min, max);
  };

  var _combineCallbacks = function _combineCallbacks(callback, config) {
    if (callback && config.onComplete) {
      return function () {
        config.onComplete && config.onComplete.apply(config, arguments);
        callback && callback.apply(void 0, arguments);
      };
    } else {
      return callback || config.onComplete;
    }
  };

  var maybeVectorAnim = function maybeVectorAnim(value, config, anim) {
    if (value instanceof AnimatedValueXY) {
      var configX = _objectSpread({}, config);

      var configY = _objectSpread({}, config);

      for (var key in config) {
        var _config$key = config[key],
            x = _config$key.x,
            y = _config$key.y;

        if (x !== undefined && y !== undefined) {
          configX[key] = x;
          configY[key] = y;
        }
      }

      var aX = anim(value.x, configX);
      var aY = anim(value.y, configY);
      return parallel([aX, aY], {
        stopTogether: false
      });
    }

    return null;
  };

  var spring = function spring(value, config) {
    var _start = function start(animatedValue, configuration, callback) {
      callback = _combineCallbacks(callback, configuration);
      var singleValue = animatedValue;
      var singleConfig = configuration;
      singleValue.stopTracking();

      if (configuration.toValue instanceof AnimatedNode) {
        singleValue.track(new AnimatedTracking(singleValue, configuration.toValue, SpringAnimation, singleConfig, callback));
      } else {
        singleValue.animate(new SpringAnimation(singleConfig), callback);
      }
    };

    return maybeVectorAnim(value, config, spring) || {
      start: function start(callback) {
        _start(value, config, callback);
      },
      stop: function stop() {
        value.stopAnimation();
      },
      reset: function reset() {
        value.resetAnimation();
      },
      _startNativeLoop: function _startNativeLoop(iterations) {
        var singleConfig = _objectSpread({}, config, {
          iterations: iterations
        });

        _start(value, singleConfig);
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return config.useNativeDriver || false;
      }
    };
  };

  var timing = function timing(value, config) {
    var _start2 = function start(animatedValue, configuration, callback) {
      callback = _combineCallbacks(callback, configuration);
      var singleValue = animatedValue;
      var singleConfig = configuration;
      singleValue.stopTracking();

      if (configuration.toValue instanceof AnimatedNode) {
        singleValue.track(new AnimatedTracking(singleValue, configuration.toValue, TimingAnimation, singleConfig, callback));
      } else {
        singleValue.animate(new TimingAnimation(singleConfig), callback);
      }
    };

    return maybeVectorAnim(value, config, timing) || {
      start: function start(callback) {
        _start2(value, config, callback);
      },
      stop: function stop() {
        value.stopAnimation();
      },
      reset: function reset() {
        value.resetAnimation();
      },
      _startNativeLoop: function _startNativeLoop(iterations) {
        var singleConfig = _objectSpread({}, config, {
          iterations: iterations
        });

        _start2(value, singleConfig);
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return config.useNativeDriver || false;
      }
    };
  };

  var decay = function decay(value, config) {
    var _start3 = function start(animatedValue, configuration, callback) {
      callback = _combineCallbacks(callback, configuration);
      var singleValue = animatedValue;
      var singleConfig = configuration;
      singleValue.stopTracking();
      singleValue.animate(new DecayAnimation(singleConfig), callback);
    };

    return maybeVectorAnim(value, config, decay) || {
      start: function start(callback) {
        _start3(value, config, callback);
      },
      stop: function stop() {
        value.stopAnimation();
      },
      reset: function reset() {
        value.resetAnimation();
      },
      _startNativeLoop: function _startNativeLoop(iterations) {
        var singleConfig = _objectSpread({}, config, {
          iterations: iterations
        });

        _start3(value, singleConfig);
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return config.useNativeDriver || false;
      }
    };
  };

  var sequence = function sequence(animations) {
    var current = 0;
    return {
      start: function start(callback) {
        var onComplete = function onComplete(result) {
          if (!result.finished) {
            callback && callback(result);
            return;
          }

          current++;

          if (current === animations.length) {
            callback && callback(result);
            return;
          }

          animations[current].start(onComplete);
        };

        if (animations.length === 0) {
          callback && callback({
            finished: true
          });
        } else {
          animations[current].start(onComplete);
        }
      },
      stop: function stop() {
        if (current < animations.length) {
          animations[current].stop();
        }
      },
      reset: function reset() {
        animations.forEach(function (animation, idx) {
          if (idx <= current) {
            animation.reset();
          }
        });
        current = 0;
      },
      _startNativeLoop: function _startNativeLoop() {
        throw new Error('Loops run using the native driver cannot contain Animated.sequence animations');
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return false;
      }
    };
  };

  var parallel = function parallel(animations, config) {
    var doneCount = 0;
    var hasEnded = {};
    var stopTogether = !(config && config.stopTogether === false);
    var result = {
      start: function start(callback) {
        if (doneCount === animations.length) {
          callback && callback({
            finished: true
          });
          return;
        }

        animations.forEach(function (animation, idx) {
          var cb = function cb(endResult) {
            hasEnded[idx] = true;
            doneCount++;

            if (doneCount === animations.length) {
              doneCount = 0;
              callback && callback(endResult);
              return;
            }

            if (!endResult.finished && stopTogether) {
              result.stop();
            }
          };

          if (!animation) {
            cb({
              finished: true
            });
          } else {
            animation.start(cb);
          }
        });
      },
      stop: function stop() {
        animations.forEach(function (animation, idx) {
          !hasEnded[idx] && animation.stop();
          hasEnded[idx] = true;
        });
      },
      reset: function reset() {
        animations.forEach(function (animation, idx) {
          animation.reset();
          hasEnded[idx] = false;
          doneCount = 0;
        });
      },
      _startNativeLoop: function _startNativeLoop() {
        throw new Error('Loops run using the native driver cannot contain Animated.parallel animations');
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return false;
      }
    };
    return result;
  };

  var delay = function delay(time) {
    return timing(new AnimatedValue(0), {
      toValue: 0,
      delay: time,
      duration: 0
    });
  };

  var stagger = function stagger(time, animations) {
    return parallel(animations.map(function (animation, i) {
      return sequence([delay(time * i), animation]);
    }));
  };

  var loop = function loop(animation) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$iterations = _ref.iterations,
        iterations = _ref$iterations === void 0 ? -1 : _ref$iterations;

    var isFinished = false;
    var iterationsSoFar = 0;
    return {
      start: function start(callback) {
        var restart = function restart() {
          var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            finished: true
          };

          if (isFinished || iterationsSoFar === iterations || result.finished === false) {
            callback && callback(result);
          } else {
            iterationsSoFar++;
            animation.reset();
            animation.start(restart);
          }
        };

        if (!animation || iterations === 0) {
          callback && callback({
            finished: true
          });
        } else {
          if (animation._isUsingNativeDriver()) {
            animation._startNativeLoop(iterations);
          } else {
            restart();
          }
        }
      },
      stop: function stop() {
        isFinished = true;
        animation.stop();
      },
      reset: function reset() {
        iterationsSoFar = 0;
        isFinished = false;
        animation.reset();
      },
      _startNativeLoop: function _startNativeLoop() {
        throw new Error('Loops run using the native driver cannot contain Animated.loop animations');
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return animation._isUsingNativeDriver();
      }
    };
  };

  function forkEvent(event, listener) {
    if (!event) {
      return listener;
    } else if (event instanceof AnimatedEvent) {
      event.__addListener(listener);

      return event;
    } else {
      return function () {
        typeof event === 'function' && event.apply(void 0, arguments);
        listener.apply(void 0, arguments);
      };
    }
  }

  function unforkEvent(event, listener) {
    if (event && event instanceof AnimatedEvent) {
      event.__removeListener(listener);
    }
  }

  var event = function event(argMapping, config) {
    var animatedEvent = new AnimatedEvent(argMapping, config);

    if (animatedEvent.__isNative) {
      return animatedEvent;
    } else {
      return animatedEvent.__getHandler();
    }
  };

  module.exports = {
    Value: AnimatedValue,
    ValueXY: AnimatedValueXY,
    Interpolation: AnimatedInterpolation,
    Node: AnimatedNode,
    decay: decay,
    timing: timing,
    spring: spring,
    add: add,
    subtract: subtract,
    divide: divide,
    multiply: multiply,
    modulo: modulo,
    diffClamp: diffClamp,
    delay: delay,
    sequence: sequence,
    parallel: parallel,
    stagger: stagger,
    loop: loop,
    event: event,
    createAnimatedComponent: createAnimatedComponent,
    attachNativeEvent: attachNativeEvent,
    forkEvent: forkEvent,
    unforkEvent: unforkEvent,
    __PropsOnlyForTests: AnimatedProps
  };
},469,[148,470,478,479,480,472,481,482,473,483,486,487,471,488,489,491,493,496],"node_modules\\react-native\\Libraries\\Animated\\src\\AnimatedImplementation.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/defineProperty");

  var AnimatedValue = _$$_REQUIRE(_dependencyMap[3], "./nodes/AnimatedValue");

  var NativeAnimatedHelper = _$$_REQUIRE(_dependencyMap[4], "./NativeAnimatedHelper");

  var ReactNative = _$$_REQUIRE(_dependencyMap[5], "ReactNative");

  var invariant = _$$_REQUIRE(_dependencyMap[6], "fbjs/lib/invariant");

  var _require = _$$_REQUIRE(_dependencyMap[4], "./NativeAnimatedHelper"),
      shouldUseNativeDriver = _require.shouldUseNativeDriver;

  function attachNativeEvent(viewRef, eventName, argMapping) {
    var eventMappings = [];

    var traverse = function traverse(value, path) {
      if (value instanceof AnimatedValue) {
        value.__makeNative();

        eventMappings.push({
          nativeEventPath: path,
          animatedValueTag: value.__getNativeTag()
        });
      } else if (typeof value === 'object') {
        for (var _key in value) {
          traverse(value[_key], path.concat(_key));
        }
      }
    };

    invariant(argMapping[0] && argMapping[0].nativeEvent, 'Native driven events only support animated values contained inside `nativeEvent`.');
    traverse(argMapping[0].nativeEvent, []);
    var viewTag = ReactNative.findNodeHandle(viewRef);
    eventMappings.forEach(function (mapping) {
      NativeAnimatedHelper.API.addAnimatedEventToView(viewTag, eventName, mapping);
    });
    return {
      detach: function detach() {
        eventMappings.forEach(function (mapping) {
          NativeAnimatedHelper.API.removeAnimatedEventFromView(viewTag, eventName, mapping.animatedValueTag);
        });
      }
    };
  }

  var AnimatedEvent = function () {
    function AnimatedEvent(argMapping) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, AnimatedEvent);

      _defineProperty(this, "_argMapping", void 0);

      _defineProperty(this, "_listeners", []);

      _defineProperty(this, "_callListeners", void 0);

      _defineProperty(this, "_attachedEvent", void 0);

      _defineProperty(this, "__isNative", void 0);

      this._argMapping = argMapping;

      if (config.listener) {
        this.__addListener(config.listener);
      }

      this._callListeners = this._callListeners.bind(this);
      this._attachedEvent = null;
      this.__isNative = shouldUseNativeDriver(config);

      if (__DEV__) {
        this._validateMapping();
      }
    }

    _createClass(AnimatedEvent, [{
      key: "__addListener",
      value: function __addListener(callback) {
        this._listeners.push(callback);
      }
    }, {
      key: "__removeListener",
      value: function __removeListener(callback) {
        this._listeners = this._listeners.filter(function (listener) {
          return listener !== callback;
        });
      }
    }, {
      key: "__attach",
      value: function __attach(viewRef, eventName) {
        invariant(this.__isNative, 'Only native driven events need to be attached.');
        this._attachedEvent = attachNativeEvent(viewRef, eventName, this._argMapping);
      }
    }, {
      key: "__detach",
      value: function __detach(viewTag, eventName) {
        invariant(this.__isNative, 'Only native driven events need to be detached.');
        this._attachedEvent && this._attachedEvent.detach();
      }
    }, {
      key: "__getHandler",
      value: function __getHandler() {
        var _this = this;

        if (this.__isNative) {
          return this._callListeners;
        }

        return function () {
          for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
            args[_key2] = arguments[_key2];
          }

          var traverse = function traverse(recMapping, recEvt, key) {
            if (typeof recEvt === 'number' && recMapping instanceof AnimatedValue) {
              recMapping.setValue(recEvt);
            } else if (typeof recMapping === 'object') {
              for (var mappingKey in recMapping) {
                traverse(recMapping[mappingKey], recEvt[mappingKey], mappingKey);
              }
            }
          };

          if (!_this.__isNative) {
            _this._argMapping.forEach(function (mapping, idx) {
              traverse(mapping, args[idx], 'arg' + idx);
            });
          }

          _this._callListeners.apply(_this, args);
        };
      }
    }, {
      key: "_callListeners",
      value: function _callListeners() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
          args[_key3] = arguments[_key3];
        }

        this._listeners.forEach(function (listener) {
          return listener.apply(void 0, args);
        });
      }
    }, {
      key: "_validateMapping",
      value: function _validateMapping() {
        var traverse = function traverse(recMapping, recEvt, key) {
          if (typeof recEvt === 'number') {
            invariant(recMapping instanceof AnimatedValue, 'Bad mapping of type ' + typeof recMapping + ' for key ' + key + ', event value must map to AnimatedValue');
            return;
          }

          invariant(typeof recMapping === 'object', 'Bad mapping of type ' + typeof recMapping + ' for key ' + key);
          invariant(typeof recEvt === 'object', 'Bad event of type ' + typeof recEvt + ' for key ' + key);

          for (var mappingKey in recMapping) {
            traverse(recMapping[mappingKey], recEvt[mappingKey], mappingKey);
          }
        };
      }
    }]);

    return AnimatedEvent;
  }();

  module.exports = {
    AnimatedEvent: AnimatedEvent,
    attachNativeEvent: attachNativeEvent
  };
},470,[24,25,32,471,474,178,117],"node_modules\\react-native\\Libraries\\Animated\\src\\AnimatedEvent.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _get = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/get");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var AnimatedInterpolation = _$$_REQUIRE(_dependencyMap[8], "./AnimatedInterpolation");

  var AnimatedNode = _$$_REQUIRE(_dependencyMap[9], "./AnimatedNode");

  var AnimatedWithChildren = _$$_REQUIRE(_dependencyMap[10], "./AnimatedWithChildren");

  var InteractionManager = _$$_REQUIRE(_dependencyMap[11], "InteractionManager");

  var NativeAnimatedHelper = _$$_REQUIRE(_dependencyMap[12], "../NativeAnimatedHelper");

  var NativeAnimatedAPI = NativeAnimatedHelper.API;
  var _uniqueId = 1;

  function _flush(rootNode) {
    var animatedStyles = new Set();

    function findAnimatedStyles(node) {
      if (typeof node.update === 'function') {
        animatedStyles.add(node);
      } else {
        node.__getChildren().forEach(findAnimatedStyles);
      }
    }

    findAnimatedStyles(rootNode);
    animatedStyles.forEach(function (animatedStyle) {
      return animatedStyle.update();
    });
  }

  var AnimatedValue = function (_AnimatedWithChildren) {
    _inherits(AnimatedValue, _AnimatedWithChildren);

    function AnimatedValue(value) {
      var _this;

      _classCallCheck(this, AnimatedValue);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedValue).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_value", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_startingValue", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_offset", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_animation", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_tracking", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_listeners", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "__nativeAnimatedValueListener", void 0);

      _this._startingValue = _this._value = value;
      _this._offset = 0;
      _this._animation = null;
      _this._listeners = {};
      return _this;
    }

    _createClass(AnimatedValue, [{
      key: "__detach",
      value: function __detach() {
        this.stopAnimation();

        _get(_getPrototypeOf(AnimatedValue.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._value + this._offset;
      }
    }, {
      key: "__makeNative",
      value: function __makeNative() {
        _get(_getPrototypeOf(AnimatedValue.prototype), "__makeNative", this).call(this);

        if (Object.keys(this._listeners).length) {
          this._startListeningToNativeValueUpdates();
        }
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        if (this._animation) {
          this._animation.stop();

          this._animation = null;
        }

        this._updateValue(value, !this.__isNative);

        if (this.__isNative) {
          NativeAnimatedAPI.setAnimatedNodeValue(this.__getNativeTag(), value);
        }
      }
    }, {
      key: "setOffset",
      value: function setOffset(offset) {
        this._offset = offset;

        if (this.__isNative) {
          NativeAnimatedAPI.setAnimatedNodeOffset(this.__getNativeTag(), offset);
        }
      }
    }, {
      key: "flattenOffset",
      value: function flattenOffset() {
        this._value += this._offset;
        this._offset = 0;

        if (this.__isNative) {
          NativeAnimatedAPI.flattenAnimatedNodeOffset(this.__getNativeTag());
        }
      }
    }, {
      key: "extractOffset",
      value: function extractOffset() {
        this._offset += this._value;
        this._value = 0;

        if (this.__isNative) {
          NativeAnimatedAPI.extractAnimatedNodeOffset(this.__getNativeTag());
        }
      }
    }, {
      key: "addListener",
      value: function addListener(callback) {
        var id = String(_uniqueId++);
        this._listeners[id] = callback;

        if (this.__isNative) {
          this._startListeningToNativeValueUpdates();
        }

        return id;
      }
    }, {
      key: "removeListener",
      value: function removeListener(id) {
        delete this._listeners[id];

        if (this.__isNative && Object.keys(this._listeners).length === 0) {
          this._stopListeningForNativeValueUpdates();
        }
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners() {
        this._listeners = {};

        if (this.__isNative) {
          this._stopListeningForNativeValueUpdates();
        }
      }
    }, {
      key: "_startListeningToNativeValueUpdates",
      value: function _startListeningToNativeValueUpdates() {
        var _this2 = this;

        if (this.__nativeAnimatedValueListener) {
          return;
        }

        NativeAnimatedAPI.startListeningToAnimatedNodeValue(this.__getNativeTag());
        this.__nativeAnimatedValueListener = NativeAnimatedHelper.nativeEventEmitter.addListener('onAnimatedValueUpdate', function (data) {
          if (data.tag !== _this2.__getNativeTag()) {
            return;
          }

          _this2._updateValue(data.value, false);
        });
      }
    }, {
      key: "_stopListeningForNativeValueUpdates",
      value: function _stopListeningForNativeValueUpdates() {
        if (!this.__nativeAnimatedValueListener) {
          return;
        }

        this.__nativeAnimatedValueListener.remove();

        this.__nativeAnimatedValueListener = null;
        NativeAnimatedAPI.stopListeningToAnimatedNodeValue(this.__getNativeTag());
      }
    }, {
      key: "stopAnimation",
      value: function stopAnimation(callback) {
        this.stopTracking();
        this._animation && this._animation.stop();
        this._animation = null;
        callback && callback(this.__getValue());
      }
    }, {
      key: "resetAnimation",
      value: function resetAnimation(callback) {
        this.stopAnimation(callback);
        this._value = this._startingValue;
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new AnimatedInterpolation(this, config);
      }
    }, {
      key: "animate",
      value: function animate(animation, callback) {
        var _this3 = this;

        var handle = null;

        if (animation.__isInteraction) {
          handle = InteractionManager.createInteractionHandle();
        }

        var previousAnimation = this._animation;
        this._animation && this._animation.stop();
        this._animation = animation;
        animation.start(this._value, function (value) {
          _this3._updateValue(value, true);
        }, function (result) {
          _this3._animation = null;

          if (handle !== null) {
            InteractionManager.clearInteractionHandle(handle);
          }

          callback && callback(result);
        }, previousAnimation, this);
      }
    }, {
      key: "stopTracking",
      value: function stopTracking() {
        this._tracking && this._tracking.__detach();
        this._tracking = null;
      }
    }, {
      key: "track",
      value: function track(tracking) {
        this.stopTracking();
        this._tracking = tracking;
      }
    }, {
      key: "_updateValue",
      value: function _updateValue(value, flush) {
        this._value = value;

        if (flush) {
          _flush(this);
        }

        for (var _key in this._listeners) {
          this._listeners[_key]({
            value: this.__getValue()
          });
        }
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'value',
          value: this._value,
          offset: this._offset
        };
      }
    }]);

    return AnimatedValue;
  }(AnimatedWithChildren);

  module.exports = AnimatedValue;
},471,[24,25,26,29,138,30,28,32,472,473,475,476,474],"node_modules\\react-native\\Libraries\\Animated\\src\\nodes\\AnimatedValue.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _get = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/get");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/objectSpread");

  var AnimatedNode = _$$_REQUIRE(_dependencyMap[9], "./AnimatedNode");

  var AnimatedWithChildren = _$$_REQUIRE(_dependencyMap[10], "./AnimatedWithChildren");

  var NativeAnimatedHelper = _$$_REQUIRE(_dependencyMap[11], "../NativeAnimatedHelper");

  var invariant = _$$_REQUIRE(_dependencyMap[12], "fbjs/lib/invariant");

  var normalizeColor = _$$_REQUIRE(_dependencyMap[13], "normalizeColor");

  var linear = function linear(t) {
    return t;
  };

  function createInterpolation(config) {
    if (config.outputRange && typeof config.outputRange[0] === 'string') {
      return createInterpolationFromStringOutputRange(config);
    }

    var outputRange = config.outputRange;
    checkInfiniteRange('outputRange', outputRange);
    var inputRange = config.inputRange;
    checkInfiniteRange('inputRange', inputRange);
    checkValidInputRange(inputRange);
    invariant(inputRange.length === outputRange.length, 'inputRange (' + inputRange.length + ') and outputRange (' + outputRange.length + ') must have the same length');
    var easing = config.easing || linear;
    var extrapolateLeft = 'extend';

    if (config.extrapolateLeft !== undefined) {
      extrapolateLeft = config.extrapolateLeft;
    } else if (config.extrapolate !== undefined) {
      extrapolateLeft = config.extrapolate;
    }

    var extrapolateRight = 'extend';

    if (config.extrapolateRight !== undefined) {
      extrapolateRight = config.extrapolateRight;
    } else if (config.extrapolate !== undefined) {
      extrapolateRight = config.extrapolate;
    }

    return function (input) {
      invariant(typeof input === 'number', 'Cannot interpolation an input which is not a number');
      var range = findRange(input, inputRange);
      return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight);
    };
  }

  function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight) {
    var result = input;

    if (result < inputMin) {
      if (extrapolateLeft === 'identity') {
        return result;
      } else if (extrapolateLeft === 'clamp') {
        result = inputMin;
      } else if (extrapolateLeft === 'extend') {}
    }

    if (result > inputMax) {
      if (extrapolateRight === 'identity') {
        return result;
      } else if (extrapolateRight === 'clamp') {
        result = inputMax;
      } else if (extrapolateRight === 'extend') {}
    }

    if (outputMin === outputMax) {
      return outputMin;
    }

    if (inputMin === inputMax) {
      if (input <= inputMin) {
        return outputMin;
      }

      return outputMax;
    }

    if (inputMin === -Infinity) {
      result = -result;
    } else if (inputMax === Infinity) {
      result = result - inputMin;
    } else {
      result = (result - inputMin) / (inputMax - inputMin);
    }

    result = easing(result);

    if (outputMin === -Infinity) {
      result = -result;
    } else if (outputMax === Infinity) {
      result = result + outputMin;
    } else {
      result = result * (outputMax - outputMin) + outputMin;
    }

    return result;
  }

  function colorToRgba(input) {
    var int32Color = normalizeColor(input);

    if (int32Color === null) {
      return input;
    }

    int32Color = int32Color || 0;
    var r = (int32Color & 0xff000000) >>> 24;
    var g = (int32Color & 0x00ff0000) >>> 16;
    var b = (int32Color & 0x0000ff00) >>> 8;
    var a = (int32Color & 0x000000ff) / 255;
    return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
  }

  var stringShapeRegex = /[0-9\.-]+/g;

  function createInterpolationFromStringOutputRange(config) {
    var outputRange = config.outputRange;
    invariant(outputRange.length >= 2, 'Bad output range');
    outputRange = outputRange.map(colorToRgba);
    checkPattern(outputRange);
    var outputRanges = outputRange[0].match(stringShapeRegex).map(function () {
      return [];
    });
    outputRange.forEach(function (value) {
      value.match(stringShapeRegex).forEach(function (number, i) {
        outputRanges[i].push(+number);
      });
    });
    var interpolations = outputRange[0].match(stringShapeRegex).map(function (value, i) {
      return createInterpolation(_objectSpread({}, config, {
        outputRange: outputRanges[i]
      }));
    });
    var shouldRound = isRgbOrRgba(outputRange[0]);
    return function (input) {
      var i = 0;
      return outputRange[0].replace(stringShapeRegex, function () {
        var val = +interpolations[i++](input);
        var rounded = shouldRound && i < 4 ? Math.round(val) : Math.round(val * 1000) / 1000;
        return String(rounded);
      });
    };
  }

  function isRgbOrRgba(range) {
    return typeof range === 'string' && range.startsWith('rgb');
  }

  function checkPattern(arr) {
    var pattern = arr[0].replace(stringShapeRegex, '');

    for (var i = 1; i < arr.length; ++i) {
      invariant(pattern === arr[i].replace(stringShapeRegex, ''), 'invalid pattern ' + arr[0] + ' and ' + arr[i]);
    }
  }

  function findRange(input, inputRange) {
    var i;

    for (i = 1; i < inputRange.length - 1; ++i) {
      if (inputRange[i] >= input) {
        break;
      }
    }

    return i - 1;
  }

  function checkValidInputRange(arr) {
    invariant(arr.length >= 2, 'inputRange must have at least 2 elements');

    for (var i = 1; i < arr.length; ++i) {
      invariant(arr[i] >= arr[i - 1], 'inputRange must be monotonically non-decreasing ' + arr);
    }
  }

  function checkInfiniteRange(name, arr) {
    invariant(arr.length >= 2, name + ' must have at least 2 elements');
    invariant(arr.length !== 2 || arr[0] !== -Infinity || arr[1] !== Infinity, name + 'cannot be ]-infinity;+infinity[ ' + arr);
  }

  var AnimatedInterpolation = function (_AnimatedWithChildren) {
    _inherits(AnimatedInterpolation, _AnimatedWithChildren);

    function AnimatedInterpolation(parent, config) {
      var _this;

      _classCallCheck(this, AnimatedInterpolation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedInterpolation).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_parent", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_config", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_interpolation", void 0);

      _this._parent = parent;
      _this._config = config;
      _this._interpolation = createInterpolation(config);
      return _this;
    }

    _createClass(AnimatedInterpolation, [{
      key: "__makeNative",
      value: function __makeNative() {
        this._parent.__makeNative();

        _get(_getPrototypeOf(AnimatedInterpolation.prototype), "__makeNative", this).call(this);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        var parentValue = this._parent.__getValue();

        invariant(typeof parentValue === 'number', 'Cannot interpolate an input which is not a number.');
        return this._interpolation(parentValue);
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new AnimatedInterpolation(this, config);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._parent.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._parent.__removeChild(this);

        _get(_getPrototypeOf(AnimatedInterpolation.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__transformDataType",
      value: function __transformDataType(range) {
        return range.map(function (value) {
          if (typeof value !== 'string') {
            return value;
          }

          if (/deg$/.test(value)) {
            var degrees = parseFloat(value) || 0;
            var radians = degrees * Math.PI / 180.0;
            return radians;
          } else {
            return parseFloat(value) || 0;
          }
        });
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        if (__DEV__) {
          NativeAnimatedHelper.validateInterpolation(this._config);
        }

        return {
          inputRange: this._config.inputRange,
          outputRange: this.__transformDataType(this._config.outputRange),
          extrapolateLeft: this._config.extrapolateLeft || this._config.extrapolate || 'extend',
          extrapolateRight: this._config.extrapolateRight || this._config.extrapolate || 'extend',
          type: 'interpolation'
        };
      }
    }]);

    return AnimatedInterpolation;
  }(AnimatedWithChildren);

  _defineProperty(AnimatedInterpolation, "__createInterpolation", createInterpolation);

  module.exports = AnimatedInterpolation;
},472,[24,25,26,29,138,30,28,32,148,473,475,474,117,157],"node_modules\\react-native\\Libraries\\Animated\\src\\nodes\\AnimatedInterpolation.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/defineProperty");

  var NativeAnimatedHelper = _$$_REQUIRE(_dependencyMap[3], "../NativeAnimatedHelper");

  var invariant = _$$_REQUIRE(_dependencyMap[4], "fbjs/lib/invariant");

  var AnimatedNode = function () {
    function AnimatedNode() {
      _classCallCheck(this, AnimatedNode);

      _defineProperty(this, "__isNative", void 0);

      _defineProperty(this, "__nativeTag", void 0);
    }

    _createClass(AnimatedNode, [{
      key: "__attach",
      value: function __attach() {}
    }, {
      key: "__detach",
      value: function __detach() {
        if (this.__isNative && this.__nativeTag != null) {
          NativeAnimatedHelper.API.dropAnimatedNode(this.__nativeTag);
          this.__nativeTag = undefined;
        }
      }
    }, {
      key: "__getValue",
      value: function __getValue() {}
    }, {
      key: "__getAnimatedValue",
      value: function __getAnimatedValue() {
        return this.__getValue();
      }
    }, {
      key: "__addChild",
      value: function __addChild(child) {}
    }, {
      key: "__removeChild",
      value: function __removeChild(child) {}
    }, {
      key: "__getChildren",
      value: function __getChildren() {
        return [];
      }
    }, {
      key: "__makeNative",
      value: function __makeNative() {
        if (!this.__isNative) {
          throw new Error('This node cannot be made a "native" animated node');
        }
      }
    }, {
      key: "__getNativeTag",
      value: function __getNativeTag() {
        NativeAnimatedHelper.assertNativeAnimatedModule();
        invariant(this.__isNative, 'Attempt to get native tag from node not marked as "native"');

        if (this.__nativeTag == null) {
          var nativeTag = NativeAnimatedHelper.generateNewNodeTag();
          NativeAnimatedHelper.API.createAnimatedNode(nativeTag, this.__getNativeConfig());
          this.__nativeTag = nativeTag;
        }

        return this.__nativeTag;
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        throw new Error('This JS animated node type cannot be used as native animated node');
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return this.__getValue();
      }
    }]);

    return AnimatedNode;
  }();

  module.exports = AnimatedNode;
},473,[24,25,32,474,117],"node_modules\\react-native\\Libraries\\Animated\\src\\nodes\\AnimatedNode.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var NativeAnimatedModule = _$$_REQUIRE(_dependencyMap[0], "NativeModules").NativeAnimatedModule;

  var NativeEventEmitter = _$$_REQUIRE(_dependencyMap[1], "NativeEventEmitter");

  var invariant = _$$_REQUIRE(_dependencyMap[2], "fbjs/lib/invariant");

  var __nativeAnimatedNodeTagCount = 1;
  var __nativeAnimationIdCount = 1;
  var nativeEventEmitter;
  var API = {
    createAnimatedNode: function createAnimatedNode(tag, config) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.createAnimatedNode(tag, config);
    },
    startListeningToAnimatedNodeValue: function startListeningToAnimatedNodeValue(tag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.startListeningToAnimatedNodeValue(tag);
    },
    stopListeningToAnimatedNodeValue: function stopListeningToAnimatedNodeValue(tag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.stopListeningToAnimatedNodeValue(tag);
    },
    connectAnimatedNodes: function connectAnimatedNodes(parentTag, childTag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.connectAnimatedNodes(parentTag, childTag);
    },
    disconnectAnimatedNodes: function disconnectAnimatedNodes(parentTag, childTag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.disconnectAnimatedNodes(parentTag, childTag);
    },
    startAnimatingNode: function startAnimatingNode(animationId, nodeTag, config, endCallback) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.startAnimatingNode(animationId, nodeTag, config, endCallback);
    },
    stopAnimation: function stopAnimation(animationId) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.stopAnimation(animationId);
    },
    setAnimatedNodeValue: function setAnimatedNodeValue(nodeTag, value) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.setAnimatedNodeValue(nodeTag, value);
    },
    setAnimatedNodeOffset: function setAnimatedNodeOffset(nodeTag, offset) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.setAnimatedNodeOffset(nodeTag, offset);
    },
    flattenAnimatedNodeOffset: function flattenAnimatedNodeOffset(nodeTag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.flattenAnimatedNodeOffset(nodeTag);
    },
    extractAnimatedNodeOffset: function extractAnimatedNodeOffset(nodeTag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.extractAnimatedNodeOffset(nodeTag);
    },
    connectAnimatedNodeToView: function connectAnimatedNodeToView(nodeTag, viewTag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.connectAnimatedNodeToView(nodeTag, viewTag);
    },
    disconnectAnimatedNodeFromView: function disconnectAnimatedNodeFromView(nodeTag, viewTag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.disconnectAnimatedNodeFromView(nodeTag, viewTag);
    },
    dropAnimatedNode: function dropAnimatedNode(tag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.dropAnimatedNode(tag);
    },
    addAnimatedEventToView: function addAnimatedEventToView(viewTag, eventName, eventMapping) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.addAnimatedEventToView(viewTag, eventName, eventMapping);
    },
    removeAnimatedEventFromView: function removeAnimatedEventFromView(viewTag, eventName, animatedNodeTag) {
      assertNativeAnimatedModule();
      NativeAnimatedModule.removeAnimatedEventFromView(viewTag, eventName, animatedNodeTag);
    }
  };
  var STYLES_WHITELIST = {
    opacity: true,
    transform: true,
    borderRadius: true,
    borderBottomEndRadius: true,
    borderBottomLeftRadius: true,
    borderBottomRightRadius: true,
    borderBottomStartRadius: true,
    borderTopEndRadius: true,
    borderTopLeftRadius: true,
    borderTopRightRadius: true,
    borderTopStartRadius: true,
    shadowOpacity: true,
    shadowRadius: true,
    scaleX: true,
    scaleY: true,
    translateX: true,
    translateY: true
  };
  var TRANSFORM_WHITELIST = {
    translateX: true,
    translateY: true,
    scale: true,
    scaleX: true,
    scaleY: true,
    rotate: true,
    rotateX: true,
    rotateY: true,
    perspective: true
  };
  var SUPPORTED_INTERPOLATION_PARAMS = {
    inputRange: true,
    outputRange: true,
    extrapolate: true,
    extrapolateRight: true,
    extrapolateLeft: true
  };

  function addWhitelistedStyleProp(prop) {
    STYLES_WHITELIST[prop] = true;
  }

  function addWhitelistedTransformProp(prop) {
    TRANSFORM_WHITELIST[prop] = true;
  }

  function addWhitelistedInterpolationParam(param) {
    SUPPORTED_INTERPOLATION_PARAMS[param] = true;
  }

  function validateTransform(configs) {
    configs.forEach(function (config) {
      if (!TRANSFORM_WHITELIST.hasOwnProperty(config.property)) {
        throw new Error("Property '" + config.property + "' is not supported by native animated module");
      }
    });
  }

  function validateStyles(styles) {
    for (var key in styles) {
      if (!STYLES_WHITELIST.hasOwnProperty(key)) {
        throw new Error("Style property '" + key + "' is not supported by native animated module");
      }
    }
  }

  function validateInterpolation(config) {
    for (var key in config) {
      if (!SUPPORTED_INTERPOLATION_PARAMS.hasOwnProperty(key)) {
        throw new Error("Interpolation property '" + key + "' is not supported by native animated module");
      }
    }
  }

  function generateNewNodeTag() {
    return __nativeAnimatedNodeTagCount++;
  }

  function generateNewAnimationId() {
    return __nativeAnimationIdCount++;
  }

  function assertNativeAnimatedModule() {
    invariant(NativeAnimatedModule, 'Native animated module is not available');
  }

  var _warnedMissingNativeAnimated = false;

  function shouldUseNativeDriver(config) {
    if (config.useNativeDriver && !NativeAnimatedModule) {
      if (!_warnedMissingNativeAnimated) {
        console.warn('Animated: `useNativeDriver` is not supported because the native ' + 'animated module is missing. Falling back to JS-based animation. To ' + 'resolve this, add `RCTAnimation` module to this app, or remove ' + '`useNativeDriver`. ' + 'More info: https://github.com/facebook/react-native/issues/11094#issuecomment-263240420');
        _warnedMissingNativeAnimated = true;
      }

      return false;
    }

    return config.useNativeDriver || false;
  }

  module.exports = {
    API: API,
    addWhitelistedStyleProp: addWhitelistedStyleProp,
    addWhitelistedTransformProp: addWhitelistedTransformProp,
    addWhitelistedInterpolationParam: addWhitelistedInterpolationParam,
    validateStyles: validateStyles,
    validateTransform: validateTransform,
    validateInterpolation: validateInterpolation,
    generateNewNodeTag: generateNewNodeTag,
    generateNewAnimationId: generateNewAnimationId,
    assertNativeAnimatedModule: assertNativeAnimatedModule,
    shouldUseNativeDriver: shouldUseNativeDriver,

    get nativeEventEmitter() {
      if (!nativeEventEmitter) {
        nativeEventEmitter = new NativeEventEmitter(NativeAnimatedModule);
      }

      return nativeEventEmitter;
    }

  };
},474,[119,219,117],"node_modules\\react-native\\Libraries\\Animated\\src\\NativeAnimatedHelper.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/defineProperty");

  var AnimatedNode = _$$_REQUIRE(_dependencyMap[7], "./AnimatedNode");

  var NativeAnimatedHelper = _$$_REQUIRE(_dependencyMap[8], "../NativeAnimatedHelper");

  var AnimatedWithChildren = function (_AnimatedNode) {
    _inherits(AnimatedWithChildren, _AnimatedNode);

    function AnimatedWithChildren() {
      var _this;

      _classCallCheck(this, AnimatedWithChildren);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedWithChildren).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_children", void 0);

      _this._children = [];
      return _this;
    }

    _createClass(AnimatedWithChildren, [{
      key: "__makeNative",
      value: function __makeNative() {
        if (!this.__isNative) {
          this.__isNative = true;

          for (var _iterator = this._children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
            var _ref;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref = _i.value;
            }

            var _child = _ref;

            _child.__makeNative();

            NativeAnimatedHelper.API.connectAnimatedNodes(this.__getNativeTag(), _child.__getNativeTag());
          }
        }
      }
    }, {
      key: "__addChild",
      value: function __addChild(child) {
        if (this._children.length === 0) {
          this.__attach();
        }

        this._children.push(child);

        if (this.__isNative) {
          child.__makeNative();

          NativeAnimatedHelper.API.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
        }
      }
    }, {
      key: "__removeChild",
      value: function __removeChild(child) {
        var index = this._children.indexOf(child);

        if (index === -1) {
          console.warn("Trying to remove a child that doesn't exist");
          return;
        }

        if (this.__isNative && child.__isNative) {
          NativeAnimatedHelper.API.disconnectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
        }

        this._children.splice(index, 1);

        if (this._children.length === 0) {
          this.__detach();
        }
      }
    }, {
      key: "__getChildren",
      value: function __getChildren() {
        return this._children;
      }
    }]);

    return AnimatedWithChildren;
  }(AnimatedNode);

  module.exports = AnimatedWithChildren;
},475,[24,25,26,29,30,28,32,473,474],"node_modules\\react-native\\Libraries\\Animated\\src\\nodes\\AnimatedWithChildren.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var BatchedBridge = _$$_REQUIRE(_dependencyMap[0], "BatchedBridge");

  var EventEmitter = _$$_REQUIRE(_dependencyMap[1], "EventEmitter");

  var Set = _$$_REQUIRE(_dependencyMap[2], "Set");

  var TaskQueue = _$$_REQUIRE(_dependencyMap[3], "TaskQueue");

  var infoLog = _$$_REQUIRE(_dependencyMap[4], "infoLog");

  var invariant = _$$_REQUIRE(_dependencyMap[5], "fbjs/lib/invariant");

  var keyMirror = _$$_REQUIRE(_dependencyMap[6], "fbjs/lib/keyMirror");

  var _emitter = new EventEmitter();

  var DEBUG_DELAY = 0;
  var DEBUG = false;
  var InteractionManager = {
    Events: keyMirror({
      interactionStart: true,
      interactionComplete: true
    }),
    runAfterInteractions: function runAfterInteractions(task) {
      var tasks = [];
      var promise = new Promise(function (resolve) {
        _scheduleUpdate();

        if (task) {
          tasks.push(task);
        }

        tasks.push({
          run: resolve,
          name: 'resolve ' + (task && task.name || '?')
        });

        _taskQueue.enqueueTasks(tasks);
      });
      return {
        then: promise.then.bind(promise),
        done: function done() {
          if (promise.done) {
            return promise.done.apply(promise, arguments);
          } else {
            console.warn('Tried to call done when not supported by current Promise implementation.');
          }
        },
        cancel: function cancel() {
          _taskQueue.cancelTasks(tasks);
        }
      };
    },
    createInteractionHandle: function createInteractionHandle() {
      DEBUG && infoLog('create interaction handle');

      _scheduleUpdate();

      var handle = ++_inc;

      _addInteractionSet.add(handle);

      return handle;
    },
    clearInteractionHandle: function clearInteractionHandle(handle) {
      DEBUG && infoLog('clear interaction handle');
      invariant(!!handle, 'Must provide a handle to clear.');

      _scheduleUpdate();

      _addInteractionSet.delete(handle);

      _deleteInteractionSet.add(handle);
    },
    addListener: _emitter.addListener.bind(_emitter),
    setDeadline: function setDeadline(deadline) {
      _deadline = deadline;
    }
  };

  var _interactionSet = new Set();

  var _addInteractionSet = new Set();

  var _deleteInteractionSet = new Set();

  var _taskQueue = new TaskQueue({
    onMoreTasks: _scheduleUpdate
  });

  var _nextUpdateHandle = 0;
  var _inc = 0;

  var _deadline = -1;

  function _scheduleUpdate() {
    if (!_nextUpdateHandle) {
      if (_deadline > 0) {
        _nextUpdateHandle = setTimeout(_processUpdate, 0 + DEBUG_DELAY);
      } else {
        _nextUpdateHandle = setImmediate(_processUpdate);
      }
    }
  }

  function _processUpdate() {
    _nextUpdateHandle = 0;
    var interactionCount = _interactionSet.size;

    _addInteractionSet.forEach(function (handle) {
      return _interactionSet.add(handle);
    });

    _deleteInteractionSet.forEach(function (handle) {
      return _interactionSet.delete(handle);
    });

    var nextInteractionCount = _interactionSet.size;

    if (interactionCount !== 0 && nextInteractionCount === 0) {
      _emitter.emit(InteractionManager.Events.interactionComplete);
    } else if (interactionCount === 0 && nextInteractionCount !== 0) {
      _emitter.emit(InteractionManager.Events.interactionStart);
    }

    if (nextInteractionCount === 0) {
      while (_taskQueue.hasTasksToProcess()) {
        _taskQueue.processNext();

        if (_deadline > 0 && BatchedBridge.getEventLoopRunningTime() >= _deadline) {
          _scheduleUpdate();

          break;
        }
      }
    }

    _addInteractionSet.clear();

    _deleteInteractionSet.clear();
  }

  module.exports = InteractionManager;
},476,[126,140,187,477,242,117,159],"node_modules\\react-native\\Libraries\\Interaction\\InteractionManager.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/defineProperty");

  var infoLog = _$$_REQUIRE(_dependencyMap[4], "infoLog");

  var invariant = _$$_REQUIRE(_dependencyMap[5], "fbjs/lib/invariant");

  var DEBUG = false;

  var TaskQueue = function () {
    function TaskQueue(_ref) {
      var onMoreTasks = _ref.onMoreTasks;

      _classCallCheck(this, TaskQueue);

      _defineProperty(this, "_queueStack", void 0);

      _defineProperty(this, "_onMoreTasks", void 0);

      this._onMoreTasks = onMoreTasks;
      this._queueStack = [{
        tasks: [],
        popable: false
      }];
    }

    _createClass(TaskQueue, [{
      key: "enqueue",
      value: function enqueue(task) {
        this._getCurrentQueue().push(task);
      }
    }, {
      key: "enqueueTasks",
      value: function enqueueTasks(tasks) {
        var _this = this;

        tasks.forEach(function (task) {
          return _this.enqueue(task);
        });
      }
    }, {
      key: "cancelTasks",
      value: function cancelTasks(tasksToCancel) {
        this._queueStack = this._queueStack.map(function (queue) {
          return _objectSpread({}, queue, {
            tasks: queue.tasks.filter(function (task) {
              return tasksToCancel.indexOf(task) === -1;
            })
          });
        }).filter(function (queue, idx) {
          return queue.tasks.length > 0 || idx === 0;
        });
      }
    }, {
      key: "hasTasksToProcess",
      value: function hasTasksToProcess() {
        return this._getCurrentQueue().length > 0;
      }
    }, {
      key: "processNext",
      value: function processNext() {
        var queue = this._getCurrentQueue();

        if (queue.length) {
          var task = queue.shift();

          try {
            if (task.gen) {
              DEBUG && infoLog('genPromise for task ' + task.name);

              this._genPromise(task);
            } else if (task.run) {
              DEBUG && infoLog('run task ' + task.name);
              task.run();
            } else {
              invariant(typeof task === 'function', 'Expected Function, SimpleTask, or PromiseTask, but got:\n' + JSON.stringify(task, null, 2));
              DEBUG && infoLog('run anonymous task');
              task();
            }
          } catch (e) {
            e.message = 'TaskQueue: Error with task ' + (task.name || '') + ': ' + e.message;
            throw e;
          }
        }
      }
    }, {
      key: "_getCurrentQueue",
      value: function _getCurrentQueue() {
        var stackIdx = this._queueStack.length - 1;
        var queue = this._queueStack[stackIdx];

        if (queue.popable && queue.tasks.length === 0 && this._queueStack.length > 1) {
          this._queueStack.pop();

          DEBUG && infoLog('popped queue: ', {
            stackIdx: stackIdx,
            queueStackSize: this._queueStack.length
          });
          return this._getCurrentQueue();
        } else {
          return queue.tasks;
        }
      }
    }, {
      key: "_genPromise",
      value: function _genPromise(task) {
        var _this2 = this;

        this._queueStack.push({
          tasks: [],
          popable: false
        });

        var stackIdx = this._queueStack.length - 1;
        DEBUG && infoLog('push new queue: ', {
          stackIdx: stackIdx
        });
        DEBUG && infoLog('exec gen task ' + task.name);
        task.gen().then(function () {
          DEBUG && infoLog('onThen for gen task ' + task.name, {
            stackIdx: stackIdx,
            queueStackSize: _this2._queueStack.length
          });
          _this2._queueStack[stackIdx].popable = true;
          _this2.hasTasksToProcess() && _this2._onMoreTasks();
        }).catch(function (ex) {
          ex.message = "TaskQueue: Error resolving Promise in task " + task.name + ": " + ex.message;
          throw ex;
        }).done();
      }
    }]);

    return TaskQueue;
  }();

  module.exports = TaskQueue;
},477,[148,24,25,32,242,117],"node_modules\\react-native\\Libraries\\Interaction\\TaskQueue.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _get = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/get");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var AnimatedInterpolation = _$$_REQUIRE(_dependencyMap[8], "./AnimatedInterpolation");

  var AnimatedNode = _$$_REQUIRE(_dependencyMap[9], "./AnimatedNode");

  var AnimatedValue = _$$_REQUIRE(_dependencyMap[10], "./AnimatedValue");

  var AnimatedWithChildren = _$$_REQUIRE(_dependencyMap[11], "./AnimatedWithChildren");

  var AnimatedAddition = function (_AnimatedWithChildren) {
    _inherits(AnimatedAddition, _AnimatedWithChildren);

    function AnimatedAddition(a, b) {
      var _this;

      _classCallCheck(this, AnimatedAddition);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedAddition).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_a", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_b", void 0);

      _this._a = typeof a === 'number' ? new AnimatedValue(a) : a;
      _this._b = typeof b === 'number' ? new AnimatedValue(b) : b;
      return _this;
    }

    _createClass(AnimatedAddition, [{
      key: "__makeNative",
      value: function __makeNative() {
        this._a.__makeNative();

        this._b.__makeNative();

        _get(_getPrototypeOf(AnimatedAddition.prototype), "__makeNative", this).call(this);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._a.__getValue() + this._b.__getValue();
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new AnimatedInterpolation(this, config);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._a.__addChild(this);

        this._b.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._a.__removeChild(this);

        this._b.__removeChild(this);

        _get(_getPrototypeOf(AnimatedAddition.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'addition',
          input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
        };
      }
    }]);

    return AnimatedAddition;
  }(AnimatedWithChildren);

  module.exports = AnimatedAddition;
},478,[24,25,26,29,138,30,28,32,472,473,471,475],"node_modules\\react-native\\Libraries\\Animated\\src\\nodes\\AnimatedAddition.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _get = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/get");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var AnimatedInterpolation = _$$_REQUIRE(_dependencyMap[8], "./AnimatedInterpolation");

  var AnimatedNode = _$$_REQUIRE(_dependencyMap[9], "./AnimatedNode");

  var AnimatedWithChildren = _$$_REQUIRE(_dependencyMap[10], "./AnimatedWithChildren");

  var AnimatedDiffClamp = function (_AnimatedWithChildren) {
    _inherits(AnimatedDiffClamp, _AnimatedWithChildren);

    function AnimatedDiffClamp(a, min, max) {
      var _this;

      _classCallCheck(this, AnimatedDiffClamp);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedDiffClamp).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_a", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_min", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_max", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_value", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_lastValue", void 0);

      _this._a = a;
      _this._min = min;
      _this._max = max;
      _this._value = _this._lastValue = _this._a.__getValue();
      return _this;
    }

    _createClass(AnimatedDiffClamp, [{
      key: "__makeNative",
      value: function __makeNative() {
        this._a.__makeNative();

        _get(_getPrototypeOf(AnimatedDiffClamp.prototype), "__makeNative", this).call(this);
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new AnimatedInterpolation(this, config);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        var value = this._a.__getValue();

        var diff = value - this._lastValue;
        this._lastValue = value;
        this._value = Math.min(Math.max(this._value + diff, this._min), this._max);
        return this._value;
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._a.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._a.__removeChild(this);

        _get(_getPrototypeOf(AnimatedDiffClamp.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'diffclamp',
          input: this._a.__getNativeTag(),
          min: this._min,
          max: this._max
        };
      }
    }]);

    return AnimatedDiffClamp;
  }(AnimatedWithChildren);

  module.exports = AnimatedDiffClamp;
},479,[24,25,26,29,138,30,28,32,472,473,475],"node_modules\\react-native\\Libraries\\Animated\\src\\nodes\\AnimatedDiffClamp.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _get = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/get");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var AnimatedInterpolation = _$$_REQUIRE(_dependencyMap[8], "./AnimatedInterpolation");

  var AnimatedNode = _$$_REQUIRE(_dependencyMap[9], "./AnimatedNode");

  var AnimatedValue = _$$_REQUIRE(_dependencyMap[10], "./AnimatedValue");

  var AnimatedWithChildren = _$$_REQUIRE(_dependencyMap[11], "./AnimatedWithChildren");

  var AnimatedDivision = function (_AnimatedWithChildren) {
    _inherits(AnimatedDivision, _AnimatedWithChildren);

    function AnimatedDivision(a, b) {
      var _this;

      _classCallCheck(this, AnimatedDivision);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedDivision).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_a", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_b", void 0);

      _this._a = typeof a === 'number' ? new AnimatedValue(a) : a;
      _this._b = typeof b === 'number' ? new AnimatedValue(b) : b;
      return _this;
    }

    _createClass(AnimatedDivision, [{
      key: "__makeNative",
      value: function __makeNative() {
        this._a.__makeNative();

        this._b.__makeNative();

        _get(_getPrototypeOf(AnimatedDivision.prototype), "__makeNative", this).call(this);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        var a = this._a.__getValue();

        var b = this._b.__getValue();

        if (b === 0) {
          console.error('Detected division by zero in AnimatedDivision');
        }

        return a / b;
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new AnimatedInterpolation(this, config);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._a.__addChild(this);

        this._b.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._a.__removeChild(this);

        this._b.__removeChild(this);

        _get(_getPrototypeOf(AnimatedDivision.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'division',
          input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
        };
      }
    }]);

    return AnimatedDivision;
  }(AnimatedWithChildren);

  module.exports = AnimatedDivision;
},480,[24,25,26,29,138,30,28,32,472,473,471,475],"node_modules\\react-native\\Libraries\\Animated\\src\\nodes\\AnimatedDivision.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _get = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/get");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var AnimatedInterpolation = _$$_REQUIRE(_dependencyMap[8], "./AnimatedInterpolation");

  var AnimatedNode = _$$_REQUIRE(_dependencyMap[9], "./AnimatedNode");

  var AnimatedWithChildren = _$$_REQUIRE(_dependencyMap[10], "./AnimatedWithChildren");

  var AnimatedModulo = function (_AnimatedWithChildren) {
    _inherits(AnimatedModulo, _AnimatedWithChildren);

    function AnimatedModulo(a, modulus) {
      var _this;

      _classCallCheck(this, AnimatedModulo);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedModulo).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_a", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_modulus", void 0);

      _this._a = a;
      _this._modulus = modulus;
      return _this;
    }

    _createClass(AnimatedModulo, [{
      key: "__makeNative",
      value: function __makeNative() {
        this._a.__makeNative();

        _get(_getPrototypeOf(AnimatedModulo.prototype), "__makeNative", this).call(this);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return (this._a.__getValue() % this._modulus + this._modulus) % this._modulus;
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new AnimatedInterpolation(this, config);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._a.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._a.__removeChild(this);

        _get(_getPrototypeOf(AnimatedModulo.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'modulus',
          input: this._a.__getNativeTag(),
          modulus: this._modulus
        };
      }
    }]);

    return AnimatedModulo;
  }(AnimatedWithChildren);

  module.exports = AnimatedModulo;
},481,[24,25,26,29,138,30,28,32,472,473,475],"node_modules\\react-native\\Libraries\\Animated\\src\\nodes\\AnimatedModulo.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _get = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/get");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var AnimatedInterpolation = _$$_REQUIRE(_dependencyMap[8], "./AnimatedInterpolation");

  var AnimatedNode = _$$_REQUIRE(_dependencyMap[9], "./AnimatedNode");

  var AnimatedValue = _$$_REQUIRE(_dependencyMap[10], "./AnimatedValue");

  var AnimatedWithChildren = _$$_REQUIRE(_dependencyMap[11], "./AnimatedWithChildren");

  var AnimatedMultiplication = function (_AnimatedWithChildren) {
    _inherits(AnimatedMultiplication, _AnimatedWithChildren);

    function AnimatedMultiplication(a, b) {
      var _this;

      _classCallCheck(this, AnimatedMultiplication);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedMultiplication).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_a", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_b", void 0);

      _this._a = typeof a === 'number' ? new AnimatedValue(a) : a;
      _this._b = typeof b === 'number' ? new AnimatedValue(b) : b;
      return _this;
    }

    _createClass(AnimatedMultiplication, [{
      key: "__makeNative",
      value: function __makeNative() {
        this._a.__makeNative();

        this._b.__makeNative();

        _get(_getPrototypeOf(AnimatedMultiplication.prototype), "__makeNative", this).call(this);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._a.__getValue() * this._b.__getValue();
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new AnimatedInterpolation(this, config);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._a.__addChild(this);

        this._b.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._a.__removeChild(this);

        this._b.__removeChild(this);

        _get(_getPrototypeOf(AnimatedMultiplication.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'multiplication',
          input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
        };
      }
    }]);

    return AnimatedMultiplication;
  }(AnimatedWithChildren);

  module.exports = AnimatedMultiplication;
},482,[24,25,26,29,138,30,28,32,472,473,471,475],"node_modules\\react-native\\Libraries\\Animated\\src\\nodes\\AnimatedMultiplication.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _get = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/get");

  var _inherits = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/defineProperty");

  var _require = _$$_REQUIRE(_dependencyMap[9], "../AnimatedEvent"),
      AnimatedEvent = _require.AnimatedEvent;

  var AnimatedNode = _$$_REQUIRE(_dependencyMap[10], "./AnimatedNode");

  var AnimatedStyle = _$$_REQUIRE(_dependencyMap[11], "./AnimatedStyle");

  var NativeAnimatedHelper = _$$_REQUIRE(_dependencyMap[12], "../NativeAnimatedHelper");

  var ReactNative = _$$_REQUIRE(_dependencyMap[13], "ReactNative");

  var invariant = _$$_REQUIRE(_dependencyMap[14], "fbjs/lib/invariant");

  var AnimatedProps = function (_AnimatedNode) {
    _inherits(AnimatedProps, _AnimatedNode);

    function AnimatedProps(props, callback) {
      var _this;

      _classCallCheck(this, AnimatedProps);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedProps).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_props", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_animatedView", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_callback", void 0);

      if (props.style) {
        props = _objectSpread({}, props, {
          style: new AnimatedStyle(props.style)
        });
      }

      _this._props = props;
      _this._callback = callback;

      _this.__attach();

      return _this;
    }

    _createClass(AnimatedProps, [{
      key: "__getValue",
      value: function __getValue() {
        var props = {};

        for (var key in this._props) {
          var value = this._props[key];

          if (value instanceof AnimatedNode) {
            if (!value.__isNative || value instanceof AnimatedStyle) {
              props[key] = value.__getValue();
            }
          } else if (value instanceof AnimatedEvent) {
            props[key] = value.__getHandler();
          } else {
            props[key] = value;
          }
        }

        return props;
      }
    }, {
      key: "__getAnimatedValue",
      value: function __getAnimatedValue() {
        var props = {};

        for (var key in this._props) {
          var value = this._props[key];

          if (value instanceof AnimatedNode) {
            props[key] = value.__getAnimatedValue();
          }
        }

        return props;
      }
    }, {
      key: "__attach",
      value: function __attach() {
        for (var key in this._props) {
          var value = this._props[key];

          if (value instanceof AnimatedNode) {
            value.__addChild(this);
          }
        }
      }
    }, {
      key: "__detach",
      value: function __detach() {
        if (this.__isNative && this._animatedView) {
          this.__disconnectAnimatedView();
        }

        for (var key in this._props) {
          var value = this._props[key];

          if (value instanceof AnimatedNode) {
            value.__removeChild(this);
          }
        }

        _get(_getPrototypeOf(AnimatedProps.prototype), "__detach", this).call(this);
      }
    }, {
      key: "update",
      value: function update() {
        this._callback();
      }
    }, {
      key: "__makeNative",
      value: function __makeNative() {
        if (!this.__isNative) {
          this.__isNative = true;

          for (var key in this._props) {
            var value = this._props[key];

            if (value instanceof AnimatedNode) {
              value.__makeNative();
            }
          }

          if (this._animatedView) {
            this.__connectAnimatedView();
          }
        }
      }
    }, {
      key: "setNativeView",
      value: function setNativeView(animatedView) {
        if (this._animatedView === animatedView) {
          return;
        }

        this._animatedView = animatedView;

        if (this.__isNative) {
          this.__connectAnimatedView();
        }
      }
    }, {
      key: "__connectAnimatedView",
      value: function __connectAnimatedView() {
        invariant(this.__isNative, 'Expected node to be marked as "native"');
        var nativeViewTag = ReactNative.findNodeHandle(this._animatedView);
        invariant(nativeViewTag != null, 'Unable to locate attached view in the native tree');
        NativeAnimatedHelper.API.connectAnimatedNodeToView(this.__getNativeTag(), nativeViewTag);
      }
    }, {
      key: "__disconnectAnimatedView",
      value: function __disconnectAnimatedView() {
        invariant(this.__isNative, 'Expected node to be marked as "native"');
        var nativeViewTag = ReactNative.findNodeHandle(this._animatedView);
        invariant(nativeViewTag != null, 'Unable to locate attached view in the native tree');
        NativeAnimatedHelper.API.disconnectAnimatedNodeFromView(this.__getNativeTag(), nativeViewTag);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        var propsConfig = {};

        for (var propKey in this._props) {
          var value = this._props[propKey];

          if (value instanceof AnimatedNode) {
            propsConfig[propKey] = value.__getNativeTag();
          }
        }

        return {
          type: 'props',
          props: propsConfig
        };
      }
    }]);

    return AnimatedProps;
  }(AnimatedNode);

  module.exports = AnimatedProps;
},483,[148,24,25,26,29,138,30,28,32,470,473,484,474,178,117],"node_modules\\react-native\\Libraries\\Animated\\src\\nodes\\AnimatedProps.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _get = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/get");

  var _inherits = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/defineProperty");

  var AnimatedNode = _$$_REQUIRE(_dependencyMap[9], "./AnimatedNode");

  var AnimatedTransform = _$$_REQUIRE(_dependencyMap[10], "./AnimatedTransform");

  var AnimatedWithChildren = _$$_REQUIRE(_dependencyMap[11], "./AnimatedWithChildren");

  var NativeAnimatedHelper = _$$_REQUIRE(_dependencyMap[12], "../NativeAnimatedHelper");

  var flattenStyle = _$$_REQUIRE(_dependencyMap[13], "flattenStyle");

  var AnimatedStyle = function (_AnimatedWithChildren) {
    _inherits(AnimatedStyle, _AnimatedWithChildren);

    function AnimatedStyle(style) {
      var _this;

      _classCallCheck(this, AnimatedStyle);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedStyle).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_style", void 0);

      style = flattenStyle(style) || {};

      if (style.transform) {
        style = _objectSpread({}, style, {
          transform: new AnimatedTransform(style.transform)
        });
      }

      _this._style = style;
      return _this;
    }

    _createClass(AnimatedStyle, [{
      key: "_walkStyleAndGetValues",
      value: function _walkStyleAndGetValues(style) {
        var updatedStyle = {};

        for (var key in style) {
          var value = style[key];

          if (value instanceof AnimatedNode) {
            if (!value.__isNative) {
              updatedStyle[key] = value.__getValue();
            }
          } else if (value && !Array.isArray(value) && typeof value === 'object') {
            updatedStyle[key] = this._walkStyleAndGetValues(value);
          } else {
            updatedStyle[key] = value;
          }
        }

        return updatedStyle;
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._walkStyleAndGetValues(this._style);
      }
    }, {
      key: "_walkStyleAndGetAnimatedValues",
      value: function _walkStyleAndGetAnimatedValues(style) {
        var updatedStyle = {};

        for (var key in style) {
          var value = style[key];

          if (value instanceof AnimatedNode) {
            updatedStyle[key] = value.__getAnimatedValue();
          } else if (value && !Array.isArray(value) && typeof value === 'object') {
            updatedStyle[key] = this._walkStyleAndGetAnimatedValues(value);
          }
        }

        return updatedStyle;
      }
    }, {
      key: "__getAnimatedValue",
      value: function __getAnimatedValue() {
        return this._walkStyleAndGetAnimatedValues(this._style);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        for (var key in this._style) {
          var value = this._style[key];

          if (value instanceof AnimatedNode) {
            value.__addChild(this);
          }
        }
      }
    }, {
      key: "__detach",
      value: function __detach() {
        for (var key in this._style) {
          var value = this._style[key];

          if (value instanceof AnimatedNode) {
            value.__removeChild(this);
          }
        }

        _get(_getPrototypeOf(AnimatedStyle.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__makeNative",
      value: function __makeNative() {
        for (var key in this._style) {
          var value = this._style[key];

          if (value instanceof AnimatedNode) {
            value.__makeNative();
          }
        }

        _get(_getPrototypeOf(AnimatedStyle.prototype), "__makeNative", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        var styleConfig = {};

        for (var styleKey in this._style) {
          if (this._style[styleKey] instanceof AnimatedNode) {
            styleConfig[styleKey] = this._style[styleKey].__getNativeTag();
          }
        }

        NativeAnimatedHelper.validateStyles(styleConfig);
        return {
          type: 'style',
          style: styleConfig
        };
      }
    }]);

    return AnimatedStyle;
  }(AnimatedWithChildren);

  module.exports = AnimatedStyle;
},484,[148,24,25,26,29,138,30,28,32,473,485,475,474,174],"node_modules\\react-native\\Libraries\\Animated\\src\\nodes\\AnimatedStyle.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _get = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/get");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var AnimatedNode = _$$_REQUIRE(_dependencyMap[8], "./AnimatedNode");

  var AnimatedWithChildren = _$$_REQUIRE(_dependencyMap[9], "./AnimatedWithChildren");

  var NativeAnimatedHelper = _$$_REQUIRE(_dependencyMap[10], "../NativeAnimatedHelper");

  var AnimatedTransform = function (_AnimatedWithChildren) {
    _inherits(AnimatedTransform, _AnimatedWithChildren);

    function AnimatedTransform(transforms) {
      var _this;

      _classCallCheck(this, AnimatedTransform);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedTransform).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_transforms", void 0);

      _this._transforms = transforms;
      return _this;
    }

    _createClass(AnimatedTransform, [{
      key: "__makeNative",
      value: function __makeNative() {
        this._transforms.forEach(function (transform) {
          for (var key in transform) {
            var value = transform[key];

            if (value instanceof AnimatedNode) {
              value.__makeNative();
            }
          }
        });

        _get(_getPrototypeOf(AnimatedTransform.prototype), "__makeNative", this).call(this);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._transforms.map(function (transform) {
          var result = {};

          for (var key in transform) {
            var value = transform[key];

            if (value instanceof AnimatedNode) {
              result[key] = value.__getValue();
            } else {
              result[key] = value;
            }
          }

          return result;
        });
      }
    }, {
      key: "__getAnimatedValue",
      value: function __getAnimatedValue() {
        return this._transforms.map(function (transform) {
          var result = {};

          for (var key in transform) {
            var value = transform[key];

            if (value instanceof AnimatedNode) {
              result[key] = value.__getAnimatedValue();
            } else {
              result[key] = value;
            }
          }

          return result;
        });
      }
    }, {
      key: "__attach",
      value: function __attach() {
        var _this2 = this;

        this._transforms.forEach(function (transform) {
          for (var key in transform) {
            var value = transform[key];

            if (value instanceof AnimatedNode) {
              value.__addChild(_this2);
            }
          }
        });
      }
    }, {
      key: "__detach",
      value: function __detach() {
        var _this3 = this;

        this._transforms.forEach(function (transform) {
          for (var key in transform) {
            var value = transform[key];

            if (value instanceof AnimatedNode) {
              value.__removeChild(_this3);
            }
          }
        });

        _get(_getPrototypeOf(AnimatedTransform.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        var transConfigs = [];

        this._transforms.forEach(function (transform) {
          for (var key in transform) {
            var value = transform[key];

            if (value instanceof AnimatedNode) {
              transConfigs.push({
                type: 'animated',
                property: key,
                nodeTag: value.__getNativeTag()
              });
            } else {
              transConfigs.push({
                type: 'static',
                property: key,
                value: value
              });
            }
          }
        });

        NativeAnimatedHelper.validateTransform(transConfigs);
        return {
          type: 'transform',
          transforms: transConfigs
        };
      }
    }]);

    return AnimatedTransform;
  }(AnimatedWithChildren);

  module.exports = AnimatedTransform;
},485,[24,25,26,29,138,30,28,32,473,475,474],"node_modules\\react-native\\Libraries\\Animated\\src\\nodes\\AnimatedTransform.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _get = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/get");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var AnimatedInterpolation = _$$_REQUIRE(_dependencyMap[8], "./AnimatedInterpolation");

  var AnimatedNode = _$$_REQUIRE(_dependencyMap[9], "./AnimatedNode");

  var AnimatedValue = _$$_REQUIRE(_dependencyMap[10], "./AnimatedValue");

  var AnimatedWithChildren = _$$_REQUIRE(_dependencyMap[11], "./AnimatedWithChildren");

  var AnimatedSubtraction = function (_AnimatedWithChildren) {
    _inherits(AnimatedSubtraction, _AnimatedWithChildren);

    function AnimatedSubtraction(a, b) {
      var _this;

      _classCallCheck(this, AnimatedSubtraction);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedSubtraction).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_a", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_b", void 0);

      _this._a = typeof a === 'number' ? new AnimatedValue(a) : a;
      _this._b = typeof b === 'number' ? new AnimatedValue(b) : b;
      return _this;
    }

    _createClass(AnimatedSubtraction, [{
      key: "__makeNative",
      value: function __makeNative() {
        this._a.__makeNative();

        this._b.__makeNative();

        _get(_getPrototypeOf(AnimatedSubtraction.prototype), "__makeNative", this).call(this);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._a.__getValue() - this._b.__getValue();
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new AnimatedInterpolation(this, config);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._a.__addChild(this);

        this._b.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._a.__removeChild(this);

        this._b.__removeChild(this);

        _get(_getPrototypeOf(AnimatedSubtraction.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'subtraction',
          input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
        };
      }
    }]);

    return AnimatedSubtraction;
  }(AnimatedWithChildren);

  module.exports = AnimatedSubtraction;
},486,[24,25,26,29,138,30,28,32,472,473,471,475],"node_modules\\react-native\\Libraries\\Animated\\src\\nodes\\AnimatedSubtraction.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _get = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/get");

  var _inherits = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/defineProperty");

  var AnimatedValue = _$$_REQUIRE(_dependencyMap[9], "./AnimatedValue");

  var AnimatedNode = _$$_REQUIRE(_dependencyMap[10], "./AnimatedNode");

  var _require = _$$_REQUIRE(_dependencyMap[11], "../NativeAnimatedHelper"),
      generateNewAnimationId = _require.generateNewAnimationId,
      shouldUseNativeDriver = _require.shouldUseNativeDriver;

  var AnimatedTracking = function (_AnimatedNode) {
    _inherits(AnimatedTracking, _AnimatedNode);

    function AnimatedTracking(value, parent, animationClass, animationConfig, callback) {
      var _this;

      _classCallCheck(this, AnimatedTracking);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedTracking).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_value", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_parent", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_callback", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_animationConfig", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_animationClass", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_useNativeDriver", void 0);

      _this._value = value;
      _this._parent = parent;
      _this._animationClass = animationClass;
      _this._animationConfig = animationConfig;
      _this._useNativeDriver = shouldUseNativeDriver(animationConfig);
      _this._callback = callback;

      _this.__attach();

      return _this;
    }

    _createClass(AnimatedTracking, [{
      key: "__makeNative",
      value: function __makeNative() {
        this.__isNative = true;

        this._parent.__makeNative();

        _get(_getPrototypeOf(AnimatedTracking.prototype), "__makeNative", this).call(this);

        this._value.__makeNative();
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._parent.__getValue();
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._parent.__addChild(this);

        if (this._useNativeDriver) {
          this.__makeNative();
        }
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._parent.__removeChild(this);

        _get(_getPrototypeOf(AnimatedTracking.prototype), "__detach", this).call(this);
      }
    }, {
      key: "update",
      value: function update() {
        this._value.animate(new this._animationClass(_objectSpread({}, this._animationConfig, {
          toValue: this._animationConfig.toValue.__getValue()
        })), this._callback);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        var animation = new this._animationClass(_objectSpread({}, this._animationConfig, {
          toValue: undefined
        }));

        var animationConfig = animation.__getNativeAnimationConfig();

        return {
          type: 'tracking',
          animationId: generateNewAnimationId(),
          animationConfig: animationConfig,
          toValue: this._parent.__getNativeTag(),
          value: this._value.__getNativeTag()
        };
      }
    }]);

    return AnimatedTracking;
  }(AnimatedNode);

  module.exports = AnimatedTracking;
},487,[148,24,25,26,29,138,30,28,32,471,473,474],"node_modules\\react-native\\Libraries\\Animated\\src\\nodes\\AnimatedTracking.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/defineProperty");

  var AnimatedValue = _$$_REQUIRE(_dependencyMap[7], "./AnimatedValue");

  var AnimatedWithChildren = _$$_REQUIRE(_dependencyMap[8], "./AnimatedWithChildren");

  var invariant = _$$_REQUIRE(_dependencyMap[9], "fbjs/lib/invariant");

  var _uniqueId = 1;

  var AnimatedValueXY = function (_AnimatedWithChildren) {
    _inherits(AnimatedValueXY, _AnimatedWithChildren);

    function AnimatedValueXY(valueIn) {
      var _this;

      _classCallCheck(this, AnimatedValueXY);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedValueXY).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "x", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "y", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_listeners", void 0);

      var value = valueIn || {
        x: 0,
        y: 0
      };

      if (typeof value.x === 'number' && typeof value.y === 'number') {
        _this.x = new AnimatedValue(value.x);
        _this.y = new AnimatedValue(value.y);
      } else {
        invariant(value.x instanceof AnimatedValue && value.y instanceof AnimatedValue, 'AnimatedValueXY must be initialized with an object of numbers or ' + 'AnimatedValues.');
        _this.x = value.x;
        _this.y = value.y;
      }

      _this._listeners = {};
      return _this;
    }

    _createClass(AnimatedValueXY, [{
      key: "setValue",
      value: function setValue(value) {
        this.x.setValue(value.x);
        this.y.setValue(value.y);
      }
    }, {
      key: "setOffset",
      value: function setOffset(offset) {
        this.x.setOffset(offset.x);
        this.y.setOffset(offset.y);
      }
    }, {
      key: "flattenOffset",
      value: function flattenOffset() {
        this.x.flattenOffset();
        this.y.flattenOffset();
      }
    }, {
      key: "extractOffset",
      value: function extractOffset() {
        this.x.extractOffset();
        this.y.extractOffset();
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return {
          x: this.x.__getValue(),
          y: this.y.__getValue()
        };
      }
    }, {
      key: "resetAnimation",
      value: function resetAnimation(callback) {
        this.x.resetAnimation();
        this.y.resetAnimation();
        callback && callback(this.__getValue());
      }
    }, {
      key: "stopAnimation",
      value: function stopAnimation(callback) {
        this.x.stopAnimation();
        this.y.stopAnimation();
        callback && callback(this.__getValue());
      }
    }, {
      key: "addListener",
      value: function addListener(callback) {
        var _this2 = this;

        var id = String(_uniqueId++);

        var jointCallback = function jointCallback(_ref) {
          var number = _ref.value;
          callback(_this2.__getValue());
        };

        this._listeners[id] = {
          x: this.x.addListener(jointCallback),
          y: this.y.addListener(jointCallback)
        };
        return id;
      }
    }, {
      key: "removeListener",
      value: function removeListener(id) {
        this.x.removeListener(this._listeners[id].x);
        this.y.removeListener(this._listeners[id].y);
        delete this._listeners[id];
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners() {
        this.x.removeAllListeners();
        this.y.removeAllListeners();
        this._listeners = {};
      }
    }, {
      key: "getLayout",
      value: function getLayout() {
        return {
          left: this.x,
          top: this.y
        };
      }
    }, {
      key: "getTranslateTransform",
      value: function getTranslateTransform() {
        return [{
          translateX: this.x
        }, {
          translateY: this.y
        }];
      }
    }]);

    return AnimatedValueXY;
  }(AnimatedWithChildren);

  module.exports = AnimatedValueXY;
},488,[24,25,26,29,30,28,32,471,475,117],"node_modules\\react-native\\Libraries\\Animated\\src\\nodes\\AnimatedValueXY.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _get = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/get");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var Animation = _$$_REQUIRE(_dependencyMap[8], "./Animation");

  var _require = _$$_REQUIRE(_dependencyMap[9], "../NativeAnimatedHelper"),
      shouldUseNativeDriver = _require.shouldUseNativeDriver;

  var DecayAnimation = function (_Animation) {
    _inherits(DecayAnimation, _Animation);

    function DecayAnimation(config) {
      var _this;

      _classCallCheck(this, DecayAnimation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(DecayAnimation).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_startTime", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_lastValue", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_fromValue", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_deceleration", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_velocity", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onUpdate", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_animationFrame", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_useNativeDriver", void 0);

      _this._deceleration = config.deceleration !== undefined ? config.deceleration : 0.998;
      _this._velocity = config.velocity;
      _this._useNativeDriver = shouldUseNativeDriver(config);
      _this.__isInteraction = config.isInteraction !== undefined ? config.isInteraction : true;
      _this.__iterations = config.iterations !== undefined ? config.iterations : 1;
      return _this;
    }

    _createClass(DecayAnimation, [{
      key: "__getNativeAnimationConfig",
      value: function __getNativeAnimationConfig() {
        return {
          type: 'decay',
          deceleration: this._deceleration,
          velocity: this._velocity,
          iterations: this.__iterations
        };
      }
    }, {
      key: "start",
      value: function start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
        this.__active = true;
        this._lastValue = fromValue;
        this._fromValue = fromValue;
        this._onUpdate = onUpdate;
        this.__onEnd = onEnd;
        this._startTime = Date.now();

        if (this._useNativeDriver) {
          this.__startNativeAnimation(animatedValue);
        } else {
          this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
        }
      }
    }, {
      key: "onUpdate",
      value: function onUpdate() {
        var now = Date.now();
        var value = this._fromValue + this._velocity / (1 - this._deceleration) * (1 - Math.exp(-(1 - this._deceleration) * (now - this._startTime)));

        this._onUpdate(value);

        if (Math.abs(this._lastValue - value) < 0.1) {
          this.__debouncedOnEnd({
            finished: true
          });

          return;
        }

        this._lastValue = value;

        if (this.__active) {
          this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
        }
      }
    }, {
      key: "stop",
      value: function stop() {
        _get(_getPrototypeOf(DecayAnimation.prototype), "stop", this).call(this);

        this.__active = false;
        global.cancelAnimationFrame(this._animationFrame);

        this.__debouncedOnEnd({
          finished: false
        });
      }
    }]);

    return DecayAnimation;
  }(Animation);

  module.exports = DecayAnimation;
},489,[24,25,26,29,138,30,28,32,490,474],"node_modules\\react-native\\Libraries\\Animated\\src\\animations\\DecayAnimation.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/defineProperty");

  var NativeAnimatedHelper = _$$_REQUIRE(_dependencyMap[3], "NativeAnimatedHelper");

  var Animation = function () {
    function Animation() {
      _classCallCheck(this, Animation);

      _defineProperty(this, "__active", void 0);

      _defineProperty(this, "__isInteraction", void 0);

      _defineProperty(this, "__nativeId", void 0);

      _defineProperty(this, "__onEnd", void 0);

      _defineProperty(this, "__iterations", void 0);
    }

    _createClass(Animation, [{
      key: "start",
      value: function start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {}
    }, {
      key: "stop",
      value: function stop() {
        if (this.__nativeId) {
          NativeAnimatedHelper.API.stopAnimation(this.__nativeId);
        }
      }
    }, {
      key: "__getNativeAnimationConfig",
      value: function __getNativeAnimationConfig() {
        throw new Error('This animation type cannot be offloaded to native');
      }
    }, {
      key: "__debouncedOnEnd",
      value: function __debouncedOnEnd(result) {
        var onEnd = this.__onEnd;
        this.__onEnd = null;
        onEnd && onEnd(result);
      }
    }, {
      key: "__startNativeAnimation",
      value: function __startNativeAnimation(animatedValue) {
        animatedValue.__makeNative();

        this.__nativeId = NativeAnimatedHelper.generateNewAnimationId();
        NativeAnimatedHelper.API.startAnimatingNode(this.__nativeId, animatedValue.__getNativeTag(), this.__getNativeAnimationConfig(), this.__debouncedOnEnd.bind(this));
      }
    }]);

    return Animation;
  }();

  module.exports = Animation;
},490,[24,25,32,474],"node_modules\\react-native\\Libraries\\Animated\\src\\animations\\Animation.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _get = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/get");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var AnimatedValue = _$$_REQUIRE(_dependencyMap[8], "../nodes/AnimatedValue");

  var AnimatedValueXY = _$$_REQUIRE(_dependencyMap[9], "../nodes/AnimatedValueXY");

  var Animation = _$$_REQUIRE(_dependencyMap[10], "./Animation");

  var SpringConfig = _$$_REQUIRE(_dependencyMap[11], "../SpringConfig");

  var invariant = _$$_REQUIRE(_dependencyMap[12], "fbjs/lib/invariant");

  var _require = _$$_REQUIRE(_dependencyMap[13], "../NativeAnimatedHelper"),
      shouldUseNativeDriver = _require.shouldUseNativeDriver;

  function withDefault(value, defaultValue) {
    if (value === undefined || value === null) {
      return defaultValue;
    }

    return value;
  }

  var SpringAnimation = function (_Animation) {
    _inherits(SpringAnimation, _Animation);

    function SpringAnimation(config) {
      var _this;

      _classCallCheck(this, SpringAnimation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SpringAnimation).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_overshootClamping", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_restDisplacementThreshold", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_restSpeedThreshold", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_lastVelocity", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_startPosition", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_lastPosition", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_fromValue", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_toValue", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_stiffness", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_damping", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_mass", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_initialVelocity", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_delay", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_timeout", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_startTime", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_lastTime", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_frameTime", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onUpdate", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_animationFrame", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_useNativeDriver", void 0);

      _this._overshootClamping = withDefault(config.overshootClamping, false);
      _this._restDisplacementThreshold = withDefault(config.restDisplacementThreshold, 0.001);
      _this._restSpeedThreshold = withDefault(config.restSpeedThreshold, 0.001);
      _this._initialVelocity = withDefault(config.velocity, 0);
      _this._lastVelocity = withDefault(config.velocity, 0);
      _this._toValue = config.toValue;
      _this._delay = withDefault(config.delay, 0);
      _this._useNativeDriver = shouldUseNativeDriver(config);
      _this.__isInteraction = config.isInteraction !== undefined ? config.isInteraction : true;
      _this.__iterations = config.iterations !== undefined ? config.iterations : 1;

      if (config.stiffness !== undefined || config.damping !== undefined || config.mass !== undefined) {
        invariant(config.bounciness === undefined && config.speed === undefined && config.tension === undefined && config.friction === undefined, 'You can define one of bounciness/speed, tension/friction, or stiffness/damping/mass, but not more than one');
        _this._stiffness = withDefault(config.stiffness, 100);
        _this._damping = withDefault(config.damping, 10);
        _this._mass = withDefault(config.mass, 1);
      } else if (config.bounciness !== undefined || config.speed !== undefined) {
        invariant(config.tension === undefined && config.friction === undefined && config.stiffness === undefined && config.damping === undefined && config.mass === undefined, 'You can define one of bounciness/speed, tension/friction, or stiffness/damping/mass, but not more than one');
        var springConfig = SpringConfig.fromBouncinessAndSpeed(withDefault(config.bounciness, 8), withDefault(config.speed, 12));
        _this._stiffness = springConfig.stiffness;
        _this._damping = springConfig.damping;
        _this._mass = 1;
      } else {
        var _springConfig = SpringConfig.fromOrigamiTensionAndFriction(withDefault(config.tension, 40), withDefault(config.friction, 7));

        _this._stiffness = _springConfig.stiffness;
        _this._damping = _springConfig.damping;
        _this._mass = 1;
      }

      invariant(_this._stiffness > 0, 'Stiffness value must be greater than 0');
      invariant(_this._damping > 0, 'Damping value must be greater than 0');
      invariant(_this._mass > 0, 'Mass value must be greater than 0');
      return _this;
    }

    _createClass(SpringAnimation, [{
      key: "__getNativeAnimationConfig",
      value: function __getNativeAnimationConfig() {
        return {
          type: 'spring',
          overshootClamping: this._overshootClamping,
          restDisplacementThreshold: this._restDisplacementThreshold,
          restSpeedThreshold: this._restSpeedThreshold,
          stiffness: this._stiffness,
          damping: this._damping,
          mass: this._mass,
          initialVelocity: withDefault(this._initialVelocity, this._lastVelocity),
          toValue: this._toValue,
          iterations: this.__iterations
        };
      }
    }, {
      key: "start",
      value: function start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
        var _this2 = this;

        this.__active = true;
        this._startPosition = fromValue;
        this._lastPosition = this._startPosition;
        this._onUpdate = onUpdate;
        this.__onEnd = onEnd;
        this._lastTime = Date.now();
        this._frameTime = 0.0;

        if (previousAnimation instanceof SpringAnimation) {
          var internalState = previousAnimation.getInternalState();
          this._lastPosition = internalState.lastPosition;
          this._lastVelocity = internalState.lastVelocity;
          this._initialVelocity = this._lastVelocity;
          this._lastTime = internalState.lastTime;
        }

        var start = function start() {
          if (_this2._useNativeDriver) {
            _this2.__startNativeAnimation(animatedValue);
          } else {
            _this2.onUpdate();
          }
        };

        if (this._delay) {
          this._timeout = setTimeout(start, this._delay);
        } else {
          start();
        }
      }
    }, {
      key: "getInternalState",
      value: function getInternalState() {
        return {
          lastPosition: this._lastPosition,
          lastVelocity: this._lastVelocity,
          lastTime: this._lastTime
        };
      }
    }, {
      key: "onUpdate",
      value: function onUpdate() {
        var MAX_STEPS = 64;
        var now = Date.now();

        if (now > this._lastTime + MAX_STEPS) {
          now = this._lastTime + MAX_STEPS;
        }

        var deltaTime = (now - this._lastTime) / 1000;
        this._frameTime += deltaTime;
        var c = this._damping;
        var m = this._mass;
        var k = this._stiffness;
        var v0 = -this._initialVelocity;
        var zeta = c / (2 * Math.sqrt(k * m));
        var omega0 = Math.sqrt(k / m);
        var omega1 = omega0 * Math.sqrt(1.0 - zeta * zeta);
        var x0 = this._toValue - this._startPosition;
        var position = 0.0;
        var velocity = 0.0;
        var t = this._frameTime;

        if (zeta < 1) {
          var envelope = Math.exp(-zeta * omega0 * t);
          position = this._toValue - envelope * ((v0 + zeta * omega0 * x0) / omega1 * Math.sin(omega1 * t) + x0 * Math.cos(omega1 * t));
          velocity = zeta * omega0 * envelope * (Math.sin(omega1 * t) * (v0 + zeta * omega0 * x0) / omega1 + x0 * Math.cos(omega1 * t)) - envelope * (Math.cos(omega1 * t) * (v0 + zeta * omega0 * x0) - omega1 * x0 * Math.sin(omega1 * t));
        } else {
          var _envelope = Math.exp(-omega0 * t);

          position = this._toValue - _envelope * (x0 + (v0 + omega0 * x0) * t);
          velocity = _envelope * (v0 * (t * omega0 - 1) + t * x0 * (omega0 * omega0));
        }

        this._lastTime = now;
        this._lastPosition = position;
        this._lastVelocity = velocity;

        this._onUpdate(position);

        if (!this.__active) {
          return;
        }

        var isOvershooting = false;

        if (this._overshootClamping && this._stiffness !== 0) {
          if (this._startPosition < this._toValue) {
            isOvershooting = position > this._toValue;
          } else {
            isOvershooting = position < this._toValue;
          }
        }

        var isVelocity = Math.abs(velocity) <= this._restSpeedThreshold;

        var isDisplacement = true;

        if (this._stiffness !== 0) {
          isDisplacement = Math.abs(this._toValue - position) <= this._restDisplacementThreshold;
        }

        if (isOvershooting || isVelocity && isDisplacement) {
          if (this._stiffness !== 0) {
            this._lastPosition = this._toValue;
            this._lastVelocity = 0;

            this._onUpdate(this._toValue);
          }

          this.__debouncedOnEnd({
            finished: true
          });

          return;
        }

        this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
      }
    }, {
      key: "stop",
      value: function stop() {
        _get(_getPrototypeOf(SpringAnimation.prototype), "stop", this).call(this);

        this.__active = false;
        clearTimeout(this._timeout);
        global.cancelAnimationFrame(this._animationFrame);

        this.__debouncedOnEnd({
          finished: false
        });
      }
    }]);

    return SpringAnimation;
  }(Animation);

  module.exports = SpringAnimation;
},491,[24,25,26,29,138,30,28,32,471,488,490,492,117,474],"node_modules\\react-native\\Libraries\\Animated\\src\\animations\\SpringAnimation.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function stiffnessFromOrigamiValue(oValue) {
    return (oValue - 30) * 3.62 + 194;
  }

  function dampingFromOrigamiValue(oValue) {
    return (oValue - 8) * 3 + 25;
  }

  function fromOrigamiTensionAndFriction(tension, friction) {
    return {
      stiffness: stiffnessFromOrigamiValue(tension),
      damping: dampingFromOrigamiValue(friction)
    };
  }

  function fromBouncinessAndSpeed(bounciness, speed) {
    function normalize(value, startValue, endValue) {
      return (value - startValue) / (endValue - startValue);
    }

    function projectNormal(n, start, end) {
      return start + n * (end - start);
    }

    function linearInterpolation(t, start, end) {
      return t * end + (1 - t) * start;
    }

    function quadraticOutInterpolation(t, start, end) {
      return linearInterpolation(2 * t - t * t, start, end);
    }

    function b3Friction1(x) {
      return 0.0007 * Math.pow(x, 3) - 0.031 * Math.pow(x, 2) + 0.64 * x + 1.28;
    }

    function b3Friction2(x) {
      return 0.000044 * Math.pow(x, 3) - 0.006 * Math.pow(x, 2) + 0.36 * x + 2;
    }

    function b3Friction3(x) {
      return 0.00000045 * Math.pow(x, 3) - 0.000332 * Math.pow(x, 2) + 0.1078 * x + 5.84;
    }

    function b3Nobounce(tension) {
      if (tension <= 18) {
        return b3Friction1(tension);
      } else if (tension > 18 && tension <= 44) {
        return b3Friction2(tension);
      } else {
        return b3Friction3(tension);
      }
    }

    var b = normalize(bounciness / 1.7, 0, 20);
    b = projectNormal(b, 0, 0.8);
    var s = normalize(speed / 1.7, 0, 20);
    var bouncyTension = projectNormal(s, 0.5, 200);
    var bouncyFriction = quadraticOutInterpolation(b, b3Nobounce(bouncyTension), 0.01);
    return {
      stiffness: stiffnessFromOrigamiValue(bouncyTension),
      damping: dampingFromOrigamiValue(bouncyFriction)
    };
  }

  module.exports = {
    fromOrigamiTensionAndFriction: fromOrigamiTensionAndFriction,
    fromBouncinessAndSpeed: fromBouncinessAndSpeed
  };
},492,[],"node_modules\\react-native\\Libraries\\Animated\\src\\SpringConfig.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _get = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/get");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var AnimatedValue = _$$_REQUIRE(_dependencyMap[8], "../nodes/AnimatedValue");

  var AnimatedValueXY = _$$_REQUIRE(_dependencyMap[9], "../nodes/AnimatedValueXY");

  var Animation = _$$_REQUIRE(_dependencyMap[10], "./Animation");

  var _require = _$$_REQUIRE(_dependencyMap[11], "../NativeAnimatedHelper"),
      shouldUseNativeDriver = _require.shouldUseNativeDriver;

  var _easeInOut;

  function easeInOut() {
    if (!_easeInOut) {
      var Easing = _$$_REQUIRE(_dependencyMap[12], "Easing");

      _easeInOut = Easing.inOut(Easing.ease);
    }

    return _easeInOut;
  }

  var TimingAnimation = function (_Animation) {
    _inherits(TimingAnimation, _Animation);

    function TimingAnimation(config) {
      var _this;

      _classCallCheck(this, TimingAnimation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(TimingAnimation).call(this));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_startTime", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_fromValue", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_toValue", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_duration", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_delay", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_easing", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onUpdate", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_animationFrame", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_timeout", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_useNativeDriver", void 0);

      _this._toValue = config.toValue;
      _this._easing = config.easing !== undefined ? config.easing : easeInOut();
      _this._duration = config.duration !== undefined ? config.duration : 500;
      _this._delay = config.delay !== undefined ? config.delay : 0;
      _this.__iterations = config.iterations !== undefined ? config.iterations : 1;
      _this.__isInteraction = config.isInteraction !== undefined ? config.isInteraction : true;
      _this._useNativeDriver = shouldUseNativeDriver(config);
      return _this;
    }

    _createClass(TimingAnimation, [{
      key: "__getNativeAnimationConfig",
      value: function __getNativeAnimationConfig() {
        var frameDuration = 1000.0 / 60.0;
        var frames = [];

        for (var dt = 0.0; dt < this._duration; dt += frameDuration) {
          frames.push(this._easing(dt / this._duration));
        }

        frames.push(this._easing(1));
        return {
          type: 'frames',
          frames: frames,
          toValue: this._toValue,
          iterations: this.__iterations
        };
      }
    }, {
      key: "start",
      value: function start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
        var _this2 = this;

        this.__active = true;
        this._fromValue = fromValue;
        this._onUpdate = onUpdate;
        this.__onEnd = onEnd;

        var start = function start() {
          if (_this2._duration === 0 && !_this2._useNativeDriver) {
            _this2._onUpdate(_this2._toValue);

            _this2.__debouncedOnEnd({
              finished: true
            });
          } else {
            _this2._startTime = Date.now();

            if (_this2._useNativeDriver) {
              _this2.__startNativeAnimation(animatedValue);
            } else {
              _this2._animationFrame = requestAnimationFrame(_this2.onUpdate.bind(_this2));
            }
          }
        };

        if (this._delay) {
          this._timeout = setTimeout(start, this._delay);
        } else {
          start();
        }
      }
    }, {
      key: "onUpdate",
      value: function onUpdate() {
        var now = Date.now();

        if (now >= this._startTime + this._duration) {
          if (this._duration === 0) {
            this._onUpdate(this._toValue);
          } else {
            this._onUpdate(this._fromValue + this._easing(1) * (this._toValue - this._fromValue));
          }

          this.__debouncedOnEnd({
            finished: true
          });

          return;
        }

        this._onUpdate(this._fromValue + this._easing((now - this._startTime) / this._duration) * (this._toValue - this._fromValue));

        if (this.__active) {
          this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
        }
      }
    }, {
      key: "stop",
      value: function stop() {
        _get(_getPrototypeOf(TimingAnimation.prototype), "stop", this).call(this);

        this.__active = false;
        clearTimeout(this._timeout);
        global.cancelAnimationFrame(this._animationFrame);

        this.__debouncedOnEnd({
          finished: false
        });
      }
    }]);

    return TimingAnimation;
  }(Animation);

  module.exports = TimingAnimation;
},493,[24,25,26,29,138,30,28,32,471,488,490,474,494],"node_modules\\react-native\\Libraries\\Animated\\src\\animations\\TimingAnimation.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _ease;

  var Easing = function () {
    function Easing() {
      _classCallCheck(this, Easing);
    }

    _createClass(Easing, null, [{
      key: "step0",
      value: function step0(n) {
        return n > 0 ? 1 : 0;
      }
    }, {
      key: "step1",
      value: function step1(n) {
        return n >= 1 ? 1 : 0;
      }
    }, {
      key: "linear",
      value: function linear(t) {
        return t;
      }
    }, {
      key: "ease",
      value: function ease(t) {
        if (!_ease) {
          _ease = Easing.bezier(0.42, 0, 1, 1);
        }

        return _ease(t);
      }
    }, {
      key: "quad",
      value: function quad(t) {
        return t * t;
      }
    }, {
      key: "cubic",
      value: function cubic(t) {
        return t * t * t;
      }
    }, {
      key: "poly",
      value: function poly(n) {
        return function (t) {
          return Math.pow(t, n);
        };
      }
    }, {
      key: "sin",
      value: function sin(t) {
        return 1 - Math.cos(t * Math.PI / 2);
      }
    }, {
      key: "circle",
      value: function circle(t) {
        return 1 - Math.sqrt(1 - t * t);
      }
    }, {
      key: "exp",
      value: function exp(t) {
        return Math.pow(2, 10 * (t - 1));
      }
    }, {
      key: "elastic",
      value: function elastic() {
        var bounciness = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var p = bounciness * Math.PI;
        return function (t) {
          return 1 - Math.pow(Math.cos(t * Math.PI / 2), 3) * Math.cos(t * p);
        };
      }
    }, {
      key: "back",
      value: function back(s) {
        if (s === undefined) {
          s = 1.70158;
        }

        return function (t) {
          return t * t * ((s + 1) * t - s);
        };
      }
    }, {
      key: "bounce",
      value: function bounce(t) {
        if (t < 1 / 2.75) {
          return 7.5625 * t * t;
        }

        if (t < 2 / 2.75) {
          t -= 1.5 / 2.75;
          return 7.5625 * t * t + 0.75;
        }

        if (t < 2.5 / 2.75) {
          t -= 2.25 / 2.75;
          return 7.5625 * t * t + 0.9375;
        }

        t -= 2.625 / 2.75;
        return 7.5625 * t * t + 0.984375;
      }
    }, {
      key: "bezier",
      value: function bezier(x1, y1, x2, y2) {
        var _bezier = _$$_REQUIRE(_dependencyMap[2], "bezier");

        return _bezier(x1, y1, x2, y2);
      }
    }, {
      key: "in",
      value: function _in(easing) {
        return easing;
      }
    }, {
      key: "out",
      value: function out(easing) {
        return function (t) {
          return 1 - easing(1 - t);
        };
      }
    }, {
      key: "inOut",
      value: function inOut(easing) {
        return function (t) {
          if (t < 0.5) {
            return easing(t * 2) / 2;
          }

          return 1 - easing((1 - t) * 2) / 2;
        };
      }
    }]);

    return Easing;
  }();

  module.exports = Easing;
},494,[24,25,495],"node_modules\\react-native\\Libraries\\Animated\\src\\Easing.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var NEWTON_ITERATIONS = 4;
  var NEWTON_MIN_SLOPE = 0.001;
  var SUBDIVISION_PRECISION = 0.0000001;
  var SUBDIVISION_MAX_ITERATIONS = 10;
  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
  var float32ArraySupported = typeof Float32Array === 'function';

  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  function C(aA1) {
    return 3.0 * aA1;
  }

  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX,
        currentT,
        i = 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;

      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }

  module.exports = function bezier(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
      throw new Error('bezier x values must be in [0, 1] range');
    }

    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function getTForX(aX) {
      var intervalStart = 0.0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample;
      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= NEWTON_MIN_SLOPE) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    }

    return function BezierEasing(x) {
      if (mX1 === mY1 && mX2 === mY2) {
        return x;
      }

      if (x === 0) {
        return 0;
      }

      if (x === 1) {
        return 1;
      }

      return calcBezier(getTForX(x), mY1, mY2);
    };
  };
},495,[],"node_modules\\react-native\\Libraries\\Animated\\src\\bezier.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Animated\\src\\createAnimatedComponent.js";
  var _components = {
    AnimatedComponent: {
      displayName: "AnimatedComponent",
      isInFunction: true
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Animated\\src\\createAnimatedComponent.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var _require = _$$_REQUIRE(_dependencyMap[11], "./AnimatedEvent"),
      AnimatedEvent = _require.AnimatedEvent;

  var AnimatedProps = _$$_REQUIRE(_dependencyMap[12], "./nodes/AnimatedProps");

  var React = _$$_REQUIRE(_dependencyMap[13], "React");

  var ViewStylePropTypes = _$$_REQUIRE(_dependencyMap[14], "ViewStylePropTypes");

  var invariant = _$$_REQUIRE(_dependencyMap[15], "fbjs/lib/invariant");

  function createAnimatedComponent(Component) {
    invariant(typeof Component !== 'function' || Component.prototype && Component.prototype.isReactComponent, '`createAnimatedComponent` does not support stateless functional components; ' + 'use a class component instead.');

    var AnimatedComponent = function (_React$Component) {
      _inherits(AnimatedComponent, _React$Component);

      function AnimatedComponent(props) {
        var _this;

        _classCallCheck(this, AnimatedComponent);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedComponent).call(this, props));

        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_component", void 0);

        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_invokeAnimatedPropsCallbackOnMount", false);

        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_prevComponent", void 0);

        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_propsAnimated", void 0);

        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_eventDetachers", []);

        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_setComponentRef", void 0);

        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_animatedPropsCallback", function () {
          if (_this._component == null) {
            _this._invokeAnimatedPropsCallbackOnMount = true;
          } else if (AnimatedComponent.__skipSetNativeProps_FOR_TESTS_ONLY || typeof _this._component.setNativeProps !== 'function') {
            _this.forceUpdate();
          } else if (!_this._propsAnimated.__isNative) {
            _this._component.setNativeProps(_this._propsAnimated.__getAnimatedValue());
          } else {
            throw new Error('Attempting to run JS driven animation on animated ' + 'node that has been moved to "native" earlier by starting an ' + 'animation with `useNativeDriver: true`');
          }
        });

        _this._setComponentRef = _this._setComponentRef.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        return _this;
      }

      _createClass(AnimatedComponent, [{
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this._propsAnimated && this._propsAnimated.__detach();

          this._detachNativeEvents();
        }
      }, {
        key: "setNativeProps",
        value: function setNativeProps(props) {
          this._component.setNativeProps(props);
        }
      }, {
        key: "UNSAFE_componentWillMount",
        value: function UNSAFE_componentWillMount() {
          this._attachProps(this.props);
        }
      }, {
        key: "componentDidMount",
        value: function componentDidMount() {
          if (this._invokeAnimatedPropsCallbackOnMount) {
            this._invokeAnimatedPropsCallbackOnMount = false;

            this._animatedPropsCallback();
          }

          this._propsAnimated.setNativeView(this._component);

          this._attachNativeEvents();
        }
      }, {
        key: "_attachNativeEvents",
        value: function _attachNativeEvents() {
          var _this2 = this;

          var scrollableNode = this._component.getScrollableNode ? this._component.getScrollableNode() : this._component;

          var _loop = function _loop(key) {
            var prop = _this2.props[key];

            if (prop instanceof AnimatedEvent && prop.__isNative) {
              prop.__attach(scrollableNode, key);

              _this2._eventDetachers.push(function () {
                return prop.__detach(scrollableNode, key);
              });
            }
          };

          for (var key in this.props) {
            _loop(key);
          }
        }
      }, {
        key: "_detachNativeEvents",
        value: function _detachNativeEvents() {
          this._eventDetachers.forEach(function (remove) {
            return remove();
          });

          this._eventDetachers = [];
        }
      }, {
        key: "_attachProps",
        value: function _attachProps(nextProps) {
          var oldPropsAnimated = this._propsAnimated;
          this._propsAnimated = new AnimatedProps(nextProps, this._animatedPropsCallback);
          oldPropsAnimated && oldPropsAnimated.__detach();
        }
      }, {
        key: "UNSAFE_componentWillReceiveProps",
        value: function UNSAFE_componentWillReceiveProps(newProps) {
          this._attachProps(newProps);
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          if (this._component !== this._prevComponent) {
            this._propsAnimated.setNativeView(this._component);
          }

          if (this._component !== this._prevComponent || prevProps !== this.props) {
            this._detachNativeEvents();

            this._attachNativeEvents();
          }
        }
      }, {
        key: "render",
        value: function render() {
          var props = this._propsAnimated.__getValue();

          return React.createElement(Component, _extends({}, props, {
            ref: this._setComponentRef,
            collapsable: this._propsAnimated.__isNative ? false : props.collapsable,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 153
            }
          }));
        }
      }, {
        key: "_setComponentRef",
        value: function _setComponentRef(c) {
          this._prevComponent = this._component;
          this._component = c;
        }
      }, {
        key: "getNode",
        value: function getNode() {
          return this._component;
        }
      }]);

      return AnimatedComponent;
    }(React.Component);

    _defineProperty(AnimatedComponent, "__skipSetNativeProps_FOR_TESTS_ONLY", false);

    AnimatedComponent = _wrapComponent("AnimatedComponent")(AnimatedComponent);
    var propTypes = Component.propTypes;
    AnimatedComponent.propTypes = {
      style: function style(props, propName, componentName) {
        if (!propTypes) {
          return;
        }

        for (var key in ViewStylePropTypes) {
          if (!propTypes[key] && props[key] !== undefined) {
            console.warn('You are setting the style `{ ' + key + ': ... }` as a prop. You ' + 'should nest it in a style object. ' + 'E.g. `{ style: { ' + key + ': ... } }`');
          }
        }
      }
    };
    return AnimatedComponent;
  }

  module.exports = createAnimatedComponent;
},496,[23,112,24,25,26,29,30,28,32,109,280,470,483,149,168,117],"node_modules\\react-native\\Libraries\\Animated\\src\\createAnimatedComponent.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _createClass = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/defineProperty");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/objectSpread");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Lists\\FlatList.js";
  var _components = {
    FlatList: {
      displayName: "FlatList"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Lists\\FlatList.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var MetroListView = _$$_REQUIRE(_dependencyMap[12], "MetroListView");

  var React = _$$_REQUIRE(_dependencyMap[13], "React");

  var View = _$$_REQUIRE(_dependencyMap[14], "View");

  var VirtualizedList = _$$_REQUIRE(_dependencyMap[15], "VirtualizedList");

  var ListView = _$$_REQUIRE(_dependencyMap[16], "ListView");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[17], "StyleSheet");

  var invariant = _$$_REQUIRE(_dependencyMap[18], "fbjs/lib/invariant");

  var defaultProps = _objectSpread({}, VirtualizedList.defaultProps, {
    numColumns: 1
  });

  var FlatList = function (_React$PureComponent) {
    _inherits(FlatList, _React$PureComponent);

    _createClass(FlatList, [{
      key: "scrollToEnd",
      value: function scrollToEnd(params) {
        if (this._listRef) {
          this._listRef.scrollToEnd(params);
        }
      }
    }, {
      key: "scrollToIndex",
      value: function scrollToIndex(params) {
        if (this._listRef) {
          this._listRef.scrollToIndex(params);
        }
      }
    }, {
      key: "scrollToItem",
      value: function scrollToItem(params) {
        if (this._listRef) {
          this._listRef.scrollToItem(params);
        }
      }
    }, {
      key: "scrollToOffset",
      value: function scrollToOffset(params) {
        if (this._listRef) {
          this._listRef.scrollToOffset(params);
        }
      }
    }, {
      key: "recordInteraction",
      value: function recordInteraction() {
        if (this._listRef) {
          this._listRef.recordInteraction();
        }
      }
    }, {
      key: "flashScrollIndicators",
      value: function flashScrollIndicators() {
        if (this._listRef) {
          this._listRef.flashScrollIndicators();
        }
      }
    }, {
      key: "getScrollResponder",
      value: function getScrollResponder() {
        if (this._listRef) {
          return this._listRef.getScrollResponder();
        }
      }
    }, {
      key: "getScrollableNode",
      value: function getScrollableNode() {
        if (this._listRef) {
          return this._listRef.getScrollableNode();
        }
      }
    }, {
      key: "setNativeProps",
      value: function setNativeProps(props) {
        if (this._listRef) {
          this._listRef.setNativeProps(props);
        }
      }
    }]);

    function FlatList(props) {
      var _this;

      _classCallCheck(this, FlatList);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FlatList).call(this, props));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "props", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_hasWarnedLegacy", false);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_listRef", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_virtualizedListPairs", []);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_captureRef", function (ref) {
        _this._listRef = ref;
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_getItem", function (data, index) {
        var numColumns = _this.props.numColumns;

        if (numColumns > 1) {
          var ret = [];

          for (var kk = 0; kk < numColumns; kk++) {
            var _item = data[index * numColumns + kk];

            if (_item != null) {
              ret.push(_item);
            }
          }

          return ret;
        } else {
          return data[index];
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_getItemCount", function (data) {
        return data ? Math.ceil(data.length / _this.props.numColumns) : 0;
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_keyExtractor", function (items, index) {
        var _this$props = _this.props,
            keyExtractor = _this$props.keyExtractor,
            numColumns = _this$props.numColumns;

        if (numColumns > 1) {
          invariant(Array.isArray(items), 'FlatList: Encountered internal consistency error, expected each item to consist of an ' + 'array with 1-%s columns; instead, received a single item.', numColumns);
          return items.map(function (it, kk) {
            return keyExtractor(it, index * numColumns + kk);
          }).join(':');
        } else {
          return keyExtractor(items, index);
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_renderItem", function (info) {
        var _this$props2 = _this.props,
            renderItem = _this$props2.renderItem,
            numColumns = _this$props2.numColumns,
            columnWrapperStyle = _this$props2.columnWrapperStyle;

        if (numColumns > 1) {
          var _item2 = info.item,
              _index = info.index;
          invariant(Array.isArray(_item2), 'Expected array of items with numColumns > 1');
          return React.createElement(View, {
            style: StyleSheet.compose(styles.row, columnWrapperStyle),
            __source: {
              fileName: _jsxFileName,
              lineNumber: 626
            }
          }, _item2.map(function (it, kk) {
            var element = renderItem({
              item: it,
              index: _index * numColumns + kk,
              separators: info.separators
            });
            return element && React.cloneElement(element, {
              key: kk
            });
          }));
        } else {
          return renderItem(info);
        }
      });

      _this._checkProps(_this.props);

      if (_this.props.viewabilityConfigCallbackPairs) {
        _this._virtualizedListPairs = _this.props.viewabilityConfigCallbackPairs.map(function (pair) {
          return {
            viewabilityConfig: pair.viewabilityConfig,
            onViewableItemsChanged: _this._createOnViewableItemsChanged(pair.onViewableItemsChanged)
          };
        });
      } else if (_this.props.onViewableItemsChanged) {
        _this._virtualizedListPairs.push({
          viewabilityConfig: _this.props.viewabilityConfig,
          onViewableItemsChanged: _this._createOnViewableItemsChanged(_this.props.onViewableItemsChanged)
        });
      }

      return _this;
    }

    _createClass(FlatList, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        invariant(prevProps.numColumns === this.props.numColumns, 'Changing numColumns on the fly is not supported. Change the key prop on FlatList when ' + 'changing the number of columns to force a fresh render of the component.');
        invariant(prevProps.onViewableItemsChanged === this.props.onViewableItemsChanged, 'Changing onViewableItemsChanged on the fly is not supported');
        invariant(prevProps.viewabilityConfig === this.props.viewabilityConfig, 'Changing viewabilityConfig on the fly is not supported');
        invariant(prevProps.viewabilityConfigCallbackPairs === this.props.viewabilityConfigCallbackPairs, 'Changing viewabilityConfigCallbackPairs on the fly is not supported');

        this._checkProps(this.props);
      }
    }, {
      key: "_checkProps",
      value: function _checkProps(props) {
        var getItem = props.getItem,
            getItemCount = props.getItemCount,
            horizontal = props.horizontal,
            legacyImplementation = props.legacyImplementation,
            numColumns = props.numColumns,
            columnWrapperStyle = props.columnWrapperStyle,
            onViewableItemsChanged = props.onViewableItemsChanged,
            viewabilityConfigCallbackPairs = props.viewabilityConfigCallbackPairs;
        invariant(!getItem && !getItemCount, 'FlatList does not support custom data formats.');

        if (numColumns > 1) {
          invariant(!horizontal, 'numColumns does not support horizontal.');
        } else {
          invariant(!columnWrapperStyle, 'columnWrapperStyle not supported for single column lists');
        }

        if (legacyImplementation) {
          invariant(numColumns === 1, 'Legacy list does not support multiple columns.');

          if (!this._hasWarnedLegacy) {
            console.warn('FlatList: legacyImplementation is deprecated and will be removed in a ' + 'future release - some features not supported and performance may suffer. ' + 'Please migrate to the default implementation.');
            this._hasWarnedLegacy = true;
          }
        }

        invariant(!(onViewableItemsChanged && viewabilityConfigCallbackPairs), 'FlatList does not support setting both onViewableItemsChanged and ' + 'viewabilityConfigCallbackPairs.');
      }
    }, {
      key: "_pushMultiColumnViewable",
      value: function _pushMultiColumnViewable(arr, v) {
        var _this$props3 = this.props,
            numColumns = _this$props3.numColumns,
            keyExtractor = _this$props3.keyExtractor;
        v.item.forEach(function (item, ii) {
          invariant(v.index != null, 'Missing index!');
          var index = v.index * numColumns + ii;
          arr.push(_objectSpread({}, v, {
            item: item,
            key: keyExtractor(item, index),
            index: index
          }));
        });
      }
    }, {
      key: "_createOnViewableItemsChanged",
      value: function _createOnViewableItemsChanged(onViewableItemsChanged) {
        var _this2 = this;

        return function (info) {
          var numColumns = _this2.props.numColumns;

          if (onViewableItemsChanged) {
            if (numColumns > 1) {
              var changed = [];
              var viewableItems = [];
              info.viewableItems.forEach(function (v) {
                return _this2._pushMultiColumnViewable(viewableItems, v);
              });
              info.changed.forEach(function (v) {
                return _this2._pushMultiColumnViewable(changed, v);
              });
              onViewableItemsChanged({
                viewableItems: viewableItems,
                changed: changed
              });
            } else {
              onViewableItemsChanged(info);
            }
          }
        };
      }
    }, {
      key: "render",
      value: function render() {
        if (this.props.legacyImplementation) {
          return React.createElement(MetroListView, _extends({}, this.props, {
            items: this.props.data,
            ref: this._captureRef,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 652
            }
          }));
        } else {
          return React.createElement(VirtualizedList, _extends({}, this.props, {
            renderItem: this._renderItem,
            getItem: this._getItem,
            getItemCount: this._getItemCount,
            keyExtractor: this._keyExtractor,
            ref: this._captureRef,
            viewabilityConfigCallbackPairs: this._virtualizedListPairs,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 663
            }
          }));
        }
      }
    }]);

    return FlatList;
  }(React.PureComponent);

  _defineProperty(FlatList, "defaultProps", defaultProps);

  FlatList = _wrapComponent("FlatList")(FlatList);
  var styles = StyleSheet.create({
    row: {
      flexDirection: 'row'
    }
  });
  module.exports = FlatList;
},497,[23,112,24,26,29,25,30,28,32,148,109,280,498,149,175,516,499,150,117],"node_modules\\react-native\\Libraries\\Lists\\FlatList.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Lists\\MetroListView.js";
  var _components = {
    MetroListView: {
      displayName: "MetroListView"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Lists\\MetroListView.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var ListView = _$$_REQUIRE(_dependencyMap[11], "ListView");

  var React = _$$_REQUIRE(_dependencyMap[12], "React");

  var RefreshControl = _$$_REQUIRE(_dependencyMap[13], "RefreshControl");

  var ScrollView = _$$_REQUIRE(_dependencyMap[14], "ScrollView");

  var invariant = _$$_REQUIRE(_dependencyMap[15], "fbjs/lib/invariant");

  var MetroListView = function (_React$Component) {
    _inherits(MetroListView, _React$Component);

    function MetroListView() {
      var _getPrototypeOf2,
          _this2 = this;

      var _this;

      _classCallCheck(this, MetroListView);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MetroListView)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", _this._computeState(_this.props, {
        ds: new ListView.DataSource({
          rowHasChanged: function rowHasChanged(itemA, itemB) {
            return true;
          },
          sectionHeaderHasChanged: function sectionHeaderHasChanged() {
            return true;
          },
          getSectionHeaderData: function getSectionHeaderData(dataBlob, sectionID) {
            return _this.state.sectionHeaderData[sectionID];
          }
        }),
        sectionHeaderData: {}
      }));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_listRef", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_captureRef", function (ref) {
        _this._listRef = ref;
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_renderFooter", function () {
        return React.createElement(_this2.props.FooterComponent, {
          key: "$footer",
          __source: {
            fileName: _jsxFileName,
            lineNumber: 183
          }
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_renderRow", function (item, sectionID, rowID, highlightRow) {
        return _this.props.renderItem({
          item: item,
          index: rowID
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_renderSectionHeader", function (section, sectionID) {
        var renderSectionHeader = _this.props.renderSectionHeader;
        invariant(renderSectionHeader, 'Must provide renderSectionHeader with sections prop');
        return renderSectionHeader({
          section: section
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_renderSeparator", function (sID, rID) {
        return React.createElement(_this2.props.SeparatorComponent, {
          key: sID + rID,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 199
          }
        });
      });

      return _this;
    }

    _createClass(MetroListView, [{
      key: "scrollToEnd",
      value: function scrollToEnd(params) {
        throw new Error('scrollToEnd not supported in legacy ListView.');
      }
    }, {
      key: "scrollToIndex",
      value: function scrollToIndex(params) {
        throw new Error('scrollToIndex not supported in legacy ListView.');
      }
    }, {
      key: "scrollToItem",
      value: function scrollToItem(params) {
        throw new Error('scrollToItem not supported in legacy ListView.');
      }
    }, {
      key: "scrollToLocation",
      value: function scrollToLocation(params) {
        throw new Error('scrollToLocation not supported in legacy ListView.');
      }
    }, {
      key: "scrollToOffset",
      value: function scrollToOffset(params) {
        var animated = params.animated,
            offset = params.offset;

        this._listRef.scrollTo(this.props.horizontal ? {
          x: offset,
          animated: animated
        } : {
          y: offset,
          animated: animated
        });
      }
    }, {
      key: "getListRef",
      value: function getListRef() {
        return this._listRef;
      }
    }, {
      key: "setNativeProps",
      value: function setNativeProps(props) {
        if (this._listRef) {
          this._listRef.setNativeProps(props);
        }
      }
    }, {
      key: "UNSAFE_componentWillReceiveProps",
      value: function UNSAFE_componentWillReceiveProps(newProps) {
        var _this3 = this;

        this.setState(function (state) {
          return _this3._computeState(newProps, state);
        });
      }
    }, {
      key: "render",
      value: function render() {
        return React.createElement(ListView, _extends({}, this.props, {
          dataSource: this.state.ds,
          ref: this._captureRef,
          renderRow: this._renderRow,
          renderFooter: this.props.FooterComponent && this._renderFooter,
          renderSectionHeader: this.props.sections && this._renderSectionHeader,
          renderSeparator: this.props.SeparatorComponent && this._renderSeparator,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 142
          }
        }));
      }
    }, {
      key: "_computeState",
      value: function _computeState(props, state) {
        var sectionHeaderData = {};

        if (props.sections) {
          invariant(!props.items, 'Cannot have both sections and items props.');
          var sections = {};
          props.sections.forEach(function (sectionIn, ii) {
            var sectionID = 's' + ii;
            sections[sectionID] = sectionIn.data;
            sectionHeaderData[sectionID] = sectionIn;
          });
          return {
            ds: state.ds.cloneWithRowsAndSections(sections),
            sectionHeaderData: sectionHeaderData
          };
        } else {
          invariant(!props.sections, 'Cannot have both sections and items props.');
          return {
            ds: state.ds.cloneWithRows(props.items),
            sectionHeaderData: sectionHeaderData
          };
        }
      }
    }]);

    return MetroListView;
  }(React.Component);

  _defineProperty(MetroListView, "defaultProps", {
    keyExtractor: function keyExtractor(item, index) {
      return item.key || String(index);
    },
    renderScrollComponent: function renderScrollComponent(props) {
      if (props.onRefresh) {
        return React.createElement(ScrollView, _extends({}, props, {
          refreshControl: React.createElement(RefreshControl, {
            refreshing: props.refreshing,
            onRefresh: props.onRefresh,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 114
            }
          }),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 107
          }
        }));
      } else {
        return React.createElement(ScrollView, _extends({}, props, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 123
          }
        }));
      }
    }
  });

  MetroListView = _wrapComponent("MetroListView")(MetroListView);
  module.exports = MetroListView;
},498,[23,112,24,25,26,29,30,28,32,109,280,499,149,515,503,117],"node_modules\\react-native\\Libraries\\Lists\\MetroListView.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectWithoutProperties = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutProperties");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Lists\\ListView\\ListView.js";

  var InternalListViewType = _$$_REQUIRE(_dependencyMap[2], "InternalListViewType");

  var ListViewDataSource = _$$_REQUIRE(_dependencyMap[3], "ListViewDataSource");

  var Platform = _$$_REQUIRE(_dependencyMap[4], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[5], "React");

  var ReactNative = _$$_REQUIRE(_dependencyMap[6], "ReactNative");

  var RCTScrollViewManager = _$$_REQUIRE(_dependencyMap[7], "NativeModules").ScrollViewManager;

  var ScrollView = _$$_REQUIRE(_dependencyMap[8], "ScrollView");

  var ScrollResponder = _$$_REQUIRE(_dependencyMap[9], "ScrollResponder");

  var StaticRenderer = _$$_REQUIRE(_dependencyMap[10], "StaticRenderer");

  var View = _$$_REQUIRE(_dependencyMap[11], "View");

  var cloneReferencedElement = _$$_REQUIRE(_dependencyMap[12], "react-clone-referenced-element");

  var createReactClass = _$$_REQUIRE(_dependencyMap[13], "create-react-class");

  var isEmpty = _$$_REQUIRE(_dependencyMap[14], "isEmpty");

  var merge = _$$_REQUIRE(_dependencyMap[15], "merge");

  var DEFAULT_PAGE_SIZE = 1;
  var DEFAULT_INITIAL_ROWS = 10;
  var DEFAULT_SCROLL_RENDER_AHEAD = 1000;
  var DEFAULT_END_REACHED_THRESHOLD = 1000;
  var DEFAULT_SCROLL_CALLBACK_THROTTLE = 50;
  var ListView = createReactClass({
    displayName: 'ListView',
    _rafIds: [],
    _childFrames: [],
    _sentEndForContentLength: null,
    _scrollComponent: null,
    _prevRenderedRowsCount: 0,
    _visibleRows: {},
    scrollProperties: {},
    mixins: [ScrollResponder.Mixin],
    statics: {
      DataSource: ListViewDataSource
    },
    getMetrics: function getMetrics() {
      return {
        contentLength: this.scrollProperties.contentLength,
        totalRows: this.props.enableEmptySections ? this.props.dataSource.getRowAndSectionCount() : this.props.dataSource.getRowCount(),
        renderedRows: this.state.curRenderedRowsCount,
        visibleRows: Object.keys(this._visibleRows).length
      };
    },
    getScrollResponder: function getScrollResponder() {
      if (this._scrollComponent && this._scrollComponent.getScrollResponder) {
        return this._scrollComponent.getScrollResponder();
      }
    },
    getScrollableNode: function getScrollableNode() {
      if (this._scrollComponent && this._scrollComponent.getScrollableNode) {
        return this._scrollComponent.getScrollableNode();
      } else {
        return ReactNative.findNodeHandle(this._scrollComponent);
      }
    },
    scrollTo: function scrollTo() {
      if (this._scrollComponent && this._scrollComponent.scrollTo) {
        var _this$_scrollComponen;

        (_this$_scrollComponen = this._scrollComponent).scrollTo.apply(_this$_scrollComponen, arguments);
      }
    },
    scrollToEnd: function scrollToEnd(options) {
      if (this._scrollComponent) {
        if (this._scrollComponent.scrollToEnd) {
          this._scrollComponent.scrollToEnd(options);
        } else {
          console.warn('The scroll component used by the ListView does not support ' + 'scrollToEnd. Check the renderScrollComponent prop of your ListView.');
        }
      }
    },
    flashScrollIndicators: function flashScrollIndicators() {
      if (this._scrollComponent && this._scrollComponent.flashScrollIndicators) {
        this._scrollComponent.flashScrollIndicators();
      }
    },
    setNativeProps: function setNativeProps(props) {
      if (this._scrollComponent) {
        this._scrollComponent.setNativeProps(props);
      }
    },
    getDefaultProps: function getDefaultProps() {
      return {
        initialListSize: DEFAULT_INITIAL_ROWS,
        pageSize: DEFAULT_PAGE_SIZE,
        renderScrollComponent: function renderScrollComponent(props) {
          return React.createElement(ScrollView, _extends({}, props, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 324
            }
          }));
        },
        scrollRenderAheadDistance: DEFAULT_SCROLL_RENDER_AHEAD,
        onEndReachedThreshold: DEFAULT_END_REACHED_THRESHOLD,
        stickySectionHeadersEnabled: Platform.OS === 'ios',
        stickyHeaderIndices: []
      };
    },
    getInitialState: function getInitialState() {
      return {
        curRenderedRowsCount: this.props.initialListSize,
        highlightedRow: {}
      };
    },
    getInnerViewNode: function getInnerViewNode() {
      return this._scrollComponent && this._scrollComponent.getInnerViewNode();
    },
    UNSAFE_componentWillMount: function UNSAFE_componentWillMount() {
      this.scrollProperties = {
        visibleLength: null,
        contentLength: null,
        offset: 0
      };
      this._rafIds = [];
      this._childFrames = [];
      this._visibleRows = {};
      this._prevRenderedRowsCount = 0;
      this._sentEndForContentLength = null;
    },
    componentWillUnmount: function componentWillUnmount() {
      this._rafIds.forEach(cancelAnimationFrame);

      this._rafIds = [];
    },
    componentDidMount: function componentDidMount() {
      var _this = this;

      this._requestAnimationFrame(function () {
        _this._measureAndUpdateScrollProps();
      });
    },
    UNSAFE_componentWillReceiveProps: function UNSAFE_componentWillReceiveProps(nextProps) {
      var _this2 = this;

      if (this.props.dataSource !== nextProps.dataSource || this.props.initialListSize !== nextProps.initialListSize) {
        this.setState(function (state, props) {
          _this2._prevRenderedRowsCount = 0;
          return {
            curRenderedRowsCount: Math.min(Math.max(state.curRenderedRowsCount, props.initialListSize), props.enableEmptySections ? props.dataSource.getRowAndSectionCount() : props.dataSource.getRowCount())
          };
        }, function () {
          return _this2._renderMoreRowsIfNeeded();
        });
      }
    },
    componentDidUpdate: function componentDidUpdate() {
      var _this3 = this;

      this._requestAnimationFrame(function () {
        _this3._measureAndUpdateScrollProps();
      });
    },
    _onRowHighlighted: function _onRowHighlighted(sectionID, rowID) {
      this.setState({
        highlightedRow: {
          sectionID: sectionID,
          rowID: rowID
        }
      });
    },
    render: function render() {
      var bodyComponents = [];
      var dataSource = this.props.dataSource;
      var allRowIDs = dataSource.rowIdentities;
      var rowCount = 0;
      var stickySectionHeaderIndices = [];
      var renderSectionHeader = this.props.renderSectionHeader;
      var header = this.props.renderHeader && this.props.renderHeader();
      var footer = this.props.renderFooter && this.props.renderFooter();
      var totalIndex = header ? 1 : 0;

      for (var sectionIdx = 0; sectionIdx < allRowIDs.length; sectionIdx++) {
        var sectionID = dataSource.sectionIdentities[sectionIdx];
        var rowIDs = allRowIDs[sectionIdx];

        if (rowIDs.length === 0) {
          if (this.props.enableEmptySections === undefined) {
            var warning = _$$_REQUIRE(_dependencyMap[16], "fbjs/lib/warning");

            warning(false, 'In next release empty section headers will be rendered.' + " In this release you can use 'enableEmptySections' flag to render empty section headers.");
            continue;
          } else {
            var invariant = _$$_REQUIRE(_dependencyMap[17], "fbjs/lib/invariant");

            invariant(this.props.enableEmptySections, "In next release 'enableEmptySections' flag will be deprecated, empty section headers will always be rendered." + ' If empty section headers are not desirable their indices should be excluded from sectionIDs object.' + " In this release 'enableEmptySections' may only have value 'true' to allow empty section headers rendering.");
          }
        }

        if (renderSectionHeader) {
          var element = renderSectionHeader(dataSource.getSectionHeaderData(sectionIdx), sectionID);

          if (element) {
            bodyComponents.push(React.cloneElement(element, {
              key: 's_' + sectionID
            }));

            if (this.props.stickySectionHeadersEnabled) {
              stickySectionHeaderIndices.push(totalIndex);
            }

            totalIndex++;
          }
        }

        for (var rowIdx = 0; rowIdx < rowIDs.length; rowIdx++) {
          var rowID = rowIDs[rowIdx];
          var comboID = sectionID + '_' + rowID;
          var shouldUpdateRow = rowCount >= this._prevRenderedRowsCount && dataSource.rowShouldUpdate(sectionIdx, rowIdx);
          var row = React.createElement(StaticRenderer, {
            key: 'r_' + comboID,
            shouldUpdate: !!shouldUpdateRow,
            render: this.props.renderRow.bind(null, dataSource.getRowData(sectionIdx, rowIdx), sectionID, rowID, this._onRowHighlighted),
            __source: {
              fileName: _jsxFileName,
              lineNumber: 463
            }
          });
          bodyComponents.push(row);
          totalIndex++;

          if (this.props.renderSeparator && (rowIdx !== rowIDs.length - 1 || sectionIdx === allRowIDs.length - 1)) {
            var adjacentRowHighlighted = this.state.highlightedRow.sectionID === sectionID && (this.state.highlightedRow.rowID === rowID || this.state.highlightedRow.rowID === rowIDs[rowIdx + 1]);
            var separator = this.props.renderSeparator(sectionID, rowID, adjacentRowHighlighted);

            if (separator) {
              bodyComponents.push(React.createElement(View, {
                key: 's_' + comboID,
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 492
                }
              }, separator));
              totalIndex++;
            }
          }

          if (++rowCount === this.state.curRenderedRowsCount) {
            break;
          }
        }

        if (rowCount >= this.state.curRenderedRowsCount) {
          break;
        }
      }

      var _this$props = this.props,
          renderScrollComponent = _this$props.renderScrollComponent,
          props = _objectWithoutProperties(_this$props, ["renderScrollComponent"]);

      if (!props.scrollEventThrottle) {
        props.scrollEventThrottle = DEFAULT_SCROLL_CALLBACK_THROTTLE;
      }

      if (props.removeClippedSubviews === undefined) {
        props.removeClippedSubviews = true;
      }

      _extends(props, {
        onScroll: this._onScroll,
        stickyHeaderIndices: this.props.stickyHeaderIndices.concat(stickySectionHeaderIndices),
        onKeyboardWillShow: undefined,
        onKeyboardWillHide: undefined,
        onKeyboardDidShow: undefined,
        onKeyboardDidHide: undefined
      });

      return cloneReferencedElement(renderScrollComponent(props), {
        ref: this._setScrollComponentRef,
        onContentSizeChange: this._onContentSizeChange,
        onLayout: this._onLayout,
        DEPRECATED_sendUpdatedChildFrames: typeof props.onChangeVisibleRows !== undefined
      }, header, bodyComponents, footer);
    },
    _requestAnimationFrame: function _requestAnimationFrame(fn) {
      var _this4 = this;

      var rafId = requestAnimationFrame(function () {
        _this4._rafIds = _this4._rafIds.filter(function (id) {
          return id !== rafId;
        });
        fn();
      });

      this._rafIds.push(rafId);
    },
    _measureAndUpdateScrollProps: function _measureAndUpdateScrollProps() {
      var scrollComponent = this.getScrollResponder();

      if (!scrollComponent || !scrollComponent.getInnerViewNode) {
        return;
      }

      RCTScrollViewManager && RCTScrollViewManager.calculateChildFrames && RCTScrollViewManager.calculateChildFrames(ReactNative.findNodeHandle(scrollComponent), this._updateVisibleRows);
    },
    _setScrollComponentRef: function _setScrollComponentRef(scrollComponent) {
      this._scrollComponent = scrollComponent;
    },
    _onContentSizeChange: function _onContentSizeChange(width, height) {
      var contentLength = !this.props.horizontal ? height : width;

      if (contentLength !== this.scrollProperties.contentLength) {
        this.scrollProperties.contentLength = contentLength;

        this._updateVisibleRows();

        this._renderMoreRowsIfNeeded();
      }

      this.props.onContentSizeChange && this.props.onContentSizeChange(width, height);
    },
    _onLayout: function _onLayout(event) {
      var _event$nativeEvent$la = event.nativeEvent.layout,
          width = _event$nativeEvent$la.width,
          height = _event$nativeEvent$la.height;
      var visibleLength = !this.props.horizontal ? height : width;

      if (visibleLength !== this.scrollProperties.visibleLength) {
        this.scrollProperties.visibleLength = visibleLength;

        this._updateVisibleRows();

        this._renderMoreRowsIfNeeded();
      }

      this.props.onLayout && this.props.onLayout(event);
    },
    _maybeCallOnEndReached: function _maybeCallOnEndReached(event) {
      if (this.props.onEndReached && this.scrollProperties.contentLength !== this._sentEndForContentLength && this._getDistanceFromEnd(this.scrollProperties) < this.props.onEndReachedThreshold && this.state.curRenderedRowsCount === (this.props.enableEmptySections ? this.props.dataSource.getRowAndSectionCount() : this.props.dataSource.getRowCount())) {
        this._sentEndForContentLength = this.scrollProperties.contentLength;
        this.props.onEndReached(event);
        return true;
      }

      return false;
    },
    _renderMoreRowsIfNeeded: function _renderMoreRowsIfNeeded() {
      if (this.scrollProperties.contentLength === null || this.scrollProperties.visibleLength === null || this.state.curRenderedRowsCount === (this.props.enableEmptySections ? this.props.dataSource.getRowAndSectionCount() : this.props.dataSource.getRowCount())) {
        this._maybeCallOnEndReached();

        return;
      }

      var distanceFromEnd = this._getDistanceFromEnd(this.scrollProperties);

      if (distanceFromEnd < this.props.scrollRenderAheadDistance) {
        this._pageInNewRows();
      }
    },
    _pageInNewRows: function _pageInNewRows() {
      var _this5 = this;

      this.setState(function (state, props) {
        var rowsToRender = Math.min(state.curRenderedRowsCount + props.pageSize, props.enableEmptySections ? props.dataSource.getRowAndSectionCount() : props.dataSource.getRowCount());
        _this5._prevRenderedRowsCount = state.curRenderedRowsCount;
        return {
          curRenderedRowsCount: rowsToRender
        };
      }, function () {
        _this5._measureAndUpdateScrollProps();

        _this5._prevRenderedRowsCount = _this5.state.curRenderedRowsCount;
      });
    },
    _getDistanceFromEnd: function _getDistanceFromEnd(scrollProperties) {
      return scrollProperties.contentLength - scrollProperties.visibleLength - scrollProperties.offset;
    },
    _updateVisibleRows: function _updateVisibleRows(updatedFrames) {
      var _this6 = this;

      if (!this.props.onChangeVisibleRows) {
        return;
      }

      if (updatedFrames) {
        updatedFrames.forEach(function (newFrame) {
          _this6._childFrames[newFrame.index] = merge(newFrame);
        });
      }

      var isVertical = !this.props.horizontal;
      var dataSource = this.props.dataSource;
      var visibleMin = this.scrollProperties.offset;
      var visibleMax = visibleMin + this.scrollProperties.visibleLength;
      var allRowIDs = dataSource.rowIdentities;
      var header = this.props.renderHeader && this.props.renderHeader();
      var totalIndex = header ? 1 : 0;
      var visibilityChanged = false;
      var changedRows = {};

      for (var sectionIdx = 0; sectionIdx < allRowIDs.length; sectionIdx++) {
        var rowIDs = allRowIDs[sectionIdx];

        if (rowIDs.length === 0) {
          continue;
        }

        var sectionID = dataSource.sectionIdentities[sectionIdx];

        if (this.props.renderSectionHeader) {
          totalIndex++;
        }

        var visibleSection = this._visibleRows[sectionID];

        if (!visibleSection) {
          visibleSection = {};
        }

        for (var rowIdx = 0; rowIdx < rowIDs.length; rowIdx++) {
          var rowID = rowIDs[rowIdx];
          var frame = this._childFrames[totalIndex];
          totalIndex++;

          if (this.props.renderSeparator && (rowIdx !== rowIDs.length - 1 || sectionIdx === allRowIDs.length - 1)) {
            totalIndex++;
          }

          if (!frame) {
            break;
          }

          var rowVisible = visibleSection[rowID];
          var min = isVertical ? frame.y : frame.x;
          var max = min + (isVertical ? frame.height : frame.width);

          if (!min && !max || min === max) {
            break;
          }

          if (min > visibleMax || max < visibleMin) {
            if (rowVisible) {
              visibilityChanged = true;
              delete visibleSection[rowID];

              if (!changedRows[sectionID]) {
                changedRows[sectionID] = {};
              }

              changedRows[sectionID][rowID] = false;
            }
          } else if (!rowVisible) {
            visibilityChanged = true;
            visibleSection[rowID] = true;

            if (!changedRows[sectionID]) {
              changedRows[sectionID] = {};
            }

            changedRows[sectionID][rowID] = true;
          }
        }

        if (!isEmpty(visibleSection)) {
          this._visibleRows[sectionID] = visibleSection;
        } else if (this._visibleRows[sectionID]) {
          delete this._visibleRows[sectionID];
        }
      }

      visibilityChanged && this.props.onChangeVisibleRows(this._visibleRows, changedRows);
    },
    _onScroll: function _onScroll(e) {
      var isVertical = !this.props.horizontal;
      this.scrollProperties.visibleLength = e.nativeEvent.layoutMeasurement[isVertical ? 'height' : 'width'];
      this.scrollProperties.contentLength = e.nativeEvent.contentSize[isVertical ? 'height' : 'width'];
      this.scrollProperties.offset = e.nativeEvent.contentOffset[isVertical ? 'y' : 'x'];

      this._updateVisibleRows(e.nativeEvent.updatedChildFrames);

      if (!this._maybeCallOnEndReached(e)) {
        this._renderMoreRowsIfNeeded();
      }

      if (this.props.onEndReached && this._getDistanceFromEnd(this.scrollProperties) > this.props.onEndReachedThreshold) {
        this._sentEndForContentLength = null;
      }

      this.props.onScroll && this.props.onScroll(e);
    }
  });
  module.exports = ListView;
},499,[120,112,500,501,146,149,178,119,503,504,513,175,514,459,502,440,211,117],"node_modules\\react-native\\Libraries\\Lists\\ListView\\ListView.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/inherits");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/defineProperty");

  var React = _$$_REQUIRE(_dependencyMap[6], "React");

  var ListViewDataSource = _$$_REQUIRE(_dependencyMap[7], "ListViewDataSource");

  var InternalListViewType = function (_React$Component) {
    "use strict";

    _inherits(InternalListViewType, _React$Component);

    function InternalListViewType() {
      _classCallCheck(this, InternalListViewType);

      return _possibleConstructorReturn(this, _getPrototypeOf(InternalListViewType).apply(this, arguments));
    }

    _createClass(InternalListViewType, [{
      key: "setNativeProps",
      value: function setNativeProps(props) {}
    }, {
      key: "flashScrollIndicators",
      value: function flashScrollIndicators() {}
    }, {
      key: "getScrollResponder",
      value: function getScrollResponder() {}
    }, {
      key: "getScrollableNode",
      value: function getScrollableNode() {}
    }, {
      key: "getMetrics",
      value: function getMetrics() {}
    }, {
      key: "scrollTo",
      value: function scrollTo() {}
    }, {
      key: "scrollToEnd",
      value: function scrollToEnd(options) {}
    }]);

    return InternalListViewType;
  }(React.Component);

  _defineProperty(InternalListViewType, "DataSource", ListViewDataSource);

  module.exports = InternalListViewType;
},500,[24,25,26,29,30,32,149,501],"node_modules\\react-native\\Libraries\\Lists\\ListView\\InternalListViewType.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _toConsumableArray = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/toConsumableArray");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/defineProperty");

  var invariant = _$$_REQUIRE(_dependencyMap[4], "fbjs/lib/invariant");

  var isEmpty = _$$_REQUIRE(_dependencyMap[5], "isEmpty");

  var warning = _$$_REQUIRE(_dependencyMap[6], "fbjs/lib/warning");

  function defaultGetRowData(dataBlob, sectionID, rowID) {
    return dataBlob[sectionID][rowID];
  }

  function defaultGetSectionHeaderData(dataBlob, sectionID) {
    return dataBlob[sectionID];
  }

  var ListViewDataSource = function () {
    function ListViewDataSource(params) {
      _classCallCheck(this, ListViewDataSource);

      _defineProperty(this, "_getRowData", void 0);

      _defineProperty(this, "_getSectionHeaderData", void 0);

      _defineProperty(this, "_rowHasChanged", void 0);

      _defineProperty(this, "_sectionHeaderHasChanged", void 0);

      _defineProperty(this, "_dataBlob", void 0);

      _defineProperty(this, "_dirtyRows", void 0);

      _defineProperty(this, "_dirtySections", void 0);

      _defineProperty(this, "_cachedRowCount", void 0);

      _defineProperty(this, "rowIdentities", void 0);

      _defineProperty(this, "sectionIdentities", void 0);

      invariant(params && typeof params.rowHasChanged === 'function', 'Must provide a rowHasChanged function.');
      this._rowHasChanged = params.rowHasChanged;
      this._getRowData = params.getRowData || defaultGetRowData;
      this._sectionHeaderHasChanged = params.sectionHeaderHasChanged;
      this._getSectionHeaderData = params.getSectionHeaderData || defaultGetSectionHeaderData;
      this._dataBlob = null;
      this._dirtyRows = [];
      this._dirtySections = [];
      this._cachedRowCount = 0;
      this.rowIdentities = [];
      this.sectionIdentities = [];
    }

    _createClass(ListViewDataSource, [{
      key: "cloneWithRows",
      value: function cloneWithRows(dataBlob, rowIdentities) {
        var rowIds = rowIdentities ? [_toConsumableArray(rowIdentities)] : null;

        if (!this._sectionHeaderHasChanged) {
          this._sectionHeaderHasChanged = function () {
            return false;
          };
        }

        return this.cloneWithRowsAndSections({
          s1: dataBlob
        }, ['s1'], rowIds);
      }
    }, {
      key: "cloneWithRowsAndSections",
      value: function cloneWithRowsAndSections(dataBlob, sectionIdentities, rowIdentities) {
        invariant(typeof this._sectionHeaderHasChanged === 'function', 'Must provide a sectionHeaderHasChanged function with section data.');
        invariant(!sectionIdentities || !rowIdentities || sectionIdentities.length === rowIdentities.length, 'row and section ids lengths must be the same');
        var newSource = new ListViewDataSource({
          getRowData: this._getRowData,
          getSectionHeaderData: this._getSectionHeaderData,
          rowHasChanged: this._rowHasChanged,
          sectionHeaderHasChanged: this._sectionHeaderHasChanged
        });
        newSource._dataBlob = dataBlob;

        if (sectionIdentities) {
          newSource.sectionIdentities = sectionIdentities;
        } else {
          newSource.sectionIdentities = Object.keys(dataBlob);
        }

        if (rowIdentities) {
          newSource.rowIdentities = rowIdentities;
        } else {
          newSource.rowIdentities = [];
          newSource.sectionIdentities.forEach(function (sectionID) {
            newSource.rowIdentities.push(Object.keys(dataBlob[sectionID]));
          });
        }

        newSource._cachedRowCount = countRows(newSource.rowIdentities);

        newSource._calculateDirtyArrays(this._dataBlob, this.sectionIdentities, this.rowIdentities);

        return newSource;
      }
    }, {
      key: "getRowCount",
      value: function getRowCount() {
        return this._cachedRowCount;
      }
    }, {
      key: "getRowAndSectionCount",
      value: function getRowAndSectionCount() {
        return this._cachedRowCount + this.sectionIdentities.length;
      }
    }, {
      key: "rowShouldUpdate",
      value: function rowShouldUpdate(sectionIndex, rowIndex) {
        var needsUpdate = this._dirtyRows[sectionIndex][rowIndex];
        warning(needsUpdate !== undefined, 'missing dirtyBit for section, row: ' + sectionIndex + ', ' + rowIndex);
        return needsUpdate;
      }
    }, {
      key: "getRowData",
      value: function getRowData(sectionIndex, rowIndex) {
        var sectionID = this.sectionIdentities[sectionIndex];
        var rowID = this.rowIdentities[sectionIndex][rowIndex];
        warning(sectionID !== undefined && rowID !== undefined, 'rendering invalid section, row: ' + sectionIndex + ', ' + rowIndex);
        return this._getRowData(this._dataBlob, sectionID, rowID);
      }
    }, {
      key: "getRowIDForFlatIndex",
      value: function getRowIDForFlatIndex(index) {
        var accessIndex = index;

        for (var ii = 0; ii < this.sectionIdentities.length; ii++) {
          if (accessIndex >= this.rowIdentities[ii].length) {
            accessIndex -= this.rowIdentities[ii].length;
          } else {
            return this.rowIdentities[ii][accessIndex];
          }
        }

        return null;
      }
    }, {
      key: "getSectionIDForFlatIndex",
      value: function getSectionIDForFlatIndex(index) {
        var accessIndex = index;

        for (var ii = 0; ii < this.sectionIdentities.length; ii++) {
          if (accessIndex >= this.rowIdentities[ii].length) {
            accessIndex -= this.rowIdentities[ii].length;
          } else {
            return this.sectionIdentities[ii];
          }
        }

        return null;
      }
    }, {
      key: "getSectionLengths",
      value: function getSectionLengths() {
        var results = [];

        for (var ii = 0; ii < this.sectionIdentities.length; ii++) {
          results.push(this.rowIdentities[ii].length);
        }

        return results;
      }
    }, {
      key: "sectionHeaderShouldUpdate",
      value: function sectionHeaderShouldUpdate(sectionIndex) {
        var needsUpdate = this._dirtySections[sectionIndex];
        warning(needsUpdate !== undefined, 'missing dirtyBit for section: ' + sectionIndex);
        return needsUpdate;
      }
    }, {
      key: "getSectionHeaderData",
      value: function getSectionHeaderData(sectionIndex) {
        if (!this._getSectionHeaderData) {
          return null;
        }

        var sectionID = this.sectionIdentities[sectionIndex];
        warning(sectionID !== undefined, 'renderSection called on invalid section: ' + sectionIndex);
        return this._getSectionHeaderData(this._dataBlob, sectionID);
      }
    }, {
      key: "_calculateDirtyArrays",
      value: function _calculateDirtyArrays(prevDataBlob, prevSectionIDs, prevRowIDs) {
        var prevSectionsHash = keyedDictionaryFromArray(prevSectionIDs);
        var prevRowsHash = {};

        for (var ii = 0; ii < prevRowIDs.length; ii++) {
          var sectionID = prevSectionIDs[ii];
          warning(!prevRowsHash[sectionID], 'SectionID appears more than once: ' + sectionID);
          prevRowsHash[sectionID] = keyedDictionaryFromArray(prevRowIDs[ii]);
        }

        this._dirtySections = [];
        this._dirtyRows = [];
        var dirty;

        for (var sIndex = 0; sIndex < this.sectionIdentities.length; sIndex++) {
          var sectionID = this.sectionIdentities[sIndex];
          dirty = !prevSectionsHash[sectionID];
          var sectionHeaderHasChanged = this._sectionHeaderHasChanged;

          if (!dirty && sectionHeaderHasChanged) {
            dirty = sectionHeaderHasChanged(this._getSectionHeaderData(prevDataBlob, sectionID), this._getSectionHeaderData(this._dataBlob, sectionID));
          }

          this._dirtySections.push(!!dirty);

          this._dirtyRows[sIndex] = [];

          for (var rIndex = 0; rIndex < this.rowIdentities[sIndex].length; rIndex++) {
            var rowID = this.rowIdentities[sIndex][rIndex];
            dirty = !prevSectionsHash[sectionID] || !prevRowsHash[sectionID][rowID] || this._rowHasChanged(this._getRowData(prevDataBlob, sectionID, rowID), this._getRowData(this._dataBlob, sectionID, rowID));

            this._dirtyRows[sIndex].push(!!dirty);
          }
        }
      }
    }]);

    return ListViewDataSource;
  }();

  function countRows(allRowIDs) {
    var totalRows = 0;

    for (var sectionIdx = 0; sectionIdx < allRowIDs.length; sectionIdx++) {
      var rowIDs = allRowIDs[sectionIdx];
      totalRows += rowIDs.length;
    }

    return totalRows;
  }

  function keyedDictionaryFromArray(arr) {
    if (isEmpty(arr)) {
      return {};
    }

    var result = {};

    for (var ii = 0; ii < arr.length; ii++) {
      var _key = arr[ii];
      warning(!result[_key], 'Value appears more than once in array: ' + _key);
      result[_key] = true;
    }

    return result;
  }

  module.exports = ListViewDataSource;
},501,[128,24,25,32,117,502,211],"node_modules\\react-native\\Libraries\\Lists\\ListView\\ListViewDataSource.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function isEmpty(obj) {
    if (Array.isArray(obj)) {
      return obj.length === 0;
    } else if (typeof obj === 'object') {
      for (var i in obj) {
        return false;
      }

      return true;
    } else {
      return !obj;
    }
  }

  module.exports = isEmpty;
},502,[],"node_modules\\react-native\\Libraries\\vendor\\core\\isEmpty.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\ScrollView\\ScrollView.js";

  var AnimatedImplementation = _$$_REQUIRE(_dependencyMap[2], "AnimatedImplementation");

  var Platform = _$$_REQUIRE(_dependencyMap[3], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[4], "React");

  var ReactNative = _$$_REQUIRE(_dependencyMap[5], "ReactNative");

  var ScrollResponder = _$$_REQUIRE(_dependencyMap[6], "ScrollResponder");

  var ScrollViewStickyHeader = _$$_REQUIRE(_dependencyMap[7], "ScrollViewStickyHeader");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[8], "StyleSheet");

  var View = _$$_REQUIRE(_dependencyMap[9], "View");

  var InternalScrollViewType = _$$_REQUIRE(_dependencyMap[10], "InternalScrollViewType");

  var createReactClass = _$$_REQUIRE(_dependencyMap[11], "create-react-class");

  var dismissKeyboard = _$$_REQUIRE(_dependencyMap[12], "dismissKeyboard");

  var flattenStyle = _$$_REQUIRE(_dependencyMap[13], "flattenStyle");

  var invariant = _$$_REQUIRE(_dependencyMap[14], "fbjs/lib/invariant");

  var processDecelerationRate = _$$_REQUIRE(_dependencyMap[15], "processDecelerationRate");

  var requireNativeComponent = _$$_REQUIRE(_dependencyMap[16], "requireNativeComponent");

  var warning = _$$_REQUIRE(_dependencyMap[17], "fbjs/lib/warning");

  var resolveAssetSource = _$$_REQUIRE(_dependencyMap[18], "resolveAssetSource");

  var AndroidScrollView;
  var AndroidHorizontalScrollContentView;
  var AndroidHorizontalScrollView;
  var RCTScrollView;
  var RCTScrollContentView;

  if (Platform.OS === 'android') {
    AndroidScrollView = requireNativeComponent('RCTScrollView');
    AndroidHorizontalScrollView = requireNativeComponent('AndroidHorizontalScrollView');
    AndroidHorizontalScrollContentView = requireNativeComponent('AndroidHorizontalScrollContentView');
  } else if (Platform.OS === 'ios') {
    RCTScrollView = requireNativeComponent('RCTScrollView');
    RCTScrollContentView = requireNativeComponent('RCTScrollContentView');
  } else {
    RCTScrollView = requireNativeComponent('RCTScrollView');
    RCTScrollContentView = requireNativeComponent('RCTScrollContentView');
  }

  var ScrollView = createReactClass({
    displayName: 'ScrollView',
    mixins: [ScrollResponder.Mixin],
    _scrollAnimatedValue: new AnimatedImplementation.Value(0),
    _scrollAnimatedValueAttachment: null,
    _stickyHeaderRefs: new Map(),
    _headerLayoutYs: new Map(),
    getInitialState: function getInitialState() {
      return _objectSpread({}, this.scrollResponderMixinGetInitialState(), {
        layoutHeight: null
      });
    },
    UNSAFE_componentWillMount: function UNSAFE_componentWillMount() {
      this._scrollAnimatedValue = new AnimatedImplementation.Value(this.props.contentOffset ? this.props.contentOffset.y : 0);

      this._scrollAnimatedValue.setOffset(this.props.contentInset ? this.props.contentInset.top : 0);

      this._stickyHeaderRefs = new Map();
      this._headerLayoutYs = new Map();
    },
    componentDidMount: function componentDidMount() {
      this._updateAnimatedNodeAttachment();
    },
    componentDidUpdate: function componentDidUpdate() {
      this._updateAnimatedNodeAttachment();
    },
    componentWillUnmount: function componentWillUnmount() {
      if (this._scrollAnimatedValueAttachment) {
        this._scrollAnimatedValueAttachment.detach();
      }
    },
    setNativeProps: function setNativeProps(props) {
      this._scrollViewRef && this._scrollViewRef.setNativeProps(props);
    },
    getScrollResponder: function getScrollResponder() {
      return this;
    },
    getScrollableNode: function getScrollableNode() {
      return ReactNative.findNodeHandle(this._scrollViewRef);
    },
    getInnerViewNode: function getInnerViewNode() {
      return ReactNative.findNodeHandle(this._innerViewRef);
    },
    scrollTo: function scrollTo(y, x, animated) {
      if (typeof y === 'number') {
        console.warn('`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, ' + 'animated: true})` instead.');
      } else {
        var _ref = y || {};

        x = _ref.x;
        y = _ref.y;
        animated = _ref.animated;
      }

      this.getScrollResponder().scrollResponderScrollTo({
        x: x || 0,
        y: y || 0,
        animated: animated !== false
      });
    },
    scrollToEnd: function scrollToEnd(options) {
      var animated = (options && options.animated) !== false;
      this.getScrollResponder().scrollResponderScrollToEnd({
        animated: animated
      });
    },
    scrollWithoutAnimationTo: function scrollWithoutAnimationTo() {
      var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      console.warn('`scrollWithoutAnimationTo` is deprecated. Use `scrollTo` instead');
      this.scrollTo({
        x: x,
        y: y,
        animated: false
      });
    },
    flashScrollIndicators: function flashScrollIndicators() {
      this.getScrollResponder().scrollResponderFlashScrollIndicators();
    },
    _getKeyForIndex: function _getKeyForIndex(index, childArray) {
      var child = childArray[index];
      return child && child.key;
    },
    _updateAnimatedNodeAttachment: function _updateAnimatedNodeAttachment() {
      if (this._scrollAnimatedValueAttachment) {
        this._scrollAnimatedValueAttachment.detach();
      }

      if (this.props.stickyHeaderIndices && this.props.stickyHeaderIndices.length > 0) {
        this._scrollAnimatedValueAttachment = AnimatedImplementation.attachNativeEvent(this._scrollViewRef, 'onScroll', [{
          nativeEvent: {
            contentOffset: {
              y: this._scrollAnimatedValue
            }
          }
        }]);
      }
    },
    _setStickyHeaderRef: function _setStickyHeaderRef(key, ref) {
      if (ref) {
        this._stickyHeaderRefs.set(key, ref);
      } else {
        this._stickyHeaderRefs.delete(key);
      }
    },
    _onStickyHeaderLayout: function _onStickyHeaderLayout(index, event, key) {
      if (!this.props.stickyHeaderIndices) {
        return;
      }

      var childArray = React.Children.toArray(this.props.children);

      if (key !== this._getKeyForIndex(index, childArray)) {
        return;
      }

      var layoutY = event.nativeEvent.layout.y;

      this._headerLayoutYs.set(key, layoutY);

      var indexOfIndex = this.props.stickyHeaderIndices.indexOf(index);
      var previousHeaderIndex = this.props.stickyHeaderIndices[indexOfIndex - 1];

      if (previousHeaderIndex != null) {
        var previousHeader = this._stickyHeaderRefs.get(this._getKeyForIndex(previousHeaderIndex, childArray));

        previousHeader && previousHeader.setNextHeaderY(layoutY);
      }
    },
    _handleScroll: function _handleScroll(e) {
      if (__DEV__) {
        if (this.props.onScroll && this.props.scrollEventThrottle == null && Platform.OS === 'ios') {
          console.log('You specified `onScroll` on a <ScrollView> but not ' + '`scrollEventThrottle`. You will only receive one event. ' + 'Using `16` you get all the events but be aware that it may ' + "cause frame drops, use a bigger number if you don't need as " + 'much precision.');
        }
      }

      if (Platform.OS === 'android') {
        if (this.props.keyboardDismissMode === 'on-drag' && this.state.isTouching) {
          dismissKeyboard();
        }
      }

      this.scrollResponderHandleScroll(e);
    },
    _handleLayout: function _handleLayout(e) {
      if (this.props.invertStickyHeaders) {
        this.setState({
          layoutHeight: e.nativeEvent.layout.height
        });
      }

      if (this.props.onLayout) {
        this.props.onLayout(e);
      }
    },
    _handleContentOnLayout: function _handleContentOnLayout(e) {
      var _e$nativeEvent$layout = e.nativeEvent.layout,
          width = _e$nativeEvent$layout.width,
          height = _e$nativeEvent$layout.height;
      this.props.onContentSizeChange && this.props.onContentSizeChange(width, height);
    },
    _scrollViewRef: null,
    _setScrollViewRef: function _setScrollViewRef(ref) {
      this._scrollViewRef = ref;
    },
    _innerViewRef: null,
    _setInnerViewRef: function _setInnerViewRef(ref) {
      this._innerViewRef = ref;
    },
    render: function render() {
      var _this = this;

      var ScrollViewClass;
      var ScrollContentContainerViewClass;

      if (Platform.OS === 'android') {
        if (this.props.horizontal) {
          ScrollViewClass = AndroidHorizontalScrollView;
          ScrollContentContainerViewClass = AndroidHorizontalScrollContentView;
        } else {
          ScrollViewClass = AndroidScrollView;
          ScrollContentContainerViewClass = View;
        }
      } else {
        ScrollViewClass = RCTScrollView;
        ScrollContentContainerViewClass = RCTScrollContentView;
      }

      invariant(ScrollViewClass !== undefined, 'ScrollViewClass must not be undefined');
      invariant(ScrollContentContainerViewClass !== undefined, 'ScrollContentContainerViewClass must not be undefined');
      var contentContainerStyle = [this.props.horizontal && styles.contentContainerHorizontal, this.props.contentContainerStyle];

      if (__DEV__ && this.props.style) {
        var style = flattenStyle(this.props.style);
        var childLayoutProps = ['alignItems', 'justifyContent'].filter(function (prop) {
          return style && style[prop] !== undefined;
        });
        invariant(childLayoutProps.length === 0, 'ScrollView child layout (' + JSON.stringify(childLayoutProps) + ') must be applied through the contentContainerStyle prop.');
      }

      var contentSizeChangeProps = {};

      if (this.props.onContentSizeChange) {
        contentSizeChangeProps = {
          onLayout: this._handleContentOnLayout
        };
      }

      var stickyHeaderIndices = this.props.stickyHeaderIndices;
      var hasStickyHeaders = stickyHeaderIndices && stickyHeaderIndices.length > 0;
      var childArray = hasStickyHeaders && React.Children.toArray(this.props.children);
      var children = hasStickyHeaders ? childArray.map(function (child, index) {
        var indexOfIndex = child ? stickyHeaderIndices.indexOf(index) : -1;

        if (indexOfIndex > -1) {
          var key = child.key;
          var nextIndex = stickyHeaderIndices[indexOfIndex + 1];
          return React.createElement(ScrollViewStickyHeader, {
            key: key,
            ref: function ref(_ref2) {
              return _this._setStickyHeaderRef(key, _ref2);
            },
            nextHeaderLayoutY: _this._headerLayoutYs.get(_this._getKeyForIndex(nextIndex, childArray)),
            onLayout: function onLayout(event) {
              return _this._onStickyHeaderLayout(index, event, key);
            },
            scrollAnimatedValue: _this._scrollAnimatedValue,
            inverted: _this.props.invertStickyHeaders,
            scrollViewHeight: _this.state.layoutHeight,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 831
            }
          }, child);
        } else {
          return child;
        }
      }) : this.props.children;
      var contentContainer = React.createElement(ScrollContentContainerViewClass, _extends({}, contentSizeChangeProps, {
        ref: this._setInnerViewRef,
        style: contentContainerStyle,
        removeClippedSubviews: Platform.OS === 'android' && hasStickyHeaders ? false : this.props.removeClippedSubviews,
        collapsable: false,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 852
        }
      }), children);
      var alwaysBounceHorizontal = this.props.alwaysBounceHorizontal !== undefined ? this.props.alwaysBounceHorizontal : this.props.horizontal;
      var alwaysBounceVertical = this.props.alwaysBounceVertical !== undefined ? this.props.alwaysBounceVertical : !this.props.horizontal;
      var DEPRECATED_sendUpdatedChildFrames = !!this.props.DEPRECATED_sendUpdatedChildFrames;
      var baseStyle = this.props.horizontal ? styles.baseHorizontal : styles.baseVertical;

      var props = _objectSpread({}, this.props, {
        alwaysBounceHorizontal: alwaysBounceHorizontal,
        alwaysBounceVertical: alwaysBounceVertical,
        style: [baseStyle, this.props.style],
        onContentSizeChange: null,
        onLayout: this._handleLayout,
        onMomentumScrollBegin: this.scrollResponderHandleMomentumScrollBegin,
        onMomentumScrollEnd: this.scrollResponderHandleMomentumScrollEnd,
        onResponderGrant: this.scrollResponderHandleResponderGrant,
        onResponderReject: this.scrollResponderHandleResponderReject,
        onResponderRelease: this.scrollResponderHandleResponderRelease,
        onResponderTerminate: this.scrollResponderHandleTerminate,
        onResponderTerminationRequest: this.scrollResponderHandleTerminationRequest,
        onScroll: this._handleScroll,
        onScrollBeginDrag: this.scrollResponderHandleScrollBeginDrag,
        onScrollEndDrag: this.scrollResponderHandleScrollEndDrag,
        onScrollShouldSetResponder: this.scrollResponderHandleScrollShouldSetResponder,
        onStartShouldSetResponder: this.scrollResponderHandleStartShouldSetResponder,
        onStartShouldSetResponderCapture: this.scrollResponderHandleStartShouldSetResponderCapture,
        onTouchEnd: this.scrollResponderHandleTouchEnd,
        onTouchMove: this.scrollResponderHandleTouchMove,
        onTouchStart: this.scrollResponderHandleTouchStart,
        onTouchCancel: this.scrollResponderHandleTouchCancel,
        scrollBarThumbImage: resolveAssetSource(this.props.scrollBarThumbImage),
        scrollEventThrottle: hasStickyHeaders ? 1 : this.props.scrollEventThrottle,
        sendMomentumEvents: this.props.onMomentumScrollBegin || this.props.onMomentumScrollEnd ? true : false,
        DEPRECATED_sendUpdatedChildFrames: DEPRECATED_sendUpdatedChildFrames,
        pagingEnabled: Platform.select({
          ios: this.props.pagingEnabled && this.props.snapToInterval == null && this.props.snapToOffsets == null,
          android: this.props.pagingEnabled || this.props.snapToInterval != null || this.props.snapToOffsets != null
        })
      });

      var decelerationRate = this.props.decelerationRate;

      if (decelerationRate != null) {
        props.decelerationRate = processDecelerationRate(decelerationRate);
      }

      var refreshControl = this.props.refreshControl;

      if (refreshControl) {
        if (Platform.OS === 'ios') {
          return React.createElement(ScrollViewClass, _extends({}, props, {
            ref: this._setScrollViewRef,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 952
            }
          }), Platform.isTV ? null : refreshControl, contentContainer);
        } else if (Platform.OS === 'android') {
          return React.cloneElement(refreshControl, {
            style: props.style
          }, React.createElement(ScrollViewClass, _extends({}, props, {
            style: baseStyle,
            ref: this._setScrollViewRef,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 967
            }
          }), contentContainer));
        }
      }

      return React.createElement(ScrollViewClass, _extends({}, props, {
        ref: this._setScrollViewRef,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 977
        }
      }), contentContainer);
    }
  });
  var TypedScrollView = ScrollView;
  var styles = StyleSheet.create({
    baseVertical: {
      flexGrow: 1,
      flexShrink: 1,
      flexDirection: 'column',
      overflow: 'scroll'
    },
    baseHorizontal: {
      flexGrow: 1,
      flexShrink: 1,
      flexDirection: 'row',
      overflow: 'scroll'
    },
    contentContainerHorizontal: {
      flexDirection: 'row'
    }
  });
  module.exports = TypedScrollView;
},503,[112,148,469,146,149,178,504,510,150,175,511,459,508,174,117,512,268,211,274],"node_modules\\react-native\\Libraries\\Components\\ScrollView\\ScrollView.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Dimensions = _$$_REQUIRE(_dependencyMap[0], "Dimensions");

  var FrameRateLogger = _$$_REQUIRE(_dependencyMap[1], "FrameRateLogger");

  var Keyboard = _$$_REQUIRE(_dependencyMap[2], "Keyboard");

  var ReactNative = _$$_REQUIRE(_dependencyMap[3], "ReactNative");

  var Subscribable = _$$_REQUIRE(_dependencyMap[4], "Subscribable");

  var TextInputState = _$$_REQUIRE(_dependencyMap[5], "TextInputState");

  var UIManager = _$$_REQUIRE(_dependencyMap[6], "UIManager");

  var invariant = _$$_REQUIRE(_dependencyMap[7], "fbjs/lib/invariant");

  var nullthrows = _$$_REQUIRE(_dependencyMap[8], "fbjs/lib/nullthrows");

  var performanceNow = _$$_REQUIRE(_dependencyMap[9], "fbjs/lib/performanceNow");

  var warning = _$$_REQUIRE(_dependencyMap[10], "fbjs/lib/warning");

  var _require = _$$_REQUIRE(_dependencyMap[11], "NativeModules"),
      ScrollViewManager = _require.ScrollViewManager;

  var IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;
  var ScrollResponderMixin = {
    mixins: [Subscribable.Mixin],
    scrollResponderMixinGetInitialState: function scrollResponderMixinGetInitialState() {
      return {
        isTouching: false,
        lastMomentumScrollBeginTime: 0,
        lastMomentumScrollEndTime: 0,
        observedScrollSinceBecomingResponder: false,
        becameResponderWhileAnimating: false
      };
    },
    scrollResponderHandleScrollShouldSetResponder: function scrollResponderHandleScrollShouldSetResponder() {
      return this.state.isTouching;
    },
    scrollResponderHandleStartShouldSetResponder: function scrollResponderHandleStartShouldSetResponder(e) {
      var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();

      if (this.props.keyboardShouldPersistTaps === 'handled' && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput) {
        return true;
      }

      return false;
    },
    scrollResponderHandleStartShouldSetResponderCapture: function scrollResponderHandleStartShouldSetResponderCapture(e) {
      if (this.scrollResponderIsAnimating()) {
        return true;
      }

      var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();
      var keyboardShouldPersistTaps = this.props.keyboardShouldPersistTaps;
      var keyboardNeverPersistTaps = !keyboardShouldPersistTaps || keyboardShouldPersistTaps === 'never';

      if (keyboardNeverPersistTaps && currentlyFocusedTextInput != null && !TextInputState.isTextInput(e.target)) {
        return true;
      }

      return false;
    },
    scrollResponderHandleResponderReject: function scrollResponderHandleResponderReject() {},
    scrollResponderHandleTerminationRequest: function scrollResponderHandleTerminationRequest() {
      return !this.state.observedScrollSinceBecomingResponder;
    },
    scrollResponderHandleTouchEnd: function scrollResponderHandleTouchEnd(e) {
      var nativeEvent = e.nativeEvent;
      this.state.isTouching = nativeEvent.touches.length !== 0;
      this.props.onTouchEnd && this.props.onTouchEnd(e);
    },
    scrollResponderHandleTouchCancel: function scrollResponderHandleTouchCancel(e) {
      this.state.isTouching = false;
      this.props.onTouchCancel && this.props.onTouchCancel(e);
    },
    scrollResponderHandleResponderRelease: function scrollResponderHandleResponderRelease(e) {
      this.props.onResponderRelease && this.props.onResponderRelease(e);
      var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();

      if (this.props.keyboardShouldPersistTaps !== true && this.props.keyboardShouldPersistTaps !== 'always' && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput && !this.state.observedScrollSinceBecomingResponder && !this.state.becameResponderWhileAnimating) {
        this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e);
        TextInputState.blurTextInput(currentlyFocusedTextInput);
      }
    },
    scrollResponderHandleScroll: function scrollResponderHandleScroll(e) {
      this.state.observedScrollSinceBecomingResponder = true;
      this.props.onScroll && this.props.onScroll(e);
    },
    scrollResponderHandleResponderGrant: function scrollResponderHandleResponderGrant(e) {
      this.state.observedScrollSinceBecomingResponder = false;
      this.props.onResponderGrant && this.props.onResponderGrant(e);
      this.state.becameResponderWhileAnimating = this.scrollResponderIsAnimating();
    },
    scrollResponderHandleScrollBeginDrag: function scrollResponderHandleScrollBeginDrag(e) {
      FrameRateLogger.beginScroll();
      this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);
    },
    scrollResponderHandleScrollEndDrag: function scrollResponderHandleScrollEndDrag(e) {
      var velocity = e.nativeEvent.velocity;

      if (!this.scrollResponderIsAnimating() && (!velocity || velocity.x === 0 && velocity.y === 0)) {
        FrameRateLogger.endScroll();
      }

      this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);
    },
    scrollResponderHandleMomentumScrollBegin: function scrollResponderHandleMomentumScrollBegin(e) {
      this.state.lastMomentumScrollBeginTime = performanceNow();
      this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);
    },
    scrollResponderHandleMomentumScrollEnd: function scrollResponderHandleMomentumScrollEnd(e) {
      FrameRateLogger.endScroll();
      this.state.lastMomentumScrollEndTime = performanceNow();
      this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);
    },
    scrollResponderHandleTouchStart: function scrollResponderHandleTouchStart(e) {
      this.state.isTouching = true;
      this.props.onTouchStart && this.props.onTouchStart(e);
    },
    scrollResponderHandleTouchMove: function scrollResponderHandleTouchMove(e) {
      this.props.onTouchMove && this.props.onTouchMove(e);
    },
    scrollResponderIsAnimating: function scrollResponderIsAnimating() {
      var now = performanceNow();
      var timeSinceLastMomentumScrollEnd = now - this.state.lastMomentumScrollEndTime;
      var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.state.lastMomentumScrollEndTime < this.state.lastMomentumScrollBeginTime;
      return isAnimating;
    },
    scrollResponderGetScrollableNode: function scrollResponderGetScrollableNode() {
      return this.getScrollableNode ? this.getScrollableNode() : ReactNative.findNodeHandle(this);
    },
    scrollResponderScrollTo: function scrollResponderScrollTo(x, y, animated) {
      if (typeof x === 'number') {
        console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');
      } else {
        var _ref = x || {};

        x = _ref.x;
        y = _ref.y;
        animated = _ref.animated;
      }

      UIManager.dispatchViewManagerCommand(nullthrows(this.scrollResponderGetScrollableNode()), UIManager.RCTScrollView.Commands.scrollTo, [x || 0, y || 0, animated !== false]);
    },
    scrollResponderScrollToEnd: function scrollResponderScrollToEnd(options) {
      var animated = (options && options.animated) !== false;
      UIManager.dispatchViewManagerCommand(this.scrollResponderGetScrollableNode(), UIManager.RCTScrollView.Commands.scrollToEnd, [animated]);
    },
    scrollResponderScrollWithoutAnimationTo: function scrollResponderScrollWithoutAnimationTo(offsetX, offsetY) {
      console.warn('`scrollResponderScrollWithoutAnimationTo` is deprecated. Use `scrollResponderScrollTo` instead');
      this.scrollResponderScrollTo({
        x: offsetX,
        y: offsetY,
        animated: false
      });
    },
    scrollResponderZoomTo: function scrollResponderZoomTo(rect, animated) {
      invariant(ScrollViewManager && ScrollViewManager.zoomToRect, 'zoomToRect is not implemented');

      if ('animated' in rect) {
        animated = rect.animated;
        delete rect.animated;
      } else if (typeof animated !== 'undefined') {
        console.warn('`scrollResponderZoomTo` `animated` argument is deprecated. Use `options.animated` instead');
      }

      ScrollViewManager.zoomToRect(this.scrollResponderGetScrollableNode(), rect, animated !== false);
    },
    scrollResponderFlashScrollIndicators: function scrollResponderFlashScrollIndicators() {
      UIManager.dispatchViewManagerCommand(this.scrollResponderGetScrollableNode(), UIManager.RCTScrollView.Commands.flashScrollIndicators, []);
    },
    scrollResponderScrollNativeHandleToKeyboard: function scrollResponderScrollNativeHandleToKeyboard(nodeHandle, additionalOffset, preventNegativeScrollOffset) {
      this.additionalScrollOffset = additionalOffset || 0;
      this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;
      UIManager.measureLayout(nodeHandle, ReactNative.findNodeHandle(this.getInnerViewNode()), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);
    },
    scrollResponderInputMeasureAndScrollToKeyboard: function scrollResponderInputMeasureAndScrollToKeyboard(left, top, width, height) {
      var keyboardScreenY = Dimensions.get('window').height;

      if (this.keyboardWillOpenTo) {
        keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;
      }

      var scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset;

      if (this.preventNegativeScrollOffset) {
        scrollOffsetY = Math.max(0, scrollOffsetY);
      }

      this.scrollResponderScrollTo({
        x: 0,
        y: scrollOffsetY,
        animated: true
      });
      this.additionalOffset = 0;
      this.preventNegativeScrollOffset = false;
    },
    scrollResponderTextInputFocusError: function scrollResponderTextInputFocusError(e) {
      console.error('Error measuring text field: ', e);
    },
    UNSAFE_componentWillMount: function UNSAFE_componentWillMount() {
      var keyboardShouldPersistTaps = this.props.keyboardShouldPersistTaps;
      warning(typeof keyboardShouldPersistTaps !== 'boolean', "'keyboardShouldPersistTaps={" + keyboardShouldPersistTaps + "}' is deprecated. " + ("Use 'keyboardShouldPersistTaps=\"" + (keyboardShouldPersistTaps ? 'always' : 'never') + "\"' instead"));
      this.keyboardWillOpenTo = null;
      this.additionalScrollOffset = 0;
      this.addListenerOn(Keyboard, 'keyboardWillShow', this.scrollResponderKeyboardWillShow);
      this.addListenerOn(Keyboard, 'keyboardWillHide', this.scrollResponderKeyboardWillHide);
      this.addListenerOn(Keyboard, 'keyboardDidShow', this.scrollResponderKeyboardDidShow);
      this.addListenerOn(Keyboard, 'keyboardDidHide', this.scrollResponderKeyboardDidHide);
    },
    scrollResponderKeyboardWillShow: function scrollResponderKeyboardWillShow(e) {
      this.keyboardWillOpenTo = e;
      this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);
    },
    scrollResponderKeyboardWillHide: function scrollResponderKeyboardWillHide(e) {
      this.keyboardWillOpenTo = null;
      this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);
    },
    scrollResponderKeyboardDidShow: function scrollResponderKeyboardDidShow(e) {
      if (e) {
        this.keyboardWillOpenTo = e;
      }

      this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);
    },
    scrollResponderKeyboardDidHide: function scrollResponderKeyboardDidHide(e) {
      this.keyboardWillOpenTo = null;
      this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);
    }
  };
  var ScrollResponder = {
    Mixin: ScrollResponderMixin
  };
  module.exports = ScrollResponder;
},504,[152,505,506,178,509,260,145,117,455,208,211,119],"node_modules\\react-native\\Libraries\\Components\\ScrollResponder.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var NativeModules = _$$_REQUIRE(_dependencyMap[0], "NativeModules");

  var invariant = _$$_REQUIRE(_dependencyMap[1], "fbjs/lib/invariant");

  var FrameRateLogger = {
    setGlobalOptions: function setGlobalOptions(options) {
      if (options.debug !== undefined) {
        invariant(NativeModules.FrameRateLogger, 'Trying to debug FrameRateLogger without the native module!');
      }

      if (NativeModules.FrameRateLogger) {
        var optionsClone = {
          debug: !!options.debug,
          reportStackTraces: !!options.reportStackTraces
        };
        Object.freeze(optionsClone);
        Object.seal(optionsClone);
        NativeModules.FrameRateLogger.setGlobalOptions(optionsClone);
      }
    },
    setContext: function setContext(context) {
      NativeModules.FrameRateLogger && NativeModules.FrameRateLogger.setContext(context);
    },
    beginScroll: function beginScroll() {
      NativeModules.FrameRateLogger && NativeModules.FrameRateLogger.beginScroll();
    },
    endScroll: function endScroll() {
      NativeModules.FrameRateLogger && NativeModules.FrameRateLogger.endScroll();
    }
  };
  module.exports = FrameRateLogger;
},505,[119,117],"node_modules\\react-native\\Libraries\\Interaction\\FrameRateLogger.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var LayoutAnimation = _$$_REQUIRE(_dependencyMap[0], "LayoutAnimation");

  var invariant = _$$_REQUIRE(_dependencyMap[1], "fbjs/lib/invariant");

  var NativeEventEmitter = _$$_REQUIRE(_dependencyMap[2], "NativeEventEmitter");

  var KeyboardObserver = _$$_REQUIRE(_dependencyMap[3], "NativeModules").KeyboardObserver;

  var dismissKeyboard = _$$_REQUIRE(_dependencyMap[4], "dismissKeyboard");

  var KeyboardEventEmitter = new NativeEventEmitter(KeyboardObserver);
  var Keyboard = {
    addListener: function addListener(eventName, callback) {
      invariant(false, 'Dummy method used for documentation');
    },
    removeListener: function removeListener(eventName, callback) {
      invariant(false, 'Dummy method used for documentation');
    },
    removeAllListeners: function removeAllListeners(eventName) {
      invariant(false, 'Dummy method used for documentation');
    },
    dismiss: function dismiss() {
      invariant(false, 'Dummy method used for documentation');
    },
    scheduleLayoutAnimation: function scheduleLayoutAnimation(event) {
      invariant(false, 'Dummy method used for documentation');
    }
  };
  Keyboard = KeyboardEventEmitter;
  Keyboard.dismiss = dismissKeyboard;

  Keyboard.scheduleLayoutAnimation = function (event) {
    var duration = event.duration,
        easing = event.easing;

    if (duration) {
      LayoutAnimation.configureNext({
        duration: duration,
        update: {
          duration: duration,
          type: easing && LayoutAnimation.Types[easing] || 'keyboard'
        }
      });
    }
  };

  module.exports = Keyboard;
},506,[507,117,219,119,508],"node_modules\\react-native\\Libraries\\Components\\Keyboard\\Keyboard.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var PropTypes = _$$_REQUIRE(_dependencyMap[0], "prop-types");

  var UIManager = _$$_REQUIRE(_dependencyMap[1], "UIManager");

  var keyMirror = _$$_REQUIRE(_dependencyMap[2], "fbjs/lib/keyMirror");

  var checkPropTypes = PropTypes.checkPropTypes;
  var TypesEnum = {
    spring: true,
    linear: true,
    easeInEaseOut: true,
    easeIn: true,
    easeOut: true,
    keyboard: true
  };
  var Types = keyMirror(TypesEnum);
  var PropertiesEnum = {
    opacity: true,
    scaleX: true,
    scaleY: true,
    scaleXY: true
  };
  var Properties = keyMirror(PropertiesEnum);
  var animType = PropTypes.shape({
    duration: PropTypes.number,
    delay: PropTypes.number,
    springDamping: PropTypes.number,
    initialVelocity: PropTypes.number,
    type: PropTypes.oneOf(Object.keys(Types)).isRequired,
    property: PropTypes.oneOf(Object.keys(Properties))
  });
  var configType = PropTypes.shape({
    duration: PropTypes.number.isRequired,
    create: animType,
    update: animType,
    delete: animType
  });

  function checkConfig(config, location, name) {
    checkPropTypes({
      config: configType
    }, {
      config: config
    }, location, name);
  }

  function configureNext(config, onAnimationDidEnd) {
    if (__DEV__) {
      checkConfig(config, 'config', 'LayoutAnimation.configureNext');
    }

    UIManager.configureNextLayoutAnimation(config, onAnimationDidEnd || function () {}, function () {});
  }

  function create(duration, type, creationProp) {
    return {
      duration: duration,
      create: {
        type: type,
        property: creationProp
      },
      update: {
        type: type
      },
      delete: {
        type: type,
        property: creationProp
      }
    };
  }

  var Presets = {
    easeInEaseOut: create(300, Types.easeInEaseOut, Properties.opacity),
    linear: create(500, Types.linear, Properties.opacity),
    spring: {
      duration: 700,
      create: {
        type: Types.linear,
        property: Properties.opacity
      },
      update: {
        type: Types.spring,
        springDamping: 0.4
      },
      delete: {
        type: Types.linear,
        property: Properties.opacity
      }
    }
  };
  var LayoutAnimation = {
    configureNext: configureNext,
    create: create,
    Types: Types,
    Properties: Properties,
    checkConfig: checkConfig,
    Presets: Presets,
    easeInEaseOut: configureNext.bind(null, Presets.easeInEaseOut),
    linear: configureNext.bind(null, Presets.linear),
    spring: configureNext.bind(null, Presets.spring)
  };
  module.exports = LayoutAnimation;
},507,[161,145,159],"node_modules\\react-native\\Libraries\\LayoutAnimation\\LayoutAnimation.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var TextInputState = _$$_REQUIRE(_dependencyMap[0], "TextInputState");

  function dismissKeyboard() {
    TextInputState.blurTextInput(TextInputState.currentlyFocusedField());
  }

  module.exports = dismissKeyboard;
},508,[260],"node_modules\\react-native\\Libraries\\Utilities\\dismissKeyboard.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Subscribable = {};
  Subscribable.Mixin = {
    UNSAFE_componentWillMount: function UNSAFE_componentWillMount() {
      this._subscribableSubscriptions = [];
    },
    componentWillUnmount: function componentWillUnmount() {
      this._subscribableSubscriptions && this._subscribableSubscriptions.forEach(function (subscription) {
        return subscription.remove();
      });
      this._subscribableSubscriptions = null;
    },
    addListenerOn: function addListenerOn(eventEmitter, eventType, listener, context) {
      this._subscribableSubscriptions.push(eventEmitter.addListener(eventType, listener, context));
    }
  };
  module.exports = Subscribable;
},509,[],"node_modules\\react-native\\Libraries\\Components\\Subscribable.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\ScrollView\\ScrollViewStickyHeader.js";
  var _components = {
    ScrollViewStickyHeader: {
      displayName: "ScrollViewStickyHeader"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\ScrollView\\ScrollViewStickyHeader.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var AnimatedImplementation = _$$_REQUIRE(_dependencyMap[10], "AnimatedImplementation");

  var React = _$$_REQUIRE(_dependencyMap[11], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[12], "StyleSheet");

  var View = _$$_REQUIRE(_dependencyMap[13], "View");

  var AnimatedView = AnimatedImplementation.createAnimatedComponent(View);

  var ScrollViewStickyHeader = function (_React$Component) {
    _inherits(ScrollViewStickyHeader, _React$Component);

    function ScrollViewStickyHeader() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, ScrollViewStickyHeader);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ScrollViewStickyHeader)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
        measured: false,
        layoutY: 0,
        layoutHeight: 0,
        nextHeaderLayoutY: _this.props.nextHeaderLayoutY
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onLayout", function (event) {
        _this.setState({
          measured: true,
          layoutY: event.nativeEvent.layout.y,
          layoutHeight: event.nativeEvent.layout.height
        });

        _this.props.onLayout(event);

        var child = React.Children.only(_this.props.children);

        if (child.props.onLayout) {
          child.props.onLayout(event);
        }
      });

      return _this;
    }

    _createClass(ScrollViewStickyHeader, [{
      key: "setNextHeaderY",
      value: function setNextHeaderY(y) {
        this.setState({
          nextHeaderLayoutY: y
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
            inverted = _this$props.inverted,
            scrollViewHeight = _this$props.scrollViewHeight;
        var _this$state = this.state,
            measured = _this$state.measured,
            layoutHeight = _this$state.layoutHeight,
            layoutY = _this$state.layoutY,
            nextHeaderLayoutY = _this$state.nextHeaderLayoutY;
        var inputRange = [-1, 0];
        var outputRange = [0, 0];

        if (measured) {
          if (inverted) {
            if (scrollViewHeight != null) {
              var stickStartPoint = layoutY + layoutHeight - scrollViewHeight;

              if (stickStartPoint > 0) {
                inputRange.push(stickStartPoint);
                outputRange.push(0);
                inputRange.push(stickStartPoint + 1);
                outputRange.push(1);
                var collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;

                if (collisionPoint > stickStartPoint) {
                  inputRange.push(collisionPoint, collisionPoint + 1);
                  outputRange.push(collisionPoint - stickStartPoint, collisionPoint - stickStartPoint);
                }
              }
            }
          } else {
            inputRange.push(layoutY);
            outputRange.push(0);

            var _collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;

            if (_collisionPoint >= layoutY) {
              inputRange.push(_collisionPoint, _collisionPoint + 1);
              outputRange.push(_collisionPoint - layoutY, _collisionPoint - layoutY);
            } else {
              inputRange.push(layoutY + 1);
              outputRange.push(1);
            }
          }
        }

        var translateY = this.props.scrollAnimatedValue.interpolate({
          inputRange: inputRange,
          outputRange: outputRange
        });
        var child = React.Children.only(this.props.children);
        return React.createElement(AnimatedView, {
          collapsable: false,
          onLayout: this._onLayout,
          style: [child.props.style, styles.header, {
            transform: [{
              translateY: translateY
            }]
          }],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 141
          }
        }, React.cloneElement(child, {
          style: styles.fill,
          onLayout: undefined
        }));
      }
    }]);

    return ScrollViewStickyHeader;
  }(React.Component);

  ScrollViewStickyHeader = _wrapComponent("ScrollViewStickyHeader")(ScrollViewStickyHeader);
  var styles = StyleSheet.create({
    header: {
      zIndex: 10
    },
    fill: {
      flex: 1
    }
  });
  module.exports = ScrollViewStickyHeader;
},510,[23,24,25,26,29,30,28,32,109,280,469,149,150,175],"node_modules\\react-native\\Libraries\\Components\\ScrollView\\ScrollViewStickyHeader.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/defineProperty");

  var ReactNative = _$$_REQUIRE(_dependencyMap[7], "ReactNative");

  var InternalScrollViewType = function (_ReactNative$NativeCo) {
    "use strict";

    _inherits(InternalScrollViewType, _ReactNative$NativeCo);

    function InternalScrollViewType() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, InternalScrollViewType);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(InternalScrollViewType)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "propTypes", void 0);

      return _this;
    }

    _createClass(InternalScrollViewType, [{
      key: "scrollTo",
      value: function scrollTo(y, x, animated) {}
    }, {
      key: "flashScrollIndicators",
      value: function flashScrollIndicators() {}
    }, {
      key: "scrollToEnd",
      value: function scrollToEnd(options) {}
    }, {
      key: "scrollWithoutAnimationTo",
      value: function scrollWithoutAnimationTo() {
        var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      }
    }, {
      key: "getScrollResponder",
      value: function getScrollResponder() {}
    }, {
      key: "getScrollableNode",
      value: function getScrollableNode() {}
    }, {
      key: "getInnerViewNode",
      value: function getInnerViewNode() {}
    }, {
      key: "scrollResponderScrollNativeHandleToKeyboard",
      value: function scrollResponderScrollNativeHandleToKeyboard(nodeHandle, additionalOffset, preventNegativeScrollOffset) {}
    }, {
      key: "scrollResponderScrollTo",
      value: function scrollResponderScrollTo(x, y, animated) {}
    }]);

    return InternalScrollViewType;
  }(ReactNative.NativeComponent);

  module.exports = InternalScrollViewType;
},511,[24,25,26,29,30,28,32,178],"node_modules\\react-native\\Libraries\\Components\\ScrollView\\InternalScrollViewType.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Platform = _$$_REQUIRE(_dependencyMap[0], "Platform");

  function processDecelerationRate(decelerationRate) {
    if (decelerationRate === 'normal') {
      return Platform.select({
        ios: 0.998,
        android: 0.985
      });
    } else if (decelerationRate === 'fast') {
      return Platform.select({
        ios: 0.99,
        android: 0.9
      });
    }

    return decelerationRate;
  }

  module.exports = processDecelerationRate;
},512,[146],"node_modules\\react-native\\Libraries\\Components\\ScrollView\\processDecelerationRate.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "./../../../react-transform-hmr/lib/index.js")).default;

  var _components = {
    StaticRenderer: {
      displayName: "StaticRenderer"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\StaticRenderer.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var React = _$$_REQUIRE(_dependencyMap[9], "React");

  var PropTypes = _$$_REQUIRE(_dependencyMap[10], "prop-types");

  var StaticRenderer = function (_React$Component) {
    _inherits(StaticRenderer, _React$Component);

    function StaticRenderer() {
      _classCallCheck(this, StaticRenderer);

      return _possibleConstructorReturn(this, _getPrototypeOf(StaticRenderer).apply(this, arguments));
    }

    _createClass(StaticRenderer, [{
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps) {
        return nextProps.shouldUpdate;
      }
    }, {
      key: "render",
      value: function render() {
        return this.props.render();
      }
    }]);

    return StaticRenderer;
  }(React.Component);

  _defineProperty(StaticRenderer, "propTypes", {
    shouldUpdate: PropTypes.bool.isRequired,
    render: PropTypes.func.isRequired
  });

  StaticRenderer = _wrapComponent("StaticRenderer")(StaticRenderer);
  module.exports = StaticRenderer;
},513,[23,24,25,26,29,30,32,109,280,149,161],"node_modules\\react-native\\Libraries\\Components\\StaticRenderer.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var React = _$$_REQUIRE(_dependencyMap[1], "react");

  function cloneReferencedElement(element, config) {
    var cloneRef = config.ref;
    var originalRef = element.ref;

    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      children[_key - 2] = arguments[_key];
    }

    if (originalRef == null || cloneRef == null) {
      return React.cloneElement.apply(React, [element, config].concat(children));
    }

    if (typeof originalRef !== 'function') {
      if (__DEV__) {
        console.warn('Cloning an element with a ref that will be overwritten because it ' + 'is not a function. Use a composable callback-style ref instead. ' + 'Ignoring ref: ' + originalRef);
      }

      return React.cloneElement.apply(React, [element, config].concat(children));
    }

    return React.cloneElement.apply(React, [element, _objectSpread({}, config, {
      ref: function ref(component) {
        cloneRef(component);
        originalRef(component);
      }
    })].concat(children));
  }

  module.exports = cloneReferencedElement;
},514,[148,109],"node_modules\\react-clone-referenced-element\\cloneReferencedElement.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\RefreshControl\\RefreshControl.js";
  var _components = {
    RefreshControl: {
      displayName: "RefreshControl"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\RefreshControl\\RefreshControl.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var Platform = _$$_REQUIRE(_dependencyMap[11], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[12], "React");

  var _require = _$$_REQUIRE(_dependencyMap[13], "ReactNative"),
      NativeComponent = _require.NativeComponent;

  var requireNativeComponent = _$$_REQUIRE(_dependencyMap[14], "requireNativeComponent");

  var nullthrows = _$$_REQUIRE(_dependencyMap[15], "fbjs/lib/nullthrows");

  if (Platform.OS === 'android') {
    var AndroidSwipeRefreshLayout = _$$_REQUIRE(_dependencyMap[16], "UIManager").AndroidSwipeRefreshLayout;

    var RefreshLayoutConsts = AndroidSwipeRefreshLayout ? AndroidSwipeRefreshLayout.Constants : {
      SIZE: {}
    };
  } else {
    var RefreshLayoutConsts = {
      SIZE: {}
    };
  }

  var NativeRefreshControl = Platform.OS === 'ios' ? requireNativeComponent('RCTRefreshControl') : requireNativeComponent('AndroidSwipeRefreshLayout');

  var RefreshControl = function (_React$Component) {
    _inherits(RefreshControl, _React$Component);

    function RefreshControl() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, RefreshControl);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RefreshControl)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_nativeRef", null);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_lastNativeRefreshing", false);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onRefresh", function () {
        _this._lastNativeRefreshing = true;
        _this.props.onRefresh && _this.props.onRefresh();

        _this.forceUpdate();
      });

      return _this;
    }

    _createClass(RefreshControl, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this._lastNativeRefreshing = this.props.refreshing;
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (this.props.refreshing !== prevProps.refreshing) {
          this._lastNativeRefreshing = this.props.refreshing;
        } else if (this.props.refreshing !== this._lastNativeRefreshing) {
          nullthrows(this._nativeRef).setNativeProps({
            refreshing: this.props.refreshing
          });
          this._lastNativeRefreshing = this.props.refreshing;
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        return React.createElement(NativeRefreshControl, _extends({}, this.props, {
          ref: function ref(_ref) {
            _this2._nativeRef = _ref;
          },
          onRefresh: this._onRefresh,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 167
          }
        }));
      }
    }]);

    return RefreshControl;
  }(React.Component);

  _defineProperty(RefreshControl, "SIZE", RefreshLayoutConsts.SIZE);

  RefreshControl = _wrapComponent("RefreshControl")(RefreshControl);
  module.exports = RefreshControl;
},515,[23,112,24,25,26,29,30,28,32,109,280,146,149,178,268,455,145],"node_modules\\react-native\\Libraries\\Components\\RefreshControl\\RefreshControl.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectSpread");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/classCallCheck");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf");

  var _createClass = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Lists\\VirtualizedList.js";
  var _components = {
    VirtualizedList: {
      displayName: "VirtualizedList"
    },
    CellRenderer: {
      displayName: "CellRenderer"
    },
    VirtualizedCellWrapper: {
      displayName: "VirtualizedCellWrapper"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Lists\\VirtualizedList.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var Batchinator = _$$_REQUIRE(_dependencyMap[12], "Batchinator");

  var FillRateHelper = _$$_REQUIRE(_dependencyMap[13], "FillRateHelper");

  var PropTypes = _$$_REQUIRE(_dependencyMap[14], "prop-types");

  var React = _$$_REQUIRE(_dependencyMap[15], "React");

  var ReactNative = _$$_REQUIRE(_dependencyMap[16], "ReactNative");

  var RefreshControl = _$$_REQUIRE(_dependencyMap[17], "RefreshControl");

  var ScrollView = _$$_REQUIRE(_dependencyMap[18], "ScrollView");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[19], "StyleSheet");

  var UIManager = _$$_REQUIRE(_dependencyMap[20], "UIManager");

  var View = _$$_REQUIRE(_dependencyMap[21], "View");

  var ViewabilityHelper = _$$_REQUIRE(_dependencyMap[22], "ViewabilityHelper");

  var flattenStyle = _$$_REQUIRE(_dependencyMap[23], "flattenStyle");

  var infoLog = _$$_REQUIRE(_dependencyMap[24], "infoLog");

  var invariant = _$$_REQUIRE(_dependencyMap[25], "fbjs/lib/invariant");

  var warning = _$$_REQUIRE(_dependencyMap[26], "fbjs/lib/warning");

  var _require = _$$_REQUIRE(_dependencyMap[27], "VirtualizeUtils"),
      computeWindowedRenderLimits = _require.computeWindowedRenderLimits;

  var _usedIndexForKey = false;
  var _keylessItemComponentName = '';

  var VirtualizedList = function (_React$PureComponent) {
    _inherits(VirtualizedList, _React$PureComponent);

    _createClass(VirtualizedList, [{
      key: "scrollToEnd",
      value: function scrollToEnd(params) {
        var animated = params ? params.animated : true;
        var veryLast = this.props.getItemCount(this.props.data) - 1;

        var frame = this._getFrameMetricsApprox(veryLast);

        var offset = Math.max(0, frame.offset + frame.length + this._footerLength - this._scrollMetrics.visibleLength);

        this._scrollRef.scrollTo(this.props.horizontal ? {
          x: offset,
          animated: animated
        } : {
          y: offset,
          animated: animated
        });
      }
    }, {
      key: "scrollToIndex",
      value: function scrollToIndex(params) {
        var _this$props = this.props,
            data = _this$props.data,
            horizontal = _this$props.horizontal,
            getItemCount = _this$props.getItemCount,
            getItemLayout = _this$props.getItemLayout,
            onScrollToIndexFailed = _this$props.onScrollToIndexFailed;
        var animated = params.animated,
            index = params.index,
            viewOffset = params.viewOffset,
            viewPosition = params.viewPosition;
        invariant(index >= 0 && index < getItemCount(data), "scrollToIndex out of range: " + index + " vs " + (getItemCount(data) - 1));

        if (!getItemLayout && index > this._highestMeasuredFrameIndex) {
          invariant(!!onScrollToIndexFailed, 'scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, ' + 'otherwise there is no way to know the location of offscreen indices or handle failures.');
          onScrollToIndexFailed({
            averageItemLength: this._averageCellLength,
            highestMeasuredFrameIndex: this._highestMeasuredFrameIndex,
            index: index
          });
          return;
        }

        var frame = this._getFrameMetricsApprox(index);

        var offset = Math.max(0, frame.offset - (viewPosition || 0) * (this._scrollMetrics.visibleLength - frame.length)) - (viewOffset || 0);

        this._scrollRef.scrollTo(horizontal ? {
          x: offset,
          animated: animated
        } : {
          y: offset,
          animated: animated
        });
      }
    }, {
      key: "scrollToItem",
      value: function scrollToItem(params) {
        var item = params.item;
        var _this$props2 = this.props,
            data = _this$props2.data,
            getItem = _this$props2.getItem,
            getItemCount = _this$props2.getItemCount;
        var itemCount = getItemCount(data);

        for (var _index = 0; _index < itemCount; _index++) {
          if (getItem(data, _index) === item) {
            this.scrollToIndex(_objectSpread({}, params, {
              index: _index
            }));
            break;
          }
        }
      }
    }, {
      key: "scrollToOffset",
      value: function scrollToOffset(params) {
        var animated = params.animated,
            offset = params.offset;

        this._scrollRef.scrollTo(this.props.horizontal ? {
          x: offset,
          animated: animated
        } : {
          y: offset,
          animated: animated
        });
      }
    }, {
      key: "recordInteraction",
      value: function recordInteraction() {
        this._nestedChildLists.forEach(function (childList) {
          childList.ref && childList.ref.recordInteraction();
        });

        this._viewabilityTuples.forEach(function (t) {
          t.viewabilityHelper.recordInteraction();
        });

        this._updateViewableItems(this.props.data);
      }
    }, {
      key: "flashScrollIndicators",
      value: function flashScrollIndicators() {
        this._scrollRef.flashScrollIndicators();
      }
    }, {
      key: "getScrollResponder",
      value: function getScrollResponder() {
        if (this._scrollRef && this._scrollRef.getScrollResponder) {
          return this._scrollRef.getScrollResponder();
        }
      }
    }, {
      key: "getScrollableNode",
      value: function getScrollableNode() {
        if (this._scrollRef && this._scrollRef.getScrollableNode) {
          return this._scrollRef.getScrollableNode();
        } else {
          return ReactNative.findNodeHandle(this._scrollRef);
        }
      }
    }, {
      key: "setNativeProps",
      value: function setNativeProps(props) {
        if (this._scrollRef) {
          this._scrollRef.setNativeProps(props);
        }
      }
    }, {
      key: "getChildContext",
      value: function getChildContext() {
        return {
          virtualizedList: {
            getScrollMetrics: this._getScrollMetrics,
            horizontal: this.props.horizontal,
            getOutermostParentListRef: this._getOutermostParentListRef,
            getNestedChildState: this._getNestedChildState,
            registerAsNestedChild: this._registerAsNestedChild,
            unregisterAsNestedChild: this._unregisterAsNestedChild
          }
        };
      }
    }, {
      key: "_getCellKey",
      value: function _getCellKey() {
        return this.context.virtualizedCell && this.context.virtualizedCell.cellKey || 'rootList';
      }
    }, {
      key: "hasMore",
      value: function hasMore() {
        return this._hasMore;
      }
    }]);

    function VirtualizedList(_props, context) {
      var _this;

      _classCallCheck(this, VirtualizedList);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(VirtualizedList).call(this, _props, context));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "props", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_getScrollMetrics", function () {
        return _this._scrollMetrics;
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_getOutermostParentListRef", function () {
        if (_this._isNestedWithSameOrientation()) {
          return _this.context.virtualizedList.getOutermostParentListRef();
        } else {
          return _assertThisInitialized(_assertThisInitialized(_this));
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_getNestedChildState", function (key) {
        var existingChildData = _this._nestedChildLists.get(key);

        return existingChildData && existingChildData.state;
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_registerAsNestedChild", function (childList) {
        var childListsInCell = _this._cellKeysToChildListKeys.get(childList.cellKey) || new Set();
        childListsInCell.add(childList.key);

        _this._cellKeysToChildListKeys.set(childList.cellKey, childListsInCell);

        var existingChildData = _this._nestedChildLists.get(childList.key);

        invariant(!(existingChildData && existingChildData.ref !== null), 'A VirtualizedList contains a cell which itself contains ' + 'more than one VirtualizedList of the same orientation as the parent ' + 'list. You must pass a unique listKey prop to each sibling list.');

        _this._nestedChildLists.set(childList.key, {
          ref: childList.ref,
          state: null
        });

        if (_this._hasInteracted) {
          childList.ref.recordInteraction();
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_unregisterAsNestedChild", function (childList) {
        _this._nestedChildLists.set(childList.key, {
          ref: null,
          state: childList.state
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onUpdateSeparators", function (keys, newProps) {
        keys.forEach(function (key) {
          var ref = key != null && _this._cellRefs[key];
          ref && ref.updateSeparatorProps(newProps);
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_averageCellLength", 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_cellKeysToChildListKeys", new Map());

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_cellRefs", {});

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_fillRateHelper", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_frames", {});

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_footerLength", 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_hasDataChangedSinceEndReached", true);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_hasInteracted", false);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_hasMore", false);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_hasWarned", {});

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_highestMeasuredFrameIndex", 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_headerLength", 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_indicesToKeys", new Map());

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_hasDoneInitialScroll", false);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_nestedChildLists", new Map());

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_offsetFromParentVirtualizedList", 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_prevParentOffset", 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_scrollMetrics", {
        contentLength: 0,
        dOffset: 0,
        dt: 10,
        offset: 0,
        timestamp: 0,
        velocity: 0,
        visibleLength: 0
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_scrollRef", null);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_sentEndForContentLength", 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_totalCellLength", 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_totalCellsMeasured", 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_updateCellsToRenderBatcher", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_viewabilityTuples", []);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_captureScrollRef", function (ref) {
        _this._scrollRef = ref;
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_defaultRenderScrollComponent", function (props) {
        var onRefresh = props.onRefresh;

        if (_this._isNestedWithSameOrientation()) {
          return React.createElement(View, _extends({}, props, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 1035
            }
          }));
        } else if (onRefresh) {
          invariant(typeof props.refreshing === 'boolean', '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' + JSON.stringify(props.refreshing) + '`');
          return React.createElement(ScrollView, _extends({}, props, {
            refreshControl: props.refreshControl == null ? React.createElement(RefreshControl, {
              refreshing: props.refreshing,
              onRefresh: onRefresh,
              progressViewOffset: props.progressViewOffset,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 1049
              }
            }) : props.refreshControl,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 1045
            }
          }));
        } else {
          return React.createElement(ScrollView, _extends({}, props, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 1062
            }
          }));
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onCellUnmount", function (cellKey) {
        var curr = _this._frames[cellKey];

        if (curr) {
          _this._frames[cellKey] = _objectSpread({}, curr, {
            inLayout: false
          });
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onLayout", function (e) {
        if (_this._isNestedWithSameOrientation()) {
          _this.measureLayoutRelativeToContainingList();
        } else {
          _this._scrollMetrics.visibleLength = _this._selectLength(e.nativeEvent.layout);
        }

        _this.props.onLayout && _this.props.onLayout(e);

        _this._scheduleCellsToRenderUpdate();

        _this._maybeCallOnEndReached();
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onLayoutEmpty", function (e) {
        _this.props.onLayout && _this.props.onLayout(e);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onLayoutFooter", function (e) {
        _this._footerLength = _this._selectLength(e.nativeEvent.layout);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onLayoutHeader", function (e) {
        _this._headerLength = _this._selectLength(e.nativeEvent.layout);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onContentSizeChange", function (width, height) {
        if (width > 0 && height > 0 && _this.props.initialScrollIndex != null && _this.props.initialScrollIndex > 0 && !_this._hasDoneInitialScroll) {
          _this.scrollToIndex({
            animated: false,
            index: _this.props.initialScrollIndex
          });

          _this._hasDoneInitialScroll = true;
        }

        if (_this.props.onContentSizeChange) {
          _this.props.onContentSizeChange(width, height);
        }

        _this._scrollMetrics.contentLength = _this._selectLength({
          height: height,
          width: width
        });

        _this._scheduleCellsToRenderUpdate();

        _this._maybeCallOnEndReached();
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_convertParentScrollMetrics", function (metrics) {
        var offset = metrics.offset - _this._offsetFromParentVirtualizedList;
        var visibleLength = metrics.visibleLength;
        var dOffset = offset - _this._scrollMetrics.offset;
        var contentLength = _this._scrollMetrics.contentLength;
        return {
          visibleLength: visibleLength,
          contentLength: contentLength,
          offset: offset,
          dOffset: dOffset
        };
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onScroll", function (e) {
        _this._nestedChildLists.forEach(function (childList) {
          childList.ref && childList.ref._onScroll(e);
        });

        if (_this.props.onScroll) {
          _this.props.onScroll(e);
        }

        var timestamp = e.timeStamp;

        var visibleLength = _this._selectLength(e.nativeEvent.layoutMeasurement);

        var contentLength = _this._selectLength(e.nativeEvent.contentSize);

        var offset = _this._selectOffset(e.nativeEvent.contentOffset);

        var dOffset = offset - _this._scrollMetrics.offset;

        if (_this._isNestedWithSameOrientation()) {
          if (_this._scrollMetrics.contentLength === 0) {
            return;
          }

          var _this$_convertParentS = _this._convertParentScrollMetrics({
            visibleLength: visibleLength,
            offset: offset
          });

          visibleLength = _this$_convertParentS.visibleLength;
          contentLength = _this$_convertParentS.contentLength;
          offset = _this$_convertParentS.offset;
          dOffset = _this$_convertParentS.dOffset;
        }

        var dt = _this._scrollMetrics.timestamp ? Math.max(1, timestamp - _this._scrollMetrics.timestamp) : 1;
        var velocity = dOffset / dt;

        if (dt > 500 && _this._scrollMetrics.dt > 500 && contentLength > 5 * visibleLength && !_this._hasWarned.perf) {
          infoLog('VirtualizedList: You have a large list that is slow to update - make sure your ' + 'renderItem function renders components that follow React performance best practices ' + 'like PureComponent, shouldComponentUpdate, etc.', {
            dt: dt,
            prevDt: _this._scrollMetrics.dt,
            contentLength: contentLength
          });
          _this._hasWarned.perf = true;
        }

        _this._scrollMetrics = {
          contentLength: contentLength,
          dt: dt,
          dOffset: dOffset,
          offset: offset,
          timestamp: timestamp,
          velocity: velocity,
          visibleLength: visibleLength
        };

        _this._updateViewableItems(_this.props.data);

        if (!_this.props) {
          return;
        }

        _this._maybeCallOnEndReached();

        if (velocity !== 0) {
          _this._fillRateHelper.activate();
        }

        _this._computeBlankness();

        _this._scheduleCellsToRenderUpdate();
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onScrollBeginDrag", function (e) {
        _this._nestedChildLists.forEach(function (childList) {
          childList.ref && childList.ref._onScrollBeginDrag(e);
        });

        _this._viewabilityTuples.forEach(function (tuple) {
          tuple.viewabilityHelper.recordInteraction();
        });

        _this._hasInteracted = true;
        _this.props.onScrollBeginDrag && _this.props.onScrollBeginDrag(e);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onScrollEndDrag", function (e) {
        var velocity = e.nativeEvent.velocity;

        if (velocity) {
          _this._scrollMetrics.velocity = _this._selectOffset(velocity);
        }

        _this._computeBlankness();

        _this.props.onScrollEndDrag && _this.props.onScrollEndDrag(e);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onMomentumScrollEnd", function (e) {
        _this._scrollMetrics.velocity = 0;

        _this._computeBlankness();

        _this.props.onMomentumScrollEnd && _this.props.onMomentumScrollEnd(e);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_updateCellsToRender", function () {
        var _this$props3 = _this.props,
            data = _this$props3.data,
            getItemCount = _this$props3.getItemCount,
            onEndReachedThreshold = _this$props3.onEndReachedThreshold;

        var isVirtualizationDisabled = _this._isVirtualizationDisabled();

        _this._updateViewableItems(data);

        if (!data) {
          return;
        }

        _this.setState(function (state) {
          var newState;

          if (!isVirtualizationDisabled) {
            if (_this._scrollMetrics.visibleLength) {
              if (!_this.props.initialScrollIndex || _this._scrollMetrics.offset) {
                newState = computeWindowedRenderLimits(_this.props, state, _this._getFrameMetricsApprox, _this._scrollMetrics);
              }
            }
          } else {
            var _this$_scrollMetrics = _this._scrollMetrics,
                contentLength = _this$_scrollMetrics.contentLength,
                offset = _this$_scrollMetrics.offset,
                visibleLength = _this$_scrollMetrics.visibleLength;
            var distanceFromEnd = contentLength - visibleLength - offset;
            var renderAhead = distanceFromEnd < onEndReachedThreshold * visibleLength ? _this.props.maxToRenderPerBatch : 0;
            newState = {
              first: 0,
              last: Math.min(state.last + renderAhead, getItemCount(data) - 1)
            };
          }

          if (newState && _this._nestedChildLists.size > 0) {
            var newFirst = newState.first;
            var newLast = newState.last;

            for (var ii = newFirst; ii <= newLast; ii++) {
              var cellKeyForIndex = _this._indicesToKeys.get(ii);

              var childListKeys = cellKeyForIndex && _this._cellKeysToChildListKeys.get(cellKeyForIndex);

              if (!childListKeys) {
                continue;
              }

              var someChildHasMore = false;

              for (var _iterator = childListKeys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === "function" ? typeof Symbol === "function" ? Symbol.iterator : "@@iterator" : "@@iterator"]();;) {
                var _ref;

                if (_isArray) {
                  if (_i >= _iterator.length) break;
                  _ref = _iterator[_i++];
                } else {
                  _i = _iterator.next();
                  if (_i.done) break;
                  _ref = _i.value;
                }

                var _childKey = _ref;

                var childList = _this._nestedChildLists.get(_childKey);

                if (childList && childList.ref && childList.ref.hasMore()) {
                  someChildHasMore = true;
                  break;
                }
              }

              if (someChildHasMore) {
                newState.last = ii;
                break;
              }
            }
          }

          return newState;
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_createViewToken", function (index, isViewable) {
        var _this$props4 = _this.props,
            data = _this$props4.data,
            getItem = _this$props4.getItem,
            keyExtractor = _this$props4.keyExtractor;
        var item = getItem(data, index);
        return {
          index: index,
          item: item,
          key: keyExtractor(item, index),
          isViewable: isViewable
        };
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_getFrameMetricsApprox", function (index) {
        var frame = _this._getFrameMetrics(index);

        if (frame && frame.index === index) {
          return frame;
        } else {
          var getItemLayout = _this.props.getItemLayout;
          invariant(!getItemLayout, 'Should not have to estimate frames when a measurement metrics function is provided');
          return {
            length: _this._averageCellLength,
            offset: _this._averageCellLength * index
          };
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_getFrameMetrics", function (index) {
        var _this$props5 = _this.props,
            data = _this$props5.data,
            getItem = _this$props5.getItem,
            getItemCount = _this$props5.getItemCount,
            getItemLayout = _this$props5.getItemLayout,
            keyExtractor = _this$props5.keyExtractor;
        invariant(getItemCount(data) > index, 'Tried to get frame for out of range index ' + index);
        var item = getItem(data, index);

        var frame = item && _this._frames[keyExtractor(item, index)];

        if (!frame || frame.index !== index) {
          if (getItemLayout) {
            frame = getItemLayout(data, index);

            if (__DEV__) {
              var frameType = PropTypes.shape({
                length: PropTypes.number.isRequired,
                offset: PropTypes.number.isRequired,
                index: PropTypes.number.isRequired
              }).isRequired;
              PropTypes.checkPropTypes({
                frame: frameType
              }, {
                frame: frame
              }, 'frame', 'VirtualizedList.getItemLayout');
            }
          }
        }

        return frame;
      });

      invariant(!_props.onScroll || !_props.onScroll.__isNative, 'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' + 'to support native onScroll events with useNativeDriver');
      invariant(_props.windowSize > 0, 'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.');
      _this._fillRateHelper = new FillRateHelper(_this._getFrameMetrics);
      _this._updateCellsToRenderBatcher = new Batchinator(_this._updateCellsToRender, _this.props.updateCellsBatchingPeriod);

      if (_this.props.viewabilityConfigCallbackPairs) {
        _this._viewabilityTuples = _this.props.viewabilityConfigCallbackPairs.map(function (pair) {
          return {
            viewabilityHelper: new ViewabilityHelper(pair.viewabilityConfig),
            onViewableItemsChanged: pair.onViewableItemsChanged
          };
        });
      } else if (_this.props.onViewableItemsChanged) {
        _this._viewabilityTuples.push({
          viewabilityHelper: new ViewabilityHelper(_this.props.viewabilityConfig),
          onViewableItemsChanged: _this.props.onViewableItemsChanged
        });
      }

      var initialState = {
        first: _this.props.initialScrollIndex || 0,
        last: Math.min(_this.props.getItemCount(_this.props.data), (_this.props.initialScrollIndex || 0) + _this.props.initialNumToRender) - 1
      };

      if (_this._isNestedWithSameOrientation()) {
        var storedState = _this.context.virtualizedList.getNestedChildState(_this.props.listKey || _this._getCellKey());

        if (storedState) {
          initialState = storedState;
          _this.state = storedState;
          _this._frames = storedState.frames;
        }
      }

      _this.state = initialState;
      return _this;
    }

    _createClass(VirtualizedList, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        if (this._isNestedWithSameOrientation()) {
          this.context.virtualizedList.registerAsNestedChild({
            cellKey: this._getCellKey(),
            key: this.props.listKey || this._getCellKey(),
            ref: this
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._isNestedWithSameOrientation()) {
          this.context.virtualizedList.unregisterAsNestedChild({
            key: this.props.listKey || this._getCellKey(),
            state: {
              first: this.state.first,
              last: this.state.last,
              frames: this._frames
            }
          });
        }

        this._updateViewableItems(null);

        this._updateCellsToRenderBatcher.dispose({
          abort: true
        });

        this._viewabilityTuples.forEach(function (tuple) {
          tuple.viewabilityHelper.dispose();
        });

        this._fillRateHelper.deactivateAndFlush();
      }
    }, {
      key: "_pushCells",
      value: function _pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, first, last, inversionStyle) {
        var _this2 = this;

        var _this$props6 = this.props,
            CellRendererComponent = _this$props6.CellRendererComponent,
            ItemSeparatorComponent = _this$props6.ItemSeparatorComponent,
            data = _this$props6.data,
            getItem = _this$props6.getItem,
            getItemCount = _this$props6.getItemCount,
            horizontal = _this$props6.horizontal,
            keyExtractor = _this$props6.keyExtractor;
        var stickyOffset = this.props.ListHeaderComponent ? 1 : 0;
        var end = getItemCount(data) - 1;
        var prevCellKey;
        last = Math.min(end, last);

        var _loop = function _loop(ii) {
          var item = getItem(data, ii);
          var key = keyExtractor(item, ii);

          _this2._indicesToKeys.set(ii, key);

          if (stickyIndicesFromProps.has(ii + stickyOffset)) {
            stickyHeaderIndices.push(cells.length);
          }

          cells.push(React.createElement(CellRenderer, {
            CellRendererComponent: CellRendererComponent,
            ItemSeparatorComponent: ii < end ? ItemSeparatorComponent : undefined,
            cellKey: key,
            fillRateHelper: _this2._fillRateHelper,
            horizontal: horizontal,
            index: ii,
            inversionStyle: inversionStyle,
            item: item,
            key: key,
            prevCellKey: prevCellKey,
            onUpdateSeparators: _this2._onUpdateSeparators,
            onLayout: function onLayout(e) {
              return _this2._onCellLayout(e, key, ii);
            },
            onUnmount: _this2._onCellUnmount,
            parentProps: _this2.props,
            ref: function ref(_ref2) {
              _this2._cellRefs[key] = _ref2;
            },
            __source: {
              fileName: _jsxFileName,
              lineNumber: 687
            }
          }));
          prevCellKey = key;
        };

        for (var ii = first; ii <= last; ii++) {
          _loop(ii);
        }
      }
    }, {
      key: "_isVirtualizationDisabled",
      value: function _isVirtualizationDisabled() {
        return this.props.disableVirtualization;
      }
    }, {
      key: "_isNestedWithSameOrientation",
      value: function _isNestedWithSameOrientation() {
        var nestedContext = this.context.virtualizedList;
        return !!(nestedContext && !!nestedContext.horizontal === !!this.props.horizontal);
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        if (__DEV__) {
          var flatStyles = flattenStyle(this.props.contentContainerStyle);
          warning(flatStyles == null || flatStyles.flexWrap !== 'wrap', '`flexWrap: `wrap`` is not supported with the `VirtualizedList` components.' + 'Consider using `numColumns` with `FlatList` instead.');
        }

        var _this$props7 = this.props,
            ListEmptyComponent = _this$props7.ListEmptyComponent,
            ListFooterComponent = _this$props7.ListFooterComponent,
            ListHeaderComponent = _this$props7.ListHeaderComponent;
        var _this$props8 = this.props,
            data = _this$props8.data,
            horizontal = _this$props8.horizontal;

        var isVirtualizationDisabled = this._isVirtualizationDisabled();

        var inversionStyle = this.props.inverted ? this.props.horizontal ? styles.horizontallyInverted : styles.verticallyInverted : null;
        var cells = [];
        var stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);
        var stickyHeaderIndices = [];

        if (ListHeaderComponent) {
          if (stickyIndicesFromProps.has(0)) {
            stickyHeaderIndices.push(0);
          }

          var element = React.isValidElement(ListHeaderComponent) ? ListHeaderComponent : React.createElement(ListHeaderComponent, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 761
            }
          });
          cells.push(React.createElement(VirtualizedCellWrapper, {
            cellKey: this._getCellKey() + '-header',
            key: "$header",
            __source: {
              fileName: _jsxFileName,
              lineNumber: 764
            }
          }, React.createElement(View, {
            onLayout: this._onLayoutHeader,
            style: StyleSheet.compose(inversionStyle, this.props.ListHeaderComponentStyle),
            __source: {
              fileName: _jsxFileName,
              lineNumber: 767
            }
          }, element)));
        }

        var itemCount = this.props.getItemCount(data);

        if (itemCount > 0) {
          _usedIndexForKey = false;
          _keylessItemComponentName = '';
          var spacerKey = !horizontal ? 'height' : 'width';
          var lastInitialIndex = this.props.initialScrollIndex ? -1 : this.props.initialNumToRender - 1;
          var _this$state = this.state,
              first = _this$state.first,
              last = _this$state.last;

          this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, 0, lastInitialIndex, inversionStyle);

          var firstAfterInitial = Math.max(lastInitialIndex + 1, first);

          if (!isVirtualizationDisabled && first > lastInitialIndex + 1) {
            var insertedStickySpacer = false;

            if (stickyIndicesFromProps.size > 0) {
              var stickyOffset = ListHeaderComponent ? 1 : 0;

              for (var ii = firstAfterInitial - 1; ii > lastInitialIndex; ii--) {
                if (stickyIndicesFromProps.has(ii + stickyOffset)) {
                  var initBlock = this._getFrameMetricsApprox(lastInitialIndex);

                  var stickyBlock = this._getFrameMetricsApprox(ii);

                  var leadSpace = stickyBlock.offset - initBlock.offset;
                  cells.push(React.createElement(View, {
                    key: "$sticky_lead",
                    style: _defineProperty({}, spacerKey, leadSpace),
                    __source: {
                      fileName: _jsxFileName,
                      lineNumber: 810
                    }
                  }));

                  this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, ii, ii, inversionStyle);

                  var trailSpace = this._getFrameMetricsApprox(first).offset - (stickyBlock.offset + stickyBlock.length);
                  cells.push(React.createElement(View, {
                    key: "$sticky_trail",
                    style: _defineProperty({}, spacerKey, trailSpace),
                    __source: {
                      fileName: _jsxFileName,
                      lineNumber: 824
                    }
                  }));
                  insertedStickySpacer = true;
                  break;
                }
              }
            }

            if (!insertedStickySpacer) {
              var _initBlock = this._getFrameMetricsApprox(lastInitialIndex);

              var firstSpace = this._getFrameMetricsApprox(first).offset - (_initBlock.offset + _initBlock.length);

              cells.push(React.createElement(View, {
                key: "$lead_spacer",
                style: _defineProperty({}, spacerKey, firstSpace),
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 837
                }
              }));
            }
          }

          this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, firstAfterInitial, last, inversionStyle);

          if (!this._hasWarned.keys && _usedIndexForKey) {
            console.warn('VirtualizedList: missing keys for items, make sure to specify a key property on each ' + 'item or provide a custom keyExtractor.', _keylessItemComponentName);
            this._hasWarned.keys = true;
          }

          if (!isVirtualizationDisabled && last < itemCount - 1) {
            var lastFrame = this._getFrameMetricsApprox(last);

            var end = this.props.getItemLayout ? itemCount - 1 : Math.min(itemCount - 1, this._highestMeasuredFrameIndex);

            var endFrame = this._getFrameMetricsApprox(end);

            var tailSpacerLength = endFrame.offset + endFrame.length - (lastFrame.offset + lastFrame.length);
            cells.push(React.createElement(View, {
              key: "$tail_spacer",
              style: _defineProperty({}, spacerKey, tailSpacerLength),
              __source: {
                fileName: _jsxFileName,
                lineNumber: 871
              }
            }));
          }
        } else if (ListEmptyComponent) {
          var _element = React.isValidElement(ListEmptyComponent) ? ListEmptyComponent : React.createElement(ListEmptyComponent, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 881
            }
          });

          cells.push(React.cloneElement(_element, {
            key: '$empty',
            onLayout: function onLayout(event) {
              _this3._onLayoutEmpty(event);

              if (_element.props.onLayout) {
                _element.props.onLayout(event);
              }
            },
            style: [_element.props.style, inversionStyle]
          }));
        }

        if (ListFooterComponent) {
          var _element2 = React.isValidElement(ListFooterComponent) ? ListFooterComponent : React.createElement(ListFooterComponent, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 901
            }
          });

          cells.push(React.createElement(VirtualizedCellWrapper, {
            cellKey: this._getCellKey() + '-footer',
            key: "$footer",
            __source: {
              fileName: _jsxFileName,
              lineNumber: 904
            }
          }, React.createElement(View, {
            onLayout: this._onLayoutFooter,
            style: StyleSheet.compose(inversionStyle, this.props.ListFooterComponentStyle),
            __source: {
              fileName: _jsxFileName,
              lineNumber: 907
            }
          }, _element2)));
        }

        var scrollProps = _objectSpread({}, this.props, {
          onContentSizeChange: this._onContentSizeChange,
          onLayout: this._onLayout,
          onScroll: this._onScroll,
          onScrollBeginDrag: this._onScrollBeginDrag,
          onScrollEndDrag: this._onScrollEndDrag,
          onMomentumScrollEnd: this._onMomentumScrollEnd,
          scrollEventThrottle: this.props.scrollEventThrottle,
          invertStickyHeaders: this.props.invertStickyHeaders !== undefined ? this.props.invertStickyHeaders : this.props.inverted,
          stickyHeaderIndices: stickyHeaderIndices
        });

        if (inversionStyle) {
          scrollProps.style = [inversionStyle, this.props.style];
        }

        this._hasMore = this.state.last < this.props.getItemCount(this.props.data) - 1;
        var ret = React.cloneElement((this.props.renderScrollComponent || this._defaultRenderScrollComponent)(scrollProps), {
          ref: this._captureScrollRef
        }, cells);

        if (this.props.debug) {
          return React.createElement(View, {
            style: {
              flex: 1
            },
            __source: {
              fileName: _jsxFileName,
              lineNumber: 958
            }
          }, ret, this._renderDebugOverlay());
        } else {
          return ret;
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _this$props9 = this.props,
            data = _this$props9.data,
            extraData = _this$props9.extraData;

        if (data !== prevProps.data || extraData !== prevProps.extraData) {
          this._hasDataChangedSinceEndReached = true;

          this._viewabilityTuples.forEach(function (tuple) {
            tuple.viewabilityHelper.resetViewableIndices();
          });
        }

        this._scheduleCellsToRenderUpdate();
      }
    }, {
      key: "_computeBlankness",
      value: function _computeBlankness() {
        this._fillRateHelper.computeBlankness(this.props, this.state, this._scrollMetrics);
      }
    }, {
      key: "_onCellLayout",
      value: function _onCellLayout(e, cellKey, index) {
        var layout = e.nativeEvent.layout;
        var next = {
          offset: this._selectOffset(layout),
          length: this._selectLength(layout),
          index: index,
          inLayout: true
        };
        var curr = this._frames[cellKey];

        if (!curr || next.offset !== curr.offset || next.length !== curr.length || index !== curr.index) {
          this._totalCellLength += next.length - (curr ? curr.length : 0);
          this._totalCellsMeasured += curr ? 0 : 1;
          this._averageCellLength = this._totalCellLength / this._totalCellsMeasured;
          this._frames[cellKey] = next;
          this._highestMeasuredFrameIndex = Math.max(this._highestMeasuredFrameIndex, index);

          this._scheduleCellsToRenderUpdate();
        } else {
          this._frames[cellKey].inLayout = true;
        }

        var childListKeys = this._cellKeysToChildListKeys.get(cellKey);

        if (childListKeys) {
          for (var _iterator2 = childListKeys, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
            var _ref7;

            if (_isArray2) {
              if (_i2 >= _iterator2.length) break;
              _ref7 = _iterator2[_i2++];
            } else {
              _i2 = _iterator2.next();
              if (_i2.done) break;
              _ref7 = _i2.value;
            }

            var _childKey2 = _ref7;

            var childList = this._nestedChildLists.get(_childKey2);

            childList && childList.ref && childList.ref.measureLayoutRelativeToContainingList();
          }
        }

        this._computeBlankness();
      }
    }, {
      key: "measureLayoutRelativeToContainingList",
      value: function measureLayoutRelativeToContainingList() {
        var _this4 = this;

        try {
          UIManager.measureLayout(ReactNative.findNodeHandle(this), ReactNative.findNodeHandle(this.context.virtualizedList.getOutermostParentListRef()), function (error) {
            console.warn("VirtualizedList: Encountered an error while measuring a list's" + ' offset from its containing VirtualizedList.');
          }, function (x, y, width, height) {
            _this4._offsetFromParentVirtualizedList = _this4._selectOffset({
              x: x,
              y: y
            });
            _this4._scrollMetrics.contentLength = _this4._selectLength({
              width: width,
              height: height
            });

            var scrollMetrics = _this4._convertParentScrollMetrics(_this4.context.virtualizedList.getScrollMetrics());

            _this4._scrollMetrics.visibleLength = scrollMetrics.visibleLength;
            _this4._scrollMetrics.offset = scrollMetrics.offset;
          });
        } catch (error) {
          console.warn('measureLayoutRelativeToContainingList threw an error', error.stack);
        }
      }
    }, {
      key: "_renderDebugOverlay",
      value: function _renderDebugOverlay() {
        var normalize = this._scrollMetrics.visibleLength / this._scrollMetrics.contentLength;
        var framesInLayout = [];
        var itemCount = this.props.getItemCount(this.props.data);

        for (var ii = 0; ii < itemCount; ii++) {
          var frame = this._getFrameMetricsApprox(ii);

          if (frame.inLayout) {
            framesInLayout.push(frame);
          }
        }

        var windowTop = this._getFrameMetricsApprox(this.state.first).offset;

        var frameLast = this._getFrameMetricsApprox(this.state.last);

        var windowLen = frameLast.offset + frameLast.length - windowTop;
        var visTop = this._scrollMetrics.offset;
        var visLen = this._scrollMetrics.visibleLength;
        var baseStyle = {
          position: 'absolute',
          top: 0,
          right: 0
        };
        return React.createElement(View, {
          style: _objectSpread({}, baseStyle, {
            bottom: 0,
            width: 20,
            borderColor: 'blue',
            borderWidth: 1
          }),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 1200
          }
        }, framesInLayout.map(function (f, ii) {
          return React.createElement(View, {
            key: 'f' + ii,
            style: _objectSpread({}, baseStyle, {
              left: 0,
              top: f.offset * normalize,
              height: f.length * normalize,
              backgroundColor: 'orange'
            }),
            __source: {
              fileName: _jsxFileName,
              lineNumber: 1209
            }
          });
        }), React.createElement(View, {
          style: _objectSpread({}, baseStyle, {
            left: 0,
            top: windowTop * normalize,
            height: windowLen * normalize,
            borderColor: 'green',
            borderWidth: 2
          }),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 1220
          }
        }), React.createElement(View, {
          style: _objectSpread({}, baseStyle, {
            left: 0,
            top: visTop * normalize,
            height: visLen * normalize,
            borderColor: 'red',
            borderWidth: 2
          }),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 1230
          }
        }));
      }
    }, {
      key: "_selectLength",
      value: function _selectLength(metrics) {
        return !this.props.horizontal ? metrics.height : metrics.width;
      }
    }, {
      key: "_selectOffset",
      value: function _selectOffset(metrics) {
        return !this.props.horizontal ? metrics.y : metrics.x;
      }
    }, {
      key: "_maybeCallOnEndReached",
      value: function _maybeCallOnEndReached() {
        var _this$props10 = this.props,
            data = _this$props10.data,
            getItemCount = _this$props10.getItemCount,
            onEndReached = _this$props10.onEndReached,
            onEndReachedThreshold = _this$props10.onEndReachedThreshold;
        var _this$_scrollMetrics2 = this._scrollMetrics,
            contentLength = _this$_scrollMetrics2.contentLength,
            visibleLength = _this$_scrollMetrics2.visibleLength,
            offset = _this$_scrollMetrics2.offset;
        var distanceFromEnd = contentLength - visibleLength - offset;

        if (onEndReached && this.state.last === getItemCount(data) - 1 && distanceFromEnd < onEndReachedThreshold * visibleLength && (this._hasDataChangedSinceEndReached || this._scrollMetrics.contentLength !== this._sentEndForContentLength)) {
          this._hasDataChangedSinceEndReached = false;
          this._sentEndForContentLength = this._scrollMetrics.contentLength;
          onEndReached({
            distanceFromEnd: distanceFromEnd
          });
        }
      }
    }, {
      key: "_scheduleCellsToRenderUpdate",
      value: function _scheduleCellsToRenderUpdate() {
        var _this$state2 = this.state,
            first = _this$state2.first,
            last = _this$state2.last;
        var _this$_scrollMetrics3 = this._scrollMetrics,
            offset = _this$_scrollMetrics3.offset,
            visibleLength = _this$_scrollMetrics3.visibleLength,
            velocity = _this$_scrollMetrics3.velocity;
        var itemCount = this.props.getItemCount(this.props.data);
        var hiPri = false;
        var scrollingThreshold = this.props.onEndReachedThreshold * visibleLength / 2;

        if (first > 0) {
          var distTop = offset - this._getFrameMetricsApprox(first).offset;

          hiPri = hiPri || distTop < 0 || velocity < -2 && distTop < scrollingThreshold;
        }

        if (last < itemCount - 1) {
          var distBottom = this._getFrameMetricsApprox(last).offset - (offset + visibleLength);
          hiPri = hiPri || distBottom < 0 || velocity > 2 && distBottom < scrollingThreshold;
        }

        if (hiPri && this._averageCellLength) {
          this._updateCellsToRenderBatcher.dispose({
            abort: true
          });

          this._updateCellsToRender();

          return;
        } else {
          this._updateCellsToRenderBatcher.schedule();
        }
      }
    }, {
      key: "_updateViewableItems",
      value: function _updateViewableItems(data) {
        var _this5 = this;

        var getItemCount = this.props.getItemCount;

        this._viewabilityTuples.forEach(function (tuple) {
          tuple.viewabilityHelper.onUpdate(getItemCount(data), _this5._scrollMetrics.offset, _this5._scrollMetrics.visibleLength, _this5._getFrameMetrics, _this5._createViewToken, tuple.onViewableItemsChanged, _this5.state);
        });
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(newProps, prevState) {
        var data = newProps.data,
            extraData = newProps.extraData,
            getItemCount = newProps.getItemCount,
            maxToRenderPerBatch = newProps.maxToRenderPerBatch;
        return {
          first: Math.max(0, Math.min(prevState.first, getItemCount(data) - 1 - maxToRenderPerBatch)),
          last: Math.max(0, Math.min(prevState.last, getItemCount(data) - 1))
        };
      }
    }]);

    return VirtualizedList;
  }(React.PureComponent);

  _defineProperty(VirtualizedList, "defaultProps", {
    disableVirtualization: false,
    horizontal: false,
    initialNumToRender: 10,
    keyExtractor: function keyExtractor(item, index) {
      if (item.key != null) {
        return item.key;
      }

      _usedIndexForKey = true;

      if (item.type && item.type.displayName) {
        _keylessItemComponentName = item.type.displayName;
      }

      return String(index);
    },
    maxToRenderPerBatch: 10,
    onEndReachedThreshold: 2,
    scrollEventThrottle: 50,
    updateCellsBatchingPeriod: 50,
    windowSize: 21
  });

  _defineProperty(VirtualizedList, "contextTypes", {
    virtualizedCell: PropTypes.shape({
      cellKey: PropTypes.string
    }),
    virtualizedList: PropTypes.shape({
      getScrollMetrics: PropTypes.func,
      horizontal: PropTypes.bool,
      getOutermostParentListRef: PropTypes.func,
      getNestedChildState: PropTypes.func,
      registerAsNestedChild: PropTypes.func,
      unregisterAsNestedChild: PropTypes.func
    })
  });

  _defineProperty(VirtualizedList, "childContextTypes", {
    virtualizedList: PropTypes.shape({
      getScrollMetrics: PropTypes.func,
      horizontal: PropTypes.bool,
      getOutermostParentListRef: PropTypes.func,
      getNestedChildState: PropTypes.func,
      registerAsNestedChild: PropTypes.func,
      unregisterAsNestedChild: PropTypes.func
    })
  });

  VirtualizedList = _wrapComponent("VirtualizedList")(VirtualizedList);

  var CellRenderer = function (_React$Component) {
    _inherits(CellRenderer, _React$Component);

    function CellRenderer() {
      var _getPrototypeOf2;

      var _this6;

      _classCallCheck(this, CellRenderer);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this6 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(CellRenderer)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this6)), "state", {
        separatorProps: {
          highlighted: false,
          leadingItem: _this6.props.item
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this6)), "_separators", {
        highlight: function highlight() {
          var _this6$props = _this6.props,
              cellKey = _this6$props.cellKey,
              prevCellKey = _this6$props.prevCellKey;

          _this6.props.onUpdateSeparators([cellKey, prevCellKey], {
            highlighted: true
          });
        },
        unhighlight: function unhighlight() {
          var _this6$props2 = _this6.props,
              cellKey = _this6$props2.cellKey,
              prevCellKey = _this6$props2.prevCellKey;

          _this6.props.onUpdateSeparators([cellKey, prevCellKey], {
            highlighted: false
          });
        },
        updateProps: function updateProps(select, newProps) {
          var _this6$props3 = _this6.props,
              cellKey = _this6$props3.cellKey,
              prevCellKey = _this6$props3.prevCellKey;

          _this6.props.onUpdateSeparators([select === 'leading' ? prevCellKey : cellKey], newProps);
        }
      });

      return _this6;
    }

    _createClass(CellRenderer, [{
      key: "getChildContext",
      value: function getChildContext() {
        return {
          virtualizedCell: {
            cellKey: this.props.cellKey
          }
        };
      }
    }, {
      key: "updateSeparatorProps",
      value: function updateSeparatorProps(newProps) {
        this.setState(function (state) {
          return {
            separatorProps: _objectSpread({}, state.separatorProps, newProps)
          };
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.props.onUnmount(this.props.cellKey);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props11 = this.props,
            CellRendererComponent = _this$props11.CellRendererComponent,
            ItemSeparatorComponent = _this$props11.ItemSeparatorComponent,
            fillRateHelper = _this$props11.fillRateHelper,
            horizontal = _this$props11.horizontal,
            item = _this$props11.item,
            index = _this$props11.index,
            inversionStyle = _this$props11.inversionStyle,
            parentProps = _this$props11.parentProps;
        var renderItem = parentProps.renderItem,
            getItemLayout = parentProps.getItemLayout;
        invariant(renderItem, 'no renderItem!');
        var element = renderItem({
          item: item,
          index: index,
          separators: this._separators
        });
        var onLayout = getItemLayout && !parentProps.debug && !fillRateHelper.enabled() ? undefined : this.props.onLayout;
        var itemSeparator = ItemSeparatorComponent && React.createElement(ItemSeparatorComponent, _extends({}, this.state.separatorProps, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 1730
          }
        }));
        var cellStyle = inversionStyle ? horizontal ? [{
          flexDirection: 'row-reverse'
        }, inversionStyle] : [{
          flexDirection: 'column-reverse'
        }, inversionStyle] : horizontal ? [{
          flexDirection: 'row'
        }, inversionStyle] : inversionStyle;

        if (!CellRendererComponent) {
          return React.createElement(View, {
            style: cellStyle,
            onLayout: onLayout,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 1741
            }
          }, element, itemSeparator);
        }

        return React.createElement(CellRendererComponent, _extends({}, this.props, {
          style: cellStyle,
          onLayout: onLayout,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 1748
          }
        }), element, itemSeparator);
      }
    }]);

    return CellRenderer;
  }(React.Component);

  _defineProperty(CellRenderer, "childContextTypes", {
    virtualizedCell: PropTypes.shape({
      cellKey: PropTypes.string
    })
  });

  CellRenderer = _wrapComponent("CellRenderer")(CellRenderer);

  var VirtualizedCellWrapper = function (_React$Component2) {
    _inherits(VirtualizedCellWrapper, _React$Component2);

    function VirtualizedCellWrapper() {
      _classCallCheck(this, VirtualizedCellWrapper);

      return _possibleConstructorReturn(this, _getPrototypeOf(VirtualizedCellWrapper).apply(this, arguments));
    }

    _createClass(VirtualizedCellWrapper, [{
      key: "getChildContext",
      value: function getChildContext() {
        return {
          virtualizedCell: {
            cellKey: this.props.cellKey
          }
        };
      }
    }, {
      key: "render",
      value: function render() {
        return this.props.children;
      }
    }]);

    return VirtualizedCellWrapper;
  }(React.Component);

  _defineProperty(VirtualizedCellWrapper, "childContextTypes", {
    virtualizedCell: PropTypes.shape({
      cellKey: PropTypes.string
    })
  });

  VirtualizedCellWrapper = _wrapComponent("VirtualizedCellWrapper")(VirtualizedCellWrapper);
  var styles = StyleSheet.create({
    verticallyInverted: {
      transform: [{
        scaleY: -1
      }]
    },
    horizontallyInverted: {
      transform: [{
        scaleX: -1
      }]
    }
  });
  module.exports = VirtualizedList;
},516,[23,112,148,24,26,29,25,30,28,32,109,280,517,518,161,149,178,515,503,150,145,175,519,174,242,117,211,520],"node_modules\\react-native\\Libraries\\Lists\\VirtualizedList.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/defineProperty");

  var InteractionManager = _$$_REQUIRE(_dependencyMap[3], "InteractionManager");

  var Batchinator = function () {
    function Batchinator(callback, delayMS) {
      _classCallCheck(this, Batchinator);

      _defineProperty(this, "_callback", void 0);

      _defineProperty(this, "_delay", void 0);

      _defineProperty(this, "_taskHandle", void 0);

      this._delay = delayMS;
      this._callback = callback;
    }

    _createClass(Batchinator, [{
      key: "dispose",
      value: function dispose() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
          abort: false
        };

        if (this._taskHandle) {
          this._taskHandle.cancel();

          if (!options.abort) {
            this._callback();
          }

          this._taskHandle = null;
        }
      }
    }, {
      key: "schedule",
      value: function schedule() {
        var _this = this;

        if (this._taskHandle) {
          return;
        }

        var timeoutHandle = setTimeout(function () {
          _this._taskHandle = InteractionManager.runAfterInteractions(function () {
            _this._taskHandle = null;

            _this._callback();
          });
        }, this._delay);
        this._taskHandle = {
          cancel: function cancel() {
            return clearTimeout(timeoutHandle);
          }
        };
      }
    }]);

    return Batchinator;
  }();

  module.exports = Batchinator;
},517,[24,25,32,476],"node_modules\\react-native\\Libraries\\Interaction\\Batchinator.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/defineProperty");

  var performanceNow = _$$_REQUIRE(_dependencyMap[4], "fbjs/lib/performanceNow");

  var warning = _$$_REQUIRE(_dependencyMap[5], "fbjs/lib/warning");

  var Info = function Info() {
    _classCallCheck(this, Info);

    _defineProperty(this, "any_blank_count", 0);

    _defineProperty(this, "any_blank_ms", 0);

    _defineProperty(this, "any_blank_speed_sum", 0);

    _defineProperty(this, "mostly_blank_count", 0);

    _defineProperty(this, "mostly_blank_ms", 0);

    _defineProperty(this, "pixels_blank", 0);

    _defineProperty(this, "pixels_sampled", 0);

    _defineProperty(this, "pixels_scrolled", 0);

    _defineProperty(this, "total_time_spent", 0);

    _defineProperty(this, "sample_count", 0);
  };

  var DEBUG = false;
  var _listeners = [];
  var _minSampleCount = 10;

  var _sampleRate = DEBUG ? 1 : null;

  var FillRateHelper = function () {
    _createClass(FillRateHelper, null, [{
      key: "addListener",
      value: function addListener(callback) {
        warning(_sampleRate !== null, 'Call `FillRateHelper.setSampleRate` before `addListener`.');

        _listeners.push(callback);

        return {
          remove: function remove() {
            _listeners = _listeners.filter(function (listener) {
              return callback !== listener;
            });
          }
        };
      }
    }, {
      key: "setSampleRate",
      value: function setSampleRate(sampleRate) {
        _sampleRate = sampleRate;
      }
    }, {
      key: "setMinSampleCount",
      value: function setMinSampleCount(minSampleCount) {
        _minSampleCount = minSampleCount;
      }
    }]);

    function FillRateHelper(getFrameMetrics) {
      _classCallCheck(this, FillRateHelper);

      _defineProperty(this, "_anyBlankStartTime", null);

      _defineProperty(this, "_enabled", false);

      _defineProperty(this, "_getFrameMetrics", void 0);

      _defineProperty(this, "_info", new Info());

      _defineProperty(this, "_mostlyBlankStartTime", null);

      _defineProperty(this, "_samplesStartTime", null);

      this._getFrameMetrics = getFrameMetrics;
      this._enabled = (_sampleRate || 0) > Math.random();

      this._resetData();
    }

    _createClass(FillRateHelper, [{
      key: "activate",
      value: function activate() {
        if (this._enabled && this._samplesStartTime == null) {
          DEBUG && console.debug('FillRateHelper: activate');
          this._samplesStartTime = performanceNow();
        }
      }
    }, {
      key: "deactivateAndFlush",
      value: function deactivateAndFlush() {
        if (!this._enabled) {
          return;
        }

        var start = this._samplesStartTime;

        if (start == null) {
          DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');
          return;
        }

        if (this._info.sample_count < _minSampleCount) {
          this._resetData();

          return;
        }

        var total_time_spent = performanceNow() - start;

        var info = _objectSpread({}, this._info, {
          total_time_spent: total_time_spent
        });

        if (DEBUG) {
          var derived = {
            avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,
            avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),
            avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,
            any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),
            any_blank_time_frac: this._info.any_blank_ms / total_time_spent,
            mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),
            mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent
          };

          for (var key in derived) {
            derived[key] = Math.round(1000 * derived[key]) / 1000;
          }

          console.debug('FillRateHelper deactivateAndFlush: ', {
            derived: derived,
            info: info
          });
        }

        _listeners.forEach(function (listener) {
          return listener(info);
        });

        this._resetData();
      }
    }, {
      key: "computeBlankness",
      value: function computeBlankness(props, state, scrollMetrics) {
        if (!this._enabled || props.getItemCount(props.data) === 0 || this._samplesStartTime == null) {
          return 0;
        }

        var dOffset = scrollMetrics.dOffset,
            offset = scrollMetrics.offset,
            velocity = scrollMetrics.velocity,
            visibleLength = scrollMetrics.visibleLength;
        this._info.sample_count++;
        this._info.pixels_sampled += Math.round(visibleLength);
        this._info.pixels_scrolled += Math.round(Math.abs(dOffset));
        var scrollSpeed = Math.round(Math.abs(velocity) * 1000);
        var now = performanceNow();

        if (this._anyBlankStartTime != null) {
          this._info.any_blank_ms += now - this._anyBlankStartTime;
        }

        this._anyBlankStartTime = null;

        if (this._mostlyBlankStartTime != null) {
          this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;
        }

        this._mostlyBlankStartTime = null;
        var blankTop = 0;
        var first = state.first;

        var firstFrame = this._getFrameMetrics(first);

        while (first <= state.last && (!firstFrame || !firstFrame.inLayout)) {
          firstFrame = this._getFrameMetrics(first);
          first++;
        }

        if (firstFrame && first > 0) {
          blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));
        }

        var blankBottom = 0;
        var last = state.last;

        var lastFrame = this._getFrameMetrics(last);

        while (last >= state.first && (!lastFrame || !lastFrame.inLayout)) {
          lastFrame = this._getFrameMetrics(last);
          last--;
        }

        if (lastFrame && last < props.getItemCount(props.data) - 1) {
          var bottomEdge = lastFrame.offset + lastFrame.length;
          blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));
        }

        var pixels_blank = Math.round(blankTop + blankBottom);
        var blankness = pixels_blank / visibleLength;

        if (blankness > 0) {
          this._anyBlankStartTime = now;
          this._info.any_blank_speed_sum += scrollSpeed;
          this._info.any_blank_count++;
          this._info.pixels_blank += pixels_blank;

          if (blankness > 0.5) {
            this._mostlyBlankStartTime = now;
            this._info.mostly_blank_count++;
          }
        } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {
          this.deactivateAndFlush();
        }

        return blankness;
      }
    }, {
      key: "enabled",
      value: function enabled() {
        return this._enabled;
      }
    }, {
      key: "_resetData",
      value: function _resetData() {
        this._anyBlankStartTime = null;
        this._info = new Info();
        this._mostlyBlankStartTime = null;
        this._samplesStartTime = null;
      }
    }]);

    return FillRateHelper;
  }();

  module.exports = FillRateHelper;
},518,[148,25,24,32,208,211],"node_modules\\react-native\\Libraries\\Lists\\FillRateHelper.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var _slicedToArray = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/slicedToArray");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/defineProperty");

  var invariant = _$$_REQUIRE(_dependencyMap[5], "fbjs/lib/invariant");

  var ViewabilityHelper = function () {
    function ViewabilityHelper() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        viewAreaCoveragePercentThreshold: 0
      };

      _classCallCheck(this, ViewabilityHelper);

      _defineProperty(this, "_config", void 0);

      _defineProperty(this, "_hasInteracted", false);

      _defineProperty(this, "_timers", new Set());

      _defineProperty(this, "_viewableIndices", []);

      _defineProperty(this, "_viewableItems", new Map());

      this._config = config;
    }

    _createClass(ViewabilityHelper, [{
      key: "dispose",
      value: function dispose() {
        this._timers.forEach(clearTimeout);
      }
    }, {
      key: "computeViewableItems",
      value: function computeViewableItems(itemCount, scrollOffset, viewportHeight, getFrameMetrics, renderRange) {
        var _this$_config = this._config,
            itemVisiblePercentThreshold = _this$_config.itemVisiblePercentThreshold,
            viewAreaCoveragePercentThreshold = _this$_config.viewAreaCoveragePercentThreshold;
        var viewAreaMode = viewAreaCoveragePercentThreshold != null;
        var viewablePercentThreshold = viewAreaMode ? viewAreaCoveragePercentThreshold : itemVisiblePercentThreshold;
        invariant(viewablePercentThreshold != null && itemVisiblePercentThreshold != null !== (viewAreaCoveragePercentThreshold != null), 'Must set exactly one of itemVisiblePercentThreshold or viewAreaCoveragePercentThreshold');
        var viewableIndices = [];

        if (itemCount === 0) {
          return viewableIndices;
        }

        var firstVisible = -1;

        var _ref = renderRange || {
          first: 0,
          last: itemCount - 1
        },
            first = _ref.first,
            last = _ref.last;

        invariant(last < itemCount, 'Invalid render range ' + JSON.stringify({
          renderRange: renderRange,
          itemCount: itemCount
        }));

        for (var idx = first; idx <= last; idx++) {
          var metrics = getFrameMetrics(idx);

          if (!metrics) {
            continue;
          }

          var top = metrics.offset - scrollOffset;
          var bottom = top + metrics.length;

          if (top < viewportHeight && bottom > 0) {
            firstVisible = idx;

            if (_isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, metrics.length)) {
              viewableIndices.push(idx);
            }
          } else if (firstVisible >= 0) {
            break;
          }
        }

        return viewableIndices;
      }
    }, {
      key: "onUpdate",
      value: function onUpdate(itemCount, scrollOffset, viewportHeight, getFrameMetrics, createViewToken, onViewableItemsChanged, renderRange) {
        var _this = this;

        if (this._config.waitForInteraction && !this._hasInteracted || itemCount === 0 || !getFrameMetrics(0)) {
          return;
        }

        var viewableIndices = [];

        if (itemCount) {
          viewableIndices = this.computeViewableItems(itemCount, scrollOffset, viewportHeight, getFrameMetrics, renderRange);
        }

        if (this._viewableIndices.length === viewableIndices.length && this._viewableIndices.every(function (v, ii) {
          return v === viewableIndices[ii];
        })) {
          return;
        }

        this._viewableIndices = viewableIndices;

        if (this._config.minimumViewTime) {
          var handle = setTimeout(function () {
            _this._timers.delete(handle);

            _this._onUpdateSync(viewableIndices, onViewableItemsChanged, createViewToken);
          }, this._config.minimumViewTime);

          this._timers.add(handle);
        } else {
          this._onUpdateSync(viewableIndices, onViewableItemsChanged, createViewToken);
        }
      }
    }, {
      key: "resetViewableIndices",
      value: function resetViewableIndices() {
        this._viewableIndices = [];
      }
    }, {
      key: "recordInteraction",
      value: function recordInteraction() {
        this._hasInteracted = true;
      }
    }, {
      key: "_onUpdateSync",
      value: function _onUpdateSync(viewableIndicesToCheck, onViewableItemsChanged, createViewToken) {
        var _this2 = this;

        viewableIndicesToCheck = viewableIndicesToCheck.filter(function (ii) {
          return _this2._viewableIndices.includes(ii);
        });
        var prevItems = this._viewableItems;
        var nextItems = new Map(viewableIndicesToCheck.map(function (ii) {
          var viewable = createViewToken(ii, true);
          return [viewable.key, viewable];
        }));
        var changed = [];

        for (var _iterator = nextItems, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
          var _ref4;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref4 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref4 = _i.value;
          }

          var _ref8 = _ref4;

          var _ref3 = _slicedToArray(_ref8, 2);

          var _key2 = _ref3[0];
          var _viewable2 = _ref3[1];

          if (!prevItems.has(_key2)) {
            changed.push(_viewable2);
          }
        }

        for (var _iterator2 = prevItems, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
          var _ref7;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref7 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref7 = _i2.value;
          }

          var _ref9 = _ref7;

          var _ref6 = _slicedToArray(_ref9, 2);

          var _key3 = _ref6[0];
          var _viewable3 = _ref6[1];

          if (!nextItems.has(_key3)) {
            changed.push(_objectSpread({}, _viewable3, {
              isViewable: false
            }));
          }
        }

        if (changed.length > 0) {
          this._viewableItems = nextItems;
          onViewableItemsChanged({
            viewableItems: Array.from(nextItems.values()),
            changed: changed,
            viewabilityConfig: this._config
          });
        }
      }
    }]);

    return ViewabilityHelper;
  }();

  function _isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, itemLength) {
    if (_isEntirelyVisible(top, bottom, viewportHeight)) {
      return true;
    } else {
      var pixels = _getPixelsVisible(top, bottom, viewportHeight);

      var percent = 100 * (viewAreaMode ? pixels / viewportHeight : pixels / itemLength);
      return percent >= viewablePercentThreshold;
    }
  }

  function _getPixelsVisible(top, bottom, viewportHeight) {
    var visibleHeight = Math.min(bottom, viewportHeight) - Math.max(top, 0);
    return Math.max(0, visibleHeight);
  }

  function _isEntirelyVisible(top, bottom, viewportHeight) {
    return top >= 0 && bottom <= viewportHeight && bottom > top;
  }

  module.exports = ViewabilityHelper;
},519,[148,122,24,25,32,117],"node_modules\\react-native\\Libraries\\Lists\\ViewabilityHelper.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _slicedToArray = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/slicedToArray");

  var invariant = _$$_REQUIRE(_dependencyMap[1], "fbjs/lib/invariant");

  function elementsThatOverlapOffsets(offsets, itemCount, getFrameMetrics) {
    var out = [];
    var outLength = 0;

    for (var ii = 0; ii < itemCount; ii++) {
      var frame = getFrameMetrics(ii);
      var trailingOffset = frame.offset + frame.length;

      for (var kk = 0; kk < offsets.length; kk++) {
        if (out[kk] == null && trailingOffset >= offsets[kk]) {
          out[kk] = ii;
          outLength++;

          if (kk === offsets.length - 1) {
            invariant(outLength === offsets.length, 'bad offsets input, should be in increasing order: %s', JSON.stringify(offsets));
            return out;
          }
        }
      }
    }

    return out;
  }

  function newRangeCount(prev, next) {
    return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));
  }

  function computeWindowedRenderLimits(props, prev, getFrameMetricsApprox, scrollMetrics) {
    var data = props.data,
        getItemCount = props.getItemCount,
        maxToRenderPerBatch = props.maxToRenderPerBatch,
        windowSize = props.windowSize;
    var itemCount = getItemCount(data);

    if (itemCount === 0) {
      return prev;
    }

    var offset = scrollMetrics.offset,
        velocity = scrollMetrics.velocity,
        visibleLength = scrollMetrics.visibleLength;
    var visibleBegin = Math.max(0, offset);
    var visibleEnd = visibleBegin + visibleLength;
    var overscanLength = (windowSize - 1) * visibleLength;
    var leadFactor = 0.5;
    var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';
    var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);
    var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);
    var lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;

    if (lastItemOffset < overscanBegin) {
      return {
        first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),
        last: itemCount - 1
      };
    }

    var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props.getItemCount(props.data), getFrameMetricsApprox),
        _elementsThatOverlapO2 = _slicedToArray(_elementsThatOverlapO, 4),
        overscanFirst = _elementsThatOverlapO2[0],
        first = _elementsThatOverlapO2[1],
        last = _elementsThatOverlapO2[2],
        overscanLast = _elementsThatOverlapO2[3];

    overscanFirst = overscanFirst == null ? 0 : overscanFirst;
    first = first == null ? Math.max(0, overscanFirst) : first;
    overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;
    last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;
    var visible = {
      first: first,
      last: last
    };
    var newCellCount = newRangeCount(prev, visible);

    while (true) {
      if (first <= overscanFirst && last >= overscanLast) {
        break;
      }

      var maxNewCells = newCellCount >= maxToRenderPerBatch;
      var firstWillAddMore = first <= prev.first || first > prev.last;
      var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);
      var lastWillAddMore = last >= prev.last || last < prev.first;
      var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);

      if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {
        break;
      }

      if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {
        if (firstWillAddMore) {
          newCellCount++;
        }

        first--;
      }

      if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {
        if (lastWillAddMore) {
          newCellCount++;
        }

        last++;
      }
    }

    if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {
      throw new Error('Bad window calculation ' + JSON.stringify({
        first: first,
        last: last,
        itemCount: itemCount,
        overscanFirst: overscanFirst,
        overscanLast: overscanLast,
        visible: visible
      }));
    }

    return {
      first: first,
      last: last
    };
  }

  var VirtualizeUtils = {
    computeWindowedRenderLimits: computeWindowedRenderLimits,
    elementsThatOverlapOffsets: elementsThatOverlapOffsets,
    newRangeCount: newRangeCount
  };
  module.exports = VirtualizeUtils;
},520,[122,117],"node_modules\\react-native\\Libraries\\Lists\\VirtualizeUtils.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var _regeneratorRuntime = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/regenerator");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectSpread");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Image\\Image.android.js";

  var ImageStylePropTypes = _$$_REQUIRE(_dependencyMap[3], "ImageStylePropTypes");

  var NativeModules = _$$_REQUIRE(_dependencyMap[4], "NativeModules");

  var React = _$$_REQUIRE(_dependencyMap[5], "React");

  var ReactNative = _$$_REQUIRE(_dependencyMap[6], "ReactNative");

  var PropTypes = _$$_REQUIRE(_dependencyMap[7], "prop-types");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[8], "StyleSheet");

  var StyleSheetPropType = _$$_REQUIRE(_dependencyMap[9], "StyleSheetPropType");

  var TextAncestor = _$$_REQUIRE(_dependencyMap[10], "TextAncestor");

  var ViewPropTypes = _$$_REQUIRE(_dependencyMap[11], "ViewPropTypes");

  var flattenStyle = _$$_REQUIRE(_dependencyMap[12], "flattenStyle");

  var merge = _$$_REQUIRE(_dependencyMap[13], "merge");

  var requireNativeComponent = _$$_REQUIRE(_dependencyMap[14], "requireNativeComponent");

  var resolveAssetSource = _$$_REQUIRE(_dependencyMap[15], "resolveAssetSource");

  var ImageLoader = NativeModules.ImageLoader;
  var RKImage = requireNativeComponent('RCTImageView');
  var RCTTextInlineImage = requireNativeComponent('RCTTextInlineImage');
  var _requestId = 1;

  function generateRequestId() {
    return _requestId++;
  }

  var ImageProps = _objectSpread({}, ViewPropTypes, {
    style: StyleSheetPropType(ImageStylePropTypes),
    source: PropTypes.oneOfType([PropTypes.shape({
      uri: PropTypes.string,
      headers: PropTypes.objectOf(PropTypes.string)
    }), PropTypes.number, PropTypes.arrayOf(PropTypes.shape({
      uri: PropTypes.string,
      width: PropTypes.number,
      height: PropTypes.number,
      headers: PropTypes.objectOf(PropTypes.string)
    }))]),
    blurRadius: PropTypes.number,
    defaultSource: PropTypes.number,
    loadingIndicatorSource: PropTypes.oneOfType([PropTypes.shape({
      uri: PropTypes.string
    }), PropTypes.number]),
    progressiveRenderingEnabled: PropTypes.bool,
    fadeDuration: PropTypes.number,
    onLoadStart: PropTypes.func,
    onError: PropTypes.func,
    onLoad: PropTypes.func,
    onLoadEnd: PropTypes.func,
    testID: PropTypes.string,
    resizeMethod: PropTypes.oneOf(['auto', 'resize', 'scale']),
    resizeMode: PropTypes.oneOf(['cover', 'contain', 'stretch', 'repeat', 'center'])
  });

  function getSize(url, success, failure) {
    return ImageLoader.getSize(url).then(function (sizes) {
      success(sizes.width, sizes.height);
    }).catch(failure || function () {
      console.warn('Failed to get size for image: ' + url);
    });
  }

  function prefetch(url, callback) {
    var requestId = generateRequestId();
    callback && callback(requestId);
    return ImageLoader.prefetchImage(url, requestId);
  }

  function abortPrefetch(requestId) {
    ImageLoader.abortRequest(requestId);
  }

  function queryCache(urls) {
    return _regeneratorRuntime.async(function queryCache$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return _regeneratorRuntime.awrap(ImageLoader.queryCache(urls));

          case 2:
            return _context.abrupt("return", _context.sent);

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, null, this);
  }

  var Image = function Image(props, forwardedRef) {
    var _source, _source3;

    var source = resolveAssetSource(props.source);
    var defaultSource = resolveAssetSource(props.defaultSource);
    var loadingIndicatorSource = resolveAssetSource(props.loadingIndicatorSource);

    if (source && source.uri === '') {
      console.warn('source.uri should not be an empty string');
    }

    if (props.src) {
      console.warn('The <Image> component requires a `source` property rather than `src`.');
    }

    if (props.children) {
      throw new Error('The <Image> component cannot contain children. If you want to render content on top of the image, consider using the <ImageBackground> component or absolute positioning.');
    }

    if (props.defaultSource && props.loadingIndicatorSource) {
      throw new Error('The <Image> component cannot have defaultSource and loadingIndicatorSource at the same time. Please use either defaultSource or loadingIndicatorSource.');
    }

    if (source && !source.uri && !Array.isArray(source)) {
      source = null;
    }

    var style;
    var sources;

    if (((_source = source) == null ? void 0 : _source.uri) != null) {
      var _source2 = source,
          _width = _source2.width,
          _height = _source2.height;
      style = flattenStyle([{
        width: _width,
        height: _height
      }, styles.base, props.style]);
      sources = [{
        uri: source.uri
      }];
    } else {
      style = flattenStyle([styles.base, props.style]);
      sources = source;
    }

    var onLoadStart = props.onLoadStart,
        onLoad = props.onLoad,
        onLoadEnd = props.onLoadEnd,
        onError = props.onError;
    var nativeProps = merge(props, {
      style: style,
      shouldNotifyLoadEvents: !!(onLoadStart || onLoad || onLoadEnd || onError),
      src: sources,
      headers: (_source3 = source) == null ? void 0 : _source3.headers,
      defaultSrc: defaultSource ? defaultSource.uri : null,
      loadingIndicatorSrc: loadingIndicatorSource ? loadingIndicatorSource.uri : null,
      ref: forwardedRef
    });
    return React.createElement(TextAncestor.Consumer, {
      __source: {
        fileName: _jsxFileName,
        lineNumber: 250
      }
    }, function (hasTextAncestor) {
      return hasTextAncestor ? React.createElement(RCTTextInlineImage, _extends({}, nativeProps, {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 253
        }
      })) : React.createElement(RKImage, _extends({}, nativeProps, {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 255
        }
      }));
    });
  };

  Image = React.forwardRef(Image);
  Image.getSize = getSize;
  Image.prefetch = prefetch;
  Image.abortPrefetch = abortPrefetch;
  Image.queryCache = queryCache;
  Image.resolveAssetSource = resolveAssetSource;
  Image.propTypes = ImageProps;
  var styles = StyleSheet.create({
    base: {
      overflow: 'hidden'
    }
  });
  module.exports = Image;
},521,[112,105,148,155,119,149,178,161,150,447,176,522,174,440,268,274],"node_modules\\react-native\\Libraries\\Image\\Image.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var React = _$$_REQUIRE(_dependencyMap[1], "React");

  var EdgeInsetsPropType = _$$_REQUIRE(_dependencyMap[2], "EdgeInsetsPropType");

  var PlatformViewPropTypes = _$$_REQUIRE(_dependencyMap[3], "PlatformViewPropTypes");

  var PropTypes = _$$_REQUIRE(_dependencyMap[4], "prop-types");

  var StyleSheetPropType = _$$_REQUIRE(_dependencyMap[5], "StyleSheetPropType");

  var ViewStylePropTypes = _$$_REQUIRE(_dependencyMap[6], "ViewStylePropTypes");

  var _require = _$$_REQUIRE(_dependencyMap[7], "ViewAccessibility"),
      AccessibilityComponentTypes = _require.AccessibilityComponentTypes,
      AccessibilityTraits = _require.AccessibilityTraits,
      AccessibilityRoles = _require.AccessibilityRoles,
      AccessibilityStates = _require.AccessibilityStates;

  var stylePropType = StyleSheetPropType(ViewStylePropTypes);
  module.exports = _objectSpread({
    accessible: PropTypes.bool,
    accessibilityLabel: PropTypes.node,
    accessibilityHint: PropTypes.string,
    accessibilityActions: PropTypes.arrayOf(PropTypes.string),
    accessibilityIgnoresInvertColors: PropTypes.bool,
    accessibilityComponentType: PropTypes.oneOf(AccessibilityComponentTypes),
    accessibilityRole: PropTypes.oneOf(AccessibilityRoles),
    accessibilityStates: PropTypes.arrayOf(PropTypes.oneOf(AccessibilityStates)),
    accessibilityLiveRegion: PropTypes.oneOf(['none', 'polite', 'assertive']),
    importantForAccessibility: PropTypes.oneOf(['auto', 'yes', 'no', 'no-hide-descendants']),
    accessibilityTraits: PropTypes.oneOfType([PropTypes.oneOf(AccessibilityTraits), PropTypes.arrayOf(PropTypes.oneOf(AccessibilityTraits))]),
    accessibilityViewIsModal: PropTypes.bool,
    accessibilityElementsHidden: PropTypes.bool,
    onAccessibilityAction: PropTypes.func,
    onAccessibilityTap: PropTypes.func,
    onMagicTap: PropTypes.func,
    testID: PropTypes.string,
    nativeID: PropTypes.string,
    onResponderGrant: PropTypes.func,
    onResponderMove: PropTypes.func,
    onResponderReject: PropTypes.func,
    onResponderRelease: PropTypes.func,
    onResponderTerminate: PropTypes.func,
    onResponderTerminationRequest: PropTypes.func,
    onStartShouldSetResponder: PropTypes.func,
    onStartShouldSetResponderCapture: PropTypes.func,
    onMoveShouldSetResponder: PropTypes.func,
    onMoveShouldSetResponderCapture: PropTypes.func,
    hitSlop: EdgeInsetsPropType,
    onLayout: PropTypes.func,
    pointerEvents: PropTypes.oneOf(['box-none', 'none', 'box-only', 'auto']),
    style: stylePropType,
    removeClippedSubviews: PropTypes.bool,
    renderToHardwareTextureAndroid: PropTypes.bool,
    shouldRasterizeIOS: PropTypes.bool,
    collapsable: PropTypes.bool,
    needsOffscreenAlphaCompositing: PropTypes.bool
  }, PlatformViewPropTypes);
},522,[148,149,446,523,161,447,168,466],"node_modules\\react-native\\Libraries\\Components\\View\\ViewPropTypes.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Platform = _$$_REQUIRE(_dependencyMap[0], "Platform");

  var TVViewPropTypes = {};

  if (Platform.isTV || Platform.OS === 'android') {
    TVViewPropTypes = _$$_REQUIRE(_dependencyMap[1], "TVViewPropTypes");
  }

  module.exports = TVViewPropTypes;
},523,[146,524],"node_modules\\react-native\\Libraries\\Components\\View\\PlatformViewPropTypes.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var PropTypes = _$$_REQUIRE(_dependencyMap[0], "prop-types");

  var TVViewPropTypes = {
    isTVSelectable: PropTypes.bool,
    hasTVPreferredFocus: PropTypes.bool,
    tvParallaxProperties: PropTypes.object,
    tvParallaxShiftDistanceX: PropTypes.number,
    tvParallaxShiftDistanceY: PropTypes.number,
    tvParallaxTiltAngle: PropTypes.number,
    tvParallaxMagnification: PropTypes.number
  };
  module.exports = TVViewPropTypes;
},524,[161],"node_modules\\react-native\\Libraries\\Components\\AppleTV\\TVViewPropTypes.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/defineProperty");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/objectSpread");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Lists\\SectionList.js";
  var _components = {
    SectionList: {
      displayName: "SectionList"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Lists\\SectionList.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var MetroListView = _$$_REQUIRE(_dependencyMap[12], "MetroListView");

  var Platform = _$$_REQUIRE(_dependencyMap[13], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[14], "React");

  var ScrollView = _$$_REQUIRE(_dependencyMap[15], "ScrollView");

  var VirtualizedSectionList = _$$_REQUIRE(_dependencyMap[16], "VirtualizedSectionList");

  var defaultProps = _objectSpread({}, VirtualizedSectionList.defaultProps, {
    stickySectionHeadersEnabled: Platform.OS === 'ios'
  });

  var SectionList = function (_React$PureComponent) {
    _inherits(SectionList, _React$PureComponent);

    function SectionList() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, SectionList);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SectionList)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "props", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_wrapperListRef", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_captureRef", function (ref) {
        _this._wrapperListRef = ref;
      });

      return _this;
    }

    _createClass(SectionList, [{
      key: "scrollToLocation",
      value: function scrollToLocation(params) {
        this._wrapperListRef.scrollToLocation(params);
      }
    }, {
      key: "recordInteraction",
      value: function recordInteraction() {
        var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

        listRef && listRef.recordInteraction();
      }
    }, {
      key: "flashScrollIndicators",
      value: function flashScrollIndicators() {
        var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

        listRef && listRef.flashScrollIndicators();
      }
    }, {
      key: "getScrollResponder",
      value: function getScrollResponder() {
        var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

        if (listRef) {
          return listRef.getScrollResponder();
        }
      }
    }, {
      key: "getScrollableNode",
      value: function getScrollableNode() {
        var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

        if (listRef) {
          return listRef.getScrollableNode();
        }
      }
    }, {
      key: "setNativeProps",
      value: function setNativeProps(props) {
        var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

        if (listRef) {
          listRef.setNativeProps(props);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var List = this.props.legacyImplementation ? MetroListView : VirtualizedSectionList;
        return React.createElement(List, _extends({}, this.props, {
          ref: this._captureRef,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 332
          }
        }));
      }
    }]);

    return SectionList;
  }(React.PureComponent);

  _defineProperty(SectionList, "defaultProps", defaultProps);

  SectionList = _wrapComponent("SectionList")(SectionList);
  module.exports = SectionList;
},525,[23,112,24,25,26,29,30,28,32,148,109,280,498,146,149,503,526],"node_modules\\react-native\\Libraries\\Lists\\SectionList.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectSpread");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/classCallCheck");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf");

  var _createClass = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Lists\\VirtualizedSectionList.js";
  var _components = {
    VirtualizedSectionList: {
      displayName: "VirtualizedSectionList"
    },
    ItemWithSeparator: {
      displayName: "ItemWithSeparator"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Lists\\VirtualizedSectionList.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var React = _$$_REQUIRE(_dependencyMap[12], "React");

  var View = _$$_REQUIRE(_dependencyMap[13], "View");

  var VirtualizedList = _$$_REQUIRE(_dependencyMap[14], "VirtualizedList");

  var invariant = _$$_REQUIRE(_dependencyMap[15], "fbjs/lib/invariant");

  var VirtualizedSectionList = function (_React$PureComponent) {
    _inherits(VirtualizedSectionList, _React$PureComponent);

    _createClass(VirtualizedSectionList, [{
      key: "scrollToLocation",
      value: function scrollToLocation(params) {
        var index = params.itemIndex + 1;

        for (var ii = 0; ii < params.sectionIndex; ii++) {
          index += this.props.sections[ii].data.length + 2;
        }

        var toIndexParams = _objectSpread({}, params, {
          index: index
        });

        this._listRef.scrollToIndex(toIndexParams);
      }
    }, {
      key: "getListRef",
      value: function getListRef() {
        return this._listRef;
      }
    }]);

    function VirtualizedSectionList(props, context) {
      var _this;

      _classCallCheck(this, VirtualizedSectionList);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(VirtualizedSectionList).call(this, props, context));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_keyExtractor", function (item, index) {
        var info = _this._subExtractor(index);

        return info && info.key || String(index);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_convertViewable", function (viewable) {
        invariant(viewable.index != null, 'Received a broken ViewToken');

        var info = _this._subExtractor(viewable.index);

        if (!info) {
          return null;
        }

        var keyExtractor = info.section.keyExtractor || _this.props.keyExtractor;
        return _objectSpread({}, viewable, {
          index: info.index,
          key: keyExtractor(viewable.item, info.index),
          section: info.section
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onViewableItemsChanged", function (_ref) {
        var viewableItems = _ref.viewableItems,
            changed = _ref.changed;

        if (_this.props.onViewableItemsChanged) {
          _this.props.onViewableItemsChanged({
            viewableItems: viewableItems.map(_this._convertViewable, _assertThisInitialized(_assertThisInitialized(_this))).filter(Boolean),
            changed: changed.map(_this._convertViewable, _assertThisInitialized(_assertThisInitialized(_this))).filter(Boolean)
          });
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_renderItem", function (_ref2) {
        var item = _ref2.item,
            index = _ref2.index;

        var info = _this._subExtractor(index);

        if (!info) {
          return null;
        }

        var infoIndex = info.index;

        if (infoIndex == null) {
          var section = info.section;

          if (info.header === true) {
            var renderSectionHeader = _this.props.renderSectionHeader;
            return renderSectionHeader ? renderSectionHeader({
              section: section
            }) : null;
          } else {
            var renderSectionFooter = _this.props.renderSectionFooter;
            return renderSectionFooter ? renderSectionFooter({
              section: section
            }) : null;
          }
        } else {
          var renderItem = info.section.renderItem || _this.props.renderItem;

          var SeparatorComponent = _this._getSeparatorComponent(index, info);

          invariant(renderItem, 'no renderItem!');
          return React.createElement(ItemWithSeparator, {
            SeparatorComponent: SeparatorComponent,
            LeadingSeparatorComponent: infoIndex === 0 ? _this.props.SectionSeparatorComponent : undefined,
            cellKey: info.key,
            index: infoIndex,
            item: item,
            leadingItem: info.leadingItem,
            leadingSection: info.leadingSection,
            onUpdateSeparator: _this._onUpdateSeparator,
            prevCellKey: (_this._subExtractor(index - 1) || {}).key,
            ref: function ref(_ref3) {
              _this._cellRefs[info.key] = _ref3;
            },
            renderItem: renderItem,
            section: info.section,
            trailingItem: info.trailingItem,
            trailingSection: info.trailingSection,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 316
            }
          });
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onUpdateSeparator", function (key, newProps) {
        var ref = _this._cellRefs[key];
        ref && ref.updateSeparatorProps(newProps);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_cellRefs", {});

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_listRef", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_captureRef", function (ref) {
        _this._listRef = ref;
      });

      _this.state = _this._computeState(props);
      return _this;
    }

    _createClass(VirtualizedSectionList, [{
      key: "UNSAFE_componentWillReceiveProps",
      value: function UNSAFE_componentWillReceiveProps(nextProps) {
        this.setState(this._computeState(nextProps));
      }
    }, {
      key: "_computeState",
      value: function _computeState(props) {
        var offset = props.ListHeaderComponent ? 1 : 0;
        var stickyHeaderIndices = [];
        var itemCount = props.sections.reduce(function (v, section) {
          stickyHeaderIndices.push(v + offset);
          return v + section.data.length + 2;
        }, 0);
        return {
          childProps: _objectSpread({}, props, {
            renderItem: this._renderItem,
            ItemSeparatorComponent: undefined,
            data: props.sections,
            getItemCount: function getItemCount() {
              return itemCount;
            },
            getItem: getItem,
            keyExtractor: this._keyExtractor,
            onViewableItemsChanged: props.onViewableItemsChanged ? this._onViewableItemsChanged : undefined,
            stickyHeaderIndices: props.stickySectionHeadersEnabled ? stickyHeaderIndices : undefined
          })
        };
      }
    }, {
      key: "render",
      value: function render() {
        return React.createElement(VirtualizedList, _extends({}, this.state.childProps, {
          ref: this._captureRef,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 201
          }
        }));
      }
    }, {
      key: "_subExtractor",
      value: function _subExtractor(index) {
        var itemIndex = index;
        var defaultKeyExtractor = this.props.keyExtractor;

        for (var ii = 0; ii < this.props.sections.length; ii++) {
          var section = this.props.sections[ii];
          var key = section.key || String(ii);
          itemIndex -= 1;

          if (itemIndex >= section.data.length + 1) {
            itemIndex -= section.data.length + 1;
          } else if (itemIndex === -1) {
            return {
              section: section,
              key: key + ':header',
              index: null,
              header: true,
              trailingSection: this.props.sections[ii + 1]
            };
          } else if (itemIndex === section.data.length) {
            return {
              section: section,
              key: key + ':footer',
              index: null,
              header: false,
              trailingSection: this.props.sections[ii + 1]
            };
          } else {
            var keyExtractor = section.keyExtractor || defaultKeyExtractor;
            return {
              section: section,
              key: key + ':' + keyExtractor(section.data[itemIndex], itemIndex),
              index: itemIndex,
              leadingItem: section.data[itemIndex - 1],
              leadingSection: this.props.sections[ii - 1],
              trailingItem: section.data[itemIndex + 1],
              trailingSection: this.props.sections[ii + 1]
            };
          }
        }
      }
    }, {
      key: "_getSeparatorComponent",
      value: function _getSeparatorComponent(index, info) {
        info = info || this._subExtractor(index);

        if (!info) {
          return null;
        }

        var ItemSeparatorComponent = info.section.ItemSeparatorComponent || this.props.ItemSeparatorComponent;
        var SectionSeparatorComponent = this.props.SectionSeparatorComponent;
        var isLastItemInList = index === this.state.childProps.getItemCount() - 1;
        var isLastItemInSection = info.index === info.section.data.length - 1;

        if (SectionSeparatorComponent && isLastItemInSection) {
          return SectionSeparatorComponent;
        }

        if (ItemSeparatorComponent && !isLastItemInSection && !isLastItemInList) {
          return ItemSeparatorComponent;
        }

        return null;
      }
    }]);

    return VirtualizedSectionList;
  }(React.PureComponent);

  _defineProperty(VirtualizedSectionList, "defaultProps", _objectSpread({}, VirtualizedList.defaultProps, {
    data: []
  }));

  VirtualizedSectionList = _wrapComponent("VirtualizedSectionList")(VirtualizedSectionList);

  var ItemWithSeparator = function (_React$Component) {
    _inherits(ItemWithSeparator, _React$Component);

    function ItemWithSeparator() {
      var _getPrototypeOf2;

      var _this2;

      _classCallCheck(this, ItemWithSeparator);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this2 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ItemWithSeparator)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "state", {
        separatorProps: {
          highlighted: false,
          leadingItem: _this2.props.item,
          leadingSection: _this2.props.leadingSection,
          section: _this2.props.section,
          trailingItem: _this2.props.trailingItem,
          trailingSection: _this2.props.trailingSection
        },
        leadingSeparatorProps: {
          highlighted: false,
          leadingItem: _this2.props.leadingItem,
          leadingSection: _this2.props.leadingSection,
          section: _this2.props.section,
          trailingItem: _this2.props.item,
          trailingSection: _this2.props.trailingSection
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_separators", {
        highlight: function highlight() {
          ['leading', 'trailing'].forEach(function (s) {
            return _this2._separators.updateProps(s, {
              highlighted: true
            });
          });
        },
        unhighlight: function unhighlight() {
          ['leading', 'trailing'].forEach(function (s) {
            return _this2._separators.updateProps(s, {
              highlighted: false
            });
          });
        },
        updateProps: function updateProps(select, newProps) {
          var _this2$props = _this2.props,
              LeadingSeparatorComponent = _this2$props.LeadingSeparatorComponent,
              cellKey = _this2$props.cellKey,
              prevCellKey = _this2$props.prevCellKey;

          if (select === 'leading' && LeadingSeparatorComponent != null) {
            _this2.setState(function (state) {
              return {
                leadingSeparatorProps: _objectSpread({}, state.leadingSeparatorProps, newProps)
              };
            });
          } else {
            _this2.props.onUpdateSeparator(select === 'leading' && prevCellKey || cellKey, newProps);
          }
        }
      });

      return _this2;
    }

    _createClass(ItemWithSeparator, [{
      key: "updateSeparatorProps",
      value: function updateSeparatorProps(newProps) {
        this.setState(function (state) {
          return {
            separatorProps: _objectSpread({}, state.separatorProps, newProps)
          };
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
            LeadingSeparatorComponent = _this$props.LeadingSeparatorComponent,
            SeparatorComponent = _this$props.SeparatorComponent,
            item = _this$props.item,
            index = _this$props.index,
            section = _this$props.section;
        var element = this.props.renderItem({
          item: item,
          index: index,
          section: section,
          separators: this._separators
        });
        var leadingSeparator = LeadingSeparatorComponent && React.createElement(LeadingSeparatorComponent, _extends({}, this.state.leadingSeparatorProps, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 502
          }
        }));
        var separator = SeparatorComponent && React.createElement(SeparatorComponent, _extends({}, this.state.separatorProps, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 505
          }
        }));
        return leadingSeparator || separator ? React.createElement(View, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 508
          }
        }, leadingSeparator, element, separator) : element;
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(props, prevState) {
        return {
          separatorProps: _objectSpread({}, prevState.separatorProps, {
            leadingItem: props.item,
            leadingSection: props.leadingSection,
            section: props.section,
            trailingItem: props.trailingItem,
            trailingSection: props.trailingSection
          }),
          leadingSeparatorProps: _objectSpread({}, prevState.leadingSeparatorProps, {
            leadingItem: props.leadingItem,
            leadingSection: props.leadingSection,
            section: props.section,
            trailingItem: props.item,
            trailingSection: props.trailingSection
          })
        };
      }
    }]);

    return ItemWithSeparator;
  }(React.Component);

  ItemWithSeparator = _wrapComponent("ItemWithSeparator")(ItemWithSeparator);

  function getItem(sections, index) {
    if (!sections) {
      return null;
    }

    var itemIdx = index - 1;

    for (var ii = 0; ii < sections.length; ii++) {
      if (itemIdx === -1 || itemIdx === sections[ii].data.length) {
        return sections[ii];
      } else if (itemIdx < sections[ii].data.length) {
        return sections[ii].data[itemIdx];
      } else {
        itemIdx -= sections[ii].data.length + 2;
      }
    }

    return null;
  }

  module.exports = VirtualizedSectionList;
},526,[23,112,148,24,26,29,25,30,28,32,109,280,149,175,516,117],"node_modules\\react-native\\Libraries\\Lists\\VirtualizedSectionList.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _require = _$$_REQUIRE(_dependencyMap[0], "ReactNative"),
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _require.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  var NativeMethodsMixin = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.NativeMethodsMixin;
  module.exports = NativeMethodsMixin;
},527,[178],"node_modules\\react-native\\Libraries\\Renderer\\shims\\NativeMethodsMixin.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\CheckBox\\CheckBox.android.js";

  var NativeMethodsMixin = _$$_REQUIRE(_dependencyMap[2], "NativeMethodsMixin");

  var PropTypes = _$$_REQUIRE(_dependencyMap[3], "prop-types");

  var React = _$$_REQUIRE(_dependencyMap[4], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[5], "StyleSheet");

  var ViewPropTypes = _$$_REQUIRE(_dependencyMap[6], "ViewPropTypes");

  var createReactClass = _$$_REQUIRE(_dependencyMap[7], "create-react-class");

  var requireNativeComponent = _$$_REQUIRE(_dependencyMap[8], "requireNativeComponent");

  var RCTCheckBox = requireNativeComponent('AndroidCheckBox');
  var CheckBox = createReactClass({
    displayName: 'CheckBox',
    propTypes: _objectSpread({}, ViewPropTypes, {
      value: PropTypes.bool,
      disabled: PropTypes.bool,
      onChange: PropTypes.func,
      onValueChange: PropTypes.func,
      testID: PropTypes.string
    }),
    getDefaultProps: function getDefaultProps() {
      return {
        value: false,
        disabled: false
      };
    },
    mixins: [NativeMethodsMixin],
    _rctCheckBox: {},
    _onChange: function _onChange(event) {
      this._rctCheckBox.setNativeProps({
        value: this.props.value
      });

      this.props.onChange && this.props.onChange(event);
      this.props.onValueChange && this.props.onValueChange(event.nativeEvent.value);
    },
    render: function render() {
      var _this = this;

      var props = _objectSpread({}, this.props);

      props.onStartShouldSetResponder = function () {
        return true;
      };

      props.onResponderTerminationRequest = function () {
        return false;
      };

      props.enabled = !this.props.disabled;
      props.on = this.props.value;
      props.style = [styles.rctCheckBox, this.props.style];
      return React.createElement(RCTCheckBox, _extends({}, props, {
        ref: function ref(_ref) {
          _this._rctCheckBox = _ref;
        },
        onChange: this._onChange,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 143
        }
      }));
    }
  });
  var styles = StyleSheet.create({
    rctCheckBox: {
      height: 32,
      width: 32
    }
  });
  module.exports = CheckBox;
},528,[112,148,527,161,149,150,522,459,268],"node_modules\\react-native\\Libraries\\Components\\CheckBox\\CheckBox.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\DatePicker\\DatePickerIOS.android.js";
  var _components = {
    DummyDatePickerIOS: {
      displayName: "DummyDatePickerIOS"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\DatePicker\\DatePickerIOS.android.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var React = _$$_REQUIRE(_dependencyMap[8], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[9], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[10], "Text");

  var View = _$$_REQUIRE(_dependencyMap[11], "View");

  var DummyDatePickerIOS = function (_React$Component) {
    _inherits(DummyDatePickerIOS, _React$Component);

    function DummyDatePickerIOS() {
      _classCallCheck(this, DummyDatePickerIOS);

      return _possibleConstructorReturn(this, _getPrototypeOf(DummyDatePickerIOS).apply(this, arguments));
    }

    _createClass(DummyDatePickerIOS, [{
      key: "render",
      value: function render() {
        return React.createElement(View, {
          style: [styles.dummyDatePickerIOS, this.props.style],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 20
          }
        }, React.createElement(Text, {
          style: styles.datePickerText,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 21
          }
        }, "DatePickerIOS is not supported on this platform!"));
      }
    }]);

    return DummyDatePickerIOS;
  }(React.Component);

  DummyDatePickerIOS = _wrapComponent("DummyDatePickerIOS")(DummyDatePickerIOS);
  var styles = StyleSheet.create({
    dummyDatePickerIOS: {
      height: 100,
      width: 300,
      backgroundColor: '#ffbcbc',
      borderWidth: 1,
      borderColor: 'red',
      alignItems: 'center',
      justifyContent: 'center',
      margin: 10
    },
    datePickerText: {
      color: '#333333',
      margin: 20
    }
  });
  module.exports = DummyDatePickerIOS;
},529,[23,24,25,26,29,30,109,280,149,150,444,175],"node_modules\\react-native\\Libraries\\Components\\DatePicker\\DatePickerIOS.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\DrawerAndroid\\DrawerLayoutAndroid.android.js";

  var ColorPropType = _$$_REQUIRE(_dependencyMap[2], "ColorPropType");

  var NativeMethodsMixin = _$$_REQUIRE(_dependencyMap[3], "NativeMethodsMixin");

  var Platform = _$$_REQUIRE(_dependencyMap[4], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[5], "React");

  var PropTypes = _$$_REQUIRE(_dependencyMap[6], "prop-types");

  var ReactNative = _$$_REQUIRE(_dependencyMap[7], "ReactNative");

  var StatusBar = _$$_REQUIRE(_dependencyMap[8], "StatusBar");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[9], "StyleSheet");

  var UIManager = _$$_REQUIRE(_dependencyMap[10], "UIManager");

  var View = _$$_REQUIRE(_dependencyMap[11], "View");

  var ViewPropTypes = _$$_REQUIRE(_dependencyMap[12], "ViewPropTypes");

  var DrawerConsts = UIManager.AndroidDrawerLayout.Constants;

  var createReactClass = _$$_REQUIRE(_dependencyMap[13], "create-react-class");

  var dismissKeyboard = _$$_REQUIRE(_dependencyMap[14], "dismissKeyboard");

  var requireNativeComponent = _$$_REQUIRE(_dependencyMap[15], "requireNativeComponent");

  var RK_DRAWER_REF = 'drawerlayout';
  var INNERVIEW_REF = 'innerView';
  var DRAWER_STATES = ['Idle', 'Dragging', 'Settling'];
  var DrawerLayoutAndroid = createReactClass({
    displayName: 'DrawerLayoutAndroid',
    statics: {
      positions: DrawerConsts.DrawerPosition
    },
    propTypes: _objectSpread({}, ViewPropTypes, {
      keyboardDismissMode: PropTypes.oneOf(['none', 'on-drag']),
      drawerBackgroundColor: ColorPropType,
      drawerPosition: PropTypes.oneOf([DrawerConsts.DrawerPosition.Left, DrawerConsts.DrawerPosition.Right]),
      drawerWidth: PropTypes.number,
      drawerLockMode: PropTypes.oneOf(['unlocked', 'locked-closed', 'locked-open']),
      onDrawerSlide: PropTypes.func,
      onDrawerStateChanged: PropTypes.func,
      onDrawerOpen: PropTypes.func,
      onDrawerClose: PropTypes.func,
      renderNavigationView: PropTypes.func.isRequired,
      statusBarBackgroundColor: ColorPropType
    }),
    mixins: [NativeMethodsMixin],
    getDefaultProps: function getDefaultProps() {
      return {
        drawerBackgroundColor: 'white'
      };
    },
    getInitialState: function getInitialState() {
      return {
        statusBarBackgroundColor: undefined
      };
    },
    getInnerViewNode: function getInnerViewNode() {
      return this.refs[INNERVIEW_REF].getInnerViewNode();
    },
    render: function render() {
      var drawStatusBar = Platform.Version >= 21 && this.props.statusBarBackgroundColor;
      var drawerViewWrapper = React.createElement(View, {
        style: [styles.drawerSubview, {
          width: this.props.drawerWidth,
          backgroundColor: this.props.drawerBackgroundColor
        }],
        collapsable: false,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 172
        }
      }, this.props.renderNavigationView(), drawStatusBar && React.createElement(View, {
        style: styles.drawerStatusBar,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 182
        }
      }));
      var childrenWrapper = React.createElement(View, {
        ref: INNERVIEW_REF,
        style: styles.mainSubview,
        collapsable: false,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 186
        }
      }, drawStatusBar && React.createElement(StatusBar, {
        translucent: true,
        backgroundColor: this.props.statusBarBackgroundColor,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 188
        }
      }), drawStatusBar && React.createElement(View, {
        style: [styles.statusBar, {
          backgroundColor: this.props.statusBarBackgroundColor
        }],
        __source: {
          fileName: _jsxFileName,
          lineNumber: 194
        }
      }), this.props.children);
      return React.createElement(AndroidDrawerLayout, _extends({}, this.props, {
        ref: RK_DRAWER_REF,
        drawerWidth: this.props.drawerWidth,
        drawerPosition: this.props.drawerPosition,
        drawerLockMode: this.props.drawerLockMode,
        style: [styles.base, this.props.style],
        onDrawerSlide: this._onDrawerSlide,
        onDrawerOpen: this._onDrawerOpen,
        onDrawerClose: this._onDrawerClose,
        onDrawerStateChanged: this._onDrawerStateChanged,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 205
        }
      }), childrenWrapper, drawerViewWrapper);
    },
    _onDrawerSlide: function _onDrawerSlide(event) {
      if (this.props.onDrawerSlide) {
        this.props.onDrawerSlide(event);
      }

      if (this.props.keyboardDismissMode === 'on-drag') {
        dismissKeyboard();
      }
    },
    _onDrawerOpen: function _onDrawerOpen() {
      if (this.props.onDrawerOpen) {
        this.props.onDrawerOpen();
      }
    },
    _onDrawerClose: function _onDrawerClose() {
      if (this.props.onDrawerClose) {
        this.props.onDrawerClose();
      }
    },
    _onDrawerStateChanged: function _onDrawerStateChanged(event) {
      if (this.props.onDrawerStateChanged) {
        this.props.onDrawerStateChanged(DRAWER_STATES[event.nativeEvent.drawerState]);
      }
    },
    openDrawer: function openDrawer() {
      UIManager.dispatchViewManagerCommand(this._getDrawerLayoutHandle(), UIManager.AndroidDrawerLayout.Commands.openDrawer, null);
    },
    closeDrawer: function closeDrawer() {
      UIManager.dispatchViewManagerCommand(this._getDrawerLayoutHandle(), UIManager.AndroidDrawerLayout.Commands.closeDrawer, null);
    },
    _getDrawerLayoutHandle: function _getDrawerLayoutHandle() {
      return ReactNative.findNodeHandle(this.refs[RK_DRAWER_REF]);
    }
  });
  var styles = StyleSheet.create({
    base: {
      flex: 1,
      elevation: 16
    },
    mainSubview: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    },
    drawerSubview: {
      position: 'absolute',
      top: 0,
      bottom: 0
    },
    statusBar: {
      height: StatusBar.currentHeight
    },
    drawerStatusBar: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      height: StatusBar.currentHeight,
      backgroundColor: 'rgba(0, 0, 0, 0.251)'
    }
  });
  var AndroidDrawerLayout = requireNativeComponent('AndroidDrawerLayout');
  module.exports = DrawerLayoutAndroid;
},530,[112,148,156,527,146,149,161,178,531,150,145,175,522,459,508,268],"node_modules\\react-native\\Libraries\\Components\\DrawerAndroid\\DrawerLayoutAndroid.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var _extends = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/extends");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _components = {
    StatusBar: {
      displayName: "StatusBar"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\StatusBar\\StatusBar.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var React = _$$_REQUIRE(_dependencyMap[11], "React");

  var PropTypes = _$$_REQUIRE(_dependencyMap[12], "prop-types");

  var ColorPropType = _$$_REQUIRE(_dependencyMap[13], "ColorPropType");

  var Platform = _$$_REQUIRE(_dependencyMap[14], "Platform");

  var processColor = _$$_REQUIRE(_dependencyMap[15], "processColor");

  var StatusBarManager = _$$_REQUIRE(_dependencyMap[16], "NativeModules").StatusBarManager;

  function mergePropsStack(propsStack, defaultValues) {
    return propsStack.reduce(function (prev, cur) {
      for (var prop in cur) {
        if (cur[prop] != null) {
          prev[prop] = cur[prop];
        }
      }

      return prev;
    }, _extends({}, defaultValues));
  }

  function createStackEntry(props) {
    return {
      backgroundColor: props.backgroundColor != null ? {
        value: props.backgroundColor,
        animated: props.animated
      } : null,
      barStyle: props.barStyle != null ? {
        value: props.barStyle,
        animated: props.animated
      } : null,
      translucent: props.translucent,
      hidden: props.hidden != null ? {
        value: props.hidden,
        animated: props.animated,
        transition: props.showHideTransition
      } : null,
      networkActivityIndicatorVisible: props.networkActivityIndicatorVisible
    };
  }

  var StatusBar = function (_React$Component) {
    _inherits(StatusBar, _React$Component);

    function StatusBar() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, StatusBar);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(StatusBar)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_stackEntry", null);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_updatePropsStack", function () {
        clearImmediate(StatusBar._updateImmediate);
        StatusBar._updateImmediate = setImmediate(function () {
          var oldProps = StatusBar._currentValues;
          var mergedProps = mergePropsStack(StatusBar._propsStack, StatusBar._defaultProps);

          if (Platform.OS === 'ios') {
            if (!oldProps || oldProps.barStyle.value !== mergedProps.barStyle.value) {
              StatusBarManager.setStyle(mergedProps.barStyle.value, mergedProps.barStyle.animated);
            }

            if (!oldProps || oldProps.hidden.value !== mergedProps.hidden.value) {
              StatusBarManager.setHidden(mergedProps.hidden.value, mergedProps.hidden.animated ? mergedProps.hidden.transition : 'none');
            }

            if (!oldProps || oldProps.networkActivityIndicatorVisible !== mergedProps.networkActivityIndicatorVisible) {
              StatusBarManager.setNetworkActivityIndicatorVisible(mergedProps.networkActivityIndicatorVisible);
            }
          } else if (Platform.OS === 'android') {
            if (!oldProps || oldProps.barStyle.value !== mergedProps.barStyle.value) {
              StatusBarManager.setStyle(mergedProps.barStyle.value);
            }

            if (!oldProps || oldProps.backgroundColor.value !== mergedProps.backgroundColor.value) {
              StatusBarManager.setColor(processColor(mergedProps.backgroundColor.value), mergedProps.backgroundColor.animated);
            }

            if (!oldProps || oldProps.hidden.value !== mergedProps.hidden.value) {
              StatusBarManager.setHidden(mergedProps.hidden.value);
            }

            if (!oldProps || oldProps.translucent !== mergedProps.translucent) {
              StatusBarManager.setTranslucent(mergedProps.translucent);
            }
          }

          StatusBar._currentValues = mergedProps;
        });
      });

      return _this;
    }

    _createClass(StatusBar, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this._stackEntry = createStackEntry(this.props);

        StatusBar._propsStack.push(this._stackEntry);

        this._updatePropsStack();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var index = StatusBar._propsStack.indexOf(this._stackEntry);

        StatusBar._propsStack.splice(index, 1);

        this._updatePropsStack();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var index = StatusBar._propsStack.indexOf(this._stackEntry);

        this._stackEntry = createStackEntry(this.props);
        StatusBar._propsStack[index] = this._stackEntry;

        this._updatePropsStack();
      }
    }, {
      key: "render",
      value: function render() {
        return null;
      }
    }], [{
      key: "setHidden",
      value: function setHidden(hidden, animation) {
        animation = animation || 'none';
        StatusBar._defaultProps.hidden.value = hidden;

        if (Platform.OS === 'ios') {
          StatusBarManager.setHidden(hidden, animation);
        } else if (Platform.OS === 'android') {
          StatusBarManager.setHidden(hidden);
        }
      }
    }, {
      key: "setBarStyle",
      value: function setBarStyle(style, animated) {
        animated = animated || false;
        StatusBar._defaultProps.barStyle.value = style;

        if (Platform.OS === 'ios') {
          StatusBarManager.setStyle(style, animated);
        } else if (Platform.OS === 'android') {
          StatusBarManager.setStyle(style);
        }
      }
    }, {
      key: "setNetworkActivityIndicatorVisible",
      value: function setNetworkActivityIndicatorVisible(visible) {
        if (Platform.OS !== 'ios') {
          console.warn('`setNetworkActivityIndicatorVisible` is only available on iOS');
          return;
        }

        StatusBar._defaultProps.networkActivityIndicatorVisible = visible;
        StatusBarManager.setNetworkActivityIndicatorVisible(visible);
      }
    }, {
      key: "setBackgroundColor",
      value: function setBackgroundColor(color, animated) {
        if (Platform.OS !== 'android') {
          console.warn('`setBackgroundColor` is only available on Android');
          return;
        }

        animated = animated || false;
        StatusBar._defaultProps.backgroundColor.value = color;
        StatusBarManager.setColor(processColor(color), animated);
      }
    }, {
      key: "setTranslucent",
      value: function setTranslucent(translucent) {
        if (Platform.OS !== 'android') {
          console.warn('`setTranslucent` is only available on Android');
          return;
        }

        StatusBar._defaultProps.translucent = translucent;
        StatusBarManager.setTranslucent(translucent);
      }
    }]);

    return StatusBar;
  }(React.Component);

  _defineProperty(StatusBar, "_propsStack", []);

  _defineProperty(StatusBar, "_defaultProps", createStackEntry({
    animated: false,
    showHideTransition: 'fade',
    backgroundColor: 'black',
    barStyle: 'default',
    translucent: false,
    hidden: false,
    networkActivityIndicatorVisible: false
  }));

  _defineProperty(StatusBar, "_updateImmediate", null);

  _defineProperty(StatusBar, "_currentValues", null);

  _defineProperty(StatusBar, "currentHeight", StatusBarManager.HEIGHT);

  _defineProperty(StatusBar, "propTypes", {
    hidden: PropTypes.bool,
    animated: PropTypes.bool,
    backgroundColor: ColorPropType,
    translucent: PropTypes.bool,
    barStyle: PropTypes.oneOf(['default', 'light-content', 'dark-content']),
    networkActivityIndicatorVisible: PropTypes.bool,
    showHideTransition: PropTypes.oneOf(['fade', 'slide'])
  });

  _defineProperty(StatusBar, "defaultProps", {
    animated: false,
    showHideTransition: 'fade'
  });

  StatusBar = _wrapComponent("StatusBar")(StatusBar);
  module.exports = StatusBar;
},531,[23,24,25,26,29,30,28,32,112,109,280,149,161,156,146,169,119],"node_modules\\react-native\\Libraries\\Components\\StatusBar\\StatusBar.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var _objectWithoutProperties = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutProperties");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Image\\ImageBackground.js";
  var _components = {
    ImageBackground: {
      displayName: "ImageBackground"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Image\\ImageBackground.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var Image = _$$_REQUIRE(_dependencyMap[12], "Image");

  var React = _$$_REQUIRE(_dependencyMap[13], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[14], "StyleSheet");

  var View = _$$_REQUIRE(_dependencyMap[15], "View");

  var ensureComponentIsNative = _$$_REQUIRE(_dependencyMap[16], "ensureComponentIsNative");

  var ImageBackground = function (_React$Component) {
    _inherits(ImageBackground, _React$Component);

    function ImageBackground() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, ImageBackground);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ImageBackground)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_viewRef", null);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_captureRef", function (ref) {
        _this._viewRef = ref;
      });

      return _this;
    }

    _createClass(ImageBackground, [{
      key: "setNativeProps",
      value: function setNativeProps(props) {
        var viewRef = this._viewRef;

        if (viewRef) {
          ensureComponentIsNative(viewRef);
          viewRef.setNativeProps(props);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
            children = _this$props.children,
            style = _this$props.style,
            imageStyle = _this$props.imageStyle,
            imageRef = _this$props.imageRef,
            props = _objectWithoutProperties(_this$props, ["children", "style", "imageStyle", "imageRef"]);

        return React.createElement(View, {
          accessibilityIgnoresInvertColors: true,
          style: style,
          ref: this._captureRef,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 63
          }
        }, React.createElement(Image, _extends({}, props, {
          style: [StyleSheet.absoluteFill, {
            width: style.width,
            height: style.height
          }, imageStyle],
          ref: imageRef,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 67
          }
        })), children);
      }
    }]);

    return ImageBackground;
  }(React.Component);

  ImageBackground = _wrapComponent("ImageBackground")(ImageBackground);
  module.exports = ImageBackground;
},532,[23,112,120,24,25,26,29,30,28,32,109,280,521,149,150,175,533],"node_modules\\react-native\\Libraries\\Image\\ImageBackground.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var invariant = _$$_REQUIRE(_dependencyMap[0], "fbjs/lib/invariant");

  var ensureComponentIsNative = function ensureComponentIsNative(component) {
    invariant(component && typeof component.setNativeProps === 'function', 'Touchable child must either be native or forward setNativeProps to a ' + 'native component');
  };

  module.exports = ensureComponentIsNative;
},533,[117],"node_modules\\react-native\\Libraries\\Components\\Touchable\\ensureComponentIsNative.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var RCTImageEditingManager = _$$_REQUIRE(_dependencyMap[2], "NativeModules").ImageEditingManager;

  var ImageEditor = function () {
    function ImageEditor() {
      _classCallCheck(this, ImageEditor);
    }

    _createClass(ImageEditor, null, [{
      key: "cropImage",
      value: function cropImage(uri, cropData, success, failure) {
        RCTImageEditingManager.cropImage(uri, cropData, success, failure);
      }
    }]);

    return ImageEditor;
  }();

  module.exports = ImageEditor;
},534,[24,25,119],"node_modules\\react-native\\Libraries\\Image\\ImageEditor.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var RCTImageStoreManager = _$$_REQUIRE(_dependencyMap[2], "NativeModules").ImageStoreManager;

  var ImageStore = function () {
    function ImageStore() {
      _classCallCheck(this, ImageStore);
    }

    _createClass(ImageStore, null, [{
      key: "hasImageForTag",
      value: function hasImageForTag(uri, callback) {
        if (RCTImageStoreManager.hasImageForTag) {
          RCTImageStoreManager.hasImageForTag(uri, callback);
        } else {
          console.warn('hasImageForTag() not implemented');
        }
      }
    }, {
      key: "removeImageForTag",
      value: function removeImageForTag(uri) {
        if (RCTImageStoreManager.removeImageForTag) {
          RCTImageStoreManager.removeImageForTag(uri);
        } else {
          console.warn('removeImageForTag() not implemented');
        }
      }
    }, {
      key: "addImageFromBase64",
      value: function addImageFromBase64(base64ImageData, success, failure) {
        RCTImageStoreManager.addImageFromBase64(base64ImageData, success, failure);
      }
    }, {
      key: "getBase64ForTag",
      value: function getBase64ForTag(uri, success, failure) {
        RCTImageStoreManager.getBase64ForTag(uri, success, failure);
      }
    }]);

    return ImageStore;
  }();

  module.exports = ImageStore;
},535,[24,25,119],"node_modules\\react-native\\Libraries\\Image\\ImageStore.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\TextInput\\InputAccessoryView.js";
  var _components = {
    InputAccessoryView: {
      displayName: "InputAccessoryView"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\TextInput\\InputAccessoryView.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var ColorPropType = _$$_REQUIRE(_dependencyMap[8], "ColorPropType");

  var React = _$$_REQUIRE(_dependencyMap[9], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[10], "StyleSheet");

  var ViewPropTypes = _$$_REQUIRE(_dependencyMap[11], "ViewPropTypes");

  var requireNativeComponent = _$$_REQUIRE(_dependencyMap[12], "requireNativeComponent");

  var RCTInputAccessoryView = requireNativeComponent('RCTInputAccessoryView');

  var InputAccessoryView = function (_React$Component) {
    _inherits(InputAccessoryView, _React$Component);

    function InputAccessoryView() {
      _classCallCheck(this, InputAccessoryView);

      return _possibleConstructorReturn(this, _getPrototypeOf(InputAccessoryView).apply(this, arguments));
    }

    _createClass(InputAccessoryView, [{
      key: "render",
      value: function render() {
        console.warn('<InputAccessoryView> is not supported on Android yet.');

        if (React.Children.count(this.props.children) === 0) {
          return null;
        }

        return React.createElement(RCTInputAccessoryView, {
          style: [this.props.style, styles.container],
          nativeID: this.props.nativeID,
          backgroundColor: this.props.backgroundColor,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 99
          }
        }, this.props.children);
      }
    }]);

    return InputAccessoryView;
  }(React.Component);

  InputAccessoryView = _wrapComponent("InputAccessoryView")(InputAccessoryView);
  var styles = StyleSheet.create({
    container: {
      position: 'absolute'
    }
  });
  module.exports = InputAccessoryView;
},536,[23,24,25,26,29,30,109,280,156,149,150,522,268],"node_modules\\react-native\\Libraries\\Components\\TextInput\\InputAccessoryView.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var _objectWithoutProperties = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutProperties");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\Keyboard\\KeyboardAvoidingView.js";
  var _components = {
    KeyboardAvoidingView: {
      displayName: "KeyboardAvoidingView"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\Keyboard\\KeyboardAvoidingView.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var Keyboard = _$$_REQUIRE(_dependencyMap[12], "Keyboard");

  var LayoutAnimation = _$$_REQUIRE(_dependencyMap[13], "LayoutAnimation");

  var Platform = _$$_REQUIRE(_dependencyMap[14], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[15], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[16], "StyleSheet");

  var View = _$$_REQUIRE(_dependencyMap[17], "View");

  var viewRef = 'VIEW';

  var KeyboardAvoidingView = function (_React$Component) {
    _inherits(KeyboardAvoidingView, _React$Component);

    function KeyboardAvoidingView() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, KeyboardAvoidingView);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(KeyboardAvoidingView)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_frame", null);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_subscriptions", []);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
        bottom: 0
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onKeyboardChange", function (event) {
        if (event == null) {
          _this.setState({
            bottom: 0
          });

          return;
        }

        var duration = event.duration,
            easing = event.easing,
            endCoordinates = event.endCoordinates;

        var height = _this._relativeKeyboardHeight(endCoordinates);

        if (_this.state.bottom === height) {
          return;
        }

        if (duration && easing) {
          LayoutAnimation.configureNext({
            duration: duration,
            update: {
              duration: duration,
              type: LayoutAnimation.Types[easing] || 'keyboard'
            }
          });
        }

        _this.setState({
          bottom: height
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onLayout", function (event) {
        _this._frame = event.nativeEvent.layout;
      });

      return _this;
    }

    _createClass(KeyboardAvoidingView, [{
      key: "_relativeKeyboardHeight",
      value: function _relativeKeyboardHeight(keyboardFrame) {
        var frame = this._frame;

        if (!frame || !keyboardFrame) {
          return 0;
        }

        var keyboardY = keyboardFrame.screenY - this.props.keyboardVerticalOffset;
        return Math.max(frame.y + frame.height - keyboardY, 0);
      }
    }, {
      key: "UNSAFE_componentWillUpdate",
      value: function UNSAFE_componentWillUpdate(nextProps, nextState) {
        if (nextState.bottom === this.state.bottom && this.props.behavior === 'height' && nextProps.behavior === 'height') {
          nextState.bottom = 0;
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        if (Platform.OS === 'ios') {
          this._subscriptions = [Keyboard.addListener('keyboardWillChangeFrame', this._onKeyboardChange)];
        } else {
          this._subscriptions = [Keyboard.addListener('keyboardDidHide', this._onKeyboardChange), Keyboard.addListener('keyboardDidShow', this._onKeyboardChange)];
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this._subscriptions.forEach(function (subscription) {
          subscription.remove();
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
            behavior = _this$props.behavior,
            children = _this$props.children,
            contentContainerStyle = _this$props.contentContainerStyle,
            enabled = _this$props.enabled,
            keyboardVerticalOffset = _this$props.keyboardVerticalOffset,
            style = _this$props.style,
            props = _objectWithoutProperties(_this$props, ["behavior", "children", "contentContainerStyle", "enabled", "keyboardVerticalOffset", "style"]);

        var bottomHeight = enabled ? this.state.bottom : 0;

        switch (behavior) {
          case 'height':
            var heightStyle;

            if (this._frame != null) {
              heightStyle = {
                height: this._frame.height - bottomHeight,
                flex: 0
              };
            }

            return React.createElement(View, _extends({
              ref: viewRef,
              style: StyleSheet.compose(style, heightStyle),
              onLayout: this._onLayout
            }, props, {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 172
              }
            }), children);

          case 'position':
            return React.createElement(View, _extends({
              ref: viewRef,
              style: style,
              onLayout: this._onLayout
            }, props, {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 186
              }
            }), React.createElement(View, {
              style: StyleSheet.compose(contentContainerStyle, {
                bottom: bottomHeight
              }),
              __source: {
                fileName: _jsxFileName,
                lineNumber: 191
              }
            }, children));

          case 'padding':
            return React.createElement(View, _extends({
              ref: viewRef,
              style: StyleSheet.compose(style, {
                paddingBottom: bottomHeight
              }),
              onLayout: this._onLayout
            }, props, {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 205
              }
            }), children);

          default:
            return React.createElement(View, _extends({
              ref: viewRef,
              onLayout: this._onLayout,
              style: style
            }, props, {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 219
              }
            }), children);
        }
      }
    }]);

    return KeyboardAvoidingView;
  }(React.Component);

  _defineProperty(KeyboardAvoidingView, "defaultProps", {
    enabled: true,
    keyboardVerticalOffset: 0
  });

  KeyboardAvoidingView = _wrapComponent("KeyboardAvoidingView")(KeyboardAvoidingView);
  module.exports = KeyboardAvoidingView;
},537,[23,112,120,24,25,26,29,30,28,32,109,280,506,507,146,149,150,175],"node_modules\\react-native\\Libraries\\Components\\Keyboard\\KeyboardAvoidingView.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = _$$_REQUIRE(_dependencyMap[0], "UnimplementedView");
},538,[539],"node_modules\\react-native\\Libraries\\Components\\MaskedView\\MaskedViewIOS.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\UnimplementedViews\\UnimplementedView.js";
  var _components = {
    UnimplementedView: {
      displayName: "UnimplementedView"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\UnimplementedViews\\UnimplementedView.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var React = _$$_REQUIRE(_dependencyMap[8], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[9], "StyleSheet");

  var UnimplementedView = function (_React$Component) {
    _inherits(UnimplementedView, _React$Component);

    function UnimplementedView() {
      _classCallCheck(this, UnimplementedView);

      return _possibleConstructorReturn(this, _getPrototypeOf(UnimplementedView).apply(this, arguments));
    }

    _createClass(UnimplementedView, [{
      key: "setNativeProps",
      value: function setNativeProps() {}
    }, {
      key: "render",
      value: function render() {
        var View = _$$_REQUIRE(_dependencyMap[10], "View");

        return React.createElement(View, {
          style: [styles.unimplementedView, this.props.style],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 30
          }
        }, this.props.children);
      }
    }]);

    return UnimplementedView;
  }(React.Component);

  UnimplementedView = _wrapComponent("UnimplementedView")(UnimplementedView);
  var styles = StyleSheet.create({
    unimplementedView: __DEV__ ? {
      alignSelf: 'flex-start',
      borderColor: 'red',
      borderWidth: 1
    } : {}
  });
  module.exports = UnimplementedView;
},539,[23,24,25,26,29,30,109,280,149,150,175],"node_modules\\react-native\\Libraries\\Components\\UnimplementedViews\\UnimplementedView.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Modal\\Modal.js",
      _container;

  var _components = {
    Modal: {
      displayName: "Modal"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Modal\\Modal.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var AppContainer = _$$_REQUIRE(_dependencyMap[10], "AppContainer");

  var I18nManager = _$$_REQUIRE(_dependencyMap[11], "I18nManager");

  var NativeEventEmitter = _$$_REQUIRE(_dependencyMap[12], "NativeEventEmitter");

  var NativeModules = _$$_REQUIRE(_dependencyMap[13], "NativeModules");

  var Platform = _$$_REQUIRE(_dependencyMap[14], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[15], "React");

  var PropTypes = _$$_REQUIRE(_dependencyMap[16], "prop-types");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[17], "StyleSheet");

  var View = _$$_REQUIRE(_dependencyMap[18], "View");

  var deprecatedPropType = _$$_REQUIRE(_dependencyMap[19], "deprecatedPropType");

  var requireNativeComponent = _$$_REQUIRE(_dependencyMap[20], "requireNativeComponent");

  var RCTModalHostView = requireNativeComponent('RCTModalHostView');
  var ModalEventEmitter = Platform.OS === 'ios' && NativeModules.ModalManager ? new NativeEventEmitter(NativeModules.ModalManager) : null;
  var uniqueModalIdentifier = 0;

  var Modal = function (_React$Component) {
    _inherits(Modal, _React$Component);

    function Modal(props) {
      var _this;

      _classCallCheck(this, Modal);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Modal).call(this, props));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_identifier", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_eventSubscription", void 0);

      Modal._confirmProps(props);

      _this._identifier = uniqueModalIdentifier++;
      return _this;
    }

    _createClass(Modal, [{
      key: "getChildContext",
      value: function getChildContext() {
        return {
          virtualizedList: null
        };
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        if (ModalEventEmitter) {
          this._eventSubscription = ModalEventEmitter.addListener('modalDismissed', function (event) {
            if (event.modalID === _this2._identifier && _this2.props.onDismiss) {
              _this2.props.onDismiss();
            }
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._eventSubscription) {
          this._eventSubscription.remove();
        }
      }
    }, {
      key: "UNSAFE_componentWillReceiveProps",
      value: function UNSAFE_componentWillReceiveProps(nextProps) {
        Modal._confirmProps(nextProps);
      }
    }, {
      key: "render",
      value: function render() {
        if (this.props.visible === false) {
          return null;
        }

        var containerStyles = {
          backgroundColor: this.props.transparent ? 'transparent' : 'white'
        };
        var animationType = this.props.animationType;

        if (!animationType) {
          animationType = 'none';

          if (this.props.animated) {
            animationType = 'slide';
          }
        }

        var presentationStyle = this.props.presentationStyle;

        if (!presentationStyle) {
          presentationStyle = 'fullScreen';

          if (this.props.transparent) {
            presentationStyle = 'overFullScreen';
          }
        }

        var innerChildren = __DEV__ ? React.createElement(AppContainer, {
          rootTag: this.context.rootTag,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 230
          }
        }, this.props.children) : this.props.children;
        return React.createElement(RCTModalHostView, {
          animationType: animationType,
          presentationStyle: presentationStyle,
          transparent: this.props.transparent,
          hardwareAccelerated: this.props.hardwareAccelerated,
          onRequestClose: this.props.onRequestClose,
          onShow: this.props.onShow,
          identifier: this._identifier,
          style: styles.modal,
          onStartShouldSetResponder: this._shouldSetResponder,
          supportedOrientations: this.props.supportedOrientations,
          onOrientationChange: this.props.onOrientationChange,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 238
          }
        }, React.createElement(View, {
          style: [styles.container, containerStyles],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 250
          }
        }, innerChildren));
      }
    }, {
      key: "_shouldSetResponder",
      value: function _shouldSetResponder() {
        return true;
      }
    }], [{
      key: "_confirmProps",
      value: function _confirmProps(props) {
        if (props.presentationStyle && props.presentationStyle !== 'overFullScreen' && props.transparent) {
          console.warn("Modal with '" + props.presentationStyle + "' presentation style and 'transparent' value is not supported.");
        }
      }
    }]);

    return Modal;
  }(React.Component);

  _defineProperty(Modal, "propTypes", {
    animationType: PropTypes.oneOf(['none', 'slide', 'fade']),
    presentationStyle: PropTypes.oneOf(['fullScreen', 'pageSheet', 'formSheet', 'overFullScreen']),
    transparent: PropTypes.bool,
    hardwareAccelerated: PropTypes.bool,
    visible: PropTypes.bool,
    onRequestClose: Platform.isTV || Platform.OS === 'android' ? PropTypes.func.isRequired : PropTypes.func,
    onShow: PropTypes.func,
    onDismiss: PropTypes.func,
    animated: deprecatedPropType(PropTypes.bool, 'Use the `animationType` prop instead.'),
    supportedOrientations: PropTypes.arrayOf(PropTypes.oneOf(['portrait', 'portrait-upside-down', 'landscape', 'landscape-left', 'landscape-right'])),
    onOrientationChange: PropTypes.func
  });

  _defineProperty(Modal, "defaultProps", {
    visible: true,
    hardwareAccelerated: false
  });

  _defineProperty(Modal, "contextTypes", {
    rootTag: PropTypes.number
  });

  _defineProperty(Modal, "childContextTypes", {
    virtualizedList: PropTypes.object
  });

  Modal = _wrapComponent("Modal")(Modal);
  var side = I18nManager.isRTL ? 'right' : 'left';
  var styles = StyleSheet.create({
    modal: {
      position: 'absolute'
    },
    container: (_container = {
      position: 'absolute'
    }, _defineProperty(_container, side, 0), _defineProperty(_container, "top", 0), _container)
  });
  module.exports = Modal;
},540,[23,24,25,26,29,30,28,32,109,280,541,547,219,119,146,149,161,150,175,166,268],"node_modules\\react-native\\Libraries\\Modal\\Modal.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\ReactNative\\AppContainer.js";
  var _components = {
    AppContainer: {
      displayName: "AppContainer"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\ReactNative\\AppContainer.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var EmitterSubscription = _$$_REQUIRE(_dependencyMap[10], "EmitterSubscription");

  var PropTypes = _$$_REQUIRE(_dependencyMap[11], "prop-types");

  var RCTDeviceEventEmitter = _$$_REQUIRE(_dependencyMap[12], "RCTDeviceEventEmitter");

  var React = _$$_REQUIRE(_dependencyMap[13], "React");

  var ReactNative = _$$_REQUIRE(_dependencyMap[14], "ReactNative");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[15], "StyleSheet");

  var View = _$$_REQUIRE(_dependencyMap[16], "View");

  var AppContainer = function (_React$Component) {
    _inherits(AppContainer, _React$Component);

    function AppContainer() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, AppContainer);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AppContainer)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
        inspector: null,
        mainKey: 1
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_mainRef", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_subscription", null);

      return _this;
    }

    _createClass(AppContainer, [{
      key: "getChildContext",
      value: function getChildContext() {
        return {
          rootTag: this.props.rootTag
        };
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        if (__DEV__) {
          if (!global.__RCTProfileIsProfiling) {
            this._subscription = RCTDeviceEventEmitter.addListener('toggleElementInspector', function () {
              var Inspector = _$$_REQUIRE(_dependencyMap[17], "Inspector");

              var inspector = _this2.state.inspector ? null : React.createElement(Inspector, {
                inspectedViewTag: ReactNative.findNodeHandle(_this2._mainRef),
                onRequestRerenderApp: function onRequestRerenderApp(updateInspectedViewTag) {
                  _this2.setState(function (s) {
                    return {
                      mainKey: s.mainKey + 1
                    };
                  }, function () {
                    return updateInspectedViewTag(ReactNative.findNodeHandle(_this2._mainRef));
                  });
                },
                __source: {
                  fileName: _jsxFileName,
                  lineNumber: 62
                }
              });

              _this2.setState({
                inspector: inspector
              });
            });
          }
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._subscription != null) {
          this._subscription.remove();
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        var yellowBox = null;

        if (__DEV__) {
          if (!global.__RCTProfileIsProfiling) {
            var YellowBox = _$$_REQUIRE(_dependencyMap[18], "YellowBox");

            yellowBox = React.createElement(YellowBox, {
              __source: {
                fileName: _jsxFileName,
                lineNumber: 93
              }
            });
          }
        }

        var innerView = React.createElement(View, {
          collapsable: !this.state.inspector,
          key: this.state.mainKey,
          pointerEvents: "box-none",
          style: styles.appContainer,
          ref: function ref(_ref) {
            _this3._mainRef = _ref;
          },
          __source: {
            fileName: _jsxFileName,
            lineNumber: 98
          }
        }, this.props.children);
        var Wrapper = this.props.WrapperComponent;

        if (Wrapper != null) {
          innerView = React.createElement(Wrapper, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 112
            }
          }, innerView);
        }

        return React.createElement(View, {
          style: styles.appContainer,
          pointerEvents: "box-none",
          __source: {
            fileName: _jsxFileName,
            lineNumber: 115
          }
        }, innerView, yellowBox, this.state.inspector);
      }
    }]);

    return AppContainer;
  }(React.Component);

  _defineProperty(AppContainer, "childContextTypes", {
    rootTag: PropTypes.number
  });

  AppContainer = _wrapComponent("AppContainer")(AppContainer);
  var styles = StyleSheet.create({
    appContainer: {
      flex: 1
    }
  });

  if (__DEV__) {
    if (!global.__RCTProfileIsProfiling) {
      var YellowBox = _$$_REQUIRE(_dependencyMap[18], "YellowBox");

      YellowBox.install();
    }
  }

  module.exports = AppContainer;
},541,[23,24,25,26,29,30,28,32,109,280,141,161,137,149,178,150,175,542,559],"node_modules\\react-native\\Libraries\\ReactNative\\AppContainer.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\Inspector.js";
  var _components = {
    Inspector: {
      displayName: "Inspector"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\Inspector.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var Dimensions = _$$_REQUIRE(_dependencyMap[10], "Dimensions");

  var InspectorOverlay = _$$_REQUIRE(_dependencyMap[11], "InspectorOverlay");

  var InspectorPanel = _$$_REQUIRE(_dependencyMap[12], "InspectorPanel");

  var Platform = _$$_REQUIRE(_dependencyMap[13], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[14], "React");

  var ReactNative = _$$_REQUIRE(_dependencyMap[15], "ReactNative");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[16], "StyleSheet");

  var Touchable = _$$_REQUIRE(_dependencyMap[17], "Touchable");

  var UIManager = _$$_REQUIRE(_dependencyMap[18], "UIManager");

  var View = _$$_REQUIRE(_dependencyMap[19], "View");

  var invariant = _$$_REQUIRE(_dependencyMap[20], "fbjs/lib/invariant");

  var hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
  var renderers = findRenderers();
  hook.resolveRNStyle = _$$_REQUIRE(_dependencyMap[21], "flattenStyle");

  function findRenderers() {
    var allRenderers = Object.keys(hook._renderers).map(function (key) {
      return hook._renderers[key];
    });
    invariant(allRenderers.length >= 1, 'Expected to find at least one React Native renderer on DevTools hook.');
    return allRenderers;
  }

  function getInspectorDataForViewTag(touchedViewTag) {
    for (var i = 0; i < renderers.length; i++) {
      var renderer = renderers[i];
      var inspectorData = renderer.getInspectorDataForViewTag(touchedViewTag);

      if (inspectorData.hierarchy.length > 0) {
        return inspectorData;
      }
    }

    throw new Error('Expected to find at least one React renderer.');
  }

  var Inspector = function (_React$Component) {
    _inherits(Inspector, _React$Component);

    function Inspector(_props) {
      var _this;

      _classCallCheck(this, Inspector);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Inspector).call(this, _props));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_subs", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "attachToDevtools", function (agent) {
        var _hideWait = null;
        var hlSub = agent.sub('highlight', function (_ref) {
          var node = _ref.node,
              name = _ref.name,
              props = _ref.props;
          clearTimeout(_hideWait);

          if (typeof node !== 'number') {
            node = ReactNative.findNodeHandle(node);
          }

          UIManager.measure(node, function (x, y, width, height, left, top) {
            _this.setState({
              hierarchy: [],
              inspected: {
                frame: {
                  left: left,
                  top: top,
                  width: width,
                  height: height
                },
                style: props ? props.style : {}
              }
            });
          });
        });
        var hideSub = agent.sub('hideHighlight', function () {
          if (_this.state.inspected === null) {
            return;
          }

          _hideWait = setTimeout(function () {
            _this.setState({
              inspected: null
            });
          }, 100);
        });
        _this._subs = [hlSub, hideSub];
        agent.on('shutdown', function () {
          _this.setState({
            devtoolsAgent: null
          });

          _this._subs = null;
        });

        _this.setState({
          devtoolsAgent: agent
        });
      });

      _this.state = {
        devtoolsAgent: null,
        hierarchy: null,
        panelPos: 'bottom',
        inspecting: true,
        perfing: false,
        inspected: null,
        selection: null,
        inspectedViewTag: _this.props.inspectedViewTag,
        networking: false
      };
      return _this;
    }

    _createClass(Inspector, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        hook.on('react-devtools', this.attachToDevtools);

        if (hook.reactDevtoolsAgent) {
          this.attachToDevtools(hook.reactDevtoolsAgent);
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._subs) {
          this._subs.map(function (fn) {
            return fn();
          });
        }

        hook.off('react-devtools', this.attachToDevtools);
      }
    }, {
      key: "UNSAFE_componentWillReceiveProps",
      value: function UNSAFE_componentWillReceiveProps(newProps) {
        this.setState({
          inspectedViewTag: newProps.inspectedViewTag
        });
      }
    }, {
      key: "setSelection",
      value: function setSelection(i) {
        var _this2 = this;

        var hierarchyItem = this.state.hierarchy[i];

        var _hierarchyItem$getIns = hierarchyItem.getInspectorData(ReactNative.findNodeHandle),
            measure = _hierarchyItem$getIns.measure,
            props = _hierarchyItem$getIns.props,
            source = _hierarchyItem$getIns.source;

        measure(function (x, y, width, height, left, top) {
          _this2.setState({
            inspected: {
              frame: {
                left: left,
                top: top,
                width: width,
                height: height
              },
              style: props.style,
              source: source
            },
            selection: i
          });
        });
      }
    }, {
      key: "onTouchViewTag",
      value: function onTouchViewTag(touchedViewTag, frame, pointerY) {
        var _getInspectorDataForV = getInspectorDataForViewTag(touchedViewTag),
            hierarchy = _getInspectorDataForV.hierarchy,
            props = _getInspectorDataForV.props,
            selection = _getInspectorDataForV.selection,
            source = _getInspectorDataForV.source;

        if (this.state.devtoolsAgent) {
          var offsetFromLeaf = hierarchy.length - 1 - selection;
          this.state.devtoolsAgent.selectFromDOMNode(touchedViewTag, true, offsetFromLeaf);
        }

        this.setState({
          panelPos: pointerY > Dimensions.get('window').height / 2 ? 'top' : 'bottom',
          selection: selection,
          hierarchy: hierarchy,
          inspected: {
            style: props.style,
            frame: frame,
            source: source
          }
        });
      }
    }, {
      key: "setPerfing",
      value: function setPerfing(val) {
        this.setState({
          perfing: val,
          inspecting: false,
          inspected: null,
          networking: false
        });
      }
    }, {
      key: "setInspecting",
      value: function setInspecting(val) {
        this.setState({
          inspecting: val,
          inspected: null
        });
      }
    }, {
      key: "setTouchTargeting",
      value: function setTouchTargeting(val) {
        var _this3 = this;

        Touchable.TOUCH_TARGET_DEBUG = val;
        this.props.onRequestRerenderApp(function (inspectedViewTag) {
          _this3.setState({
            inspectedViewTag: inspectedViewTag
          });
        });
      }
    }, {
      key: "setNetworking",
      value: function setNetworking(val) {
        this.setState({
          networking: val,
          perfing: false,
          inspecting: false,
          inspected: null
        });
      }
    }, {
      key: "render",
      value: function render() {
        var panelContainerStyle = this.state.panelPos === 'bottom' ? {
          bottom: 0
        } : {
          top: Platform.OS === 'ios' ? 20 : 0
        };
        return React.createElement(View, {
          style: styles.container,
          pointerEvents: "box-none",
          __source: {
            fileName: _jsxFileName,
            lineNumber: 245
          }
        }, this.state.inspecting && React.createElement(InspectorOverlay, {
          inspected: this.state.inspected,
          inspectedViewTag: this.state.inspectedViewTag,
          onTouchViewTag: this.onTouchViewTag.bind(this),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 247
          }
        }), React.createElement(View, {
          style: [styles.panelContainer, panelContainerStyle],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 253
          }
        }, React.createElement(InspectorPanel, {
          devtoolsIsOpen: !!this.state.devtoolsAgent,
          inspecting: this.state.inspecting,
          perfing: this.state.perfing,
          setPerfing: this.setPerfing.bind(this),
          setInspecting: this.setInspecting.bind(this),
          inspected: this.state.inspected,
          hierarchy: this.state.hierarchy,
          selection: this.state.selection,
          setSelection: this.setSelection.bind(this),
          touchTargeting: Touchable.TOUCH_TARGET_DEBUG,
          setTouchTargeting: this.setTouchTargeting.bind(this),
          networking: this.state.networking,
          setNetworking: this.setNetworking.bind(this),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 254
          }
        })));
      }
    }]);

    return Inspector;
  }(React.Component);

  Inspector = _wrapComponent("Inspector")(Inspector);
  var styles = StyleSheet.create({
    container: {
      position: 'absolute',
      backgroundColor: 'transparent',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    },
    panelContainer: {
      position: 'absolute',
      left: 0,
      right: 0
    }
  });
  module.exports = Inspector;
},542,[23,24,25,26,29,30,28,32,109,280,152,543,548,146,149,178,150,449,145,175,117,174],"node_modules\\react-native\\Libraries\\Inspector\\Inspector.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\InspectorOverlay.js";
  var _components = {
    InspectorOverlay: {
      displayName: "InspectorOverlay"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\InspectorOverlay.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var Dimensions = _$$_REQUIRE(_dependencyMap[10], "Dimensions");

  var ElementBox = _$$_REQUIRE(_dependencyMap[11], "ElementBox");

  var PropTypes = _$$_REQUIRE(_dependencyMap[12], "prop-types");

  var React = _$$_REQUIRE(_dependencyMap[13], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[14], "StyleSheet");

  var UIManager = _$$_REQUIRE(_dependencyMap[15], "UIManager");

  var View = _$$_REQUIRE(_dependencyMap[16], "View");

  var InspectorOverlay = function (_React$Component) {
    _inherits(InspectorOverlay, _React$Component);

    function InspectorOverlay() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, InspectorOverlay);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(InspectorOverlay)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "findViewForTouchEvent", function (e) {
        var _e$nativeEvent$touche = e.nativeEvent.touches[0],
            locationX = _e$nativeEvent$touche.locationX,
            locationY = _e$nativeEvent$touche.locationY;
        UIManager.findSubviewIn(_this.props.inspectedViewTag, [locationX, locationY], function (nativeViewTag, left, top, width, height) {
          _this.props.onTouchViewTag(nativeViewTag, {
            left: left,
            top: top,
            width: width,
            height: height
          }, locationY);
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "shouldSetResponser", function (e) {
        _this.findViewForTouchEvent(e);

        return true;
      });

      return _this;
    }

    _createClass(InspectorOverlay, [{
      key: "render",
      value: function render() {
        var content = null;

        if (this.props.inspected) {
          content = React.createElement(ElementBox, {
            frame: this.props.inspected.frame,
            style: this.props.inspected.style,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 66
            }
          });
        }

        return React.createElement(View, {
          onStartShouldSetResponder: this.shouldSetResponser,
          onResponderMove: this.findViewForTouchEvent,
          style: [styles.inspector, {
            height: Dimensions.get('window').height
          }],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 74
          }
        }, content);
      }
    }]);

    return InspectorOverlay;
  }(React.Component);

  _defineProperty(InspectorOverlay, "propTypes", {
    inspected: PropTypes.shape({
      frame: PropTypes.object,
      style: PropTypes.any
    }),
    inspectedViewTag: PropTypes.number,
    onTouchViewTag: PropTypes.func.isRequired
  });

  InspectorOverlay = _wrapComponent("InspectorOverlay")(InspectorOverlay);
  var styles = StyleSheet.create({
    inspector: {
      backgroundColor: 'transparent',
      position: 'absolute',
      left: 0,
      top: 0,
      right: 0
    }
  });
  module.exports = InspectorOverlay;
},543,[23,24,25,26,29,30,28,32,109,280,152,544,161,149,150,145,175],"node_modules\\react-native\\Libraries\\Inspector\\InspectorOverlay.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/inherits");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\ElementBox.js";
  var _components = {
    ElementBox: {
      displayName: "ElementBox"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\ElementBox.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var BorderBox = _$$_REQUIRE(_dependencyMap[9], "BorderBox");

  var React = _$$_REQUIRE(_dependencyMap[10], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[11], "StyleSheet");

  var View = _$$_REQUIRE(_dependencyMap[12], "View");

  var flattenStyle = _$$_REQUIRE(_dependencyMap[13], "flattenStyle");

  var resolveBoxStyle = _$$_REQUIRE(_dependencyMap[14], "resolveBoxStyle");

  var ElementBox = function (_React$Component) {
    _inherits(ElementBox, _React$Component);

    function ElementBox() {
      _classCallCheck(this, ElementBox);

      return _possibleConstructorReturn(this, _getPrototypeOf(ElementBox).apply(this, arguments));
    }

    _createClass(ElementBox, [{
      key: "render",
      value: function render() {
        var style = flattenStyle(this.props.style) || {};
        var margin = resolveBoxStyle('margin', style);
        var padding = resolveBoxStyle('padding', style);

        var frameStyle = _objectSpread({}, this.props.frame);

        var contentStyle = {
          width: this.props.frame.width,
          height: this.props.frame.height
        };

        if (margin != null) {
          frameStyle.top -= margin.top;
          frameStyle.left -= margin.left;
          frameStyle.height += margin.top + margin.bottom;
          frameStyle.width += margin.left + margin.right;

          if (margin.top < 0) {
            contentStyle.height += margin.top;
          }

          if (margin.bottom < 0) {
            contentStyle.height += margin.bottom;
          }

          if (margin.left < 0) {
            contentStyle.width += margin.left;
          }

          if (margin.right < 0) {
            contentStyle.width += margin.right;
          }
        }

        if (padding != null) {
          contentStyle.width -= padding.left + padding.right;
          contentStyle.height -= padding.top + padding.bottom;
        }

        return React.createElement(View, {
          style: [styles.frame, frameStyle],
          pointerEvents: "none",
          __source: {
            fileName: _jsxFileName,
            lineNumber: 59
          }
        }, React.createElement(BorderBox, {
          box: margin,
          style: styles.margin,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 60
          }
        }, React.createElement(BorderBox, {
          box: padding,
          style: styles.padding,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 61
          }
        }, React.createElement(View, {
          style: [styles.content, contentStyle],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 62
          }
        }))));
      }
    }]);

    return ElementBox;
  }(React.Component);

  ElementBox = _wrapComponent("ElementBox")(ElementBox);
  var styles = StyleSheet.create({
    frame: {
      position: 'absolute'
    },
    content: {
      backgroundColor: 'rgba(200, 230, 255, 0.8)'
    },
    padding: {
      borderColor: 'rgba(77, 255, 0, 0.3)'
    },
    margin: {
      borderColor: 'rgba(255, 132, 0, 0.3)'
    }
  });
  module.exports = ElementBox;
},544,[23,148,24,25,26,29,30,109,280,545,149,150,175,174,546],"node_modules\\react-native\\Libraries\\Inspector\\ElementBox.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\BorderBox.js";
  var _components = {
    BorderBox: {
      displayName: "BorderBox"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\BorderBox.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var React = _$$_REQUIRE(_dependencyMap[8], "React");

  var View = _$$_REQUIRE(_dependencyMap[9], "View");

  var BorderBox = function (_React$Component) {
    _inherits(BorderBox, _React$Component);

    function BorderBox() {
      _classCallCheck(this, BorderBox);

      return _possibleConstructorReturn(this, _getPrototypeOf(BorderBox).apply(this, arguments));
    }

    _createClass(BorderBox, [{
      key: "render",
      value: function render() {
        var box = this.props.box;

        if (!box) {
          return this.props.children;
        }

        var style = {
          borderTopWidth: box.top,
          borderBottomWidth: box.bottom,
          borderLeftWidth: box.left,
          borderRightWidth: box.right
        };
        return React.createElement(View, {
          style: [style, this.props.style],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 28
          }
        }, this.props.children);
      }
    }]);

    return BorderBox;
  }(React.Component);

  BorderBox = _wrapComponent("BorderBox")(BorderBox);
  module.exports = BorderBox;
},545,[23,24,25,26,29,30,109,280,149,175],"node_modules\\react-native\\Libraries\\Inspector\\BorderBox.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var I18nManager = _$$_REQUIRE(_dependencyMap[0], "I18nManager");

  function resolveBoxStyle(prefix, style) {
    var hasParts = false;
    var result = {
      bottom: 0,
      left: 0,
      right: 0,
      top: 0
    };
    var styleForAll = style[prefix];

    if (styleForAll != null) {
      var _arr = Object.keys(result);

      for (var _i = 0; _i < _arr.length; _i++) {
        var key = _arr[_i];
        result[key] = styleForAll;
      }

      hasParts = true;
    }

    var styleForHorizontal = style[prefix + 'Horizontal'];

    if (styleForHorizontal != null) {
      result.left = styleForHorizontal;
      result.right = styleForHorizontal;
      hasParts = true;
    } else {
      var styleForLeft = style[prefix + 'Left'];

      if (styleForLeft != null) {
        result.left = styleForLeft;
        hasParts = true;
      }

      var styleForRight = style[prefix + 'Right'];

      if (styleForRight != null) {
        result.right = styleForRight;
        hasParts = true;
      }

      var styleForEnd = style[prefix + 'End'];

      if (styleForEnd != null) {
        if (I18nManager.isRTL && I18nManager.doLeftAndRightSwapInRTL) {
          result.left = styleForEnd;
        } else {
          result.right = styleForEnd;
        }

        hasParts = true;
      }

      var styleForStart = style[prefix + 'Start'];

      if (styleForStart != null) {
        if (I18nManager.isRTL && I18nManager.doLeftAndRightSwapInRTL) {
          result.right = styleForStart;
        } else {
          result.left = styleForStart;
        }

        hasParts = true;
      }
    }

    var styleForVertical = style[prefix + 'Vertical'];

    if (styleForVertical != null) {
      result.bottom = styleForVertical;
      result.top = styleForVertical;
      hasParts = true;
    } else {
      var styleForBottom = style[prefix + 'Bottom'];

      if (styleForBottom != null) {
        result.bottom = styleForBottom;
        hasParts = true;
      }

      var styleForTop = style[prefix + 'Top'];

      if (styleForTop != null) {
        result.top = styleForTop;
        hasParts = true;
      }
    }

    return hasParts ? result : null;
  }

  module.exports = resolveBoxStyle;
},546,[547],"node_modules\\react-native\\Libraries\\Inspector\\resolveBoxStyle.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var I18nManager = _$$_REQUIRE(_dependencyMap[0], "NativeModules").I18nManager || {
    isRTL: false,
    doLeftAndRightSwapInRTL: true,
    allowRTL: function allowRTL() {},
    forceRTL: function forceRTL() {},
    swapLeftAndRightInRTL: function swapLeftAndRightInRTL() {}
  };
  module.exports = I18nManager;
},547,[119],"node_modules\\react-native\\Libraries\\ReactNative\\I18nManager.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\InspectorPanel.js";
  var _components = {
    InspectorPanel: {
      displayName: "InspectorPanel"
    },
    Button: {
      displayName: "Button"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\InspectorPanel.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var ElementProperties = _$$_REQUIRE(_dependencyMap[8], "ElementProperties");

  var NetworkOverlay = _$$_REQUIRE(_dependencyMap[9], "NetworkOverlay");

  var PerformanceOverlay = _$$_REQUIRE(_dependencyMap[10], "PerformanceOverlay");

  var React = _$$_REQUIRE(_dependencyMap[11], "React");

  var PropTypes = _$$_REQUIRE(_dependencyMap[12], "prop-types");

  var ScrollView = _$$_REQUIRE(_dependencyMap[13], "ScrollView");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[14], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[15], "Text");

  var TouchableHighlight = _$$_REQUIRE(_dependencyMap[16], "TouchableHighlight");

  var View = _$$_REQUIRE(_dependencyMap[17], "View");

  var InspectorPanel = function (_React$Component) {
    _inherits(InspectorPanel, _React$Component);

    function InspectorPanel() {
      _classCallCheck(this, InspectorPanel);

      return _possibleConstructorReturn(this, _getPrototypeOf(InspectorPanel).apply(this, arguments));
    }

    _createClass(InspectorPanel, [{
      key: "renderWaiting",
      value: function renderWaiting() {
        if (this.props.inspecting) {
          return React.createElement(Text, {
            style: styles.waitingText,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 28
            }
          }, "Tap something to inspect it");
        }

        return React.createElement(Text, {
          style: styles.waitingText,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 31
          }
        }, "Nothing is inspected");
      }
    }, {
      key: "render",
      value: function render() {
        var contents;

        if (this.props.inspected) {
          contents = React.createElement(ScrollView, {
            style: styles.properties,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 38
            }
          }, React.createElement(ElementProperties, {
            style: this.props.inspected.style,
            frame: this.props.inspected.frame,
            source: this.props.inspected.source,
            hierarchy: this.props.hierarchy,
            selection: this.props.selection,
            setSelection: this.props.setSelection,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 39
            }
          }));
        } else if (this.props.perfing) {
          contents = React.createElement(PerformanceOverlay, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 50
            }
          });
        } else if (this.props.networking) {
          contents = React.createElement(NetworkOverlay, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 52
            }
          });
        } else {
          contents = React.createElement(View, {
            style: styles.waiting,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 54
            }
          }, this.renderWaiting());
        }

        return React.createElement(View, {
          style: styles.container,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 57
          }
        }, !this.props.devtoolsIsOpen && contents, React.createElement(View, {
          style: styles.buttonRow,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 59
          }
        }, React.createElement(Button, {
          title: 'Inspect',
          pressed: this.props.inspecting,
          onClick: this.props.setInspecting,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 60
          }
        }), React.createElement(Button, {
          title: 'Perf',
          pressed: this.props.perfing,
          onClick: this.props.setPerfing,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 65
          }
        }), React.createElement(Button, {
          title: 'Network',
          pressed: this.props.networking,
          onClick: this.props.setNetworking,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 70
          }
        }), React.createElement(Button, {
          title: 'Touchables',
          pressed: this.props.touchTargeting,
          onClick: this.props.setTouchTargeting,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 75
          }
        })));
      }
    }]);

    return InspectorPanel;
  }(React.Component);

  InspectorPanel = _wrapComponent("InspectorPanel")(InspectorPanel);
  InspectorPanel.propTypes = {
    devtoolsIsOpen: PropTypes.bool,
    inspecting: PropTypes.bool,
    setInspecting: PropTypes.func,
    inspected: PropTypes.object,
    perfing: PropTypes.bool,
    setPerfing: PropTypes.func,
    touchTargeting: PropTypes.bool,
    setTouchTargeting: PropTypes.func,
    networking: PropTypes.bool,
    setNetworking: PropTypes.func
  };

  var Button = function (_React$Component2) {
    _inherits(Button, _React$Component2);

    function Button() {
      _classCallCheck(this, Button);

      return _possibleConstructorReturn(this, _getPrototypeOf(Button).apply(this, arguments));
    }

    _createClass(Button, [{
      key: "render",
      value: function render() {
        var _this = this;

        return React.createElement(TouchableHighlight, {
          onPress: function onPress() {
            return _this.props.onClick(!_this.props.pressed);
          },
          style: [styles.button, this.props.pressed && styles.buttonPressed],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 102
          }
        }, React.createElement(Text, {
          style: styles.buttonText,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 105
          }
        }, this.props.title));
      }
    }]);

    return Button;
  }(React.Component);

  Button = _wrapComponent("Button")(Button);
  var styles = StyleSheet.create({
    buttonRow: {
      flexDirection: 'row'
    },
    button: {
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      margin: 2,
      height: 30,
      justifyContent: 'center',
      alignItems: 'center'
    },
    buttonPressed: {
      backgroundColor: 'rgba(255, 255, 255, 0.3)'
    },
    buttonText: {
      textAlign: 'center',
      color: 'white',
      margin: 5
    },
    container: {
      backgroundColor: 'rgba(0, 0, 0, 0.7)'
    },
    properties: {
      height: 200
    },
    waiting: {
      height: 100
    },
    waitingText: {
      fontSize: 20,
      textAlign: 'center',
      marginVertical: 20,
      color: 'white'
    }
  });
  module.exports = InspectorPanel;
},548,[23,24,25,26,29,30,109,280,549,555,558,149,161,503,150,444,552,175],"node_modules\\react-native\\Libraries\\Inspector\\InspectorPanel.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\ElementProperties.js";
  var _components = {
    ElementProperties: {
      displayName: "ElementProperties"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\ElementProperties.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var BoxInspector = _$$_REQUIRE(_dependencyMap[9], "BoxInspector");

  var PropTypes = _$$_REQUIRE(_dependencyMap[10], "prop-types");

  var React = _$$_REQUIRE(_dependencyMap[11], "React");

  var StyleInspector = _$$_REQUIRE(_dependencyMap[12], "StyleInspector");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[13], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[14], "Text");

  var TouchableHighlight = _$$_REQUIRE(_dependencyMap[15], "TouchableHighlight");

  var TouchableWithoutFeedback = _$$_REQUIRE(_dependencyMap[16], "TouchableWithoutFeedback");

  var View = _$$_REQUIRE(_dependencyMap[17], "View");

  var flattenStyle = _$$_REQUIRE(_dependencyMap[18], "flattenStyle");

  var mapWithSeparator = _$$_REQUIRE(_dependencyMap[19], "mapWithSeparator");

  var openFileInEditor = _$$_REQUIRE(_dependencyMap[20], "openFileInEditor");

  var ElementProperties = function (_React$Component) {
    _inherits(ElementProperties, _React$Component);

    function ElementProperties() {
      _classCallCheck(this, ElementProperties);

      return _possibleConstructorReturn(this, _getPrototypeOf(ElementProperties).apply(this, arguments));
    }

    _createClass(ElementProperties, [{
      key: "render",
      value: function render() {
        var _this = this;

        var style = flattenStyle(this.props.style);
        var selection = this.props.selection;
        var openFileButton;
        var source = this.props.source;

        var _ref = source || {},
            fileName = _ref.fileName,
            lineNumber = _ref.lineNumber;

        if (fileName && lineNumber) {
          var parts = fileName.split('/');
          var fileNameShort = parts[parts.length - 1];
          openFileButton = React.createElement(TouchableHighlight, {
            style: styles.openButton,
            onPress: openFileInEditor.bind(null, fileName, lineNumber),
            __source: {
              fileName: _jsxFileName,
              lineNumber: 61
            }
          }, React.createElement(Text, {
            style: styles.openButtonTitle,
            numberOfLines: 1,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 64
            }
          }, fileNameShort, ":", lineNumber));
        }

        return React.createElement(TouchableWithoutFeedback, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 73
          }
        }, React.createElement(View, {
          style: styles.info,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 74
          }
        }, React.createElement(View, {
          style: styles.breadcrumb,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 75
          }
        }, mapWithSeparator(this.props.hierarchy, function (hierarchyItem, i) {
          return React.createElement(TouchableHighlight, {
            key: 'item-' + i,
            style: [styles.breadItem, i === selection && styles.selected],
            onPress: function onPress() {
              return _this.props.setSelection(i);
            },
            __source: {
              fileName: _jsxFileName,
              lineNumber: 79
            }
          }, React.createElement(Text, {
            style: styles.breadItemText,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 84
            }
          }, hierarchyItem.name));
        }, function (i) {
          return React.createElement(Text, {
            key: 'sep-' + i,
            style: styles.breadSep,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 88
            }
          }, "\u25B8");
        })), React.createElement(View, {
          style: styles.row,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 94
          }
        }, React.createElement(View, {
          style: styles.col,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 95
          }
        }, React.createElement(StyleInspector, {
          style: style,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 96
          }
        }), openFileButton), React.createElement(BoxInspector, {
          style: style,
          frame: this.props.frame,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 101
          }
        }))));
      }
    }]);

    return ElementProperties;
  }(React.Component);

  _defineProperty(ElementProperties, "propTypes", {
    hierarchy: PropTypes.array.isRequired,
    style: PropTypes.oneOfType([PropTypes.object, PropTypes.array, PropTypes.number]),
    source: PropTypes.shape({
      fileName: PropTypes.string,
      lineNumber: PropTypes.number
    })
  });

  ElementProperties = _wrapComponent("ElementProperties")(ElementProperties);
  var styles = StyleSheet.create({
    breadSep: {
      fontSize: 8,
      color: 'white'
    },
    breadcrumb: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      alignItems: 'flex-start',
      marginBottom: 5
    },
    selected: {
      borderColor: 'white',
      borderRadius: 5
    },
    breadItem: {
      borderWidth: 1,
      borderColor: 'transparent',
      marginHorizontal: 2
    },
    breadItemText: {
      fontSize: 10,
      color: 'white',
      marginHorizontal: 5
    },
    row: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between'
    },
    col: {
      flex: 1
    },
    info: {
      padding: 10
    },
    openButton: {
      padding: 10,
      backgroundColor: '#000',
      marginVertical: 5,
      marginRight: 5,
      borderRadius: 2
    },
    openButtonTitle: {
      color: 'white',
      fontSize: 8
    }
  });
  module.exports = ElementProperties;
},549,[23,24,25,26,29,30,32,109,280,550,161,149,551,150,444,552,457,175,174,553,554],"node_modules\\react-native\\Libraries\\Inspector\\ElementProperties.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\BoxInspector.js";
  var _components = {
    BoxInspector: {
      displayName: "BoxInspector"
    },
    BoxContainer: {
      displayName: "BoxContainer"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\BoxInspector.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var React = _$$_REQUIRE(_dependencyMap[8], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[9], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[10], "Text");

  var View = _$$_REQUIRE(_dependencyMap[11], "View");

  var resolveBoxStyle = _$$_REQUIRE(_dependencyMap[12], "resolveBoxStyle");

  var blank = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  };

  var BoxInspector = function (_React$Component) {
    _inherits(BoxInspector, _React$Component);

    function BoxInspector() {
      _classCallCheck(this, BoxInspector);

      return _possibleConstructorReturn(this, _getPrototypeOf(BoxInspector).apply(this, arguments));
    }

    _createClass(BoxInspector, [{
      key: "render",
      value: function render() {
        var frame = this.props.frame;
        var style = this.props.style;
        var margin = style && resolveBoxStyle('margin', style) || blank;
        var padding = style && resolveBoxStyle('padding', style) || blank;
        return React.createElement(BoxContainer, {
          title: "margin",
          titleStyle: styles.marginLabel,
          box: margin,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 33
          }
        }, React.createElement(BoxContainer, {
          title: "padding",
          box: padding,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 34
          }
        }, React.createElement(View, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 35
          }
        }, React.createElement(Text, {
          style: styles.innerText,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 36
          }
        }, "(", (frame.left || 0).toFixed(1), ", ", (frame.top || 0).toFixed(1), ")"), React.createElement(Text, {
          style: styles.innerText,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 39
          }
        }, (frame.width || 0).toFixed(1), " \xD7", ' ', (frame.height || 0).toFixed(1)))));
      }
    }]);

    return BoxInspector;
  }(React.Component);

  BoxInspector = _wrapComponent("BoxInspector")(BoxInspector);

  var BoxContainer = function (_React$Component2) {
    _inherits(BoxContainer, _React$Component2);

    function BoxContainer() {
      _classCallCheck(this, BoxContainer);

      return _possibleConstructorReturn(this, _getPrototypeOf(BoxContainer).apply(this, arguments));
    }

    _createClass(BoxContainer, [{
      key: "render",
      value: function render() {
        var box = this.props.box;
        return React.createElement(View, {
          style: styles.box,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 54
          }
        }, React.createElement(View, {
          style: styles.row,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 55
          }
        }, React.createElement(Text, {
          style: [this.props.titleStyle, styles.label],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 57
          }
        }, this.props.title), React.createElement(Text, {
          style: styles.boxText,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 60
          }
        }, box.top)), React.createElement(View, {
          style: styles.row,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 62
          }
        }, React.createElement(Text, {
          style: styles.boxText,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 63
          }
        }, box.left), this.props.children, React.createElement(Text, {
          style: styles.boxText,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 65
          }
        }, box.right)), React.createElement(Text, {
          style: styles.boxText,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 67
          }
        }, box.bottom));
      }
    }]);

    return BoxContainer;
  }(React.Component);

  BoxContainer = _wrapComponent("BoxContainer")(BoxContainer);
  var styles = StyleSheet.create({
    row: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-around'
    },
    marginLabel: {
      width: 60
    },
    label: {
      fontSize: 10,
      color: 'rgb(255,100,0)',
      marginLeft: 5,
      flex: 1,
      textAlign: 'left',
      top: -3
    },
    buffer: {
      fontSize: 10,
      color: 'yellow',
      flex: 1,
      textAlign: 'center'
    },
    innerText: {
      color: 'yellow',
      fontSize: 12,
      textAlign: 'center',
      width: 70
    },
    box: {
      borderWidth: 1,
      borderColor: 'grey'
    },
    boxText: {
      color: 'white',
      fontSize: 12,
      marginHorizontal: 3,
      marginVertical: 2,
      textAlign: 'center'
    }
  });
  module.exports = BoxInspector;
},550,[23,24,25,26,29,30,109,280,149,150,444,175,546],"node_modules\\react-native\\Libraries\\Inspector\\BoxInspector.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\StyleInspector.js";
  var _components = {
    StyleInspector: {
      displayName: "StyleInspector"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\StyleInspector.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var React = _$$_REQUIRE(_dependencyMap[8], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[9], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[10], "Text");

  var View = _$$_REQUIRE(_dependencyMap[11], "View");

  var StyleInspector = function (_React$Component) {
    _inherits(StyleInspector, _React$Component);

    function StyleInspector() {
      _classCallCheck(this, StyleInspector);

      return _possibleConstructorReturn(this, _getPrototypeOf(StyleInspector).apply(this, arguments));
    }

    _createClass(StyleInspector, [{
      key: "render",
      value: function render() {
        var _this = this;

        if (!this.props.style) {
          return React.createElement(Text, {
            style: styles.noStyle,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 21
            }
          }, "No style");
        }

        var names = Object.keys(this.props.style);
        return React.createElement(View, {
          style: styles.container,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 25
          }
        }, React.createElement(View, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 26
          }
        }, names.map(function (name) {
          return React.createElement(Text, {
            key: name,
            style: styles.attr,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 28
            }
          }, name, ":");
        })), React.createElement(View, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 34
          }
        }, names.map(function (name) {
          var value = typeof _this.props.style[name] === 'object' ? JSON.stringify(_this.props.style[name]) : _this.props.style[name];
          return React.createElement(Text, {
            key: name,
            style: styles.value,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 41
            }
          }, value);
        })));
      }
    }]);

    return StyleInspector;
  }(React.Component);

  StyleInspector = _wrapComponent("StyleInspector")(StyleInspector);
  var styles = StyleSheet.create({
    container: {
      flexDirection: 'row'
    },
    row: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-around'
    },
    attr: {
      fontSize: 10,
      color: '#ccc'
    },
    value: {
      fontSize: 10,
      color: 'white',
      marginLeft: 10
    },
    noStyle: {
      color: 'white',
      fontSize: 10
    }
  });
  module.exports = StyleInspector;
},551,[23,24,25,26,29,30,109,280,149,150,444,175],"node_modules\\react-native\\Libraries\\Inspector\\StyleInspector.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\Touchable\\TouchableHighlight.js";

  var ColorPropType = _$$_REQUIRE(_dependencyMap[1], "ColorPropType");

  var NativeMethodsMixin = _$$_REQUIRE(_dependencyMap[2], "NativeMethodsMixin");

  var PropTypes = _$$_REQUIRE(_dependencyMap[3], "prop-types");

  var Platform = _$$_REQUIRE(_dependencyMap[4], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[5], "React");

  var ReactNativeViewAttributes = _$$_REQUIRE(_dependencyMap[6], "ReactNativeViewAttributes");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[7], "StyleSheet");

  var Touchable = _$$_REQUIRE(_dependencyMap[8], "Touchable");

  var TouchableWithoutFeedback = _$$_REQUIRE(_dependencyMap[9], "TouchableWithoutFeedback");

  var View = _$$_REQUIRE(_dependencyMap[10], "View");

  var ViewPropTypes = _$$_REQUIRE(_dependencyMap[11], "ViewPropTypes");

  var createReactClass = _$$_REQUIRE(_dependencyMap[12], "create-react-class");

  var ensurePositiveDelayProps = _$$_REQUIRE(_dependencyMap[13], "ensurePositiveDelayProps");

  var DEFAULT_PROPS = {
    activeOpacity: 0.85,
    delayPressOut: 100,
    underlayColor: 'black'
  };
  var PRESS_RETENTION_OFFSET = {
    top: 20,
    left: 20,
    right: 20,
    bottom: 30
  };
  var TouchableHighlight = createReactClass({
    displayName: 'TouchableHighlight',
    propTypes: _objectSpread({}, TouchableWithoutFeedback.propTypes, {
      activeOpacity: PropTypes.number,
      underlayColor: ColorPropType,
      style: ViewPropTypes.style,
      onShowUnderlay: PropTypes.func,
      onHideUnderlay: PropTypes.func,
      hasTVPreferredFocus: PropTypes.bool,
      tvParallaxProperties: PropTypes.object,
      testOnly_pressed: PropTypes.bool
    }),
    mixins: [NativeMethodsMixin, Touchable.Mixin],
    getDefaultProps: function getDefaultProps() {
      return DEFAULT_PROPS;
    },
    getInitialState: function getInitialState() {
      this._isMounted = false;

      if (this.props.testOnly_pressed) {
        return _objectSpread({}, this.touchableGetInitialState(), {
          extraChildStyle: {
            opacity: this.props.activeOpacity
          },
          extraUnderlayStyle: {
            backgroundColor: this.props.underlayColor
          }
        });
      } else {
        return _objectSpread({}, this.touchableGetInitialState(), {
          extraChildStyle: null,
          extraUnderlayStyle: null
        });
      }
    },
    componentDidMount: function componentDidMount() {
      this._isMounted = true;
      ensurePositiveDelayProps(this.props);
    },
    componentWillUnmount: function componentWillUnmount() {
      this._isMounted = false;
      clearTimeout(this._hideTimeout);
    },
    UNSAFE_componentWillReceiveProps: function UNSAFE_componentWillReceiveProps(nextProps) {
      ensurePositiveDelayProps(nextProps);
    },
    viewConfig: {
      uiViewClassName: 'RCTView',
      validAttributes: ReactNativeViewAttributes.RCTView
    },
    touchableHandleActivePressIn: function touchableHandleActivePressIn(e) {
      clearTimeout(this._hideTimeout);
      this._hideTimeout = null;

      this._showUnderlay();

      this.props.onPressIn && this.props.onPressIn(e);
    },
    touchableHandleActivePressOut: function touchableHandleActivePressOut(e) {
      if (!this._hideTimeout) {
        this._hideUnderlay();
      }

      this.props.onPressOut && this.props.onPressOut(e);
    },
    touchableHandlePress: function touchableHandlePress(e) {
      clearTimeout(this._hideTimeout);

      if (!Platform.isTV) {
        this._showUnderlay();

        this._hideTimeout = setTimeout(this._hideUnderlay, this.props.delayPressOut);
      }

      this.props.onPress && this.props.onPress(e);
    },
    touchableHandleLongPress: function touchableHandleLongPress(e) {
      this.props.onLongPress && this.props.onLongPress(e);
    },
    touchableGetPressRectOffset: function touchableGetPressRectOffset() {
      return this.props.pressRetentionOffset || PRESS_RETENTION_OFFSET;
    },
    touchableGetHitSlop: function touchableGetHitSlop() {
      return this.props.hitSlop;
    },
    touchableGetHighlightDelayMS: function touchableGetHighlightDelayMS() {
      return this.props.delayPressIn;
    },
    touchableGetLongPressDelayMS: function touchableGetLongPressDelayMS() {
      return this.props.delayLongPress;
    },
    touchableGetPressOutDelayMS: function touchableGetPressOutDelayMS() {
      return this.props.delayPressOut;
    },
    _showUnderlay: function _showUnderlay() {
      if (!this._isMounted || !this._hasPressHandler()) {
        return;
      }

      this.setState({
        extraChildStyle: {
          opacity: this.props.activeOpacity
        },
        extraUnderlayStyle: {
          backgroundColor: this.props.underlayColor
        }
      });
      this.props.onShowUnderlay && this.props.onShowUnderlay();
    },
    _hideUnderlay: function _hideUnderlay() {
      clearTimeout(this._hideTimeout);
      this._hideTimeout = null;

      if (this.props.testOnly_pressed) {
        return;
      }

      if (this._hasPressHandler()) {
        this.setState({
          extraChildStyle: null,
          extraUnderlayStyle: null
        });
        this.props.onHideUnderlay && this.props.onHideUnderlay();
      }
    },
    _hasPressHandler: function _hasPressHandler() {
      return !!(this.props.onPress || this.props.onPressIn || this.props.onPressOut || this.props.onLongPress);
    },
    render: function render() {
      var child = React.Children.only(this.props.children);
      return React.createElement(View, {
        accessible: this.props.accessible !== false,
        accessibilityLabel: this.props.accessibilityLabel,
        accessibilityHint: this.props.accessibilityHint,
        accessibilityRole: this.props.accessibilityRole,
        accessibilityStates: this.props.accessibilityStates,
        style: StyleSheet.compose(this.props.style, this.state.extraUnderlayStyle),
        onLayout: this.props.onLayout,
        hitSlop: this.props.hitSlop,
        isTVSelectable: true,
        tvParallaxProperties: this.props.tvParallaxProperties,
        hasTVPreferredFocus: this.props.hasTVPreferredFocus,
        onStartShouldSetResponder: this.touchableHandleStartShouldSetResponder,
        onResponderTerminationRequest: this.touchableHandleResponderTerminationRequest,
        onResponderGrant: this.touchableHandleResponderGrant,
        onResponderMove: this.touchableHandleResponderMove,
        onResponderRelease: this.touchableHandleResponderRelease,
        onResponderTerminate: this.touchableHandleResponderTerminate,
        nativeID: this.props.nativeID,
        testID: this.props.testID,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 348
        }
      }, React.cloneElement(child, {
        style: StyleSheet.compose(child.props.style, this.state.extraChildStyle)
      }), Touchable.renderDebugView({
        color: 'green',
        hitSlop: this.props.hitSlop
      }));
    }
  });
  module.exports = TouchableHighlight;
},552,[148,156,527,161,146,149,439,150,449,457,175,522,459,465],"node_modules\\react-native\\Libraries\\Components\\Touchable\\TouchableHighlight.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function mapWithSeparator(items, itemRenderer, spacerRenderer) {
    var mapped = [];

    if (items.length > 0) {
      mapped.push(itemRenderer(items[0], 0, items));

      for (var ii = 1; ii < items.length; ii++) {
        mapped.push(spacerRenderer(ii - 1), itemRenderer(items[ii], ii, items));
      }
    }

    return mapped;
  }

  module.exports = mapWithSeparator;
},553,[],"node_modules\\react-native\\Libraries\\Utilities\\mapWithSeparator.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var getDevServer = _$$_REQUIRE(_dependencyMap[0], "getDevServer");

  function openFileInEditor(file, lineNumber) {
    fetch(getDevServer().url + 'open-stack-frame', {
      method: 'POST',
      body: JSON.stringify({
        file: file,
        lineNumber: lineNumber
      })
    });
  }

  module.exports = openFileInEditor;
},554,[193],"node_modules\\react-native\\Libraries\\Core\\Devtools\\openFileInEditor.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\NetworkOverlay.js";
  var _components = {
    NetworkOverlay: {
      displayName: "NetworkOverlay"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\NetworkOverlay.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var ListView = _$$_REQUIRE(_dependencyMap[10], "ListView");

  var React = _$$_REQUIRE(_dependencyMap[11], "React");

  var ScrollView = _$$_REQUIRE(_dependencyMap[12], "ScrollView");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[13], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[14], "Text");

  var TouchableHighlight = _$$_REQUIRE(_dependencyMap[15], "TouchableHighlight");

  var View = _$$_REQUIRE(_dependencyMap[16], "View");

  var WebSocketInterceptor = _$$_REQUIRE(_dependencyMap[17], "WebSocketInterceptor");

  var XHRInterceptor = _$$_REQUIRE(_dependencyMap[18], "XHRInterceptor");

  var LISTVIEW_CELL_HEIGHT = 15;
  var SEPARATOR_THICKNESS = 2;
  var nextXHRId = 0;

  var NetworkOverlay = function (_React$Component) {
    _inherits(NetworkOverlay, _React$Component);

    function NetworkOverlay(props) {
      var _this;

      _classCallCheck(this, NetworkOverlay);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(NetworkOverlay).call(this, props));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_requests", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_listViewDataSource", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_listView", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_listViewHighlighted", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_listViewHeight", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_scrollView", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_detailViewItems", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_listViewOnLayout", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_captureRequestListView", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_captureDetailScrollView", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_renderRow", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_closeButtonClicked", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_socketIdMap", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_xhrIdMap", void 0);

      _this._requests = [];
      _this._detailViewItems = [];
      _this._listViewDataSource = new ListView.DataSource({
        rowHasChanged: function rowHasChanged(r1, r2) {
          return r1 !== r2;
        }
      });
      _this.state = {
        dataSource: _this._listViewDataSource.cloneWithRows([]),
        newDetailInfo: false,
        detailRowID: null
      };
      _this._listViewHighlighted = false;
      _this._listViewHeight = 0;
      _this._captureRequestListView = _this._captureRequestListView.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this._captureDetailScrollView = _this._captureDetailScrollView.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this._listViewOnLayout = _this._listViewOnLayout.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this._renderRow = _this._renderRow.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this._closeButtonClicked = _this._closeButtonClicked.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this._socketIdMap = {};
      _this._xhrIdMap = {};
      return _this;
    }

    _createClass(NetworkOverlay, [{
      key: "_enableXHRInterception",
      value: function _enableXHRInterception() {
        var _this2 = this;

        if (XHRInterceptor.isInterceptorEnabled()) {
          return;
        }

        XHRInterceptor.setOpenCallback(function (method, url, xhr) {
          xhr._index = nextXHRId++;
          var xhrIndex = _this2._requests.length;
          _this2._xhrIdMap[xhr._index] = xhrIndex;
          var _xhr = {
            type: 'XMLHttpRequest',
            method: method,
            url: url
          };

          _this2._requests.push(_xhr);

          _this2._detailViewItems.push([]);

          _this2._genDetailViewItem(xhrIndex);

          _this2.setState({
            dataSource: _this2._listViewDataSource.cloneWithRows(_this2._requests)
          }, _this2._scrollToBottom());
        });
        XHRInterceptor.setRequestHeaderCallback(function (header, value, xhr) {
          var xhrIndex = _this2._getRequestIndexByXHRID(xhr._index);

          if (xhrIndex === -1) {
            return;
          }

          var networkInfo = _this2._requests[xhrIndex];

          if (!networkInfo.requestHeaders) {
            networkInfo.requestHeaders = {};
          }

          networkInfo.requestHeaders[header] = value;

          _this2._genDetailViewItem(xhrIndex);
        });
        XHRInterceptor.setSendCallback(function (data, xhr) {
          var xhrIndex = _this2._getRequestIndexByXHRID(xhr._index);

          if (xhrIndex === -1) {
            return;
          }

          _this2._requests[xhrIndex].dataSent = data;

          _this2._genDetailViewItem(xhrIndex);
        });
        XHRInterceptor.setHeaderReceivedCallback(function (type, size, responseHeaders, xhr) {
          var xhrIndex = _this2._getRequestIndexByXHRID(xhr._index);

          if (xhrIndex === -1) {
            return;
          }

          var networkInfo = _this2._requests[xhrIndex];
          networkInfo.responseContentType = type;
          networkInfo.responseSize = size;
          networkInfo.responseHeaders = responseHeaders;

          _this2._genDetailViewItem(xhrIndex);
        });
        XHRInterceptor.setResponseCallback(function (status, timeout, response, responseURL, responseType, xhr) {
          var xhrIndex = _this2._getRequestIndexByXHRID(xhr._index);

          if (xhrIndex === -1) {
            return;
          }

          var networkInfo = _this2._requests[xhrIndex];
          networkInfo.status = status;
          networkInfo.timeout = timeout;
          networkInfo.response = response;
          networkInfo.responseURL = responseURL;
          networkInfo.responseType = responseType;

          _this2._genDetailViewItem(xhrIndex);
        });
        XHRInterceptor.enableInterception();
      }
    }, {
      key: "_enableWebSocketInterception",
      value: function _enableWebSocketInterception() {
        var _this3 = this;

        if (WebSocketInterceptor.isInterceptorEnabled()) {
          return;
        }

        WebSocketInterceptor.setConnectCallback(function (url, protocols, options, socketId) {
          var socketIndex = _this3._requests.length;
          _this3._socketIdMap[socketId] = socketIndex;
          var _webSocket = {
            type: 'WebSocket',
            url: url,
            protocols: protocols
          };

          _this3._requests.push(_webSocket);

          _this3._detailViewItems.push([]);

          _this3._genDetailViewItem(socketIndex);

          _this3.setState({
            dataSource: _this3._listViewDataSource.cloneWithRows(_this3._requests)
          }, _this3._scrollToBottom());
        });
        WebSocketInterceptor.setCloseCallback(function (statusCode, closeReason, socketId) {
          var socketIndex = _this3._socketIdMap[socketId];

          if (socketIndex === undefined) {
            return;
          }

          if (statusCode !== null && closeReason !== null) {
            _this3._requests[socketIndex].status = statusCode;
            _this3._requests[socketIndex].closeReason = closeReason;
          }

          _this3._genDetailViewItem(socketIndex);
        });
        WebSocketInterceptor.setSendCallback(function (data, socketId) {
          var socketIndex = _this3._socketIdMap[socketId];

          if (socketIndex === undefined) {
            return;
          }

          if (!_this3._requests[socketIndex].messages) {
            _this3._requests[socketIndex].messages = '';
          }

          _this3._requests[socketIndex].messages += 'Sent: ' + JSON.stringify(data) + '\n';

          _this3._genDetailViewItem(socketIndex);
        });
        WebSocketInterceptor.setOnMessageCallback(function (socketId, message) {
          var socketIndex = _this3._socketIdMap[socketId];

          if (socketIndex === undefined) {
            return;
          }

          if (!_this3._requests[socketIndex].messages) {
            _this3._requests[socketIndex].messages = '';
          }

          _this3._requests[socketIndex].messages += 'Received: ' + JSON.stringify(message) + '\n';

          _this3._genDetailViewItem(socketIndex);
        });
        WebSocketInterceptor.setOnCloseCallback(function (socketId, message) {
          var socketIndex = _this3._socketIdMap[socketId];

          if (socketIndex === undefined) {
            return;
          }

          _this3._requests[socketIndex].serverClose = message;

          _this3._genDetailViewItem(socketIndex);
        });
        WebSocketInterceptor.setOnErrorCallback(function (socketId, message) {
          var socketIndex = _this3._socketIdMap[socketId];

          if (socketIndex === undefined) {
            return;
          }

          _this3._requests[socketIndex].serverError = message;

          _this3._genDetailViewItem(socketIndex);
        });
        WebSocketInterceptor.enableInterception();
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this._enableXHRInterception();

        this._enableWebSocketInterception();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        XHRInterceptor.disableInterception();
        WebSocketInterceptor.disableInterception();
      }
    }, {
      key: "_renderRow",
      value: function _renderRow(rowData, sectionID, rowID, highlightRow) {
        var _this4 = this;

        var urlCellViewStyle = styles.urlEvenCellView;
        var methodCellViewStyle = styles.methodEvenCellView;

        if (rowID % 2 === 1) {
          urlCellViewStyle = styles.urlOddCellView;
          methodCellViewStyle = styles.methodOddCellView;
        }

        return React.createElement(TouchableHighlight, {
          onPress: function onPress() {
            _this4._pressRow(rowID);

            highlightRow(sectionID, rowID);
          },
          __source: {
            fileName: _jsxFileName,
            lineNumber: 297
          }
        }, React.createElement(View, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 302
          }
        }, React.createElement(View, {
          style: styles.tableRow,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 303
          }
        }, React.createElement(View, {
          style: urlCellViewStyle,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 304
          }
        }, React.createElement(Text, {
          style: styles.cellText,
          numberOfLines: 1,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 305
          }
        }, rowData.url)), React.createElement(View, {
          style: methodCellViewStyle,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 309
          }
        }, React.createElement(Text, {
          style: styles.cellText,
          numberOfLines: 1,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 310
          }
        }, this._getTypeShortName(rowData.type))))));
      }
    }, {
      key: "_renderSeperator",
      value: function _renderSeperator(sectionID, rowID, adjacentRowHighlighted) {
        return React.createElement(View, {
          key: sectionID + "-" + rowID,
          style: {
            height: adjacentRowHighlighted ? SEPARATOR_THICKNESS : 0,
            backgroundColor: adjacentRowHighlighted ? '#3B5998' : '#CCCCCC'
          },
          __source: {
            fileName: _jsxFileName,
            lineNumber: 326
          }
        });
      }
    }, {
      key: "_scrollToBottom",
      value: function _scrollToBottom() {
        if (this._listView) {
          var scrollResponder = this._listView.getScrollResponder();

          if (scrollResponder) {
            var scrollY = Math.max(this._requests.length * LISTVIEW_CELL_HEIGHT + (this._listViewHighlighted ? 2 * SEPARATOR_THICKNESS : 0) - this._listViewHeight, 0);
            scrollResponder.scrollResponderScrollTo({
              x: 0,
              y: scrollY,
              animated: true
            });
          }
        }
      }
    }, {
      key: "_captureRequestListView",
      value: function _captureRequestListView(listRef) {
        this._listView = listRef;
      }
    }, {
      key: "_listViewOnLayout",
      value: function _listViewOnLayout(event) {
        var height = event.nativeEvent.layout.height;
        this._listViewHeight = height;
      }
    }, {
      key: "_pressRow",
      value: function _pressRow(rowID) {
        this._listViewHighlighted = true;
        this.setState({
          detailRowID: rowID
        }, this._scrollToTop());
      }
    }, {
      key: "_scrollToTop",
      value: function _scrollToTop() {
        if (this._scrollView) {
          this._scrollView.scrollTo({
            y: 0,
            animated: false
          });
        }
      }
    }, {
      key: "_captureDetailScrollView",
      value: function _captureDetailScrollView(scrollRef) {
        this._scrollView = scrollRef;
      }
    }, {
      key: "_closeButtonClicked",
      value: function _closeButtonClicked() {
        this.setState({
          detailRowID: null
        });
      }
    }, {
      key: "_getStringByValue",
      value: function _getStringByValue(value) {
        if (value === undefined) {
          return 'undefined';
        }

        if (typeof value === 'object') {
          return JSON.stringify(value);
        }

        if (typeof value === 'string' && value.length > 500) {
          return String(value).substr(0, 500).concat('\n***TRUNCATED TO 500 CHARACTERS***');
        }

        return value;
      }
    }, {
      key: "_getRequestIndexByXHRID",
      value: function _getRequestIndexByXHRID(index) {
        if (index === undefined) {
          return -1;
        }

        var xhrIndex = this._xhrIdMap[index];

        if (xhrIndex === undefined) {
          return -1;
        } else {
          return xhrIndex;
        }
      }
    }, {
      key: "_getTypeShortName",
      value: function _getTypeShortName(type) {
        if (type === 'XMLHttpRequest') {
          return 'XHR';
        } else if (type === 'WebSocket') {
          return 'WS';
        }

        return '';
      }
    }, {
      key: "_genDetailViewItem",
      value: function _genDetailViewItem(index) {
        this._detailViewItems[index] = [];
        var detailViewItem = this._detailViewItems[index];
        var requestItem = this._requests[index];

        for (var _key in requestItem) {
          detailViewItem.push(React.createElement(View, {
            style: styles.detailViewRow,
            key: _key,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 439
            }
          }, React.createElement(Text, {
            style: [styles.detailViewText, styles.detailKeyCellView],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 440
            }
          }, _key), React.createElement(Text, {
            style: [styles.detailViewText, styles.detailValueCellView],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 443
            }
          }, this._getStringByValue(requestItem[_key]))));
        }

        if (this.state.detailRowID != null && Number(this.state.detailRowID) === index) {
          this.setState({
            newDetailInfo: true
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        return React.createElement(View, {
          style: styles.container,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 460
          }
        }, this.state.detailRowID != null && React.createElement(TouchableHighlight, {
          style: styles.closeButton,
          onPress: this._closeButtonClicked,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 462
          }
        }, React.createElement(View, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 465
          }
        }, React.createElement(Text, {
          style: styles.clostButtonText,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 466
          }
        }, "v"))), this.state.detailRowID != null && React.createElement(ScrollView, {
          style: styles.detailScrollView,
          ref: this._captureDetailScrollView,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 471
          }
        }, this._detailViewItems[this.state.detailRowID]), React.createElement(View, {
          style: styles.listViewTitle,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 477
          }
        }, this._requests.length > 0 && React.createElement(View, {
          style: styles.tableRow,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 479
          }
        }, React.createElement(View, {
          style: styles.urlTitleCellView,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 480
          }
        }, React.createElement(Text, {
          style: styles.cellText,
          numberOfLines: 1,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 481
          }
        }, "URL")), React.createElement(View, {
          style: styles.methodTitleCellView,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 485
          }
        }, React.createElement(Text, {
          style: styles.cellText,
          numberOfLines: 1,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 486
          }
        }, "Type")))), React.createElement(ListView, {
          style: styles.listView,
          ref: this._captureRequestListView,
          dataSource: this.state.dataSource,
          renderRow: this._renderRow,
          enableEmptySections: true,
          renderSeparator: this._renderSeperator,
          onLayout: this._listViewOnLayout,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 493
          }
        }));
      }
    }]);

    return NetworkOverlay;
  }(React.Component);

  NetworkOverlay = _wrapComponent("NetworkOverlay")(NetworkOverlay);
  var styles = StyleSheet.create({
    container: {
      paddingTop: 10,
      paddingBottom: 10,
      paddingLeft: 5,
      paddingRight: 5
    },
    listViewTitle: {
      height: 20
    },
    listView: {
      flex: 1,
      height: 60
    },
    tableRow: {
      flexDirection: 'row',
      flex: 1
    },
    cellText: {
      color: 'white',
      fontSize: 12
    },
    methodTitleCellView: {
      height: 18,
      borderColor: '#DCD7CD',
      borderTopWidth: 1,
      borderBottomWidth: 1,
      borderRightWidth: 1,
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: '#444',
      flex: 1
    },
    urlTitleCellView: {
      height: 18,
      borderColor: '#DCD7CD',
      borderTopWidth: 1,
      borderBottomWidth: 1,
      borderLeftWidth: 1,
      borderRightWidth: 1,
      justifyContent: 'center',
      backgroundColor: '#444',
      flex: 5,
      paddingLeft: 3
    },
    methodOddCellView: {
      height: 15,
      borderColor: '#DCD7CD',
      borderRightWidth: 1,
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: '#000',
      flex: 1
    },
    urlOddCellView: {
      height: 15,
      borderColor: '#DCD7CD',
      borderLeftWidth: 1,
      borderRightWidth: 1,
      justifyContent: 'center',
      backgroundColor: '#000',
      flex: 5,
      paddingLeft: 3
    },
    methodEvenCellView: {
      height: 15,
      borderColor: '#DCD7CD',
      borderRightWidth: 1,
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: '#888',
      flex: 1
    },
    urlEvenCellView: {
      height: 15,
      borderColor: '#DCD7CD',
      borderLeftWidth: 1,
      borderRightWidth: 1,
      justifyContent: 'center',
      backgroundColor: '#888',
      flex: 5,
      paddingLeft: 3
    },
    detailScrollView: {
      flex: 1,
      height: 180,
      marginTop: 5,
      marginBottom: 5
    },
    detailKeyCellView: {
      flex: 1.3
    },
    detailValueCellView: {
      flex: 2
    },
    detailViewRow: {
      flexDirection: 'row',
      paddingHorizontal: 3
    },
    detailViewText: {
      color: 'white',
      fontSize: 11
    },
    clostButtonText: {
      color: 'white',
      fontSize: 10
    },
    closeButton: {
      marginTop: 5,
      backgroundColor: '#888',
      justifyContent: 'center',
      alignItems: 'center'
    }
  });
  module.exports = NetworkOverlay;
},555,[23,24,25,26,29,30,28,32,109,280,499,149,503,150,444,552,175,556,557],"node_modules\\react-native\\Libraries\\Inspector\\NetworkOverlay.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var RCTWebSocketModule = _$$_REQUIRE(_dependencyMap[0], "NativeModules").WebSocketModule;

  var NativeEventEmitter = _$$_REQUIRE(_dependencyMap[1], "NativeEventEmitter");

  var base64 = _$$_REQUIRE(_dependencyMap[2], "base64-js");

  var originalRCTWebSocketConnect = RCTWebSocketModule.connect;
  var originalRCTWebSocketSend = RCTWebSocketModule.send;
  var originalRCTWebSocketSendBinary = RCTWebSocketModule.sendBinary;
  var originalRCTWebSocketClose = RCTWebSocketModule.close;
  var eventEmitter;
  var subscriptions;
  var closeCallback;
  var sendCallback;
  var connectCallback;
  var onOpenCallback;
  var onMessageCallback;
  var onErrorCallback;
  var onCloseCallback;
  var _isInterceptorEnabled = false;
  var WebSocketInterceptor = {
    setCloseCallback: function setCloseCallback(callback) {
      closeCallback = callback;
    },
    setSendCallback: function setSendCallback(callback) {
      sendCallback = callback;
    },
    setConnectCallback: function setConnectCallback(callback) {
      connectCallback = callback;
    },
    setOnOpenCallback: function setOnOpenCallback(callback) {
      onOpenCallback = callback;
    },
    setOnMessageCallback: function setOnMessageCallback(callback) {
      onMessageCallback = callback;
    },
    setOnErrorCallback: function setOnErrorCallback(callback) {
      onErrorCallback = callback;
    },
    setOnCloseCallback: function setOnCloseCallback(callback) {
      onCloseCallback = callback;
    },
    isInterceptorEnabled: function isInterceptorEnabled() {
      return _isInterceptorEnabled;
    },
    _unregisterEvents: function _unregisterEvents() {
      subscriptions.forEach(function (e) {
        return e.remove();
      });
      subscriptions = [];
    },
    _registerEvents: function _registerEvents() {
      subscriptions = [eventEmitter.addListener('websocketMessage', function (ev) {
        if (onMessageCallback) {
          onMessageCallback(ev.id, ev.type === 'binary' ? WebSocketInterceptor._arrayBufferToString(ev.data) : ev.data);
        }
      }), eventEmitter.addListener('websocketOpen', function (ev) {
        if (onOpenCallback) {
          onOpenCallback(ev.id);
        }
      }), eventEmitter.addListener('websocketClosed', function (ev) {
        if (onCloseCallback) {
          onCloseCallback(ev.id, {
            code: ev.code,
            reason: ev.reason
          });
        }
      }), eventEmitter.addListener('websocketFailed', function (ev) {
        if (onErrorCallback) {
          onErrorCallback(ev.id, {
            message: ev.message
          });
        }
      })];
    },
    enableInterception: function enableInterception() {
      if (_isInterceptorEnabled) {
        return;
      }

      eventEmitter = new NativeEventEmitter(RCTWebSocketModule);

      WebSocketInterceptor._registerEvents();

      RCTWebSocketModule.connect = function (url, protocols, options, socketId) {
        if (connectCallback) {
          connectCallback(url, protocols, options, socketId);
        }

        originalRCTWebSocketConnect.apply(this, arguments);
      };

      RCTWebSocketModule.send = function (data, socketId) {
        if (sendCallback) {
          sendCallback(data, socketId);
        }

        originalRCTWebSocketSend.apply(this, arguments);
      };

      RCTWebSocketModule.sendBinary = function (data, socketId) {
        if (sendCallback) {
          sendCallback(WebSocketInterceptor._arrayBufferToString(data), socketId);
        }

        originalRCTWebSocketSendBinary.apply(this, arguments);
      };

      RCTWebSocketModule.close = function () {
        if (closeCallback) {
          if (arguments.length === 3) {
            closeCallback(arguments[0], arguments[1], arguments[2]);
          } else {
            closeCallback(null, null, arguments[0]);
          }
        }

        originalRCTWebSocketClose.apply(this, arguments);
      };

      _isInterceptorEnabled = true;
    },
    _arrayBufferToString: function _arrayBufferToString(data) {
      var value = base64.toByteArray(data).buffer;

      if (value === undefined || value === null) {
        return '(no value)';
      }

      if (typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && value instanceof ArrayBuffer) {
        return "ArrayBuffer {" + String(Array.from(new Uint8Array(value))) + "}";
      }

      return value;
    },
    disableInterception: function disableInterception() {
      if (!_isInterceptorEnabled) {
        return;
      }

      _isInterceptorEnabled = false;
      RCTWebSocketModule.send = originalRCTWebSocketSend;
      RCTWebSocketModule.sendBinary = originalRCTWebSocketSendBinary;
      RCTWebSocketModule.close = originalRCTWebSocketClose;
      RCTWebSocketModule.connect = originalRCTWebSocketConnect;
      connectCallback = null;
      closeCallback = null;
      sendCallback = null;
      onOpenCallback = null;
      onMessageCallback = null;
      onCloseCallback = null;
      onErrorCallback = null;

      WebSocketInterceptor._unregisterEvents();
    }
  };
  module.exports = WebSocketInterceptor;
},556,[119,219,222],"node_modules\\react-native\\Libraries\\WebSocket\\WebSocketInterceptor.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var XMLHttpRequest = _$$_REQUIRE(_dependencyMap[0], "XMLHttpRequest");

  var originalXHROpen = XMLHttpRequest.prototype.open;
  var originalXHRSend = XMLHttpRequest.prototype.send;
  var originalXHRSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
  var openCallback;
  var sendCallback;
  var requestHeaderCallback;
  var headerReceivedCallback;
  var responseCallback;
  var _isInterceptorEnabled = false;
  var XHRInterceptor = {
    setOpenCallback: function setOpenCallback(callback) {
      openCallback = callback;
    },
    setSendCallback: function setSendCallback(callback) {
      sendCallback = callback;
    },
    setHeaderReceivedCallback: function setHeaderReceivedCallback(callback) {
      headerReceivedCallback = callback;
    },
    setResponseCallback: function setResponseCallback(callback) {
      responseCallback = callback;
    },
    setRequestHeaderCallback: function setRequestHeaderCallback(callback) {
      requestHeaderCallback = callback;
    },
    isInterceptorEnabled: function isInterceptorEnabled() {
      return _isInterceptorEnabled;
    },
    enableInterception: function enableInterception() {
      if (_isInterceptorEnabled) {
        return;
      }

      XMLHttpRequest.prototype.open = function (method, url) {
        if (openCallback) {
          openCallback(method, url, this);
        }

        originalXHROpen.apply(this, arguments);
      };

      XMLHttpRequest.prototype.setRequestHeader = function (header, value) {
        if (requestHeaderCallback) {
          requestHeaderCallback(header, value, this);
        }

        originalXHRSetRequestHeader.apply(this, arguments);
      };

      XMLHttpRequest.prototype.send = function (data) {
        var _this = this;

        if (sendCallback) {
          sendCallback(data, this);
        }

        if (this.addEventListener) {
          this.addEventListener('readystatechange', function () {
            if (!_isInterceptorEnabled) {
              return;
            }

            if (_this.readyState === _this.HEADERS_RECEIVED) {
              var contentTypeString = _this.getResponseHeader('Content-Type');

              var contentLengthString = _this.getResponseHeader('Content-Length');

              var responseContentType, responseSize;

              if (contentTypeString) {
                responseContentType = contentTypeString.split(';')[0];
              }

              if (contentLengthString) {
                responseSize = parseInt(contentLengthString, 10);
              }

              if (headerReceivedCallback) {
                headerReceivedCallback(responseContentType, responseSize, _this.getAllResponseHeaders(), _this);
              }
            }

            if (_this.readyState === _this.DONE) {
              if (responseCallback) {
                responseCallback(_this.status, _this.timeout, _this.response, _this.responseURL, _this.responseType, _this);
              }
            }
          }, false);
        }

        originalXHRSend.apply(this, arguments);
      };

      _isInterceptorEnabled = true;
    },
    disableInterception: function disableInterception() {
      if (!_isInterceptorEnabled) {
        return;
      }

      _isInterceptorEnabled = false;
      XMLHttpRequest.prototype.send = originalXHRSend;
      XMLHttpRequest.prototype.open = originalXHROpen;
      XMLHttpRequest.prototype.setRequestHeader = originalXHRSetRequestHeader;
      responseCallback = null;
      openCallback = null;
      sendCallback = null;
      headerReceivedCallback = null;
      requestHeaderCallback = null;
    }
  };
  module.exports = XHRInterceptor;
},557,[212],"node_modules\\react-native\\Libraries\\Network\\XHRInterceptor.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\PerformanceOverlay.js";
  var _components = {
    PerformanceOverlay: {
      displayName: "PerformanceOverlay"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Inspector\\PerformanceOverlay.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var PerformanceLogger = _$$_REQUIRE(_dependencyMap[8], "PerformanceLogger");

  var React = _$$_REQUIRE(_dependencyMap[9], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[10], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[11], "Text");

  var View = _$$_REQUIRE(_dependencyMap[12], "View");

  var PerformanceOverlay = function (_React$Component) {
    _inherits(PerformanceOverlay, _React$Component);

    function PerformanceOverlay() {
      _classCallCheck(this, PerformanceOverlay);

      return _possibleConstructorReturn(this, _getPrototypeOf(PerformanceOverlay).apply(this, arguments));
    }

    _createClass(PerformanceOverlay, [{
      key: "render",
      value: function render() {
        var perfLogs = PerformanceLogger.getTimespans();
        var items = [];

        for (var key in perfLogs) {
          if (perfLogs[key].totalTime) {
            var unit = key === 'BundleSize' ? 'b' : 'ms';
            items.push(React.createElement(View, {
              style: styles.row,
              key: key,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 28
              }
            }, React.createElement(Text, {
              style: [styles.text, styles.label],
              __source: {
                fileName: _jsxFileName,
                lineNumber: 29
              }
            }, key), React.createElement(Text, {
              style: [styles.text, styles.totalTime],
              __source: {
                fileName: _jsxFileName,
                lineNumber: 30
              }
            }, perfLogs[key].totalTime + unit)));
          }
        }

        return React.createElement(View, {
          style: styles.container,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 38
          }
        }, items);
      }
    }]);

    return PerformanceOverlay;
  }(React.Component);

  PerformanceOverlay = _wrapComponent("PerformanceOverlay")(PerformanceOverlay);
  var styles = StyleSheet.create({
    container: {
      height: 100,
      paddingTop: 10
    },
    label: {
      flex: 1
    },
    row: {
      flexDirection: 'row',
      paddingHorizontal: 10
    },
    text: {
      color: 'white',
      fontSize: 12
    },
    totalTime: {
      paddingRight: 100
    }
  });
  module.exports = PerformanceOverlay;
},558,[23,24,25,26,29,30,109,280,241,149,150,444,175],"node_modules\\react-native\\Libraries\\Inspector\\PerformanceOverlay.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "./../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\YellowBox\\YellowBox.js";
  var _components = {
    YellowBox: {
      displayName: "YellowBox"
    },
    _component: {}
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\YellowBox\\YellowBox.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var React = _$$_REQUIRE(_dependencyMap[10], "React");

  var YellowBox;

  if (__DEV__) {
    var Platform = _$$_REQUIRE(_dependencyMap[11], "Platform");

    var RCTLog = _$$_REQUIRE(_dependencyMap[12], "RCTLog");

    var YellowBoxList = _$$_REQUIRE(_dependencyMap[13], "YellowBoxList");

    var YellowBoxRegistry = _$$_REQUIRE(_dependencyMap[14], "YellowBoxRegistry");

    var _console = console,
        error = _console.error,
        warn = _console.warn;
    YellowBox = _wrapComponent("YellowBox")(function (_React$Component) {
      _inherits(YellowBox, _React$Component);

      function YellowBox() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck(this, YellowBox);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(YellowBox)).call.apply(_getPrototypeOf2, [this].concat(args)));

        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_subscription", void 0);

        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
          registry: null
        });

        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handleDismiss", function (category) {
          YellowBoxRegistry.delete(category);
        });

        return _this;
      }

      _createClass(YellowBox, [{
        key: "render",
        value: function render() {
          return this.state.registry == null ? null : React.createElement(YellowBoxList, {
            onDismiss: this._handleDismiss,
            onDismissAll: this._handleDismissAll,
            registry: this.state.registry,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 104
            }
          });
        }
      }, {
        key: "componentDidMount",
        value: function componentDidMount() {
          var _this2 = this;

          this._subscription = YellowBoxRegistry.observe(function (registry) {
            _this2.setState({
              registry: registry
            });
          });
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          if (this._subscription != null) {
            this._subscription.unsubscribe();
          }
        }
      }, {
        key: "_handleDismissAll",
        value: function _handleDismissAll() {
          YellowBoxRegistry.clear();
        }
      }], [{
        key: "ignoreWarnings",
        value: function ignoreWarnings(patterns) {
          YellowBoxRegistry.addIgnorePatterns(patterns);
        }
      }, {
        key: "install",
        value: function install() {
          console.error = function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            error.call.apply(error, [console].concat(args));

            if (typeof args[0] === 'string' && args[0].startsWith('Warning: ')) {
              registerWarning.apply(void 0, args);
            }
          };

          console.warn = function () {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }

            warn.call.apply(warn, [console].concat(args));
            registerWarning.apply(void 0, args);
          };

          if (console.disableYellowBox === true) {
            YellowBoxRegistry.setDisabled(true);
          }

          Object.defineProperty(console, 'disableYellowBox', {
            configurable: true,
            get: function get() {
              return YellowBoxRegistry.isDisabled();
            },
            set: function set(value) {
              return YellowBoxRegistry.setDisabled(value);
            }
          });

          if (Platform.isTesting) {
            console.disableYellowBox = true;
          }

          RCTLog.setWarningHandler(function () {
            registerWarning.apply(void 0, arguments);
          });
        }
      }, {
        key: "uninstall",
        value: function uninstall() {
          console.error = error;
          console.warn = error;
          delete console.disableYellowBox;
        }
      }]);

      return YellowBox;
    }(React.Component));

    var registerWarning = function registerWarning() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      YellowBoxRegistry.add({
        args: args,
        framesToPop: 2
      });
    };
  } else {
    YellowBox = _wrapComponent("_component")(function (_React$Component2) {
      _inherits(_class2, _React$Component2);

      function _class2() {
        _classCallCheck(this, _class2);

        return _possibleConstructorReturn(this, _getPrototypeOf(_class2).apply(this, arguments));
      }

      _createClass(_class2, [{
        key: "render",
        value: function render() {
          return null;
        }
      }], [{
        key: "ignoreWarnings",
        value: function ignoreWarnings(patterns) {}
      }, {
        key: "install",
        value: function install() {}
      }, {
        key: "uninstall",
        value: function uninstall() {}
      }]);

      return _class2;
    }(React.Component));
  }

  module.exports = YellowBox;
},559,[23,24,25,26,29,30,28,32,109,280,149,146,239,560,576],"node_modules\\react-native\\Libraries\\YellowBox\\YellowBox.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var _slicedToArray = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/slicedToArray");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxList.js";
  var _components = {
    YellowBoxList: {
      displayName: "YellowBoxList"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxList.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var Dimensions = _$$_REQUIRE(_dependencyMap[12], "Dimensions");

  var React = _$$_REQUIRE(_dependencyMap[13], "React");

  var FlatList = _$$_REQUIRE(_dependencyMap[14], "FlatList");

  var SafeAreaView = _$$_REQUIRE(_dependencyMap[15], "SafeAreaView");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[16], "StyleSheet");

  var View = _$$_REQUIRE(_dependencyMap[17], "View");

  var YellowBoxButton = _$$_REQUIRE(_dependencyMap[18], "YellowBoxButton");

  var YellowBoxInspector = _$$_REQUIRE(_dependencyMap[19], "YellowBoxInspector");

  var YellowBoxListRow = _$$_REQUIRE(_dependencyMap[20], "YellowBoxListRow");

  var YellowBoxStyle = _$$_REQUIRE(_dependencyMap[21], "YellowBoxStyle");

  var VIEWPORT_RATIO = 0.5;
  var MAX_ITEMS = Math.floor(Dimensions.get('window').height * VIEWPORT_RATIO / (YellowBoxListRow.GUTTER + YellowBoxListRow.HEIGHT));

  var YellowBoxList = function (_React$Component) {
    _inherits(YellowBoxList, _React$Component);

    function YellowBoxList() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, YellowBoxList);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(YellowBoxList)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
        selectedCategory: null
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handleInspectorDismiss", function () {
        var category = _this.state.selectedCategory;

        if (category == null) {
          return;
        }

        _this.setState({
          selectedCategory: null
        }, function () {
          _this.props.onDismiss(category);
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handleInspectorMinimize", function () {
        _this.setState({
          selectedCategory: null
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handleRowPress", function (category) {
        _this.setState({
          selectedCategory: category
        });
      });

      return _this;
    }

    _createClass(YellowBoxList, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var selectedWarnings = this.state.selectedCategory == null ? null : this.props.registry.get(this.state.selectedCategory);

        if (selectedWarnings != null) {
          return React.createElement(View, {
            style: StyleSheet.absoluteFill,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 56
            }
          }, React.createElement(YellowBoxInspector, {
            onDismiss: this._handleInspectorDismiss,
            onMinimize: this._handleInspectorMinimize,
            warnings: selectedWarnings,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 57
            }
          }));
        }

        var items = [];

        for (var _iterator = this.props.registry, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
          var _ref3;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref3 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref3 = _i.value;
          }

          var _ref5 = _ref3;

          var _ref2 = _slicedToArray(_ref5, 2);

          var _category2 = _ref2[0];
          var _warnings = _ref2[1];
          items.unshift({
            category: _category2,
            warnings: _warnings
          });
        }

        var listStyle = {
          height: Math.min(items.length, MAX_ITEMS + 0.5) * (YellowBoxListRow.GUTTER + YellowBoxListRow.HEIGHT)
        };
        return items.length === 0 ? null : React.createElement(View, {
          style: styles.list,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 79
          }
        }, React.createElement(View, {
          pointerEvents: "box-none",
          style: styles.dismissAll,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 80
          }
        }, React.createElement(YellowBoxButton, {
          hitSlop: {
            bottom: 4,
            left: 4,
            right: 4,
            top: 4
          },
          label: "Dismiss All",
          onPress: this.props.onDismissAll,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 81
          }
        })), React.createElement(FlatList, {
          data: items,
          keyExtractor: function keyExtractor(item) {
            return item.category;
          },
          renderItem: function renderItem(_ref4) {
            var item = _ref4.item;
            return React.createElement(YellowBoxListRow, _extends({}, item, {
              onPress: _this2._handleRowPress,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 91
              }
            }));
          },
          scrollEnabled: items.length > MAX_ITEMS,
          scrollsToTop: false,
          style: listStyle,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 87
          }
        }), React.createElement(SafeAreaView, {
          style: styles.safeArea,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 97
          }
        }));
      }
    }]);

    return YellowBoxList;
  }(React.Component);

  YellowBoxList = _wrapComponent("YellowBoxList")(YellowBoxList);
  var styles = StyleSheet.create({
    list: {
      bottom: 0,
      position: 'absolute',
      width: '100%'
    },
    dismissAll: {
      bottom: '100%',
      flexDirection: 'row',
      justifyContent: 'flex-end',
      paddingBottom: 4,
      paddingEnd: 4,
      position: 'absolute',
      width: '100%'
    },
    safeArea: {
      backgroundColor: YellowBoxStyle.getBackgroundColor(0.95),
      marginTop: StyleSheet.hairlineWidth
    }
  });
  module.exports = YellowBoxList;
},560,[23,112,122,24,25,26,29,30,28,32,109,280,152,149,497,561,150,175,562,565,573,564],"node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxList.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = _$$_REQUIRE(_dependencyMap[0], "View");
},561,[175],"node_modules\\react-native\\Libraries\\Components\\SafeAreaView\\SafeAreaView.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxButton.js";

  var React = _$$_REQUIRE(_dependencyMap[0], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[1], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[2], "Text");

  var YellowBoxPressable = _$$_REQUIRE(_dependencyMap[3], "YellowBoxPressable");

  var YellowBoxStyle = _$$_REQUIRE(_dependencyMap[4], "YellowBoxStyle");

  var YellowBoxButton = function YellowBoxButton(props) {
    return React.createElement(YellowBoxPressable, {
      hitSlop: props.hitSlop,
      onPress: props.onPress,
      style: styles.root,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 28
      }
    }, React.createElement(Text, {
      numberOfLines: 1,
      style: styles.label,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 32
      }
    }, props.label));
  };

  var styles = StyleSheet.create({
    root: {
      borderRadius: 14,
      height: 28,
      justifyContent: 'center',
      paddingHorizontal: 12
    },
    label: {
      color: YellowBoxStyle.getTextColor(1),
      fontSize: 12,
      includeFontPadding: false,
      lineHeight: 16
    }
  });
  module.exports = YellowBoxButton;
},562,[149,150,444,563,564],"node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxButton.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxPressable.js";
  var _components = {
    YellowBoxPressable: {
      displayName: "YellowBoxPressable"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxPressable.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var React = _$$_REQUIRE(_dependencyMap[10], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[11], "StyleSheet");

  var TouchableWithoutFeedback = _$$_REQUIRE(_dependencyMap[12], "TouchableWithoutFeedback");

  var View = _$$_REQUIRE(_dependencyMap[13], "View");

  var YellowBoxStyle = _$$_REQUIRE(_dependencyMap[14], "YellowBoxStyle");

  var YellowBoxPressable = function (_React$Component) {
    _inherits(YellowBoxPressable, _React$Component);

    function YellowBoxPressable() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, YellowBoxPressable);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(YellowBoxPressable)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
        pressed: false
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handlePressIn", function () {
        _this.setState({
          pressed: true
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handlePressOut", function () {
        _this.setState({
          pressed: false
        });
      });

      return _this;
    }

    _createClass(YellowBoxPressable, [{
      key: "render",
      value: function render() {
        var content = React.createElement(View, {
          style: StyleSheet.compose({
            backgroundColor: this.state.pressed ? this.props.backgroundColor.pressed : this.props.backgroundColor.default
          }, this.props.style),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 52
          }
        }, this.props.children);
        return this.props.onPress == null ? content : React.createElement(TouchableWithoutFeedback, {
          hitSlop: this.props.hitSlop,
          onPress: this.props.onPress,
          onPressIn: this._handlePressIn,
          onPressOut: this._handlePressOut,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 67
          }
        }, content);
      }
    }]);

    return YellowBoxPressable;
  }(React.Component);

  _defineProperty(YellowBoxPressable, "defaultProps", {
    backgroundColor: {
      default: YellowBoxStyle.getBackgroundColor(0.95),
      pressed: YellowBoxStyle.getHighlightColor(1)
    }
  });

  YellowBoxPressable = _wrapComponent("YellowBoxPressable")(YellowBoxPressable);
  module.exports = YellowBoxPressable;
},563,[23,24,25,26,29,30,28,32,109,280,149,150,457,175,564],"node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxPressable.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var YellowBoxStyle = {
    getBackgroundColor: function getBackgroundColor(opacity) {
      return "rgba(250, 186, 48, " + opacity + ")";
    },
    getDividerColor: function getDividerColor(opacity) {
      return "rgba(255, 255, 255, " + opacity + ")";
    },
    getHighlightColor: function getHighlightColor(opacity) {
      return "rgba(252, 176, 29, " + opacity + ")";
    },
    getTextColor: function getTextColor(opacity) {
      return "rgba(255, 255, 255, " + opacity + ")";
    }
  };
  module.exports = YellowBoxStyle;
},564,[],"node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxStyle.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxInspector.js";
  var _components = {
    YellowBoxInspector: {
      displayName: "YellowBoxInspector"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxInspector.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var Platform = _$$_REQUIRE(_dependencyMap[10], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[11], "React");

  var ScrollView = _$$_REQUIRE(_dependencyMap[12], "ScrollView");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[13], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[14], "Text");

  var View = _$$_REQUIRE(_dependencyMap[15], "View");

  var YellowBoxCategory = _$$_REQUIRE(_dependencyMap[16], "YellowBoxCategory");

  var YellowBoxInspectorFooter = _$$_REQUIRE(_dependencyMap[17], "YellowBoxInspectorFooter");

  var YellowBoxInspectorHeader = _$$_REQUIRE(_dependencyMap[18], "YellowBoxInspectorHeader");

  var YellowBoxInspectorSourceMapStatus = _$$_REQUIRE(_dependencyMap[19], "YellowBoxInspectorSourceMapStatus");

  var YellowBoxInspectorStackFrame = _$$_REQUIRE(_dependencyMap[20], "YellowBoxInspectorStackFrame");

  var YellowBoxStyle = _$$_REQUIRE(_dependencyMap[21], "YellowBoxStyle");

  var openFileInEditor = _$$_REQUIRE(_dependencyMap[22], "openFileInEditor");

  var YellowBoxInspector = function (_React$Component) {
    _inherits(YellowBoxInspector, _React$Component);

    function YellowBoxInspector() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, YellowBoxInspector);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(YellowBoxInspector)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_symbolication", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
        selectedIndex: 0
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handleSelectIndex", function (selectedIndex) {
        _this.setState({
          selectedIndex: selectedIndex
        });
      });

      return _this;
    }

    _createClass(YellowBoxInspector, [{
      key: "render",
      value: function render() {
        var warnings = this.props.warnings;
        var selectedIndex = this.state.selectedIndex;
        var warning = warnings[selectedIndex];
        return React.createElement(View, {
          style: styles.root,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 55
          }
        }, React.createElement(YellowBoxInspectorHeader, {
          onSelectIndex: this._handleSelectIndex,
          selectedIndex: selectedIndex,
          warnings: warnings,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 56
          }
        }), React.createElement(ScrollView, {
          contentContainerStyle: styles.bodyContent,
          key: selectedIndex,
          style: styles.body,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 61
          }
        }, React.createElement(View, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 65
          }
        }, React.createElement(View, {
          style: styles.bodyHeading,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 66
          }
        }, React.createElement(Text, {
          style: styles.bodyHeadingText,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 67
          }
        }, "Warning")), React.createElement(Text, {
          style: styles.bodyText,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 69
          }
        }, YellowBoxCategory.render(warning.message, styles.substitutionText))), React.createElement(View, {
          style: styles.bodySection,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 76
          }
        }, React.createElement(View, {
          style: styles.bodyHeading,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 77
          }
        }, React.createElement(Text, {
          style: styles.bodyHeadingText,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 78
          }
        }, "Stack"), React.createElement(YellowBoxInspectorSourceMapStatus, {
          status: warning.symbolicated.status,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 79
          }
        })), warning.getAvailableStack().map(function (frame, index) {
          return React.createElement(YellowBoxInspectorStackFrame, {
            key: index,
            frame: frame,
            onPress: warning.symbolicated.status === 'COMPLETE' ? function () {
              openFileInEditor(frame.file, frame.lineNumber);
            } : null,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 84
            }
          });
        }))), React.createElement(YellowBoxInspectorFooter, {
          onDismiss: this.props.onDismiss,
          onMinimize: this.props.onMinimize,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 98
          }
        }));
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this._handleSymbolication();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        if (prevProps.warnings !== this.props.warnings || prevState.selectedIndex !== this.state.selectedIndex) {
          this._cancelSymbolication();

          this._handleSymbolication();
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this._cancelSymbolication();
      }
    }, {
      key: "_handleSymbolication",
      value: function _handleSymbolication() {
        var _this2 = this;

        var warning = this.props.warnings[this.state.selectedIndex];

        if (warning.symbolicated.status !== 'COMPLETE') {
          this._symbolication = warning.symbolicate(function () {
            _this2.forceUpdate();
          });
        }
      }
    }, {
      key: "_cancelSymbolication",
      value: function _cancelSymbolication() {
        if (this._symbolication != null) {
          this._symbolication.abort();

          this._symbolication = null;
        }
      }
    }]);

    return YellowBoxInspector;
  }(React.Component);

  YellowBoxInspector = _wrapComponent("YellowBoxInspector")(YellowBoxInspector);
  var styles = StyleSheet.create({
    root: {
      elevation: Platform.OS === 'android' ? Number.MAX_SAFE_INTEGER : undefined,
      height: '100%'
    },
    body: {
      backgroundColor: YellowBoxStyle.getBackgroundColor(0.95),
      borderBottomColor: YellowBoxStyle.getDividerColor(0.95),
      borderBottomWidth: StyleSheet.hairlineWidth,
      borderTopColor: YellowBoxStyle.getDividerColor(0.95),
      borderTopWidth: StyleSheet.hairlineWidth,
      flex: 1
    },
    bodyContent: {
      paddingVertical: 12
    },
    bodyHeading: {
      alignItems: 'center',
      flexDirection: 'row',
      marginBottom: 6,
      paddingHorizontal: 12
    },
    bodyHeadingText: {
      color: YellowBoxStyle.getTextColor(1),
      flex: 1,
      fontSize: 20,
      fontWeight: '600',
      includeFontPadding: false,
      lineHeight: 28
    },
    bodyText: {
      color: YellowBoxStyle.getTextColor(1),
      fontSize: 14,
      includeFontPadding: false,
      lineHeight: 18,
      paddingHorizontal: 12
    },
    substitutionText: {
      color: YellowBoxStyle.getTextColor(0.6)
    },
    bodySection: {
      marginTop: 20
    }
  });
  module.exports = YellowBoxInspector;
},565,[23,24,25,26,29,30,28,32,109,280,146,149,503,150,444,175,566,568,569,570,572,564,554],"node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxInspector.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _toConsumableArray = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/toConsumableArray");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\YellowBox\\Data\\YellowBoxCategory.js";

  var React = _$$_REQUIRE(_dependencyMap[1], "React");

  var Text = _$$_REQUIRE(_dependencyMap[2], "Text");

  var UTFSequence = _$$_REQUIRE(_dependencyMap[3], "UTFSequence");

  var stringifySafe = _$$_REQUIRE(_dependencyMap[4], "stringifySafe");

  var SUBSTITUTION = UTFSequence.BOM + '%s';
  var YellowBoxCategory = {
    parse: function parse(args) {
      var categoryParts = [];
      var contentParts = [];
      var substitutionOffsets = [];

      var remaining = _toConsumableArray(args);

      if (typeof remaining[0] === 'string') {
        var formatString = String(remaining.shift());
        var formatStringParts = formatString.split('%s');
        var substitutionCount = formatStringParts.length - 1;
        var substitutions = remaining.splice(0, substitutionCount);
        var categoryString = '';
        var contentString = '';
        var substitutionIndex = 0;

        for (var _iterator = formatStringParts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var _formatStringPart = _ref;
          categoryString += _formatStringPart;
          contentString += _formatStringPart;

          if (substitutionIndex < substitutionCount) {
            if (substitutionIndex < substitutions.length) {
              var substitution = stringifySafe(substitutions[substitutionIndex]);
              substitutionOffsets.push({
                length: substitution.length,
                offset: contentString.length
              });
              categoryString += SUBSTITUTION;
              contentString += substitution;
            } else {
              substitutionOffsets.push({
                length: 2,
                offset: contentString.length
              });
              categoryString += '%s';
              contentString += '%s';
            }

            substitutionIndex++;
          }
        }

        categoryParts.push(categoryString);
        contentParts.push(contentString);
      }

      var remainingArgs = remaining.map(stringifySafe);
      categoryParts.push.apply(categoryParts, _toConsumableArray(remainingArgs));
      contentParts.push.apply(contentParts, _toConsumableArray(remainingArgs));
      return {
        category: categoryParts.join(' '),
        message: {
          content: contentParts.join(' '),
          substitutions: substitutionOffsets
        }
      };
    },
    render: function render(_ref2, substitutionStyle) {
      var content = _ref2.content,
          substitutions = _ref2.substitutions;
      var elements = [];
      var lastOffset = substitutions.reduce(function (prevOffset, substitution, index) {
        var key = String(index);

        if (substitution.offset > prevOffset) {
          var prevPart = content.substr(prevOffset, substitution.offset - prevOffset);
          elements.push(React.createElement(Text, {
            key: key,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 119
            }
          }, prevPart));
        }

        var substititionPart = content.substr(substitution.offset, substitution.length);
        elements.push(React.createElement(Text, {
          key: key + '.5',
          style: substitutionStyle,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 127
          }
        }, substititionPart));
        return substitution.offset + substitution.length;
      }, 0);

      if (lastOffset < content.length) {
        var lastPart = content.substr(lastOffset);
        elements.push(React.createElement(Text, {
          key: "-1",
          __source: {
            fileName: _jsxFileName,
            lineNumber: 139
          }
        }, lastPart));
      }

      return elements;
    }
  };
  module.exports = YellowBoxCategory;
},566,[128,149,444,567,135],"node_modules\\react-native\\Libraries\\YellowBox\\Data\\YellowBoxCategory.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var deepFreezeAndThrowOnMutationInDev = _$$_REQUIRE(_dependencyMap[0], "deepFreezeAndThrowOnMutationInDev");

  var UTFSequence = deepFreezeAndThrowOnMutationInDev({
    BOM: "\uFEFF",
    BULLET: "\u2022",
    BULLET_SP: "\xA0\u2022\xA0",
    MIDDOT: "\xB7",
    MIDDOT_SP: "\xA0\xB7\xA0",
    MIDDOT_KATAKANA: "\u30FB",
    MDASH: "\u2014",
    MDASH_SP: "\xA0\u2014\xA0",
    NDASH: "\u2013",
    NDASH_SP: "\xA0\u2013\xA0",
    NBSP: "\xA0",
    PIZZA: "\uD83C\uDF55",
    TRIANGLE_LEFT: "\u25C0",
    TRIANGLE_RIGHT: "\u25B6"
  });
  module.exports = UTFSequence;
},567,[134],"node_modules\\react-native\\Libraries\\UTFSequence.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxInspectorFooter.js";

  var React = _$$_REQUIRE(_dependencyMap[0], "React");

  var SafeAreaView = _$$_REQUIRE(_dependencyMap[1], "SafeAreaView");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[2], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[3], "Text");

  var View = _$$_REQUIRE(_dependencyMap[4], "View");

  var YellowBoxPressable = _$$_REQUIRE(_dependencyMap[5], "YellowBoxPressable");

  var YellowBoxStyle = _$$_REQUIRE(_dependencyMap[6], "YellowBoxStyle");

  var YellowBoxInspectorFooter = function YellowBoxInspectorFooter(props) {
    return React.createElement(View, {
      style: styles.root,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 27
      }
    }, React.createElement(YellowBoxPressable, {
      backgroundColor: {
        default: 'transparent',
        pressed: YellowBoxStyle.getHighlightColor(1)
      },
      onPress: props.onMinimize,
      style: styles.button,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 28
      }
    }, React.createElement(View, {
      style: styles.content,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 35
      }
    }, React.createElement(Text, {
      style: styles.label,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 36
      }
    }, "Minimize")), React.createElement(SafeAreaView, {
      __source: {
        fileName: _jsxFileName,
        lineNumber: 38
      }
    })), React.createElement(YellowBoxPressable, {
      backgroundColor: {
        default: 'transparent',
        pressed: YellowBoxStyle.getHighlightColor(1)
      },
      onPress: props.onDismiss,
      style: styles.button,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 40
      }
    }, React.createElement(View, {
      style: styles.content,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 47
      }
    }, React.createElement(Text, {
      style: styles.label,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 48
      }
    }, "Dismiss")), React.createElement(SafeAreaView, {
      __source: {
        fileName: _jsxFileName,
        lineNumber: 50
      }
    })));
  };

  var styles = StyleSheet.create({
    root: {
      backgroundColor: YellowBoxStyle.getBackgroundColor(0.95),
      flexDirection: 'row'
    },
    button: {
      flex: 1
    },
    content: {
      alignItems: 'center',
      height: 48,
      justifyContent: 'center'
    },
    label: {
      color: YellowBoxStyle.getTextColor(1),
      fontSize: 14,
      includeFontPadding: false,
      lineHeight: 18
    }
  });
  module.exports = YellowBoxInspectorFooter;
},568,[149,561,150,444,175,563,564],"node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxInspectorFooter.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxInspectorHeader.js";

  var Platform = _$$_REQUIRE(_dependencyMap[0], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[1], "React");

  var SafeAreaView = _$$_REQUIRE(_dependencyMap[2], "SafeAreaView");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[3], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[4], "Text");

  var UTFSequence = _$$_REQUIRE(_dependencyMap[5], "UTFSequence");

  var View = _$$_REQUIRE(_dependencyMap[6], "View");

  var YellowBoxPressable = _$$_REQUIRE(_dependencyMap[7], "YellowBoxPressable");

  var YellowBoxStyle = _$$_REQUIRE(_dependencyMap[8], "YellowBoxStyle");

  var YellowBoxInspectorHeader = function YellowBoxInspectorHeader(props) {
    var prevIndex = props.selectedIndex - 1;
    var nextIndex = props.selectedIndex + 1;
    var titleText = props.warnings.length === 1 ? 'Single Occurrence' : "Occurrence " + (props.selectedIndex + 1) + " of " + props.warnings.length;
    return React.createElement(SafeAreaView, {
      style: styles.root,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 41
      }
    }, React.createElement(View, {
      style: styles.header,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 42
      }
    }, React.createElement(YellowBoxInspectorHeaderButton, {
      disabled: props.warnings[prevIndex] == null,
      label: UTFSequence.TRIANGLE_LEFT,
      onPress: function onPress() {
        return props.onSelectIndex(prevIndex);
      },
      __source: {
        fileName: _jsxFileName,
        lineNumber: 43
      }
    }), React.createElement(View, {
      style: styles.headerTitle,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 48
      }
    }, React.createElement(Text, {
      style: styles.headerTitleText,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 49
      }
    }, titleText)), React.createElement(YellowBoxInspectorHeaderButton, {
      disabled: props.warnings[nextIndex] == null,
      label: UTFSequence.TRIANGLE_RIGHT,
      onPress: function onPress() {
        return props.onSelectIndex(nextIndex);
      },
      __source: {
        fileName: _jsxFileName,
        lineNumber: 51
      }
    })));
  };

  var YellowBoxInspectorHeaderButton = function YellowBoxInspectorHeaderButton(props) {
    return React.createElement(YellowBoxPressable, {
      backgroundColor: {
        default: 'transparent',
        pressed: YellowBoxStyle.getHighlightColor(1)
      },
      onPress: props.disabled ? null : props.onPress,
      style: styles.headerButton,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 68
      }
    }, props.disabled ? null : React.createElement(Text, {
      style: styles.headerButtonText,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 76
      }
    }, props.label));
  };

  var styles = StyleSheet.create({
    root: {
      backgroundColor: YellowBoxStyle.getBackgroundColor(0.95)
    },
    header: {
      flexDirection: 'row',
      height: Platform.select({
        android: 48,
        ios: 44
      })
    },
    headerButton: {
      alignItems: 'center',
      aspectRatio: 1,
      justifyContent: 'center'
    },
    headerButtonText: {
      color: YellowBoxStyle.getTextColor(1),
      fontSize: 16,
      includeFontPadding: false,
      lineHeight: 20
    },
    headerTitle: {
      alignItems: 'center',
      flex: 1,
      justifyContent: 'center'
    },
    headerTitleText: {
      color: YellowBoxStyle.getTextColor(1),
      fontSize: 16,
      fontWeight: '600',
      includeFontPadding: false,
      lineHeight: 20
    }
  });
  module.exports = YellowBoxInspectorHeader;
},569,[146,149,561,150,444,567,175,563,564],"node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxInspectorHeader.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxInspectorSourceMapStatus.js";
  var _components = {
    YellowBoxInspectorSourceMapStatus: {
      displayName: "YellowBoxInspectorSourceMapStatus"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxInspectorSourceMapStatus.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var Animated = _$$_REQUIRE(_dependencyMap[10], "Animated");

  var Easing = _$$_REQUIRE(_dependencyMap[11], "Easing");

  var React = _$$_REQUIRE(_dependencyMap[12], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[13], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[14], "Text");

  var View = _$$_REQUIRE(_dependencyMap[15], "View");

  var YellowBoxImageSource = _$$_REQUIRE(_dependencyMap[16], "YellowBoxImageSource");

  var YellowBoxStyle = _$$_REQUIRE(_dependencyMap[17], "YellowBoxStyle");

  var YellowBoxInspectorSourceMapStatus = function (_React$Component) {
    _inherits(YellowBoxInspectorSourceMapStatus, _React$Component);

    function YellowBoxInspectorSourceMapStatus() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, YellowBoxInspectorSourceMapStatus);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(YellowBoxInspectorSourceMapStatus)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
        animation: null,
        rotate: null
      });

      return _this;
    }

    _createClass(YellowBoxInspectorSourceMapStatus, [{
      key: "render",
      value: function render() {
        var image;

        switch (this.props.status) {
          case 'COMPLETE':
            image = YellowBoxImageSource.check;
            break;

          case 'FAILED':
            image = YellowBoxImageSource.alertTriangle;
            break;

          case 'PENDING':
            image = YellowBoxImageSource.loader;
            break;
        }

        return image == null ? null : React.createElement(View, {
          style: StyleSheet.compose(styles.root, this.props.status === 'PENDING' ? styles.pending : null),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 55
          }
        }, React.createElement(Animated.Image, {
          source: {
            height: 16,
            uri: image,
            width: 16
          },
          style: StyleSheet.compose(styles.image, this.state.rotate == null ? null : {
            transform: [{
              rotate: this.state.rotate
            }]
          }),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 60
          }
        }), React.createElement(Text, {
          style: styles.text,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 69
          }
        }, "Source Map"));
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this._updateAnimation();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this._updateAnimation();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this.state.animation != null) {
          this.state.animation.stop();
        }
      }
    }, {
      key: "_updateAnimation",
      value: function _updateAnimation() {
        if (this.props.status === 'PENDING') {
          if (this.state.animation == null) {
            var animated = new Animated.Value(0);
            var animation = Animated.loop(Animated.timing(animated, {
              duration: 2000,
              easing: Easing.linear,
              toValue: 1,
              useNativeDriver: true
            }));
            this.setState({
              animation: animation,
              rotate: animated.interpolate({
                inputRange: [0, 1],
                outputRange: ['0deg', '360deg']
              })
            }, function () {
              animation.start();
            });
          }
        } else {
          if (this.state.animation != null) {
            this.state.animation.stop();
            this.setState({
              animation: null,
              rotate: null
            });
          }
        }
      }
    }]);

    return YellowBoxInspectorSourceMapStatus;
  }(React.Component);

  YellowBoxInspectorSourceMapStatus = _wrapComponent("YellowBoxInspectorSourceMapStatus")(YellowBoxInspectorSourceMapStatus);
  var styles = StyleSheet.create({
    root: {
      alignItems: 'center',
      backgroundColor: YellowBoxStyle.getTextColor(0.8),
      borderRadius: 12,
      flexDirection: 'row',
      height: 24,
      paddingHorizontal: 8
    },
    pending: {
      backgroundColor: YellowBoxStyle.getTextColor(0.6)
    },
    image: {
      marginEnd: 4,
      tintColor: YellowBoxStyle.getBackgroundColor(1)
    },
    text: {
      color: YellowBoxStyle.getBackgroundColor(1),
      fontSize: 12,
      includeFontPadding: false,
      lineHeight: 16
    }
  });
  module.exports = YellowBoxInspectorSourceMapStatus;
},570,[23,24,25,26,29,30,28,32,109,280,468,494,149,150,444,175,571,564],"node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxInspectorSourceMapStatus.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var PixelRatio = _$$_REQUIRE(_dependencyMap[0], "PixelRatio");

  var scale = PixelRatio.get();
  /**
   * We use inline images for YellowBox in order to avoid display latency due to
   * resource contention with symbolicating stack traces.
   *
   * The following steps were used to create these:
   *
   *   1. Download SVG files from: https://feathericons.com
   *   2. Rasterize SVG files to PNG files at 16dp, 36dp, and 48dp.
   *   3. Convert to Base64: https://www.google.com/search?q=base64+image+encoder
   *
   * @see https://github.com/feathericons/feather
   * @copyright 2013-2017 Cole Bemis
   * @license MIT
   */

  var YellowBoxImageSource = {
    alertTriangle: scale > 2 ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAB60lEQVRoge2Z3W3DIBSFj9oFPAIjZARGyAiMkBHuJh4hI2QEj5AR3Me+tQ91JALHmD8bKvmTkCr5Auc6/kzUACcnRXzuvL4GoAB8Afjeea9qXADcAfw4475c65orgBl++NeYl5ouUQiHt5tQTRJuwB6b5zLY49QVGn7I0bo+kuv60IQbuHf5CWCIqOkCgX93maia1MkRAUMo+OI+AvUPp7a50EzcUCBF6psJrUkYiZgnZJ7eId8mMeIyhpW5hyLw72LKCXsl86VqwgAKceKapW5e/nZpJnSsuHaTM7muyDq7C63JprJS69YxhNTpSlkpKeLGNHCo0EJChcSNaQA4SGiFtBMXJFSI3YVOPXFB6kMoUl9NaE0Wl4h5KQ0AOwqde+KmNrCL0EKCxJ64qQ0AlYVWSBfXZusgW6Oa0Dni2hiEv0qsoci+yUJrsoikLlKAkP11ygK54taiSOgb/O5b/DMqS+gBZeLWJlnoEX7XwQkBDPIktlEkz7hWrEmxZG4M5L9GXYTk0qxwcopKxa3VABN6cosM/C5LxTUof4ReMKHf1nRlaSnuGsGM7kfU4w8RF5Bz4aNlokLe/HQ/ngl9/Qih4L9k3h4hA1+S3odxu3Q77Hl4r1Hg75n6D01M2Difbp02Mi3ZTk5OLH4BUyEtOlDYuK0AAAAASUVORK5CYII=' : scale > 1 ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABVklEQVRYheWX4U3DMBBGH4gBMoJHyAgeoSNkAxjBG5QNOkJHCGzQDcoGZQP4gY3Oqe1cEscS4pNOqs9Jvqvv6ZrCf9fDhnutD4A3H810Br4mcW5l7hLmIdze5mZi+OJD5syeBYzC6CjyR5Ef9zI/CJMb0Im9zufC/qG2eQdchcGQuGYQ+9dJgZvl0B2xbJGrZW6IIevFXp9YVwcyB540syJfFcgSeJb0cVcDcg68XAFQCUhH+ShLBcBGIA158LQFqIB8zBRwEp9fgctcxQld/L2pZxZVAk/KkucjaDGQmoknrz35KEE2sABIRxm8tVIBaZgHb61UQOYmXk7aFgQVJ6QWPCnLAriYAVILnpTxD7yh/9EZiIEE4m+y29uMkGy1nQ6i9wYFRB5PwKdYP/v1msmnUe89gn695bG0iqjdXeMiRu9599csvGKZ0jlu0Ac/7d2rxX9Q37HW6QfX/ZguAAAAAElFTkSuQmCC' : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAvUlEQVQ4jbWT4Q3CIBCFP40DdANxg24gIzhKuwEjuIFxAkcwTtARGicoG+iPXlMCB8UfvoQc4e7ePV4A/ogWuMlqc0W7AsEo0QMNcPplugMmwMia5KwKWkNIuIkHq3wLXGQ/Sq4IC3wkLpOfmZyKeEpIEKsDYB8VN0Afkfpg30uNiycbdKcNqXEOxdBEWoEAoqta8uZ0iqqkxwGDUrSFAXAHZpOWd/+ubD5Kz335Cx1wZna4Bh54AddauVl8ARfCLO9Xq7xGAAAAAElFTkSuQmCC',
    check: scale > 2 ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAqElEQVRoge3YTQ7CIBRF4bPUu/8JS6gTSaqilh95vuR+CaO2cGgYNAUzMzOzFgHlPhRaMkDAcRoltKaTeIxPtQHxGn+Q5AgJx8cQjo8hHB9DOP76Yiu/RcTmN18WLiQCjs3zBkYXVGOeLWd+xcIr5pgyEzDz7FIjISPP/FRPUM+9W4nvYVfuCSXeB3669ldEOzRFfCUSx1cicXwlEsdXIvEPKDMzM7PMbtugw3XTpNA2AAAAAElFTkSuQmCC' : scale > 1 ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAf0lEQVRYhe2UvQ2AIBQGL3EBR3AESkv3bxxFN8DmWUgwvkI+En1X0cBd+IMg+DuDyDMCs413kfMiX4EMbD3l8oCaPIU85B4mYLEF5XJscrYFPRGvb/sZ4IlocubJGdH0wj1FSG77XYT0qdUi5O+8jOjyyZQRUnkZ0UUeBMF3OQC/0VsyGlxligAAAABJRU5ErkJggg==' : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASElEQVQ4jWNgGJHAgIGBIYESze8ZGBjWU6L5PAMDgwBNNCdAFZJt83qoQmRDSHK2AFQhzBCy/IxsCNkBJsDAwLAfiknWPBIBAETPFeuA4fr6AAAAAElFTkSuQmCC',
    loader: scale > 2 ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAABXElEQVRoge2a3W3DMAyEr+0CHkGjaISOcKN4k6zQETpCR+gGzgbpQ10kcamIpKQ6avQBBPxg3pHwL2UDg/8LASxrcNdKnCwATmssrUyeWgnju/DmXs8tRP+Sh2kgAJga1rFlWj2rcMD5YqQh77QJLbzIORjyRIJQCJW5ngYo5AVlrsgkCGqbsDbAhFfxqZsSZibP0oDXQ43HQPsg82i7sBoR+VcJq2YxKcPo0IoJLRZXmYGC6ezQmQUdVqhPBVH/CNBTSMkLVlzjA8Bbocb7GoPBoADi+umZilYzbrG/JrnljOvy734iu4To/BQaDB6Rl4LciPPF9Lmjhgvi+s7w6tCIGw3WKS0P8fvWNjt0ZkGHFeq7CQXTbkZKGg2JOxrqPUZ3s6ziNdju38IjS/dLi0EQpDLX2gDQYHEX6Hx5/YcA+6H0NgAYPnCMj3x7Mxq4wTGx3Q1E578aDDR8AX0mOGD6BEN/AAAAAElFTkSuQmCC' : scale > 1 ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABN0lEQVRYhe2WzU3EMBCFP34KyJEjJaQDXAIlJJ24BSow2wEdhHSwJSwd7JHbcmC0mOxMnDiWDIInWbHkN29exo4n8IvRAEFGU8OAA04yulyR60Jm7msbyIZloAMGwBfI4UWrWxM08LW/weC4iOMNTog4g0awKjBG827GxBwC3996NHizAifsSrTRmlsZm23CT9adktyXSq6ZUPdxgiXnZzW8CLcLuC3lvqA/gCt5NtjlPQL7TP0Wu1HtRRu4PO3T4TKTz2kG+AG9IN6CR/Su9iojBw69egfghWgL/pGCp+JFVPUqTjWjlsuqeAo1o6rt2C8QcNiV0UxoHPMieojmz0CfMKyhl1hN84xbI3gnz5Ftp7kH3iT5LsFdDUf6pzSJ6r2glIFDbuDNhqRH4I7Pvv4EvG/QqocP2Jh/xzzX/zUAAAAASUVORK5CYII=' : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAsklEQVQ4jaWTYRHCMAyFP7gJmIQ6oChgEpBQKXMwC3MADpAAEiphDuBHC4QuDRu8u9ylyWtem7Rgw2X7GT1wsghb4beAVzhtsfYyJgs44AoEQzBkjrMId1HkKPwyZ6oMSnxYsnk1NqT7yMo34Fzhd9meGJvs7Hh3NhqCLXDI/rT0lKsR+KOJgc9RdaRRarkZvELogYsi8HqxjUhGYE+aQg1jzketwFTZXHbbEpjB8eU7PwAbLiJz46707gAAAABJRU5ErkJggg=='
  };
  module.exports = YellowBoxImageSource;
},571,[151],"node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxImageSource.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxInspectorStackFrame.js";

  var React = _$$_REQUIRE(_dependencyMap[0], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[1], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[2], "Text");

  var YellowBoxPressable = _$$_REQUIRE(_dependencyMap[3], "YellowBoxPressable");

  var YellowBoxStyle = _$$_REQUIRE(_dependencyMap[4], "YellowBoxStyle");

  var YellowBoxInspectorStackFrame = function YellowBoxInspectorStackFrame(props) {
    var frame = props.frame,
        onPress = props.onPress;
    return React.createElement(YellowBoxPressable, {
      backgroundColor: {
        default: YellowBoxStyle.getBackgroundColor(0),
        pressed: YellowBoxStyle.getHighlightColor(1)
      },
      onPress: onPress,
      style: styles.frame,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 31
      }
    }, React.createElement(Text, {
      style: styles.frameName,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 38
      }
    }, frame.methodName), React.createElement(Text, {
      ellipsizeMode: "middle",
      numberOfLines: 1,
      style: styles.frameLocation,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 39
      }
    }, getFrameLocation(frame.file) + ":" + frame.lineNumber + (frame.column == null ? '' : ':' + frame.column)));
  };

  var getFrameLocation = function getFrameLocation(uri) {
    var queryIndex = uri.indexOf('?');
    var query = queryIndex < 0 ? '' : uri.substr(queryIndex);
    var path = queryIndex < 0 ? uri : uri.substr(0, queryIndex);
    var file = path.substr(path.lastIndexOf('/') + 1);
    return file + query;
  };

  var styles = StyleSheet.create({
    frame: {
      paddingHorizontal: 12,
      paddingVertical: 4
    },
    frameName: {
      color: YellowBoxStyle.getTextColor(1),
      fontSize: 14,
      includeFontPadding: false,
      lineHeight: 18
    },
    frameLocation: {
      color: YellowBoxStyle.getTextColor(0.7),
      fontSize: 12,
      fontWeight: '300',
      includeFontPadding: false,
      lineHeight: 16
    }
  });
  module.exports = YellowBoxInspectorStackFrame;
},572,[149,150,444,563,564],"node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxInspectorStackFrame.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxListRow.js";
  var _components = {
    YellowBoxListRow: {
      displayName: "YellowBoxListRow"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxListRow.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var React = _$$_REQUIRE(_dependencyMap[10], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[11], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[12], "Text");

  var YellowBoxPressable = _$$_REQUIRE(_dependencyMap[13], "YellowBoxPressable");

  var View = _$$_REQUIRE(_dependencyMap[14], "View");

  var YellowBoxCategory = _$$_REQUIRE(_dependencyMap[15], "YellowBoxCategory");

  var YellowBoxStyle = _$$_REQUIRE(_dependencyMap[16], "YellowBoxStyle");

  var YellowBoxWarning = _$$_REQUIRE(_dependencyMap[17], "YellowBoxWarning");

  var YellowBoxListRow = function (_React$Component) {
    _inherits(YellowBoxListRow, _React$Component);

    function YellowBoxListRow() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, YellowBoxListRow);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(YellowBoxListRow)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handlePress", function () {
        _this.props.onPress(_this.props.category);
      });

      return _this;
    }

    _createClass(YellowBoxListRow, [{
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps) {
        var prevProps = this.props;
        return prevProps.category !== nextProps.category || prevProps.onPress !== nextProps.onPress || prevProps.warnings.length !== nextProps.warnings.length || prevProps.warnings.some(function (prevWarning, index) {
          return prevWarning !== nextProps[index];
        });
      }
    }, {
      key: "render",
      value: function render() {
        var warnings = this.props.warnings;
        return React.createElement(YellowBoxPressable, {
          onPress: this._handlePress,
          style: styles.root,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 50
          }
        }, React.createElement(View, {
          style: styles.content,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 51
          }
        }, warnings.length < 2 ? null : React.createElement(Text, {
          style: styles.metaText,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 53
          }
        }, '(' + warnings.length + ') '), React.createElement(Text, {
          numberOfLines: 2,
          style: styles.bodyText,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 55
          }
        }, YellowBoxCategory.render(warnings[warnings.length - 1].message, styles.substitutionText))));
      }
    }]);

    return YellowBoxListRow;
  }(React.Component);

  _defineProperty(YellowBoxListRow, "GUTTER", StyleSheet.hairlineWidth);

  _defineProperty(YellowBoxListRow, "HEIGHT", 48);

  YellowBoxListRow = _wrapComponent("YellowBoxListRow")(YellowBoxListRow);
  var styles = StyleSheet.create({
    root: {
      height: YellowBoxListRow.HEIGHT,
      justifyContent: 'center',
      marginTop: YellowBoxListRow.GUTTER,
      paddingHorizontal: 12
    },
    content: {
      alignItems: 'flex-start',
      flexDirection: 'row'
    },
    bodyText: {
      color: YellowBoxStyle.getTextColor(1),
      flex: 1,
      fontSize: 14,
      includeFontPadding: false,
      lineHeight: 18
    },
    metaText: {
      color: YellowBoxStyle.getTextColor(0.5),
      fontSize: 14,
      includeFontPadding: false,
      lineHeight: 18
    },
    substitutionText: {
      color: YellowBoxStyle.getTextColor(0.6)
    }
  });
  module.exports = YellowBoxListRow;
},573,[23,24,25,26,29,30,28,32,109,280,149,150,444,563,175,566,564,574],"node_modules\\react-native\\Libraries\\YellowBox\\UI\\YellowBoxListRow.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/defineProperty");

  var YellowBoxCategory = _$$_REQUIRE(_dependencyMap[4], "YellowBoxCategory");

  var YellowBoxSymbolication = _$$_REQUIRE(_dependencyMap[5], "YellowBoxSymbolication");

  var parseErrorStack = _$$_REQUIRE(_dependencyMap[6], "parseErrorStack");

  var YellowBoxWarning = function () {
    _createClass(YellowBoxWarning, null, [{
      key: "parse",
      value: function parse(_ref) {
        var args = _ref.args,
            framesToPop = _ref.framesToPop;
        return _objectSpread({}, YellowBoxCategory.parse(args), {
          stack: createStack({
            framesToPop: framesToPop + 1
          })
        });
      }
    }]);

    function YellowBoxWarning(message, stack) {
      _classCallCheck(this, YellowBoxWarning);

      _defineProperty(this, "message", void 0);

      _defineProperty(this, "stack", void 0);

      _defineProperty(this, "symbolicated", {
        error: null,
        stack: null,
        status: 'NONE'
      });

      this.message = message;
      this.stack = stack;
    }

    _createClass(YellowBoxWarning, [{
      key: "getAvailableStack",
      value: function getAvailableStack() {
        return this.symbolicated.status === 'COMPLETE' ? this.symbolicated.stack : this.stack;
      }
    }, {
      key: "symbolicate",
      value: function symbolicate(callback) {
        var _this = this;

        var aborted = false;

        if (this.symbolicated.status !== 'COMPLETE') {
          var updateStatus = function updateStatus(error, stack) {
            if (error != null) {
              _this.symbolicated = {
                error: error,
                stack: null,
                status: 'FAILED'
              };
            } else if (stack != null) {
              _this.symbolicated = {
                error: null,
                stack: stack,
                status: 'COMPLETE'
              };
            } else {
              _this.symbolicated = {
                error: null,
                stack: null,
                status: 'PENDING'
              };
            }

            if (!aborted) {
              callback();
            }
          };

          updateStatus(null, null);
          YellowBoxSymbolication.symbolicate(this.stack).then(function (stack) {
            updateStatus(null, stack);
          }, function (error) {
            updateStatus(error, null);
          });
        }

        return {
          abort: function abort() {
            aborted = true;
          }
        };
      }
    }]);

    return YellowBoxWarning;
  }();

  function createStack(_ref2) {
    var framesToPop = _ref2.framesToPop;
    var error = new Error();
    error.framesToPop = framesToPop + 1;
    return parseErrorStack(error);
  }

  module.exports = YellowBoxWarning;
},574,[148,24,25,32,566,575,189],"node_modules\\react-native\\Libraries\\YellowBox\\Data\\YellowBoxWarning.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var symbolicateStackTrace = _$$_REQUIRE(_dependencyMap[0], "symbolicateStackTrace");

  var cache = new Map();
  var YellowBoxSymbolication = {
    symbolicate: function symbolicate(stack) {
      var key = getCacheKey(stack);
      var promise = cache.get(key);

      if (promise == null) {
        promise = symbolicateStackTrace(stack).then(sanitize);
        cache.set(key, promise);
      }

      return promise;
    }
  };

  var getCacheKey = function getCacheKey(stack) {
    return JSON.stringify(stack);
  };

  var sanitize = function sanitize(maybeStack) {
    if (!Array.isArray(maybeStack)) {
      throw new Error('Expected stack to be an array.');
    }

    var stack = [];

    for (var _iterator = maybeStack, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var _maybeFrame = _ref;

      if (typeof _maybeFrame !== 'object' || _maybeFrame == null) {
        throw new Error('Expected each stack frame to be an object.');
      }

      if (typeof _maybeFrame.column !== 'number' && _maybeFrame.column != null) {
        throw new Error('Expected stack frame `column` to be a nullable number.');
      }

      if (typeof _maybeFrame.file !== 'string') {
        throw new Error('Expected stack frame `file` to be a string.');
      }

      if (typeof _maybeFrame.lineNumber !== 'number') {
        throw new Error('Expected stack frame `lineNumber` to be a number.');
      }

      if (typeof _maybeFrame.methodName !== 'string') {
        throw new Error('Expected stack frame `methodName` to be a string.');
      }

      stack.push({
        column: _maybeFrame.column,
        file: _maybeFrame.file,
        lineNumber: _maybeFrame.lineNumber,
        methodName: _maybeFrame.methodName
      });
    }

    return stack;
  };

  module.exports = YellowBoxSymbolication;
},575,[192],"node_modules\\react-native\\Libraries\\YellowBox\\Data\\YellowBoxSymbolication.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _toConsumableArray = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/toConsumableArray");

  var _slicedToArray = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/slicedToArray");

  var YellowBoxWarning = _$$_REQUIRE(_dependencyMap[2], "YellowBoxWarning");

  var observers = new Set();
  var ignorePatterns = new Set();
  var registry = new Map();
  var disabled = false;
  var projection = new Map();
  var updateTimeout = null;

  function isWarningIgnored(warning) {
    for (var _iterator = ignorePatterns, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var _pattern = _ref;

      if (warning.message.content.includes(_pattern)) {
        return true;
      }
    }

    return false;
  }

  function handleUpdate() {
    projection = new Map();

    if (!disabled) {
      for (var _iterator2 = registry, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
        var _ref4;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref4 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref4 = _i2.value;
        }

        var _ref5 = _ref4;

        var _ref3 = _slicedToArray(_ref5, 2);

        var _category = _ref3[0];
        var _warnings = _ref3[1];

        var filtered = _warnings.filter(function (warning) {
          return !isWarningIgnored(warning);
        });

        if (filtered.length > 0) {
          projection.set(_category, filtered);
        }
      }
    }

    if (updateTimeout == null) {
      updateTimeout = setImmediate(function () {
        updateTimeout = null;

        for (var _iterator3 = observers, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
          var _ref7;

          if (_isArray3) {
            if (_i3 >= _iterator3.length) break;
            _ref7 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done) break;
            _ref7 = _i3.value;
          }

          var _ref8 = _ref7;
          var _observer = _ref8.observer;

          _observer(projection);
        }
      });
    }
  }

  var YellowBoxRegistry = {
    add: function add(_ref9) {
      var args = _ref9.args,
          framesToPop = _ref9.framesToPop;

      if (typeof args[0] === 'string' && args[0].startsWith('(ADVICE)')) {
        return;
      }

      var _YellowBoxWarning$par = YellowBoxWarning.parse({
        args: args,
        framesToPop: framesToPop + 1
      }),
          category = _YellowBoxWarning$par.category,
          message = _YellowBoxWarning$par.message,
          stack = _YellowBoxWarning$par.stack;

      var warnings = registry.get(category);

      if (warnings == null) {
        warnings = [];
      }

      warnings = _toConsumableArray(warnings).concat([new YellowBoxWarning(message, stack)]);
      registry.delete(category);
      registry.set(category, warnings);
      handleUpdate();
    },
    delete: function _delete(category) {
      if (registry.has(category)) {
        registry.delete(category);
        handleUpdate();
      }
    },
    clear: function clear() {
      if (registry.size > 0) {
        registry.clear();
        handleUpdate();
      }
    },
    addIgnorePatterns: function addIgnorePatterns(patterns) {
      var newPatterns = patterns.filter(function (pattern) {
        return !ignorePatterns.has(pattern);
      });

      if (newPatterns.length === 0) {
        return;
      }

      for (var _iterator4 = newPatterns, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
        var _ref10;

        if (_isArray4) {
          if (_i4 >= _iterator4.length) break;
          _ref10 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done) break;
          _ref10 = _i4.value;
        }

        var _pattern2 = _ref10;
        ignorePatterns.add(_pattern2);
      }

      handleUpdate();
    },
    setDisabled: function setDisabled(value) {
      if (value === disabled) {
        return;
      }

      disabled = value;
      handleUpdate();
    },
    isDisabled: function isDisabled() {
      return disabled;
    },
    observe: function observe(observer) {
      var subscription = {
        observer: observer
      };
      observers.add(subscription);
      observer(projection);
      return {
        unsubscribe: function unsubscribe() {
          observers.delete(subscription);
        }
      };
    }
  };
  module.exports = YellowBoxRegistry;
},576,[128,122,574],"node_modules\\react-native\\Libraries\\YellowBox\\Data\\YellowBoxRegistry.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = _$$_REQUIRE(_dependencyMap[0], "UnimplementedView");
},577,[539],"node_modules\\react-native\\Libraries\\Components\\Navigation\\NavigatorIOS.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/inherits");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/defineProperty");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/objectSpread");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\Picker\\Picker.js";
  var _components = {
    PickerItem: {
      displayName: "PickerItem"
    },
    Picker: {
      displayName: "Picker"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\Picker\\Picker.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var ColorPropType = _$$_REQUIRE(_dependencyMap[11], "ColorPropType");

  var PickerIOS = _$$_REQUIRE(_dependencyMap[12], "PickerIOS");

  var PickerAndroid = _$$_REQUIRE(_dependencyMap[13], "PickerAndroid");

  var Platform = _$$_REQUIRE(_dependencyMap[14], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[15], "React");

  var PropTypes = _$$_REQUIRE(_dependencyMap[16], "prop-types");

  var StyleSheetPropType = _$$_REQUIRE(_dependencyMap[17], "StyleSheetPropType");

  var TextStylePropTypes = _$$_REQUIRE(_dependencyMap[18], "TextStylePropTypes");

  var UnimplementedView = _$$_REQUIRE(_dependencyMap[19], "UnimplementedView");

  var ViewPropTypes = _$$_REQUIRE(_dependencyMap[20], "ViewPropTypes");

  var ViewStylePropTypes = _$$_REQUIRE(_dependencyMap[21], "ViewStylePropTypes");

  var itemStylePropType = StyleSheetPropType(TextStylePropTypes);
  var pickerStyleType = StyleSheetPropType(_objectSpread({}, ViewStylePropTypes, {
    color: ColorPropType
  }));
  var MODE_DIALOG = 'dialog';
  var MODE_DROPDOWN = 'dropdown';

  var PickerItem = function (_React$Component) {
    _inherits(PickerItem, _React$Component);

    function PickerItem() {
      _classCallCheck(this, PickerItem);

      return _possibleConstructorReturn(this, _getPrototypeOf(PickerItem).apply(this, arguments));
    }

    _createClass(PickerItem, [{
      key: "render",
      value: function render() {
        throw null;
      }
    }]);

    return PickerItem;
  }(React.Component);

  _defineProperty(PickerItem, "propTypes", {
    label: PropTypes.string.isRequired,
    value: PropTypes.any,
    color: ColorPropType,
    testID: PropTypes.string
  });

  PickerItem = _wrapComponent("PickerItem")(PickerItem);

  var Picker = function (_React$Component2) {
    _inherits(Picker, _React$Component2);

    function Picker() {
      _classCallCheck(this, Picker);

      return _possibleConstructorReturn(this, _getPrototypeOf(Picker).apply(this, arguments));
    }

    _createClass(Picker, [{
      key: "render",
      value: function render() {
        if (Platform.OS === 'ios') {
          return React.createElement(PickerIOS, _extends({}, this.props, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 155
            }
          }), this.props.children);
        } else if (Platform.OS === 'android') {
          return React.createElement(PickerAndroid, _extends({}, this.props, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 159
            }
          }), this.props.children);
        } else {
          return React.createElement(UnimplementedView, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 162
            }
          });
        }
      }
    }]);

    return Picker;
  }(React.Component);

  _defineProperty(Picker, "MODE_DIALOG", MODE_DIALOG);

  _defineProperty(Picker, "MODE_DROPDOWN", MODE_DROPDOWN);

  _defineProperty(Picker, "Item", PickerItem);

  _defineProperty(Picker, "defaultProps", {
    mode: MODE_DIALOG
  });

  _defineProperty(Picker, "propTypes", _objectSpread({}, ViewPropTypes, {
    style: pickerStyleType,
    selectedValue: PropTypes.any,
    onValueChange: PropTypes.func,
    enabled: PropTypes.bool,
    mode: PropTypes.oneOf(['dialog', 'dropdown']),
    itemStyle: itemStylePropType,
    prompt: PropTypes.string,
    testID: PropTypes.string
  }));

  Picker = _wrapComponent("Picker")(Picker);
  module.exports = Picker;
},578,[23,112,24,25,26,29,30,32,148,109,280,156,579,580,146,149,161,447,167,539,522,168],"node_modules\\react-native\\Libraries\\Components\\Picker\\Picker.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = _$$_REQUIRE(_dependencyMap[0], "UnimplementedView");
},579,[539],"node_modules\\react-native\\Libraries\\Components\\Picker\\PickerIOS.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/defineProperty");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/objectSpread");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\Picker\\PickerAndroid.android.js";
  var _components = {
    PickerAndroid: {
      displayName: "PickerAndroid"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\Picker\\PickerAndroid.android.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var ColorPropType = _$$_REQUIRE(_dependencyMap[12], "ColorPropType");

  var React = _$$_REQUIRE(_dependencyMap[13], "React");

  var ReactPropTypes = _$$_REQUIRE(_dependencyMap[14], "prop-types");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[15], "StyleSheet");

  var StyleSheetPropType = _$$_REQUIRE(_dependencyMap[16], "StyleSheetPropType");

  var ViewPropTypes = _$$_REQUIRE(_dependencyMap[17], "ViewPropTypes");

  var ViewStylePropTypes = _$$_REQUIRE(_dependencyMap[18], "ViewStylePropTypes");

  var processColor = _$$_REQUIRE(_dependencyMap[19], "processColor");

  var requireNativeComponent = _$$_REQUIRE(_dependencyMap[20], "requireNativeComponent");

  var DropdownPicker = requireNativeComponent('AndroidDropdownPicker');
  var DialogPicker = requireNativeComponent('AndroidDialogPicker');
  var REF_PICKER = 'picker';
  var MODE_DROPDOWN = 'dropdown';
  var pickerStyleType = StyleSheetPropType(_objectSpread({}, ViewStylePropTypes, {
    color: ColorPropType
  }));

  var PickerAndroid = function (_React$Component) {
    _inherits(PickerAndroid, _React$Component);

    function PickerAndroid(_props, context) {
      var _this;

      _classCallCheck(this, PickerAndroid);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(PickerAndroid).call(this, _props, context));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_stateFromProps", function (props) {
        var selectedIndex = 0;
        var items = React.Children.map(props.children, function (child, index) {
          if (child.props.value === props.selectedValue) {
            selectedIndex = index;
          }

          var childProps = {
            value: child.props.value,
            label: child.props.label
          };

          if (child.props.color) {
            childProps.color = processColor(child.props.color);
          }

          return childProps;
        });
        return {
          selectedIndex: selectedIndex,
          items: items
        };
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onChange", function (event) {
        if (_this.props.onValueChange) {
          var position = event.nativeEvent.position;

          if (position >= 0) {
            var children = React.Children.toArray(_this.props.children);
            var value = children[position].props.value;

            _this.props.onValueChange(value, position);
          } else {
            _this.props.onValueChange(null, position);
          }
        }

        _this._lastNativePosition = event.nativeEvent.position;

        _this.forceUpdate();
      });

      var state = _this._stateFromProps(_props);

      _this.state = _objectSpread({}, state, {
        initialSelectedIndex: state.selectedIndex
      });
      return _this;
    }

    _createClass(PickerAndroid, [{
      key: "UNSAFE_componentWillReceiveProps",
      value: function UNSAFE_componentWillReceiveProps(nextProps) {
        this.setState(this._stateFromProps(nextProps));
      }
    }, {
      key: "render",
      value: function render() {
        var Picker = this.props.mode === MODE_DROPDOWN ? DropdownPicker : DialogPicker;
        var nativeProps = {
          enabled: this.props.enabled,
          items: this.state.items,
          mode: this.props.mode,
          onSelect: this._onChange,
          prompt: this.props.prompt,
          selected: this.state.initialSelectedIndex,
          testID: this.props.testID,
          style: [styles.pickerAndroid, this.props.style],
          accessibilityLabel: this.props.accessibilityLabel
        };
        return React.createElement(Picker, _extends({
          ref: REF_PICKER
        }, nativeProps, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 122
          }
        }));
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this._lastNativePosition = this.state.initialSelectedIndex;
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        if (this.refs[REF_PICKER] && this.state.selectedIndex !== this._lastNativePosition) {
          this.refs[REF_PICKER].setNativeProps({
            selected: this.state.selectedIndex
          });
          this._lastNativePosition = this.state.selectedIndex;
        }
      }
    }]);

    return PickerAndroid;
  }(React.Component);

  _defineProperty(PickerAndroid, "propTypes", _objectSpread({}, ViewPropTypes, {
    style: pickerStyleType,
    selectedValue: ReactPropTypes.any,
    enabled: ReactPropTypes.bool,
    mode: ReactPropTypes.oneOf(['dialog', 'dropdown']),
    onValueChange: ReactPropTypes.func,
    prompt: ReactPropTypes.string,
    testID: ReactPropTypes.string
  }));

  PickerAndroid = _wrapComponent("PickerAndroid")(PickerAndroid);
  var styles = StyleSheet.create({
    pickerAndroid: {
      height: 50
    }
  });
  module.exports = PickerAndroid;
},580,[23,112,24,25,26,29,30,28,32,148,109,280,156,149,161,150,447,522,168,169,268],"node_modules\\react-native\\Libraries\\Components\\Picker\\PickerAndroid.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\ProgressViewIOS\\ProgressViewIOS.android.js";
  var _components = {
    DummyProgressViewIOS: {
      displayName: "DummyProgressViewIOS"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\ProgressViewIOS\\ProgressViewIOS.android.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var React = _$$_REQUIRE(_dependencyMap[8], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[9], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[10], "Text");

  var View = _$$_REQUIRE(_dependencyMap[11], "View");

  var DummyProgressViewIOS = function (_React$Component) {
    _inherits(DummyProgressViewIOS, _React$Component);

    function DummyProgressViewIOS() {
      _classCallCheck(this, DummyProgressViewIOS);

      return _possibleConstructorReturn(this, _getPrototypeOf(DummyProgressViewIOS).apply(this, arguments));
    }

    _createClass(DummyProgressViewIOS, [{
      key: "render",
      value: function render() {
        return React.createElement(View, {
          style: [styles.dummy, this.props.style],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 20
          }
        }, React.createElement(Text, {
          style: styles.text,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 21
          }
        }, "ProgressViewIOS is not supported on this platform!"));
      }
    }]);

    return DummyProgressViewIOS;
  }(React.Component);

  DummyProgressViewIOS = _wrapComponent("DummyProgressViewIOS")(DummyProgressViewIOS);
  var styles = StyleSheet.create({
    dummy: {
      width: 120,
      height: 20,
      backgroundColor: '#ffbcbc',
      borderWidth: 1,
      borderColor: 'red',
      alignItems: 'center',
      justifyContent: 'center'
    },
    text: {
      color: '#333333',
      margin: 5,
      fontSize: 10
    }
  });
  module.exports = DummyProgressViewIOS;
},581,[23,24,25,26,29,30,109,280,149,150,444,175],"node_modules\\react-native\\Libraries\\Components\\ProgressViewIOS\\ProgressViewIOS.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\SegmentedControlIOS\\SegmentedControlIOS.android.js";
  var _components = {
    DummySegmentedControlIOS: {
      displayName: "DummySegmentedControlIOS"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\SegmentedControlIOS\\SegmentedControlIOS.android.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var React = _$$_REQUIRE(_dependencyMap[8], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[9], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[10], "Text");

  var View = _$$_REQUIRE(_dependencyMap[11], "View");

  var DummySegmentedControlIOS = function (_React$Component) {
    _inherits(DummySegmentedControlIOS, _React$Component);

    function DummySegmentedControlIOS() {
      _classCallCheck(this, DummySegmentedControlIOS);

      return _possibleConstructorReturn(this, _getPrototypeOf(DummySegmentedControlIOS).apply(this, arguments));
    }

    _createClass(DummySegmentedControlIOS, [{
      key: "render",
      value: function render() {
        return React.createElement(View, {
          style: [styles.dummy, this.props.style],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 20
          }
        }, React.createElement(Text, {
          style: styles.text,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 21
          }
        }, "SegmentedControlIOS is not supported on this platform!"));
      }
    }]);

    return DummySegmentedControlIOS;
  }(React.Component);

  DummySegmentedControlIOS = _wrapComponent("DummySegmentedControlIOS")(DummySegmentedControlIOS);
  var styles = StyleSheet.create({
    dummy: {
      width: 120,
      height: 50,
      backgroundColor: '#ffbcbc',
      borderWidth: 1,
      borderColor: 'red',
      alignItems: 'center',
      justifyContent: 'center'
    },
    text: {
      color: '#333333',
      margin: 5,
      fontSize: 10
    }
  });
  module.exports = DummySegmentedControlIOS;
},582,[23,24,25,26,29,30,109,280,149,150,444,175],"node_modules\\react-native\\Libraries\\Components\\SegmentedControlIOS\\SegmentedControlIOS.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\Slider\\Slider.js";

  var ReactNative = _$$_REQUIRE(_dependencyMap[1], "ReactNative");

  var Platform = _$$_REQUIRE(_dependencyMap[2], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[3], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[4], "StyleSheet");

  var requireNativeComponent = _$$_REQUIRE(_dependencyMap[5], "requireNativeComponent");

  var RCTSlider = requireNativeComponent('RCTSlider');

  var Slider = function Slider(props, forwardedRef) {
    var style = StyleSheet.compose(styles.slider, props.style);

    var onValueChange = props.onValueChange && function (event) {
      var userEvent = true;

      if (Platform.OS === 'android') {
        userEvent = event.nativeEvent.fromUser;
      }

      props.onValueChange && userEvent && props.onValueChange(event.nativeEvent.value);
    };

    var onChange = onValueChange;

    var onSlidingComplete = props.onSlidingComplete && function (event) {
      props.onSlidingComplete && props.onSlidingComplete(event.nativeEvent.value);
    };

    return React.createElement(RCTSlider, _extends({}, props, {
      ref: forwardedRef,
      style: style,
      onChange: onChange,
      onSlidingComplete: onSlidingComplete,
      onValueChange: onValueChange,
      enabled: !props.disabled,
      onStartShouldSetResponder: function onStartShouldSetResponder() {
        return true;
      },
      onResponderTerminationRequest: function onResponderTerminationRequest() {
        return false;
      },
      __source: {
        fileName: _jsxFileName,
        lineNumber: 229
      }
    }));
  };

  var SliderWithRef = React.forwardRef(Slider);
  SliderWithRef.defaultProps = {
    disabled: false,
    value: 0,
    minimumValue: 0,
    maximumValue: 1,
    step: 0
  };
  var styles;

  if (Platform.OS === 'ios') {
    styles = StyleSheet.create({
      slider: {
        height: 40
      }
    });
  } else {
    styles = StyleSheet.create({
      slider: {}
    });
  }

  module.exports = SliderWithRef;
},583,[112,178,146,149,150,268],"node_modules\\react-native\\Libraries\\Components\\Slider\\Slider.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = _$$_REQUIRE(_dependencyMap[0], "UnimplementedView");
},584,[539],"node_modules\\react-native\\Libraries\\RCTTest\\SnapshotViewIOS.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var _objectWithoutProperties = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutProperties");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\Switch\\Switch.js";
  var _components = {
    Switch: {
      displayName: "Switch"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\Switch\\Switch.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var SwitchNativeComponent = _$$_REQUIRE(_dependencyMap[12], "SwitchNativeComponent");

  var Platform = _$$_REQUIRE(_dependencyMap[13], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[14], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[15], "StyleSheet");

  var Switch = function (_React$Component) {
    _inherits(Switch, _React$Component);

    function Switch() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, Switch);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Switch)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_nativeSwitchRef", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handleChange", function (event) {
        if (_this._nativeSwitchRef == null) {
          return;
        }

        var value = _this.props.value === true;

        if (Platform.OS === 'android') {
          _this._nativeSwitchRef.setNativeProps({
            on: value
          });
        } else {
          _this._nativeSwitchRef.setNativeProps({
            value: value
          });
        }

        if (_this.props.onChange != null) {
          _this.props.onChange(event);
        }

        if (_this.props.onValueChange != null) {
          _this.props.onValueChange(event.nativeEvent.value);
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handleSwitchNativeComponentRef", function (ref) {
        _this._nativeSwitchRef = ref;
      });

      return _this;
    }

    _createClass(Switch, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            disabled = _this$props.disabled,
            ios_backgroundColor = _this$props.ios_backgroundColor,
            onChange = _this$props.onChange,
            onValueChange = _this$props.onValueChange,
            style = _this$props.style,
            thumbColor = _this$props.thumbColor,
            trackColor = _this$props.trackColor,
            value = _this$props.value,
            props = _objectWithoutProperties(_this$props, ["disabled", "ios_backgroundColor", "onChange", "onValueChange", "style", "thumbColor", "trackColor", "value"]);

        var _thumbColor = thumbColor;

        var _trackColorForFalse = trackColor == null ? void 0 : trackColor.false;

        var _trackColorForTrue = trackColor == null ? void 0 : trackColor.true;

        var _ref = props,
            thumbTintColor = _ref.thumbTintColor,
            tintColor = _ref.tintColor,
            onTintColor = _ref.onTintColor;

        if (thumbTintColor != null) {
          _thumbColor = thumbTintColor;

          if (__DEV__) {
            console.warn('Switch: `thumbTintColor` is deprecated, use `thumbColor` instead.');
          }
        }

        if (tintColor != null) {
          _trackColorForFalse = tintColor;

          if (__DEV__) {
            console.warn('Switch: `tintColor` is deprecated, use `trackColor` instead.');
          }
        }

        if (onTintColor != null) {
          _trackColorForTrue = onTintColor;

          if (__DEV__) {
            console.warn('Switch: `onTintColor` is deprecated, use `trackColor` instead.');
          }
        }

        var platformProps = Platform.OS === 'android' ? {
          enabled: disabled !== true,
          on: value === true,
          style: style,
          thumbTintColor: _thumbColor,
          trackTintColor: value === true ? _trackColorForTrue : _trackColorForFalse
        } : {
          disabled: disabled,
          onTintColor: _trackColorForTrue,
          style: StyleSheet.compose({
            height: 31,
            width: 51
          }, StyleSheet.compose(style, ios_backgroundColor == null ? null : {
            backgroundColor: ios_backgroundColor,
            borderRadius: 16
          })),
          thumbTintColor: _thumbColor,
          tintColor: _trackColorForFalse,
          value: value === true
        };
        return React.createElement(SwitchNativeComponent, _extends({}, props, platformProps, {
          onChange: this._handleChange,
          onResponderTerminationRequest: returnsFalse,
          onStartShouldSetResponder: returnsTrue,
          ref: this._handleSwitchNativeComponentRef,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 164
          }
        }));
      }
    }]);

    return Switch;
  }(React.Component);

  Switch = _wrapComponent("Switch")(Switch);

  var returnsFalse = function returnsFalse() {
    return false;
  };

  var returnsTrue = function returnsTrue() {
    return true;
  };

  module.exports = Switch;
},585,[23,112,120,24,25,26,29,30,28,32,109,280,586,146,149,150],"node_modules\\react-native\\Libraries\\Components\\Switch\\Switch.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Platform = _$$_REQUIRE(_dependencyMap[0], "Platform");

  var ReactNative = _$$_REQUIRE(_dependencyMap[1], "ReactNative");

  var requireNativeComponent = _$$_REQUIRE(_dependencyMap[2], "requireNativeComponent");

  var SwitchNativeComponent = Platform.OS === 'android' ? requireNativeComponent('AndroidSwitch') : requireNativeComponent('RCTSwitch');
  module.exports = SwitchNativeComponent;
},586,[146,178,268],"node_modules\\react-native\\Libraries\\Components\\Switch\\SwitchNativeComponent.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread");

  var _extends = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/extends");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Experimental\\SwipeableRow\\SwipeableFlatList.js";
  var _components = {
    SwipeableFlatList: {
      displayName: "SwipeableFlatList"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Experimental\\SwipeableRow\\SwipeableFlatList.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var PropTypes = _$$_REQUIRE(_dependencyMap[12], "prop-types");

  var React = _$$_REQUIRE(_dependencyMap[13], "React");

  var SwipeableRow = _$$_REQUIRE(_dependencyMap[14], "SwipeableRow");

  var FlatList = _$$_REQUIRE(_dependencyMap[15], "FlatList");

  var SwipeableFlatList = function (_React$Component) {
    _inherits(SwipeableFlatList, _React$Component);

    function SwipeableFlatList(props, context) {
      var _this;

      _classCallCheck(this, SwipeableFlatList);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SwipeableFlatList).call(this, props, context));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "props", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_flatListRef", null);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_shouldBounceFirstRowOnMount", false);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onScroll", function (e) {
        if (_this.state.openRowKey) {
          _this.setState({
            openRowKey: null
          });
        }

        _this.props.onScroll && _this.props.onScroll(e);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_renderItem", function (info) {
        var slideoutView = _this.props.renderQuickActions(info);

        var key = _this.props.keyExtractor(info.item, info.index);

        if (!slideoutView) {
          return _this.props.renderItem(info);
        }

        var shouldBounceOnMount = false;

        if (_this._shouldBounceFirstRowOnMount) {
          _this._shouldBounceFirstRowOnMount = false;
          shouldBounceOnMount = true;
        }

        return React.createElement(SwipeableRow, {
          slideoutView: slideoutView,
          isOpen: key === _this.state.openRowKey,
          maxSwipeDistance: _this._getMaxSwipeDistance(info),
          onOpen: function onOpen() {
            return _this._onOpen(key);
          },
          onClose: function onClose() {
            return _this._onClose(key);
          },
          shouldBounceOnMount: shouldBounceOnMount,
          onSwipeEnd: _this._setListViewScrollable,
          onSwipeStart: _this._setListViewNotScrollable,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 135
          }
        }, _this.props.renderItem(info));
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_setListViewScrollable", function () {
        _this._setListViewScrollableTo(true);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_setListViewNotScrollable", function () {
        _this._setListViewScrollableTo(false);
      });

      _this.state = {
        openRowKey: null
      };
      _this._shouldBounceFirstRowOnMount = _this.props.bounceFirstRowOnMount;
      return _this;
    }

    _createClass(SwipeableFlatList, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        return React.createElement(FlatList, _extends({}, this.props, {
          ref: function ref(_ref) {
            _this2._flatListRef = _ref;
          },
          onScroll: this._onScroll,
          renderItem: this._renderItem,
          extraData: this.state,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 96
          }
        }));
      }
    }, {
      key: "_getMaxSwipeDistance",
      value: function _getMaxSwipeDistance(info) {
        if (typeof this.props.maxSwipeDistance === 'function') {
          return this.props.maxSwipeDistance(info);
        }

        return this.props.maxSwipeDistance;
      }
    }, {
      key: "_setListViewScrollableTo",
      value: function _setListViewScrollableTo(value) {
        if (this._flatListRef) {
          this._flatListRef.setNativeProps({
            scrollEnabled: value
          });
        }
      }
    }, {
      key: "_onOpen",
      value: function _onOpen(key) {
        this.setState({
          openRowKey: key
        });
      }
    }, {
      key: "_onClose",
      value: function _onClose(key) {
        this.setState({
          openRowKey: null
        });
      }
    }]);

    return SwipeableFlatList;
  }(React.Component);

  _defineProperty(SwipeableFlatList, "propTypes", _objectSpread({}, FlatList.propTypes, {
    bounceFirstRowOnMount: PropTypes.bool.isRequired,
    maxSwipeDistance: PropTypes.oneOfType([PropTypes.number, PropTypes.func]).isRequired,
    renderQuickActions: PropTypes.func.isRequired
  }));

  _defineProperty(SwipeableFlatList, "defaultProps", _objectSpread({}, FlatList.defaultProps, {
    bounceFirstRowOnMount: true,
    renderQuickActions: function renderQuickActions() {
      return null;
    }
  }));

  SwipeableFlatList = _wrapComponent("SwipeableFlatList")(SwipeableFlatList);
  module.exports = SwipeableFlatList;
},587,[23,148,112,24,25,26,29,30,28,32,109,280,161,149,588,497],"node_modules\\react-native\\Libraries\\Experimental\\SwipeableRow\\SwipeableFlatList.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/inherits");

  var _extends = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/extends");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Experimental\\SwipeableRow\\SwipeableRow.js";

  var Animated = _$$_REQUIRE(_dependencyMap[6], "Animated");

  var I18nManager = _$$_REQUIRE(_dependencyMap[7], "I18nManager");

  var PanResponder = _$$_REQUIRE(_dependencyMap[8], "PanResponder");

  var React = _$$_REQUIRE(_dependencyMap[9], "React");

  var PropTypes = _$$_REQUIRE(_dependencyMap[10], "prop-types");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[11], "StyleSheet");

  var TimerMixin = _$$_REQUIRE(_dependencyMap[12], "react-timer-mixin");

  var View = _$$_REQUIRE(_dependencyMap[13], "View");

  var createReactClass = _$$_REQUIRE(_dependencyMap[14], "create-react-class");

  var emptyFunction = _$$_REQUIRE(_dependencyMap[15], "fbjs/lib/emptyFunction");

  var IS_RTL = I18nManager.isRTL;
  var CLOSED_LEFT_POSITION = 0;
  var HORIZONTAL_SWIPE_DISTANCE_THRESHOLD = 10;
  var HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD = 0.3;
  var SLOW_SPEED_SWIPE_FACTOR = 4;
  var SWIPE_DURATION = 300;
  var ON_MOUNT_BOUNCE_DELAY = 700;
  var ON_MOUNT_BOUNCE_DURATION = 400;
  var RIGHT_SWIPE_BOUNCE_BACK_DISTANCE = 30;
  var RIGHT_SWIPE_BOUNCE_BACK_DURATION = 300;
  var RIGHT_SWIPE_THRESHOLD = 30 * SLOW_SPEED_SWIPE_FACTOR;
  var SwipeableRow = createReactClass({
    displayName: 'SwipeableRow',
    _panResponder: {},
    _previousLeft: CLOSED_LEFT_POSITION,
    mixins: [TimerMixin],
    propTypes: {
      children: PropTypes.any,
      isOpen: PropTypes.bool,
      preventSwipeRight: PropTypes.bool,
      maxSwipeDistance: PropTypes.number.isRequired,
      onOpen: PropTypes.func.isRequired,
      onClose: PropTypes.func.isRequired,
      onSwipeEnd: PropTypes.func.isRequired,
      onSwipeStart: PropTypes.func.isRequired,
      shouldBounceOnMount: PropTypes.bool,
      slideoutView: PropTypes.node.isRequired,
      swipeThreshold: PropTypes.number.isRequired
    },
    getInitialState: function getInitialState() {
      return {
        currentLeft: new Animated.Value(this._previousLeft),
        isSwipeableViewRendered: false,
        rowHeight: null
      };
    },
    getDefaultProps: function getDefaultProps() {
      return {
        isOpen: false,
        preventSwipeRight: false,
        maxSwipeDistance: 0,
        onOpen: emptyFunction,
        onClose: emptyFunction,
        onSwipeEnd: emptyFunction,
        onSwipeStart: emptyFunction,
        swipeThreshold: 30
      };
    },
    UNSAFE_componentWillMount: function UNSAFE_componentWillMount() {
      this._panResponder = PanResponder.create({
        onMoveShouldSetPanResponderCapture: this._handleMoveShouldSetPanResponderCapture,
        onPanResponderGrant: this._handlePanResponderGrant,
        onPanResponderMove: this._handlePanResponderMove,
        onPanResponderRelease: this._handlePanResponderEnd,
        onPanResponderTerminationRequest: this._onPanResponderTerminationRequest,
        onPanResponderTerminate: this._handlePanResponderEnd,
        onShouldBlockNativeResponder: function onShouldBlockNativeResponder(event, gestureState) {
          return false;
        }
      });
    },
    componentDidMount: function componentDidMount() {
      var _this = this;

      if (this.props.shouldBounceOnMount) {
        this.setTimeout(function () {
          _this._animateBounceBack(ON_MOUNT_BOUNCE_DURATION);
        }, ON_MOUNT_BOUNCE_DELAY);
      }
    },
    UNSAFE_componentWillReceiveProps: function UNSAFE_componentWillReceiveProps(nextProps) {
      if (this.props.isOpen && !nextProps.isOpen) {
        this._animateToClosedPosition();
      }
    },
    render: function render() {
      var slideOutView;

      if (this.state.isSwipeableViewRendered && this.state.rowHeight) {
        slideOutView = React.createElement(View, {
          style: [styles.slideOutContainer, {
            height: this.state.rowHeight
          }],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 178
          }
        }, this.props.slideoutView);
      }

      var swipeableView = React.createElement(Animated.View, {
        onLayout: this._onSwipeableViewLayout,
        style: {
          transform: [{
            translateX: this.state.currentLeft
          }]
        },
        __source: {
          fileName: _jsxFileName,
          lineNumber: 187
        }
      }, this.props.children);
      return React.createElement(View, _extends({}, this._panResponder.panHandlers, {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 195
        }
      }), slideOutView, swipeableView);
    },
    close: function close() {
      this.props.onClose();

      this._animateToClosedPosition();
    },
    _onSwipeableViewLayout: function _onSwipeableViewLayout(event) {
      this.setState({
        isSwipeableViewRendered: true,
        rowHeight: event.nativeEvent.layout.height
      });
    },
    _handleMoveShouldSetPanResponderCapture: function _handleMoveShouldSetPanResponderCapture(event, gestureState) {
      return gestureState.dy < 10 && this._isValidSwipe(gestureState);
    },
    _handlePanResponderGrant: function _handlePanResponderGrant(event, gestureState) {},
    _handlePanResponderMove: function _handlePanResponderMove(event, gestureState) {
      if (this._isSwipingExcessivelyRightFromClosedPosition(gestureState)) {
        return;
      }

      this.props.onSwipeStart();

      if (this._isSwipingRightFromClosed(gestureState)) {
        this._swipeSlowSpeed(gestureState);
      } else {
        this._swipeFullSpeed(gestureState);
      }
    },
    _isSwipingRightFromClosed: function _isSwipingRightFromClosed(gestureState) {
      var gestureStateDx = IS_RTL ? -gestureState.dx : gestureState.dx;
      return this._previousLeft === CLOSED_LEFT_POSITION && gestureStateDx > 0;
    },
    _swipeFullSpeed: function _swipeFullSpeed(gestureState) {
      this.state.currentLeft.setValue(this._previousLeft + gestureState.dx);
    },
    _swipeSlowSpeed: function _swipeSlowSpeed(gestureState) {
      this.state.currentLeft.setValue(this._previousLeft + gestureState.dx / SLOW_SPEED_SWIPE_FACTOR);
    },
    _isSwipingExcessivelyRightFromClosedPosition: function _isSwipingExcessivelyRightFromClosedPosition(gestureState) {
      var gestureStateDx = IS_RTL ? -gestureState.dx : gestureState.dx;
      return this._isSwipingRightFromClosed(gestureState) && gestureStateDx > RIGHT_SWIPE_THRESHOLD;
    },
    _onPanResponderTerminationRequest: function _onPanResponderTerminationRequest(event, gestureState) {
      return false;
    },
    _animateTo: function _animateTo(toValue) {
      var _this2 = this;

      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SWIPE_DURATION;
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : emptyFunction;
      Animated.timing(this.state.currentLeft, {
        duration: duration,
        toValue: toValue,
        useNativeDriver: true
      }).start(function () {
        _this2._previousLeft = toValue;
        callback();
      });
    },
    _animateToOpenPosition: function _animateToOpenPosition() {
      var maxSwipeDistance = IS_RTL ? -this.props.maxSwipeDistance : this.props.maxSwipeDistance;

      this._animateTo(-maxSwipeDistance);
    },
    _animateToOpenPositionWith: function _animateToOpenPositionWith(speed, distMoved) {
      speed = speed > HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD ? speed : HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD;
      var duration = Math.abs((this.props.maxSwipeDistance - Math.abs(distMoved)) / speed);
      var maxSwipeDistance = IS_RTL ? -this.props.maxSwipeDistance : this.props.maxSwipeDistance;

      this._animateTo(-maxSwipeDistance, duration);
    },
    _animateToClosedPosition: function _animateToClosedPosition() {
      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SWIPE_DURATION;

      this._animateTo(CLOSED_LEFT_POSITION, duration);
    },
    _animateToClosedPositionDuringBounce: function _animateToClosedPositionDuringBounce() {
      this._animateToClosedPosition(RIGHT_SWIPE_BOUNCE_BACK_DURATION);
    },
    _animateBounceBack: function _animateBounceBack(duration) {
      var swipeBounceBackDistance = IS_RTL ? -RIGHT_SWIPE_BOUNCE_BACK_DISTANCE : RIGHT_SWIPE_BOUNCE_BACK_DISTANCE;

      this._animateTo(-swipeBounceBackDistance, duration, this._animateToClosedPositionDuringBounce);
    },
    _isValidSwipe: function _isValidSwipe(gestureState) {
      if (this.props.preventSwipeRight && this._previousLeft === CLOSED_LEFT_POSITION && gestureState.dx > 0) {
        return false;
      }

      return Math.abs(gestureState.dx) > HORIZONTAL_SWIPE_DISTANCE_THRESHOLD;
    },
    _shouldAnimateRemainder: function _shouldAnimateRemainder(gestureState) {
      return Math.abs(gestureState.dx) > this.props.swipeThreshold || gestureState.vx > HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD;
    },
    _handlePanResponderEnd: function _handlePanResponderEnd(event, gestureState) {
      var horizontalDistance = IS_RTL ? -gestureState.dx : gestureState.dx;

      if (this._isSwipingRightFromClosed(gestureState)) {
        this.props.onOpen();

        this._animateBounceBack(RIGHT_SWIPE_BOUNCE_BACK_DURATION);
      } else if (this._shouldAnimateRemainder(gestureState)) {
        if (horizontalDistance < 0) {
          this.props.onOpen();

          this._animateToOpenPositionWith(gestureState.vx, horizontalDistance);
        } else {
          this.props.onClose();

          this._animateToClosedPosition();
        }
      } else {
        if (this._previousLeft === CLOSED_LEFT_POSITION) {
          this._animateToClosedPosition();
        } else {
          this._animateToOpenPosition();
        }
      }

      this.props.onSwipeEnd();
    }
  });

  var TypedSwipeableRow = function (_React$Component) {
    _inherits(TypedSwipeableRow, _React$Component);

    function TypedSwipeableRow() {
      _classCallCheck(this, TypedSwipeableRow);

      return _possibleConstructorReturn(this, _getPrototypeOf(TypedSwipeableRow).apply(this, arguments));
    }

    _createClass(TypedSwipeableRow, [{
      key: "close",
      value: function close() {}
    }]);

    return TypedSwipeableRow;
  }(React.Component);

  var styles = StyleSheet.create({
    slideOutContainer: {
      bottom: 0,
      left: 0,
      position: 'absolute',
      right: 0,
      top: 0
    }
  });
  module.exports = SwipeableRow;
},588,[24,25,26,29,30,112,468,547,589,149,161,150,458,175,459,144],"node_modules\\react-native\\Libraries\\Experimental\\SwipeableRow\\SwipeableRow.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var InteractionManager = _$$_REQUIRE(_dependencyMap[0], "./InteractionManager");

  var TouchHistoryMath = _$$_REQUIRE(_dependencyMap[1], "./TouchHistoryMath");

  var currentCentroidXOfTouchesChangedAfter = TouchHistoryMath.currentCentroidXOfTouchesChangedAfter;
  var currentCentroidYOfTouchesChangedAfter = TouchHistoryMath.currentCentroidYOfTouchesChangedAfter;
  var previousCentroidXOfTouchesChangedAfter = TouchHistoryMath.previousCentroidXOfTouchesChangedAfter;
  var previousCentroidYOfTouchesChangedAfter = TouchHistoryMath.previousCentroidYOfTouchesChangedAfter;
  var currentCentroidX = TouchHistoryMath.currentCentroidX;
  var currentCentroidY = TouchHistoryMath.currentCentroidY;
  var PanResponder = {
    _initializeGestureState: function _initializeGestureState(gestureState) {
      gestureState.moveX = 0;
      gestureState.moveY = 0;
      gestureState.x0 = 0;
      gestureState.y0 = 0;
      gestureState.dx = 0;
      gestureState.dy = 0;
      gestureState.vx = 0;
      gestureState.vy = 0;
      gestureState.numberActiveTouches = 0;
      gestureState._accountsForMovesUpTo = 0;
    },
    _updateGestureStateOnMove: function _updateGestureStateOnMove(gestureState, touchHistory) {
      gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
      gestureState.moveX = currentCentroidXOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
      gestureState.moveY = currentCentroidYOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
      var movedAfter = gestureState._accountsForMovesUpTo;
      var prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);
      var x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);
      var prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);
      var y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);
      var nextDX = gestureState.dx + (x - prevX);
      var nextDY = gestureState.dy + (y - prevY);
      var dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;
      gestureState.vx = (nextDX - gestureState.dx) / dt;
      gestureState.vy = (nextDY - gestureState.dy) / dt;
      gestureState.dx = nextDX;
      gestureState.dy = nextDY;
      gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;
    },
    create: function create(config) {
      var interactionState = {
        handle: null
      };
      var gestureState = {
        stateID: Math.random()
      };

      PanResponder._initializeGestureState(gestureState);

      var panHandlers = {
        onStartShouldSetResponder: function onStartShouldSetResponder(e) {
          return config.onStartShouldSetPanResponder === undefined ? false : config.onStartShouldSetPanResponder(e, gestureState);
        },
        onMoveShouldSetResponder: function onMoveShouldSetResponder(e) {
          return config.onMoveShouldSetPanResponder === undefined ? false : config.onMoveShouldSetPanResponder(e, gestureState);
        },
        onStartShouldSetResponderCapture: function onStartShouldSetResponderCapture(e) {
          if (e.nativeEvent.touches.length === 1) {
            PanResponder._initializeGestureState(gestureState);
          }

          gestureState.numberActiveTouches = e.touchHistory.numberActiveTouches;
          return config.onStartShouldSetPanResponderCapture !== undefined ? config.onStartShouldSetPanResponderCapture(e, gestureState) : false;
        },
        onMoveShouldSetResponderCapture: function onMoveShouldSetResponderCapture(e) {
          var touchHistory = e.touchHistory;

          if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {
            return false;
          }

          PanResponder._updateGestureStateOnMove(gestureState, touchHistory);

          return config.onMoveShouldSetPanResponderCapture ? config.onMoveShouldSetPanResponderCapture(e, gestureState) : false;
        },
        onResponderGrant: function onResponderGrant(e) {
          if (!interactionState.handle) {
            interactionState.handle = InteractionManager.createInteractionHandle();
          }

          gestureState.x0 = currentCentroidX(e.touchHistory);
          gestureState.y0 = currentCentroidY(e.touchHistory);
          gestureState.dx = 0;
          gestureState.dy = 0;

          if (config.onPanResponderGrant) {
            config.onPanResponderGrant(e, gestureState);
          }

          return config.onShouldBlockNativeResponder === undefined ? true : config.onShouldBlockNativeResponder();
        },
        onResponderReject: function onResponderReject(e) {
          clearInteractionHandle(interactionState, config.onPanResponderReject, e, gestureState);
        },
        onResponderRelease: function onResponderRelease(e) {
          clearInteractionHandle(interactionState, config.onPanResponderRelease, e, gestureState);

          PanResponder._initializeGestureState(gestureState);
        },
        onResponderStart: function onResponderStart(e) {
          var touchHistory = e.touchHistory;
          gestureState.numberActiveTouches = touchHistory.numberActiveTouches;

          if (config.onPanResponderStart) {
            config.onPanResponderStart(e, gestureState);
          }
        },
        onResponderMove: function onResponderMove(e) {
          var touchHistory = e.touchHistory;

          if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {
            return;
          }

          PanResponder._updateGestureStateOnMove(gestureState, touchHistory);

          if (config.onPanResponderMove) {
            config.onPanResponderMove(e, gestureState);
          }
        },
        onResponderEnd: function onResponderEnd(e) {
          var touchHistory = e.touchHistory;
          gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
          clearInteractionHandle(interactionState, config.onPanResponderEnd, e, gestureState);
        },
        onResponderTerminate: function onResponderTerminate(e) {
          clearInteractionHandle(interactionState, config.onPanResponderTerminate, e, gestureState);

          PanResponder._initializeGestureState(gestureState);
        },
        onResponderTerminationRequest: function onResponderTerminationRequest(e) {
          return config.onPanResponderTerminationRequest === undefined ? true : config.onPanResponderTerminationRequest(e, gestureState);
        }
      };
      return {
        panHandlers: panHandlers,
        getInteractionHandle: function getInteractionHandle() {
          return interactionState.handle;
        }
      };
    }
  };

  function clearInteractionHandle(interactionState, callback, event, gestureState) {
    if (interactionState.handle) {
      InteractionManager.clearInteractionHandle(interactionState.handle);
      interactionState.handle = null;
    }

    if (callback) {
      callback(event, gestureState);
    }
  }

  module.exports = PanResponder;
},589,[476,590],"node_modules\\react-native\\Libraries\\Interaction\\PanResponder.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var TouchHistoryMath = {
    centroidDimension: function centroidDimension(touchHistory, touchesChangedAfter, isXAxis, ofCurrent) {
      var touchBank = touchHistory.touchBank;
      var total = 0;
      var count = 0;
      var oneTouchData = touchHistory.numberActiveTouches === 1 ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch] : null;

      if (oneTouchData !== null) {
        if (oneTouchData.touchActive && oneTouchData.currentTimeStamp > touchesChangedAfter) {
          total += ofCurrent && isXAxis ? oneTouchData.currentPageX : ofCurrent && !isXAxis ? oneTouchData.currentPageY : !ofCurrent && isXAxis ? oneTouchData.previousPageX : oneTouchData.previousPageY;
          count = 1;
        }
      } else {
        for (var i = 0; i < touchBank.length; i++) {
          var touchTrack = touchBank[i];

          if (touchTrack !== null && touchTrack !== undefined && touchTrack.touchActive && touchTrack.currentTimeStamp >= touchesChangedAfter) {
            var toAdd = void 0;

            if (ofCurrent && isXAxis) {
              toAdd = touchTrack.currentPageX;
            } else if (ofCurrent && !isXAxis) {
              toAdd = touchTrack.currentPageY;
            } else if (!ofCurrent && isXAxis) {
              toAdd = touchTrack.previousPageX;
            } else {
              toAdd = touchTrack.previousPageY;
            }

            total += toAdd;
            count++;
          }
        }
      }

      return count > 0 ? total / count : TouchHistoryMath.noCentroid;
    },
    currentCentroidXOfTouchesChangedAfter: function currentCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true, true);
    },
    currentCentroidYOfTouchesChangedAfter: function currentCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, true);
    },
    previousCentroidXOfTouchesChangedAfter: function previousCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true, false);
    },
    previousCentroidYOfTouchesChangedAfter: function previousCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, false);
    },
    currentCentroidX: function currentCentroidX(touchHistory) {
      return TouchHistoryMath.centroidDimension(touchHistory, 0, true, true);
    },
    currentCentroidY: function currentCentroidY(touchHistory) {
      return TouchHistoryMath.centroidDimension(touchHistory, 0, false, true);
    },
    noCentroid: -1
  };
  module.exports = TouchHistoryMath;
},590,[],"node_modules\\react-native\\Libraries\\Interaction\\TouchHistoryMath.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _createClass = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/createClass");

  var _inherits = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Experimental\\SwipeableRow\\SwipeableListView.js";
  var _components = {
    SwipeableListView: {
      displayName: "SwipeableListView"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Experimental\\SwipeableRow\\SwipeableListView.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var ListView = _$$_REQUIRE(_dependencyMap[11], "ListView");

  var PropTypes = _$$_REQUIRE(_dependencyMap[12], "prop-types");

  var React = _$$_REQUIRE(_dependencyMap[13], "React");

  var SwipeableListViewDataSource = _$$_REQUIRE(_dependencyMap[14], "SwipeableListViewDataSource");

  var SwipeableRow = _$$_REQUIRE(_dependencyMap[15], "SwipeableRow");

  var SwipeableListView = function (_React$Component) {
    _inherits(SwipeableListView, _React$Component);

    _createClass(SwipeableListView, null, [{
      key: "getNewDataSource",
      value: function getNewDataSource() {
        return new SwipeableListViewDataSource({
          getRowData: function getRowData(data, sectionID, rowID) {
            return data[sectionID][rowID];
          },
          getSectionHeaderData: function getSectionHeaderData(data, sectionID) {
            return data[sectionID];
          },
          rowHasChanged: function rowHasChanged(row1, row2) {
            return row1 !== row2;
          },
          sectionHeaderHasChanged: function sectionHeaderHasChanged(s1, s2) {
            return s1 !== s2;
          }
        });
      }
    }]);

    function SwipeableListView(props, context) {
      var _this;

      _classCallCheck(this, SwipeableListView);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SwipeableListView).call(this, props, context));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "props", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", void 0);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_listViewRef", null);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_shouldBounceFirstRowOnMount", false);

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onScroll", function (e) {
        if (_this.props.dataSource.getOpenRowID()) {
          _this.setState({
            dataSource: _this.state.dataSource.setOpenRowID(null)
          });
        }

        _this.props.onScroll && _this.props.onScroll(e);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_renderRow", function (rowData, sectionID, rowID) {
        var slideoutView = _this.props.renderQuickActions(rowData, sectionID, rowID);

        if (!slideoutView) {
          return _this.props.renderRow(rowData, sectionID, rowID);
        }

        var shouldBounceOnMount = false;

        if (_this._shouldBounceFirstRowOnMount) {
          _this._shouldBounceFirstRowOnMount = false;
          shouldBounceOnMount = rowID === _this.props.dataSource.getFirstRowID();
        }

        return React.createElement(SwipeableRow, {
          slideoutView: slideoutView,
          isOpen: rowData.id === _this.props.dataSource.getOpenRowID(),
          maxSwipeDistance: _this._getMaxSwipeDistance(rowData, sectionID, rowID),
          key: rowID,
          onOpen: function onOpen() {
            return _this._onOpen(rowData.id);
          },
          onClose: function onClose() {
            return _this._onClose(rowData.id);
          },
          onSwipeEnd: function onSwipeEnd() {
            return _this._setListViewScrollable(true);
          },
          onSwipeStart: function onSwipeStart() {
            return _this._setListViewScrollable(false);
          },
          shouldBounceOnMount: shouldBounceOnMount,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 213
          }
        }, _this.props.renderRow(rowData, sectionID, rowID));
      });

      _this._shouldBounceFirstRowOnMount = _this.props.bounceFirstRowOnMount;
      _this.state = {
        dataSource: _this.props.dataSource
      };
      return _this;
    }

    _createClass(SwipeableListView, [{
      key: "UNSAFE_componentWillReceiveProps",
      value: function UNSAFE_componentWillReceiveProps(nextProps) {
        if (this.state.dataSource.getDataSource() !== nextProps.dataSource.getDataSource()) {
          this.setState({
            dataSource: nextProps.dataSource
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        return React.createElement(ListView, _extends({}, this.props, {
          ref: function ref(_ref) {
            _this2._listViewRef = _ref;
          },
          dataSource: this.state.dataSource.getDataSource(),
          onScroll: this._onScroll,
          renderRow: this._renderRow,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 121
          }
        }));
      }
    }, {
      key: "_setListViewScrollable",
      value: function _setListViewScrollable(value) {
        if (this._listViewRef && typeof this._listViewRef.setNativeProps === 'function') {
          this._listViewRef.setNativeProps({
            scrollEnabled: value
          });
        }
      }
    }, {
      key: "getScrollResponder",
      value: function getScrollResponder() {
        if (this._listViewRef && typeof this._listViewRef.getScrollResponder === 'function') {
          return this._listViewRef.getScrollResponder();
        }
      }
    }, {
      key: "_getMaxSwipeDistance",
      value: function _getMaxSwipeDistance(rowData, sectionID, rowID) {
        if (typeof this.props.maxSwipeDistance === 'function') {
          return this.props.maxSwipeDistance(rowData, sectionID, rowID);
        }

        return this.props.maxSwipeDistance;
      }
    }, {
      key: "_onOpen",
      value: function _onOpen(rowID) {
        this.setState({
          dataSource: this.state.dataSource.setOpenRowID(rowID)
        });
      }
    }, {
      key: "_onClose",
      value: function _onClose(rowID) {
        this.setState({
          dataSource: this.state.dataSource.setOpenRowID(null)
        });
      }
    }]);

    return SwipeableListView;
  }(React.Component);

  _defineProperty(SwipeableListView, "propTypes", {
    bounceFirstRowOnMount: PropTypes.bool.isRequired,
    dataSource: PropTypes.instanceOf(SwipeableListViewDataSource).isRequired,
    maxSwipeDistance: PropTypes.oneOfType([PropTypes.number, PropTypes.func]).isRequired,
    renderRow: PropTypes.func.isRequired,
    renderQuickActions: PropTypes.func.isRequired
  });

  _defineProperty(SwipeableListView, "defaultProps", {
    bounceFirstRowOnMount: false,
    renderQuickActions: function renderQuickActions() {
      return null;
    }
  });

  SwipeableListView = _wrapComponent("SwipeableListView")(SwipeableListView);
  module.exports = SwipeableListView;
},591,[23,112,24,26,29,25,30,28,32,109,280,499,161,149,592,588],"node_modules\\react-native\\Libraries\\Experimental\\SwipeableRow\\SwipeableListView.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/defineProperty");

  var ListViewDataSource = _$$_REQUIRE(_dependencyMap[3], "ListViewDataSource");

  var SwipeableListViewDataSource = function () {
    function SwipeableListViewDataSource(params) {
      var _this = this;

      _classCallCheck(this, SwipeableListViewDataSource);

      _defineProperty(this, "_previousOpenRowID", void 0);

      _defineProperty(this, "_openRowID", void 0);

      _defineProperty(this, "_dataBlob", void 0);

      _defineProperty(this, "_dataSource", void 0);

      _defineProperty(this, "rowIdentities", void 0);

      _defineProperty(this, "sectionIdentities", void 0);

      this._dataSource = new ListViewDataSource({
        getRowData: params.getRowData,
        getSectionHeaderData: params.getSectionHeaderData,
        rowHasChanged: function rowHasChanged(row1, row2) {
          return row1.id !== _this._previousOpenRowID && row2.id === _this._openRowID || row1.id === _this._previousOpenRowID && row2.id !== _this._openRowID || params.rowHasChanged(row1, row2);
        },
        sectionHeaderHasChanged: params.sectionHeaderHasChanged
      });
    }

    _createClass(SwipeableListViewDataSource, [{
      key: "cloneWithRowsAndSections",
      value: function cloneWithRowsAndSections(dataBlob, sectionIdentities, rowIdentities) {
        this._dataSource = this._dataSource.cloneWithRowsAndSections(dataBlob, sectionIdentities, rowIdentities);
        this._dataBlob = dataBlob;
        this.rowIdentities = this._dataSource.rowIdentities;
        this.sectionIdentities = this._dataSource.sectionIdentities;
        return this;
      }
    }, {
      key: "getDataSource",
      value: function getDataSource() {
        return this._dataSource;
      }
    }, {
      key: "getOpenRowID",
      value: function getOpenRowID() {
        return this._openRowID;
      }
    }, {
      key: "getFirstRowID",
      value: function getFirstRowID() {
        if (this.rowIdentities) {
          return this.rowIdentities[0] && this.rowIdentities[0][0];
        }

        return Object.keys(this._dataBlob)[0];
      }
    }, {
      key: "getLastRowID",
      value: function getLastRowID() {
        if (this.rowIdentities && this.rowIdentities.length) {
          var lastSection = this.rowIdentities[this.rowIdentities.length - 1];

          if (lastSection && lastSection.length) {
            return lastSection[lastSection.length - 1];
          }
        }

        return Object.keys(this._dataBlob)[this._dataBlob.length - 1];
      }
    }, {
      key: "setOpenRowID",
      value: function setOpenRowID(rowID) {
        this._previousOpenRowID = this._openRowID;
        this._openRowID = rowID;
        this._dataSource = this._dataSource.cloneWithRowsAndSections(this._dataBlob, this.sectionIdentities, this.rowIdentities);
        return this;
      }
    }]);

    return SwipeableListViewDataSource;
  }();

  module.exports = SwipeableListViewDataSource;
},592,[24,25,32,501],"node_modules\\react-native\\Libraries\\Experimental\\SwipeableRow\\SwipeableListViewDataSource.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\TabBarIOS\\TabBarIOS.android.js";
  var _components = {
    DummyTabBarIOS: {
      displayName: "DummyTabBarIOS"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\TabBarIOS\\TabBarIOS.android.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var React = _$$_REQUIRE(_dependencyMap[9], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[10], "StyleSheet");

  var TabBarItemIOS = _$$_REQUIRE(_dependencyMap[11], "TabBarItemIOS");

  var View = _$$_REQUIRE(_dependencyMap[12], "View");

  var DummyTabBarIOS = function (_React$Component) {
    _inherits(DummyTabBarIOS, _React$Component);

    function DummyTabBarIOS() {
      _classCallCheck(this, DummyTabBarIOS);

      return _possibleConstructorReturn(this, _getPrototypeOf(DummyTabBarIOS).apply(this, arguments));
    }

    _createClass(DummyTabBarIOS, [{
      key: "render",
      value: function render() {
        return React.createElement(View, {
          style: [this.props.style, styles.tabGroup],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 23
          }
        }, this.props.children);
      }
    }]);

    return DummyTabBarIOS;
  }(React.Component);

  _defineProperty(DummyTabBarIOS, "Item", TabBarItemIOS);

  DummyTabBarIOS = _wrapComponent("DummyTabBarIOS")(DummyTabBarIOS);
  var styles = StyleSheet.create({
    tabGroup: {
      flex: 1
    }
  });
  module.exports = DummyTabBarIOS;
},593,[23,24,25,26,29,30,32,109,280,149,150,594,175],"node_modules\\react-native\\Libraries\\Components\\TabBarIOS\\TabBarIOS.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/inherits");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\TabBarIOS\\TabBarItemIOS.android.js";
  var _components = {
    DummyTab: {
      displayName: "DummyTab"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\TabBarIOS\\TabBarItemIOS.android.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var React = _$$_REQUIRE(_dependencyMap[8], "React");

  var View = _$$_REQUIRE(_dependencyMap[9], "View");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[10], "StyleSheet");

  var DummyTab = function (_React$Component) {
    _inherits(DummyTab, _React$Component);

    function DummyTab() {
      _classCallCheck(this, DummyTab);

      return _possibleConstructorReturn(this, _getPrototypeOf(DummyTab).apply(this, arguments));
    }

    _createClass(DummyTab, [{
      key: "render",
      value: function render() {
        if (!this.props.selected) {
          return React.createElement(View, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 19
            }
          });
        }

        return React.createElement(View, {
          style: [this.props.style, styles.tab],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 22
          }
        }, this.props.children);
      }
    }]);

    return DummyTab;
  }(React.Component);

  DummyTab = _wrapComponent("DummyTab")(DummyTab);
  var styles = StyleSheet.create({
    tab: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      borderColor: 'red',
      borderWidth: 1
    }
  });
  module.exports = DummyTab;
},594,[23,24,25,26,29,30,109,280,149,175,150],"node_modules\\react-native\\Libraries\\Components\\TabBarIOS\\TabBarItemIOS.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/inherits");

  var _extends = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/extends");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/objectSpread");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\TextInput\\TextInput.js";

  var ColorPropType = _$$_REQUIRE(_dependencyMap[7], "ColorPropType");

  var DocumentSelectionState = _$$_REQUIRE(_dependencyMap[8], "DocumentSelectionState");

  var EventEmitter = _$$_REQUIRE(_dependencyMap[9], "EventEmitter");

  var NativeMethodsMixin = _$$_REQUIRE(_dependencyMap[10], "NativeMethodsMixin");

  var Platform = _$$_REQUIRE(_dependencyMap[11], "Platform");

  var React = _$$_REQUIRE(_dependencyMap[12], "React");

  var createReactClass = _$$_REQUIRE(_dependencyMap[13], "create-react-class");

  var PropTypes = _$$_REQUIRE(_dependencyMap[14], "prop-types");

  var ReactNative = _$$_REQUIRE(_dependencyMap[15], "ReactNative");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[16], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[17], "Text");

  var TextAncestor = _$$_REQUIRE(_dependencyMap[18], "TextAncestor");

  var TextInputState = _$$_REQUIRE(_dependencyMap[19], "TextInputState");

  var TimerMixin = _$$_REQUIRE(_dependencyMap[20], "react-timer-mixin");

  var TouchableWithoutFeedback = _$$_REQUIRE(_dependencyMap[21], "TouchableWithoutFeedback");

  var UIManager = _$$_REQUIRE(_dependencyMap[22], "UIManager");

  var ViewPropTypes = _$$_REQUIRE(_dependencyMap[23], "ViewPropTypes");

  var emptyFunction = _$$_REQUIRE(_dependencyMap[24], "fbjs/lib/emptyFunction");

  var invariant = _$$_REQUIRE(_dependencyMap[25], "fbjs/lib/invariant");

  var requireNativeComponent = _$$_REQUIRE(_dependencyMap[26], "requireNativeComponent");

  var warning = _$$_REQUIRE(_dependencyMap[27], "fbjs/lib/warning");

  var AndroidTextInput;
  var RCTMultilineTextInputView;
  var RCTSinglelineTextInputView;

  if (Platform.OS === 'android') {
    AndroidTextInput = requireNativeComponent('AndroidTextInput');
  } else if (Platform.OS === 'ios') {
    RCTMultilineTextInputView = requireNativeComponent('RCTMultilineTextInputView');
    RCTSinglelineTextInputView = requireNativeComponent('RCTSinglelineTextInputView');
  }

  var onlyMultiline = {
    onTextInput: true,
    children: true
  };
  var DataDetectorTypes = ['phoneNumber', 'link', 'address', 'calendarEvent', 'none', 'all'];
  var TextInput = createReactClass({
    displayName: 'TextInput',
    statics: {
      State: {
        currentlyFocusedField: TextInputState.currentlyFocusedField,
        focusTextInput: TextInputState.focusTextInput,
        blurTextInput: TextInputState.blurTextInput
      }
    },
    propTypes: _objectSpread({}, ViewPropTypes, {
      autoCapitalize: PropTypes.oneOf(['none', 'sentences', 'words', 'characters']),
      autoCorrect: PropTypes.bool,
      spellCheck: PropTypes.bool,
      autoFocus: PropTypes.bool,
      allowFontScaling: PropTypes.bool,
      editable: PropTypes.bool,
      keyboardType: PropTypes.oneOf(['default', 'email-address', 'numeric', 'phone-pad', 'number-pad', 'ascii-capable', 'numbers-and-punctuation', 'url', 'name-phone-pad', 'decimal-pad', 'twitter', 'web-search', 'visible-password']),
      keyboardAppearance: PropTypes.oneOf(['default', 'light', 'dark']),
      returnKeyType: PropTypes.oneOf(['done', 'go', 'next', 'search', 'send', 'none', 'previous', 'default', 'emergency-call', 'google', 'join', 'route', 'yahoo']),
      returnKeyLabel: PropTypes.string,
      maxLength: PropTypes.number,
      numberOfLines: PropTypes.number,
      disableFullscreenUI: PropTypes.bool,
      enablesReturnKeyAutomatically: PropTypes.bool,
      multiline: PropTypes.bool,
      textBreakStrategy: PropTypes.oneOf(['simple', 'highQuality', 'balanced']),
      onBlur: PropTypes.func,
      onFocus: PropTypes.func,
      onChange: PropTypes.func,
      onChangeText: PropTypes.func,
      onContentSizeChange: PropTypes.func,
      onTextInput: PropTypes.func,
      onEndEditing: PropTypes.func,
      onSelectionChange: PropTypes.func,
      onSubmitEditing: PropTypes.func,
      onKeyPress: PropTypes.func,
      onLayout: PropTypes.func,
      onScroll: PropTypes.func,
      placeholder: PropTypes.string,
      placeholderTextColor: ColorPropType,
      scrollEnabled: PropTypes.bool,
      secureTextEntry: PropTypes.bool,
      selectionColor: ColorPropType,
      selectionState: PropTypes.instanceOf(DocumentSelectionState),
      selection: PropTypes.shape({
        start: PropTypes.number.isRequired,
        end: PropTypes.number
      }),
      value: PropTypes.string,
      defaultValue: PropTypes.string,
      clearButtonMode: PropTypes.oneOf(['never', 'while-editing', 'unless-editing', 'always']),
      clearTextOnFocus: PropTypes.bool,
      selectTextOnFocus: PropTypes.bool,
      blurOnSubmit: PropTypes.bool,
      style: Text.propTypes.style,
      underlineColorAndroid: ColorPropType,
      inlineImageLeft: PropTypes.string,
      inlineImagePadding: PropTypes.number,
      dataDetectorTypes: PropTypes.oneOfType([PropTypes.oneOf(DataDetectorTypes), PropTypes.arrayOf(PropTypes.oneOf(DataDetectorTypes))]),
      caretHidden: PropTypes.bool,
      contextMenuHidden: PropTypes.bool,
      inputAccessoryViewID: PropTypes.string,
      textContentType: PropTypes.oneOf(['none', 'URL', 'addressCity', 'addressCityAndState', 'addressState', 'countryName', 'creditCardNumber', 'emailAddress', 'familyName', 'fullStreetAddress', 'givenName', 'jobTitle', 'location', 'middleName', 'name', 'namePrefix', 'nameSuffix', 'nickname', 'organizationName', 'postalCode', 'streetAddressLine1', 'streetAddressLine2', 'sublocality', 'telephoneNumber', 'username', 'password'])
    }),
    getDefaultProps: function getDefaultProps() {
      return {
        allowFontScaling: true,
        underlineColorAndroid: 'transparent'
      };
    },
    mixins: [NativeMethodsMixin, TimerMixin],
    isFocused: function isFocused() {
      return TextInputState.currentlyFocusedField() === ReactNative.findNodeHandle(this._inputRef);
    },
    _inputRef: undefined,
    _focusSubscription: undefined,
    _lastNativeText: undefined,
    _lastNativeSelection: undefined,
    componentDidMount: function componentDidMount() {
      var _this = this;

      this._lastNativeText = this.props.value;
      var tag = ReactNative.findNodeHandle(this._inputRef);

      if (tag != null) {
        TextInputState.registerInput(tag);
      }

      if (this.context.focusEmitter) {
        this._focusSubscription = this.context.focusEmitter.addListener('focus', function (el) {
          if (_this === el) {
            _this.requestAnimationFrame(_this.focus);
          } else if (_this.isFocused()) {
            _this.blur();
          }
        });

        if (this.props.autoFocus) {
          this.context.onFocusRequested(this);
        }
      } else {
        if (this.props.autoFocus) {
          this.requestAnimationFrame(this.focus);
        }
      }
    },
    componentWillUnmount: function componentWillUnmount() {
      this._focusSubscription && this._focusSubscription.remove();

      if (this.isFocused()) {
        this.blur();
      }

      var tag = ReactNative.findNodeHandle(this._inputRef);

      if (tag != null) {
        TextInputState.unregisterInput(tag);
      }
    },
    contextTypes: {
      onFocusRequested: PropTypes.func,
      focusEmitter: PropTypes.instanceOf(EventEmitter)
    },
    clear: function clear() {
      this.setNativeProps({
        text: ''
      });
    },
    render: function render() {
      var textInput;

      if (Platform.OS === 'ios') {
        textInput = UIManager.RCTVirtualText ? this._renderIOS() : this._renderIOSLegacy();
      } else if (Platform.OS === 'android') {
        textInput = this._renderAndroid();
      }

      return React.createElement(TextAncestor.Provider, {
        value: true,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 872
        }
      }, textInput);
    },
    _getText: function _getText() {
      return typeof this.props.value === 'string' ? this.props.value : typeof this.props.defaultValue === 'string' ? this.props.defaultValue : '';
    },
    _setNativeRef: function _setNativeRef(ref) {
      this._inputRef = ref;
    },
    _renderIOSLegacy: function _renderIOSLegacy() {
      var textContainer;

      var props = _extends({}, this.props);

      props.style = [this.props.style];

      if (props.selection && props.selection.end == null) {
        props.selection = {
          start: props.selection.start,
          end: props.selection.start
        };
      }

      if (!props.multiline) {
        if (__DEV__) {
          for (var propKey in onlyMultiline) {
            if (props[propKey]) {
              var error = new Error('TextInput prop `' + propKey + '` is only supported with multiline.');
              warning(false, '%s', error.stack);
            }
          }
        }

        textContainer = React.createElement(RCTSinglelineTextInputView, _extends({
          ref: this._setNativeRef
        }, props, {
          onFocus: this._onFocus,
          onBlur: this._onBlur,
          onChange: this._onChange,
          onSelectionChange: this._onSelectionChange,
          onSelectionChangeShouldSetResponder: emptyFunction.thatReturnsTrue,
          text: this._getText(),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 915
          }
        }));
      } else {
        var children = props.children;
        var childCount = 0;
        React.Children.forEach(children, function () {
          return ++childCount;
        });
        invariant(!(props.value && childCount), 'Cannot specify both value and children.');

        if (childCount >= 1) {
          children = React.createElement(Text, {
            style: props.style,
            allowFontScaling: props.allowFontScaling,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 936
            }
          }, children);
        }

        if (props.inputView) {
          children = [children, props.inputView];
        }

        props.style.unshift(styles.multilineInput);
        textContainer = React.createElement(RCTMultilineTextInputView, _extends({
          ref: this._setNativeRef
        }, props, {
          children: children,
          onFocus: this._onFocus,
          onBlur: this._onBlur,
          onChange: this._onChange,
          onContentSizeChange: this.props.onContentSizeChange,
          onSelectionChange: this._onSelectionChange,
          onTextInput: this._onTextInput,
          onSelectionChangeShouldSetResponder: emptyFunction.thatReturnsTrue,
          text: this._getText(),
          dataDetectorTypes: this.props.dataDetectorTypes,
          onScroll: this._onScroll,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 946
          }
        }));
      }

      return React.createElement(TouchableWithoutFeedback, {
        onLayout: props.onLayout,
        onPress: this._onPress,
        rejectResponderTermination: true,
        accessible: props.accessible,
        accessibilityLabel: props.accessibilityLabel,
        accessibilityRole: props.accessibilityRole,
        accessibilityStates: props.accessibilityStates,
        nativeID: this.props.nativeID,
        testID: props.testID,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 965
        }
      }, textContainer);
    },
    _renderIOS: function _renderIOS() {
      var props = _extends({}, this.props);

      props.style = [this.props.style];

      if (props.selection && props.selection.end == null) {
        props.selection = {
          start: props.selection.start,
          end: props.selection.start
        };
      }

      var RCTTextInputView = props.multiline ? RCTMultilineTextInputView : RCTSinglelineTextInputView;

      if (props.multiline) {
        props.style.unshift(styles.multilineInput);
      }

      var textContainer = React.createElement(RCTTextInputView, _extends({
        ref: this._setNativeRef
      }, props, {
        onFocus: this._onFocus,
        onBlur: this._onBlur,
        onChange: this._onChange,
        onContentSizeChange: this.props.onContentSizeChange,
        onSelectionChange: this._onSelectionChange,
        onTextInput: this._onTextInput,
        onSelectionChangeShouldSetResponder: emptyFunction.thatReturnsTrue,
        text: this._getText(),
        dataDetectorTypes: this.props.dataDetectorTypes,
        onScroll: this._onScroll,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 1000
        }
      }));
      return React.createElement(TouchableWithoutFeedback, {
        onLayout: props.onLayout,
        onPress: this._onPress,
        rejectResponderTermination: true,
        accessible: props.accessible,
        accessibilityLabel: props.accessibilityLabel,
        accessibilityRole: props.accessibilityRole,
        accessibilityStates: props.accessibilityStates,
        nativeID: this.props.nativeID,
        testID: props.testID,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 1017
        }
      }, textContainer);
    },
    _renderAndroid: function _renderAndroid() {
      var props = _extends({}, this.props);

      props.style = [this.props.style];
      props.autoCapitalize = UIManager.AndroidTextInput.Constants.AutoCapitalizationType[props.autoCapitalize || 'sentences'];
      var children = this.props.children;
      var childCount = 0;
      React.Children.forEach(children, function () {
        return ++childCount;
      });
      invariant(!(this.props.value && childCount), 'Cannot specify both value and children.');

      if (childCount > 1) {
        children = React.createElement(Text, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 1050
          }
        }, children);
      }

      if (props.selection && props.selection.end == null) {
        props.selection = {
          start: props.selection.start,
          end: props.selection.start
        };
      }

      var textContainer = React.createElement(AndroidTextInput, _extends({
        ref: this._setNativeRef
      }, props, {
        mostRecentEventCount: 0,
        onFocus: this._onFocus,
        onBlur: this._onBlur,
        onChange: this._onChange,
        onSelectionChange: this._onSelectionChange,
        onTextInput: this._onTextInput,
        text: this._getText(),
        children: children,
        disableFullscreenUI: this.props.disableFullscreenUI,
        textBreakStrategy: this.props.textBreakStrategy,
        onScroll: this._onScroll,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 1061
        }
      }));
      return React.createElement(TouchableWithoutFeedback, {
        onLayout: props.onLayout,
        onPress: this._onPress,
        accessible: this.props.accessible,
        accessibilityLabel: this.props.accessibilityLabel,
        accessibilityRole: this.props.accessibilityRole,
        accessibilityStates: this.props.accessibilityStates,
        nativeID: this.props.nativeID,
        testID: this.props.testID,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 1079
        }
      }, textContainer);
    },
    _onFocus: function _onFocus(event) {
      if (this.props.onFocus) {
        this.props.onFocus(event);
      }

      if (this.props.selectionState) {
        this.props.selectionState.focus();
      }
    },
    _onPress: function _onPress(event) {
      if (this.props.editable || this.props.editable === undefined) {
        this.focus();
      }
    },
    _onChange: function _onChange(event) {
      if (this._inputRef) {
        this._inputRef.setNativeProps({
          mostRecentEventCount: event.nativeEvent.eventCount
        });
      }

      var text = event.nativeEvent.text;
      this.props.onChange && this.props.onChange(event);
      this.props.onChangeText && this.props.onChangeText(text);

      if (!this._inputRef) {
        return;
      }

      this._lastNativeText = text;
      this.forceUpdate();
    },
    _onSelectionChange: function _onSelectionChange(event) {
      this.props.onSelectionChange && this.props.onSelectionChange(event);

      if (!this._inputRef) {
        return;
      }

      this._lastNativeSelection = event.nativeEvent.selection;

      if (this.props.selection || this.props.selectionState) {
        this.forceUpdate();
      }
    },
    componentDidUpdate: function componentDidUpdate() {
      var nativeProps = {};

      if (this._lastNativeText !== this.props.value && typeof this.props.value === 'string') {
        nativeProps.text = this.props.value;
      }

      var selection = this.props.selection;

      if (this._lastNativeSelection && selection && (this._lastNativeSelection.start !== selection.start || this._lastNativeSelection.end !== selection.end)) {
        nativeProps.selection = this.props.selection;
      }

      if (Object.keys(nativeProps).length > 0 && this._inputRef) {
        this._inputRef.setNativeProps(nativeProps);
      }

      if (this.props.selectionState && selection) {
        this.props.selectionState.update(selection.start, selection.end);
      }
    },
    _onBlur: function _onBlur(event) {
      this.blur();

      if (this.props.onBlur) {
        this.props.onBlur(event);
      }

      if (this.props.selectionState) {
        this.props.selectionState.blur();
      }
    },
    _onTextInput: function _onTextInput(event) {
      this.props.onTextInput && this.props.onTextInput(event);
    },
    _onScroll: function _onScroll(event) {
      this.props.onScroll && this.props.onScroll(event);
    }
  });

  var InternalTextInputType = function (_ReactNative$NativeCo) {
    _inherits(InternalTextInputType, _ReactNative$NativeCo);

    function InternalTextInputType() {
      _classCallCheck(this, InternalTextInputType);

      return _possibleConstructorReturn(this, _getPrototypeOf(InternalTextInputType).apply(this, arguments));
    }

    _createClass(InternalTextInputType, [{
      key: "clear",
      value: function clear() {}
    }, {
      key: "isFocused",
      value: function isFocused() {}
    }]);

    return InternalTextInputType;
  }(ReactNative.NativeComponent);

  var TypedTextInput = TextInput;
  var styles = StyleSheet.create({
    multilineInput: {
      paddingTop: 5
    }
  });
  module.exports = TypedTextInput;
},595,[24,25,26,29,30,112,148,156,596,140,527,146,149,459,161,178,150,444,176,260,458,457,145,522,144,117,268,211],"node_modules\\react-native\\Libraries\\Components\\TextInput\\TextInput.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var mixInEventEmitter = _$$_REQUIRE(_dependencyMap[2], "mixInEventEmitter");

  var DocumentSelectionState = function () {
    function DocumentSelectionState(anchor, focus) {
      _classCallCheck(this, DocumentSelectionState);

      this._anchorOffset = anchor;
      this._focusOffset = focus;
      this._hasFocus = false;
    }

    _createClass(DocumentSelectionState, [{
      key: "update",
      value: function update(anchor, focus) {
        if (this._anchorOffset !== anchor || this._focusOffset !== focus) {
          this._anchorOffset = anchor;
          this._focusOffset = focus;
          this.emit('update');
        }
      }
    }, {
      key: "constrainLength",
      value: function constrainLength(maxLength) {
        this.update(Math.min(this._anchorOffset, maxLength), Math.min(this._focusOffset, maxLength));
      }
    }, {
      key: "focus",
      value: function focus() {
        if (!this._hasFocus) {
          this._hasFocus = true;
          this.emit('focus');
        }
      }
    }, {
      key: "blur",
      value: function blur() {
        if (this._hasFocus) {
          this._hasFocus = false;
          this.emit('blur');
        }
      }
    }, {
      key: "hasFocus",
      value: function hasFocus() {
        return this._hasFocus;
      }
    }, {
      key: "isCollapsed",
      value: function isCollapsed() {
        return this._anchorOffset === this._focusOffset;
      }
    }, {
      key: "isBackward",
      value: function isBackward() {
        return this._anchorOffset > this._focusOffset;
      }
    }, {
      key: "getAnchorOffset",
      value: function getAnchorOffset() {
        return this._hasFocus ? this._anchorOffset : null;
      }
    }, {
      key: "getFocusOffset",
      value: function getFocusOffset() {
        return this._hasFocus ? this._focusOffset : null;
      }
    }, {
      key: "getStartOffset",
      value: function getStartOffset() {
        return this._hasFocus ? Math.min(this._anchorOffset, this._focusOffset) : null;
      }
    }, {
      key: "getEndOffset",
      value: function getEndOffset() {
        return this._hasFocus ? Math.max(this._anchorOffset, this._focusOffset) : null;
      }
    }, {
      key: "overlaps",
      value: function overlaps(start, end) {
        return this.hasFocus() && this.getStartOffset() <= end && start <= this.getEndOffset();
      }
    }]);

    return DocumentSelectionState;
  }();

  mixInEventEmitter(DocumentSelectionState, {
    blur: true,
    focus: true,
    update: true
  });
  module.exports = DocumentSelectionState;
},596,[24,25,597],"node_modules\\react-native\\Libraries\\vendor\\document\\selection\\DocumentSelectionState.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var EventEmitter = _$$_REQUIRE(_dependencyMap[1], "EventEmitter");

  var EventEmitterWithHolding = _$$_REQUIRE(_dependencyMap[2], "EventEmitterWithHolding");

  var EventHolder = _$$_REQUIRE(_dependencyMap[3], "EventHolder");

  var invariant = _$$_REQUIRE(_dependencyMap[4], "fbjs/lib/invariant");

  var keyOf = _$$_REQUIRE(_dependencyMap[5], "fbjs/lib/keyOf");

  var TYPES_KEY = keyOf({
    __types: true
  });

  function mixInEventEmitter(cls, types) {
    invariant(types, 'Must supply set of valid event types');
    var target = cls.prototype || cls;
    invariant(!target.__eventEmitter, 'An active emitter is already mixed in');
    var ctor = cls.constructor;

    if (ctor) {
      invariant(ctor === Object || ctor === Function, 'Mix EventEmitter into a class, not an instance');
    }

    if (target.hasOwnProperty(TYPES_KEY)) {
      _extends(target.__types, types);
    } else if (target.__types) {
      target.__types = _extends({}, target.__types, types);
    } else {
      target.__types = types;
    }

    _extends(target, EventEmitterMixin);
  }

  var EventEmitterMixin = {
    emit: function emit(eventType, a, b, c, d, e, _) {
      return this.__getEventEmitter().emit(eventType, a, b, c, d, e, _);
    },
    emitAndHold: function emitAndHold(eventType, a, b, c, d, e, _) {
      return this.__getEventEmitter().emitAndHold(eventType, a, b, c, d, e, _);
    },
    addListener: function addListener(eventType, listener, context) {
      return this.__getEventEmitter().addListener(eventType, listener, context);
    },
    once: function once(eventType, listener, context) {
      return this.__getEventEmitter().once(eventType, listener, context);
    },
    addRetroactiveListener: function addRetroactiveListener(eventType, listener, context) {
      return this.__getEventEmitter().addRetroactiveListener(eventType, listener, context);
    },
    addListenerMap: function addListenerMap(listenerMap, context) {
      return this.__getEventEmitter().addListenerMap(listenerMap, context);
    },
    addRetroactiveListenerMap: function addRetroactiveListenerMap(listenerMap, context) {
      return this.__getEventEmitter().addListenerMap(listenerMap, context);
    },
    removeAllListeners: function removeAllListeners() {
      this.__getEventEmitter().removeAllListeners();
    },
    removeCurrentListener: function removeCurrentListener() {
      this.__getEventEmitter().removeCurrentListener();
    },
    releaseHeldEventType: function releaseHeldEventType(eventType) {
      this.__getEventEmitter().releaseHeldEventType(eventType);
    },
    __getEventEmitter: function __getEventEmitter() {
      if (!this.__eventEmitter) {
        var emitter = new EventEmitter();

        if (__DEV__) {
          var EventValidator = _$$_REQUIRE(_dependencyMap[6], "EventValidator");

          emitter = EventValidator.addValidation(emitter, this.__types);
        }

        var holder = new EventHolder();
        this.__eventEmitter = new EventEmitterWithHolding(emitter, holder);
      }

      return this.__eventEmitter;
    }
  };
  module.exports = mixInEventEmitter;
},597,[112,140,598,599,117,600,601],"node_modules\\react-native\\Libraries\\vendor\\emitter\\mixInEventEmitter.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/defineProperty");

  var EventEmitterWithHolding = function () {
    function EventEmitterWithHolding(emitter, holder) {
      _classCallCheck(this, EventEmitterWithHolding);

      _defineProperty(this, "_emitter", void 0);

      _defineProperty(this, "_eventHolder", void 0);

      _defineProperty(this, "_currentEventToken", void 0);

      _defineProperty(this, "_emittingHeldEvents", void 0);

      this._emitter = emitter;
      this._eventHolder = holder;
      this._currentEventToken = null;
      this._emittingHeldEvents = false;
    }

    _createClass(EventEmitterWithHolding, [{
      key: "addListener",
      value: function addListener(eventType, listener, context) {
        return this._emitter.addListener(eventType, listener, context);
      }
    }, {
      key: "once",
      value: function once(eventType, listener, context) {
        return this._emitter.once(eventType, listener, context);
      }
    }, {
      key: "addRetroactiveListener",
      value: function addRetroactiveListener(eventType, listener, context) {
        var subscription = this._emitter.addListener(eventType, listener, context);

        this._emittingHeldEvents = true;

        this._eventHolder.emitToListener(eventType, listener, context);

        this._emittingHeldEvents = false;
        return subscription;
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners(eventType) {
        this._emitter.removeAllListeners(eventType);
      }
    }, {
      key: "removeCurrentListener",
      value: function removeCurrentListener() {
        this._emitter.removeCurrentListener();
      }
    }, {
      key: "listeners",
      value: function listeners(eventType) {
        return this._emitter.listeners(eventType);
      }
    }, {
      key: "emit",
      value: function emit(eventType) {
        var _this$_emitter;

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        (_this$_emitter = this._emitter).emit.apply(_this$_emitter, [eventType].concat(args));
      }
    }, {
      key: "emitAndHold",
      value: function emitAndHold(eventType) {
        var _this$_eventHolder, _this$_emitter2;

        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        this._currentEventToken = (_this$_eventHolder = this._eventHolder).holdEvent.apply(_this$_eventHolder, [eventType].concat(args));

        (_this$_emitter2 = this._emitter).emit.apply(_this$_emitter2, [eventType].concat(args));

        this._currentEventToken = null;
      }
    }, {
      key: "releaseCurrentEvent",
      value: function releaseCurrentEvent() {
        if (this._currentEventToken) {
          this._eventHolder.releaseEvent(this._currentEventToken);
        } else if (this._emittingHeldEvents) {
          this._eventHolder.releaseCurrentEvent();
        }
      }
    }, {
      key: "releaseHeldEventType",
      value: function releaseHeldEventType(eventType) {
        this._eventHolder.releaseEventType(eventType);
      }
    }]);

    return EventEmitterWithHolding;
  }();

  module.exports = EventEmitterWithHolding;
},598,[24,25,32],"node_modules\\react-native\\Libraries\\vendor\\emitter\\EventEmitterWithHolding.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/defineProperty");

  var invariant = _$$_REQUIRE(_dependencyMap[3], "fbjs/lib/invariant");

  var EventHolder = function () {
    function EventHolder() {
      _classCallCheck(this, EventHolder);

      _defineProperty(this, "_heldEvents", void 0);

      _defineProperty(this, "_currentEventKey", void 0);

      this._heldEvents = {};
      this._currentEventKey = null;
    }

    _createClass(EventHolder, [{
      key: "holdEvent",
      value: function holdEvent(eventType) {
        this._heldEvents[eventType] = this._heldEvents[eventType] || [];
        var eventsOfType = this._heldEvents[eventType];
        var key = {
          eventType: eventType,
          index: eventsOfType.length
        };

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        eventsOfType.push(args);
        return key;
      }
    }, {
      key: "emitToListener",
      value: function emitToListener(eventType, listener, context) {
        var _this = this;

        var eventsOfType = this._heldEvents[eventType];

        if (!eventsOfType) {
          return;
        }

        var origEventKey = this._currentEventKey;
        eventsOfType.forEach(function (eventHeld, index) {
          if (!eventHeld) {
            return;
          }

          _this._currentEventKey = {
            eventType: eventType,
            index: index
          };
          listener.apply(context, eventHeld);
        });
        this._currentEventKey = origEventKey;
      }
    }, {
      key: "releaseCurrentEvent",
      value: function releaseCurrentEvent() {
        invariant(this._currentEventKey !== null, 'Not in an emitting cycle; there is no current event');
        this._currentEventKey && this.releaseEvent(this._currentEventKey);
      }
    }, {
      key: "releaseEvent",
      value: function releaseEvent(token) {
        delete this._heldEvents[token.eventType][token.index];
      }
    }, {
      key: "releaseEventType",
      value: function releaseEventType(type) {
        this._heldEvents[type] = [];
      }
    }]);

    return EventHolder;
  }();

  module.exports = EventHolder;
},599,[24,25,32,117],"node_modules\\react-native\\Libraries\\vendor\\emitter\\EventHolder.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var keyOf = function keyOf(oneKeyObj) {
    var key;

    for (key in oneKeyObj) {
      if (!oneKeyObj.hasOwnProperty(key)) {
        continue;
      }

      return key;
    }

    return null;
  };

  module.exports = keyOf;
},600,[],"node_modules\\fbjs\\lib\\keyOf.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var EventValidator = {
    addValidation: function addValidation(emitter, types) {
      var eventTypes = Object.keys(types);
      var emitterWithValidation = Object.create(emitter);

      _extends(emitterWithValidation, {
        emit: function emit(type, a, b, c, d, e, _) {
          assertAllowsEventType(type, eventTypes);
          return emitter.emit.call(this, type, a, b, c, d, e, _);
        }
      });

      return emitterWithValidation;
    }
  };

  function assertAllowsEventType(type, allowedTypes) {
    if (allowedTypes.indexOf(type) === -1) {
      throw new TypeError(errorMessageFor(type, allowedTypes));
    }
  }

  function errorMessageFor(type, allowedTypes) {
    var message = 'Unknown event type "' + type + '". ';

    if (__DEV__) {
      message += recommendationFor(type, allowedTypes);
    }

    message += 'Known event types: ' + allowedTypes.join(', ') + '.';
    return message;
  }

  if (__DEV__) {
    var recommendationFor = function recommendationFor(type, allowedTypes) {
      var closestTypeRecommendation = closestTypeFor(type, allowedTypes);

      if (isCloseEnough(closestTypeRecommendation, type)) {
        return 'Did you mean "' + closestTypeRecommendation.type + '"? ';
      } else {
        return '';
      }
    };

    var closestTypeFor = function closestTypeFor(type, allowedTypes) {
      var typeRecommendations = allowedTypes.map(typeRecommendationFor.bind(this, type));
      return typeRecommendations.sort(recommendationSort)[0];
    };

    var typeRecommendationFor = function typeRecommendationFor(type, recommendedType) {
      return {
        type: recommendedType,
        distance: damerauLevenshteinDistance(type, recommendedType)
      };
    };

    var recommendationSort = function recommendationSort(recommendationA, recommendationB) {
      if (recommendationA.distance < recommendationB.distance) {
        return -1;
      } else if (recommendationA.distance > recommendationB.distance) {
        return 1;
      } else {
        return 0;
      }
    };

    var isCloseEnough = function isCloseEnough(closestType, actualType) {
      return closestType.distance / actualType.length < 0.334;
    };

    var damerauLevenshteinDistance = function damerauLevenshteinDistance(a, b) {
      var i, j;
      var d = [];

      for (i = 0; i <= a.length; i++) {
        d[i] = [i];
      }

      for (j = 1; j <= b.length; j++) {
        d[0][j] = j;
      }

      for (i = 1; i <= a.length; i++) {
        for (j = 1; j <= b.length; j++) {
          var cost = a.charAt(i - 1) === b.charAt(j - 1) ? 0 : 1;
          d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);

          if (i > 1 && j > 1 && a.charAt(i - 1) === b.charAt(j - 2) && a.charAt(i - 2) === b.charAt(j - 1)) {
            d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
          }
        }
      }

      return d[a.length][b.length];
    };
  }

  module.exports = EventValidator;
},601,[112],"node_modules\\react-native\\Libraries\\vendor\\emitter\\EventValidator.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\ToolbarAndroid\\ToolbarAndroid.android.js";

  var Image = _$$_REQUIRE(_dependencyMap[2], "Image");

  var NativeMethodsMixin = _$$_REQUIRE(_dependencyMap[3], "NativeMethodsMixin");

  var React = _$$_REQUIRE(_dependencyMap[4], "React");

  var PropTypes = _$$_REQUIRE(_dependencyMap[5], "prop-types");

  var UIManager = _$$_REQUIRE(_dependencyMap[6], "UIManager");

  var ViewPropTypes = _$$_REQUIRE(_dependencyMap[7], "ViewPropTypes");

  var ColorPropType = _$$_REQUIRE(_dependencyMap[8], "ColorPropType");

  var createReactClass = _$$_REQUIRE(_dependencyMap[9], "create-react-class");

  var requireNativeComponent = _$$_REQUIRE(_dependencyMap[10], "requireNativeComponent");

  var resolveAssetSource = _$$_REQUIRE(_dependencyMap[11], "resolveAssetSource");

  var optionalImageSource = PropTypes.oneOfType([Image.propTypes.source, PropTypes.oneOf([])]);
  var ToolbarAndroid = createReactClass({
    displayName: 'ToolbarAndroid',
    mixins: [NativeMethodsMixin],
    propTypes: _objectSpread({}, ViewPropTypes, {
      actions: PropTypes.arrayOf(PropTypes.shape({
        title: PropTypes.string.isRequired,
        icon: optionalImageSource,
        show: PropTypes.oneOf(['always', 'ifRoom', 'never']),
        showWithText: PropTypes.bool
      })),
      logo: optionalImageSource,
      navIcon: optionalImageSource,
      onActionSelected: PropTypes.func,
      onIconClicked: PropTypes.func,
      overflowIcon: optionalImageSource,
      subtitle: PropTypes.string,
      subtitleColor: ColorPropType,
      title: PropTypes.string,
      titleColor: ColorPropType,
      contentInsetStart: PropTypes.number,
      contentInsetEnd: PropTypes.number,
      rtl: PropTypes.bool,
      testID: PropTypes.string
    }),
    render: function render() {
      var nativeProps = _objectSpread({}, this.props);

      if (this.props.logo) {
        nativeProps.logo = resolveAssetSource(this.props.logo);
      }

      if (this.props.navIcon) {
        nativeProps.navIcon = resolveAssetSource(this.props.navIcon);
      }

      if (this.props.overflowIcon) {
        nativeProps.overflowIcon = resolveAssetSource(this.props.overflowIcon);
      }

      if (this.props.actions) {
        var nativeActions = [];

        for (var i = 0; i < this.props.actions.length; i++) {
          var action = _objectSpread({}, this.props.actions[i]);

          if (action.icon) {
            action.icon = resolveAssetSource(action.icon);
          }

          if (action.show) {
            action.show = UIManager.ToolbarAndroid.Constants.ShowAsAction[action.show];
          }

          nativeActions.push(action);
        }

        nativeProps.nativeActions = nativeActions;
      }

      return React.createElement(NativeToolbar, _extends({
        onSelect: this._onSelect
      }, nativeProps, {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 196
        }
      }));
    },
    _onSelect: function _onSelect(event) {
      var position = event.nativeEvent.position;

      if (position === -1) {
        this.props.onIconClicked && this.props.onIconClicked();
      } else {
        this.props.onActionSelected && this.props.onActionSelected(position);
      }
    }
  });
  var NativeToolbar = requireNativeComponent('ToolbarAndroid');
  module.exports = ToolbarAndroid;
},602,[112,148,521,527,149,161,145,522,156,459,268,274],"node_modules\\react-native\\Libraries\\Components\\ToolbarAndroid\\ToolbarAndroid.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _extends = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectSpread");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\ViewPager\\ViewPagerAndroid.android.js";
  var _components = {
    ViewPagerAndroid: {
      displayName: "ViewPagerAndroid"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\ViewPager\\ViewPagerAndroid.android.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var React = _$$_REQUIRE(_dependencyMap[12], "React");

  var PropTypes = _$$_REQUIRE(_dependencyMap[13], "prop-types");

  var ReactNative = _$$_REQUIRE(_dependencyMap[14], "ReactNative");

  var UIManager = _$$_REQUIRE(_dependencyMap[15], "UIManager");

  var ViewPropTypes = _$$_REQUIRE(_dependencyMap[16], "ViewPropTypes");

  var dismissKeyboard = _$$_REQUIRE(_dependencyMap[17], "dismissKeyboard");

  var requireNativeComponent = _$$_REQUIRE(_dependencyMap[18], "requireNativeComponent");

  var NativeAndroidViewPager = requireNativeComponent('AndroidViewPager');
  var VIEWPAGER_REF = 'viewPager';

  var ViewPagerAndroid = function (_React$Component) {
    _inherits(ViewPagerAndroid, _React$Component);

    function ViewPagerAndroid() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, ViewPagerAndroid);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ViewPagerAndroid)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getInnerViewNode", function () {
        return _this.refs[VIEWPAGER_REF].getInnerViewNode();
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_childrenWithOverridenStyle", function () {
        return React.Children.map(_this.props.children, function (child) {
          if (!child) {
            return null;
          }

          var newProps = _objectSpread({}, child.props, {
            style: [child.props.style, {
              position: 'absolute',
              left: 0,
              top: 0,
              right: 0,
              bottom: 0,
              width: undefined,
              height: undefined
            }],
            collapsable: false
          });

          if (child.type && child.type.displayName && child.type.displayName !== 'RCTView' && child.type.displayName !== 'View') {
            console.warn('Each ViewPager child must be a <View>. Was ' + child.type.displayName);
          }

          return React.createElement(child.type, newProps);
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onPageScroll", function (e) {
        if (_this.props.onPageScroll) {
          _this.props.onPageScroll(e);
        }

        if (_this.props.keyboardDismissMode === 'on-drag') {
          dismissKeyboard();
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onPageScrollStateChanged", function (e) {
        if (_this.props.onPageScrollStateChanged) {
          _this.props.onPageScrollStateChanged(e.nativeEvent.pageScrollState);
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_onPageSelected", function (e) {
        if (_this.props.onPageSelected) {
          _this.props.onPageSelected(e);
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "setPage", function (selectedPage) {
        UIManager.dispatchViewManagerCommand(ReactNative.findNodeHandle(_assertThisInitialized(_assertThisInitialized(_this))), UIManager.AndroidViewPager.Commands.setPage, [selectedPage]);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "setPageWithoutAnimation", function (selectedPage) {
        UIManager.dispatchViewManagerCommand(ReactNative.findNodeHandle(_assertThisInitialized(_assertThisInitialized(_this))), UIManager.AndroidViewPager.Commands.setPageWithoutAnimation, [selectedPage]);
      });

      return _this;
    }

    _createClass(ViewPagerAndroid, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        if (this.props.initialPage != null) {
          this.setPageWithoutAnimation(this.props.initialPage);
        }
      }
    }, {
      key: "render",
      value: function render() {
        return React.createElement(NativeAndroidViewPager, _extends({}, this.props, {
          ref: VIEWPAGER_REF,
          style: this.props.style,
          onPageScroll: this._onPageScroll,
          onPageScrollStateChanged: this._onPageScrollStateChanged,
          onPageSelected: this._onPageSelected,
          children: this._childrenWithOverridenStyle(),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 255
          }
        }));
      }
    }]);

    return ViewPagerAndroid;
  }(React.Component);

  _defineProperty(ViewPagerAndroid, "propTypes", _objectSpread({}, ViewPropTypes, {
    initialPage: PropTypes.number,
    onPageScroll: PropTypes.func,
    onPageScrollStateChanged: PropTypes.func,
    onPageSelected: PropTypes.func,
    pageMargin: PropTypes.number,
    keyboardDismissMode: PropTypes.oneOf(['none', 'on-drag']),
    scrollEnabled: PropTypes.bool,
    peekEnabled: PropTypes.bool
  }));

  ViewPagerAndroid = _wrapComponent("ViewPagerAndroid")(ViewPagerAndroid);
  module.exports = ViewPagerAndroid;
},603,[23,112,148,24,25,26,29,30,28,32,109,280,149,161,178,145,522,508,268],"node_modules\\react-native\\Libraries\\Components\\ViewPager\\ViewPagerAndroid.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _objectSpread = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread");

  var _extends = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/extends");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/inherits");

  var _assertThisInitialized = _$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/assertThisInitialized");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/defineProperty");

  var _default = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "react")).default;

  var _reactTransformHmrLibIndexJs = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "./../../../../react-transform-hmr/lib/index.js")).default;

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\WebView\\WebView.android.js";
  var _components = {
    WebView: {
      displayName: "WebView"
    }
  };

  var _reactTransformHmrLibIndexJs2 = _reactTransformHmrLibIndexJs({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\Components\\WebView\\WebView.android.js",
    components: _components,
    locals: [module],
    imports: [_default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var EdgeInsetsPropType = _$$_REQUIRE(_dependencyMap[12], "EdgeInsetsPropType");

  var ActivityIndicator = _$$_REQUIRE(_dependencyMap[13], "ActivityIndicator");

  var React = _$$_REQUIRE(_dependencyMap[14], "React");

  var PropTypes = _$$_REQUIRE(_dependencyMap[15], "prop-types");

  var ReactNative = _$$_REQUIRE(_dependencyMap[16], "ReactNative");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[17], "StyleSheet");

  var UIManager = _$$_REQUIRE(_dependencyMap[18], "UIManager");

  var View = _$$_REQUIRE(_dependencyMap[19], "View");

  var ViewPropTypes = _$$_REQUIRE(_dependencyMap[20], "ViewPropTypes");

  var WebViewShared = _$$_REQUIRE(_dependencyMap[21], "WebViewShared");

  var deprecatedPropType = _$$_REQUIRE(_dependencyMap[22], "deprecatedPropType");

  var keyMirror = _$$_REQUIRE(_dependencyMap[23], "fbjs/lib/keyMirror");

  var requireNativeComponent = _$$_REQUIRE(_dependencyMap[24], "requireNativeComponent");

  var resolveAssetSource = _$$_REQUIRE(_dependencyMap[25], "resolveAssetSource");

  var RCT_WEBVIEW_REF = 'webview';
  var WebViewState = keyMirror({
    IDLE: null,
    LOADING: null,
    ERROR: null
  });

  var defaultRenderLoading = function defaultRenderLoading() {
    return React.createElement(View, {
      style: styles.loadingView,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 37
      }
    }, React.createElement(ActivityIndicator, {
      style: styles.loadingProgressBar,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 38
      }
    }));
  };

  var WebView = function (_React$Component) {
    _inherits(WebView, _React$Component);

    function WebView() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, WebView);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WebView)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
        viewState: WebViewState.IDLE,
        lastErrorEvent: null,
        startInLoadingState: true
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "goForward", function () {
        UIManager.dispatchViewManagerCommand(_this.getWebViewHandle(), UIManager.RCTWebView.Commands.goForward, null);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "goBack", function () {
        UIManager.dispatchViewManagerCommand(_this.getWebViewHandle(), UIManager.RCTWebView.Commands.goBack, null);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "reload", function () {
        _this.setState({
          viewState: WebViewState.LOADING
        });

        UIManager.dispatchViewManagerCommand(_this.getWebViewHandle(), UIManager.RCTWebView.Commands.reload, null);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "stopLoading", function () {
        UIManager.dispatchViewManagerCommand(_this.getWebViewHandle(), UIManager.RCTWebView.Commands.stopLoading, null);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "postMessage", function (data) {
        UIManager.dispatchViewManagerCommand(_this.getWebViewHandle(), UIManager.RCTWebView.Commands.postMessage, [String(data)]);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "injectJavaScript", function (data) {
        UIManager.dispatchViewManagerCommand(_this.getWebViewHandle(), UIManager.RCTWebView.Commands.injectJavaScript, [data]);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "updateNavigationState", function (event) {
        if (_this.props.onNavigationStateChange) {
          _this.props.onNavigationStateChange(event.nativeEvent);
        }
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getWebViewHandle", function () {
        return ReactNative.findNodeHandle(_this.refs[RCT_WEBVIEW_REF]);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onLoadingStart", function (event) {
        var onLoadStart = _this.props.onLoadStart;
        onLoadStart && onLoadStart(event);

        _this.updateNavigationState(event);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onLoadingError", function (event) {
        event.persist();
        var _this$props = _this.props,
            onError = _this$props.onError,
            onLoadEnd = _this$props.onLoadEnd;
        onError && onError(event);
        onLoadEnd && onLoadEnd(event);
        console.warn('Encountered an error loading page', event.nativeEvent);

        _this.setState({
          lastErrorEvent: event.nativeEvent,
          viewState: WebViewState.ERROR
        });
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onLoadingFinish", function (event) {
        var _this$props2 = _this.props,
            onLoad = _this$props2.onLoad,
            onLoadEnd = _this$props2.onLoadEnd;
        onLoad && onLoad(event);
        onLoadEnd && onLoadEnd(event);

        _this.setState({
          viewState: WebViewState.IDLE
        });

        _this.updateNavigationState(event);
      });

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onMessage", function (event) {
        var onMessage = _this.props.onMessage;
        onMessage && onMessage(event);
      });

      return _this;
    }

    _createClass(WebView, [{
      key: "UNSAFE_componentWillMount",
      value: function UNSAFE_componentWillMount() {
        if (this.props.startInLoadingState) {
          this.setState({
            viewState: WebViewState.LOADING
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        var otherView = null;

        if (this.state.viewState === WebViewState.LOADING) {
          otherView = (this.props.renderLoading || defaultRenderLoading)();
        } else if (this.state.viewState === WebViewState.ERROR) {
          var errorEvent = this.state.lastErrorEvent;
          otherView = this.props.renderError && this.props.renderError(errorEvent.domain, errorEvent.code, errorEvent.description);
        } else if (this.state.viewState !== WebViewState.IDLE) {
          console.error('RCTWebView invalid state encountered: ' + this.state.loading);
        }

        var webViewStyles = [styles.container, this.props.style];

        if (this.state.viewState === WebViewState.LOADING || this.state.viewState === WebViewState.ERROR) {
          webViewStyles.push(styles.hidden);
        }

        var source = this.props.source || {};

        if (this.props.html) {
          source.html = this.props.html;
        } else if (this.props.url) {
          source.uri = this.props.url;
        }

        if (source.method === 'POST' && source.headers) {
          console.warn('WebView: `source.headers` is not supported when using POST.');
        } else if (source.method === 'GET' && source.body) {
          console.warn('WebView: `source.body` is not supported when using GET.');
        }

        var nativeConfig = this.props.nativeConfig || {};
        var originWhitelist = (this.props.originWhitelist || []).map(WebViewShared.originWhitelistToRegex);
        var NativeWebView = nativeConfig.component || RCTWebView;
        var webView = React.createElement(NativeWebView, _extends({
          ref: RCT_WEBVIEW_REF,
          key: "webViewKey",
          style: webViewStyles,
          source: resolveAssetSource(source),
          scalesPageToFit: this.props.scalesPageToFit,
          allowFileAccess: this.props.allowFileAccess,
          injectedJavaScript: this.props.injectedJavaScript,
          userAgent: this.props.userAgent,
          javaScriptEnabled: this.props.javaScriptEnabled,
          thirdPartyCookiesEnabled: this.props.thirdPartyCookiesEnabled,
          domStorageEnabled: this.props.domStorageEnabled,
          messagingEnabled: typeof this.props.onMessage === 'function',
          onMessage: this.onMessage,
          contentInset: this.props.contentInset,
          automaticallyAdjustContentInsets: this.props.automaticallyAdjustContentInsets,
          onContentSizeChange: this.props.onContentSizeChange,
          onLoadingStart: this.onLoadingStart,
          onLoadingFinish: this.onLoadingFinish,
          onLoadingError: this.onLoadingError,
          testID: this.props.testID,
          geolocationEnabled: this.props.geolocationEnabled,
          mediaPlaybackRequiresUserAction: this.props.mediaPlaybackRequiresUserAction,
          allowUniversalAccessFromFileURLs: this.props.allowUniversalAccessFromFileURLs,
          originWhitelist: originWhitelist,
          mixedContentMode: this.props.mixedContentMode,
          saveFormDataDisabled: this.props.saveFormDataDisabled,
          urlPrefixesForDefaultIntent: this.props.urlPrefixesForDefaultIntent
        }, nativeConfig.props, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 320
          }
        }));
        return React.createElement(View, {
          style: styles.container,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 359
          }
        }, webView, otherView);
      }
    }]);

    return WebView;
  }(React.Component);

  _defineProperty(WebView, "propTypes", _objectSpread({}, ViewPropTypes, {
    renderError: PropTypes.func,
    renderLoading: PropTypes.func,
    onLoad: PropTypes.func,
    onLoadEnd: PropTypes.func,
    onLoadStart: PropTypes.func,
    onError: PropTypes.func,
    automaticallyAdjustContentInsets: PropTypes.bool,
    contentInset: EdgeInsetsPropType,
    onNavigationStateChange: PropTypes.func,
    onMessage: PropTypes.func,
    onContentSizeChange: PropTypes.func,
    startInLoadingState: PropTypes.bool,
    style: ViewPropTypes.style,
    html: deprecatedPropType(PropTypes.string, 'Use the `source` prop instead.'),
    url: deprecatedPropType(PropTypes.string, 'Use the `source` prop instead.'),
    source: PropTypes.oneOfType([PropTypes.shape({
      uri: PropTypes.string,
      method: PropTypes.oneOf(['GET', 'POST']),
      headers: PropTypes.object,
      body: PropTypes.string
    }), PropTypes.shape({
      html: PropTypes.string,
      baseUrl: PropTypes.string
    }), PropTypes.number]),
    useWebKit: PropTypes.bool,
    javaScriptEnabled: PropTypes.bool,
    thirdPartyCookiesEnabled: PropTypes.bool,
    domStorageEnabled: PropTypes.bool,
    geolocationEnabled: PropTypes.bool,
    injectedJavaScript: PropTypes.string,
    scalesPageToFit: PropTypes.bool,
    allowFileAccess: PropTypes.bool,
    userAgent: PropTypes.string,
    testID: PropTypes.string,
    mediaPlaybackRequiresUserAction: PropTypes.bool,
    allowUniversalAccessFromFileURLs: PropTypes.bool,
    originWhitelist: PropTypes.arrayOf(PropTypes.string),
    injectJavaScript: PropTypes.func,
    mixedContentMode: PropTypes.oneOf(['never', 'always', 'compatibility']),
    saveFormDataDisabled: PropTypes.bool,
    nativeConfig: PropTypes.shape({
      component: PropTypes.any,
      props: PropTypes.object,
      viewManager: PropTypes.object
    }),
    urlPrefixesForDefaultIntent: PropTypes.arrayOf(PropTypes.string)
  }));

  _defineProperty(WebView, "defaultProps", {
    javaScriptEnabled: true,
    thirdPartyCookiesEnabled: true,
    scalesPageToFit: true,
    saveFormDataDisabled: false,
    originWhitelist: WebViewShared.defaultOriginWhitelist
  });

  WebView = _wrapComponent("WebView")(WebView);
  var RCTWebView = requireNativeComponent('RCTWebView');
  var styles = StyleSheet.create({
    container: {
      flex: 1
    },
    hidden: {
      height: 0,
      flex: 0
    },
    loadingView: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center'
    },
    loadingProgressBar: {
      height: 20
    }
  });
  module.exports = WebView;
},604,[23,148,112,24,25,26,29,30,28,32,109,280,446,147,149,161,178,150,145,175,522,605,166,159,268,274],"node_modules\\react-native\\Libraries\\Components\\WebView\\WebView.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var escapeStringRegexp = _$$_REQUIRE(_dependencyMap[0], "escape-string-regexp");

  var WebViewShared = {
    defaultOriginWhitelist: ['http://*', 'https://*'],
    extractOrigin: function extractOrigin(url) {
      var result = /^[A-Za-z0-9]+:(\/\/)?[^/]*/.exec(url);
      return result === null ? null : result[0];
    },
    originWhitelistToRegex: function originWhitelistToRegex(originWhitelist) {
      return escapeStringRegexp(originWhitelist).replace(/\\\*/g, '.*');
    }
  };
  module.exports = WebViewShared;
},605,[606],"node_modules\\react-native\\Libraries\\Components\\WebView\\WebViewShared.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

  module.exports = function (str) {
    if (typeof str !== 'string') {
      throw new TypeError('Expected a string');
    }

    return str.replace(matchOperatorsRe, '\\$&');
  };
},606,[],"node_modules\\escape-string-regexp\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var RCTActionSheetManager = _$$_REQUIRE(_dependencyMap[1], "NativeModules").ActionSheetManager;

  var invariant = _$$_REQUIRE(_dependencyMap[2], "fbjs/lib/invariant");

  var processColor = _$$_REQUIRE(_dependencyMap[3], "processColor");

  var ActionSheetIOS = {
    showActionSheetWithOptions: function showActionSheetWithOptions(options, callback) {
      invariant(typeof options === 'object' && options !== null, 'Options must be a valid object');
      invariant(typeof callback === 'function', 'Must provide a valid callback');
      RCTActionSheetManager.showActionSheetWithOptions(_objectSpread({}, options, {
        tintColor: processColor(options.tintColor)
      }), callback);
    },
    showShareActionSheetWithOptions: function showShareActionSheetWithOptions(options, failureCallback, successCallback) {
      invariant(typeof options === 'object' && options !== null, 'Options must be a valid object');
      invariant(typeof failureCallback === 'function', 'Must provide a valid failureCallback');
      invariant(typeof successCallback === 'function', 'Must provide a valid successCallback');
      RCTActionSheetManager.showShareActionSheetWithOptions(_objectSpread({}, options, {
        tintColor: processColor(options.tintColor)
      }), failureCallback, successCallback);
    }
  };
  module.exports = ActionSheetIOS;
},607,[148,119,117,169],"node_modules\\react-native\\Libraries\\ActionSheetIOS\\ActionSheetIOS.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var BatchedBridge = _$$_REQUIRE(_dependencyMap[1], "BatchedBridge");

  var BugReporting = _$$_REQUIRE(_dependencyMap[2], "BugReporting");

  var NativeModules = _$$_REQUIRE(_dependencyMap[3], "NativeModules");

  var ReactNative = _$$_REQUIRE(_dependencyMap[4], "ReactNative");

  var SceneTracker = _$$_REQUIRE(_dependencyMap[5], "SceneTracker");

  var infoLog = _$$_REQUIRE(_dependencyMap[6], "infoLog");

  var invariant = _$$_REQUIRE(_dependencyMap[7], "fbjs/lib/invariant");

  var renderApplication = _$$_REQUIRE(_dependencyMap[8], "renderApplication");

  var runnables = {};
  var runCount = 1;
  var sections = {};
  var tasks = new Map();

  var componentProviderInstrumentationHook = function componentProviderInstrumentationHook(component) {
    return component();
  };

  var wrapperComponentProvider;
  var AppRegistry = {
    setWrapperComponentProvider: function setWrapperComponentProvider(provider) {
      wrapperComponentProvider = provider;
    },
    registerConfig: function registerConfig(config) {
      config.forEach(function (appConfig) {
        if (appConfig.run) {
          AppRegistry.registerRunnable(appConfig.appKey, appConfig.run);
        } else {
          invariant(appConfig.component != null, 'AppRegistry.registerConfig(...): Every config is expected to set ' + 'either `run` or `component`, but `%s` has neither.', appConfig.appKey);
          AppRegistry.registerComponent(appConfig.appKey, appConfig.component, appConfig.section);
        }
      });
    },
    registerComponent: function registerComponent(appKey, componentProvider, section) {
      runnables[appKey] = {
        componentProvider: componentProvider,
        run: function run(appParameters) {
          renderApplication(componentProviderInstrumentationHook(componentProvider), appParameters.initialProps, appParameters.rootTag, wrapperComponentProvider && wrapperComponentProvider(appParameters), appParameters.fabric);
        }
      };

      if (section) {
        sections[appKey] = runnables[appKey];
      }

      return appKey;
    },
    registerRunnable: function registerRunnable(appKey, run) {
      runnables[appKey] = {
        run: run
      };
      return appKey;
    },
    registerSection: function registerSection(appKey, component) {
      AppRegistry.registerComponent(appKey, component, true);
    },
    getAppKeys: function getAppKeys() {
      return Object.keys(runnables);
    },
    getSectionKeys: function getSectionKeys() {
      return Object.keys(sections);
    },
    getSections: function getSections() {
      return _objectSpread({}, sections);
    },
    getRunnable: function getRunnable(appKey) {
      return runnables[appKey];
    },
    getRegistry: function getRegistry() {
      return {
        sections: AppRegistry.getSectionKeys(),
        runnables: _objectSpread({}, runnables)
      };
    },
    setComponentProviderInstrumentationHook: function setComponentProviderInstrumentationHook(hook) {
      componentProviderInstrumentationHook = hook;
    },
    runApplication: function runApplication(appKey, appParameters) {
      var msg = 'Running application "' + appKey + '" with appParams: ' + JSON.stringify(appParameters) + '. ' + '__DEV__ === ' + String(__DEV__) + ', development-level warning are ' + (__DEV__ ? 'ON' : 'OFF') + ', performance optimizations are ' + (__DEV__ ? 'OFF' : 'ON');
      infoLog(msg);
      BugReporting.addSource('AppRegistry.runApplication' + runCount++, function () {
        return msg;
      });
      invariant(runnables[appKey] && runnables[appKey].run, 'Application ' + appKey + ' has not been registered.\n\n' + "Hint: This error often happens when you're running the packager " + '(local dev server) from a wrong folder. For example you have ' + 'multiple apps and the packager is still running for the app you ' + 'were working on before.\nIf this is the case, simply kill the old ' + 'packager instance (e.g. close the packager terminal window) ' + 'and start the packager in the correct app folder (e.g. cd into app ' + "folder and run 'npm start').\n\n" + 'This error can also happen due to a require() error during ' + 'initialization or failure to call AppRegistry.registerComponent.\n\n');
      SceneTracker.setActiveScene({
        name: appKey
      });
      runnables[appKey].run(appParameters);
    },
    unmountApplicationComponentAtRootTag: function unmountApplicationComponentAtRootTag(rootTag) {
      ReactNative.unmountComponentAtNodeAndRemoveContainer(rootTag);
    },
    registerHeadlessTask: function registerHeadlessTask(taskKey, task) {
      if (tasks.has(taskKey)) {
        console.warn("registerHeadlessTask called multiple times for same key '" + taskKey + "'");
      }

      tasks.set(taskKey, task);
    },
    startHeadlessTask: function startHeadlessTask(taskId, taskKey, data) {
      var taskProvider = tasks.get(taskKey);

      if (!taskProvider) {
        throw new Error("No task registered for key " + taskKey);
      }

      taskProvider()(data).then(function () {
        return NativeModules.HeadlessJsTaskSupport.notifyTaskFinished(taskId);
      }).catch(function (reason) {
        console.error(reason);
        NativeModules.HeadlessJsTaskSupport.notifyTaskFinished(taskId);
      });
    }
  };
  BatchedBridge.registerCallableModule('AppRegistry', AppRegistry);
  module.exports = AppRegistry;
},608,[148,126,609,119,178,611,242,117,612],"node_modules\\react-native\\Libraries\\ReactNative\\AppRegistry.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _slicedToArray = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/slicedToArray");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/defineProperty");

  var RCTDeviceEventEmitter = _$$_REQUIRE(_dependencyMap[4], "RCTDeviceEventEmitter");

  var Map = _$$_REQUIRE(_dependencyMap[5], "Map");

  var infoLog = _$$_REQUIRE(_dependencyMap[6], "infoLog");

  function defaultExtras() {
    BugReporting.addFileSource('react_hierarchy.txt', function () {
      return _$$_REQUIRE(_dependencyMap[7], "dumpReactTree")();
    });
  }

  var BugReporting = function () {
    function BugReporting() {
      _classCallCheck(this, BugReporting);
    }

    _createClass(BugReporting, null, [{
      key: "_maybeInit",
      value: function _maybeInit() {
        if (!BugReporting._subscription) {
          BugReporting._subscription = RCTDeviceEventEmitter.addListener('collectBugExtraData', BugReporting.collectExtraData, null);
          defaultExtras();
        }

        if (!BugReporting._redboxSubscription) {
          BugReporting._redboxSubscription = RCTDeviceEventEmitter.addListener('collectRedBoxExtraData', BugReporting.collectExtraData, null);
        }
      }
    }, {
      key: "addSource",
      value: function addSource(key, callback) {
        return this._addSource(key, callback, BugReporting._extraSources);
      }
    }, {
      key: "addFileSource",
      value: function addFileSource(key, callback) {
        return this._addSource(key, callback, BugReporting._fileSources);
      }
    }, {
      key: "_addSource",
      value: function _addSource(key, callback, source) {
        BugReporting._maybeInit();

        if (source.has(key)) {
          console.warn("BugReporting.add* called multiple times for same key '" + key + "'");
        }

        source.set(key, callback);
        return {
          remove: function remove() {
            source.delete(key);
          }
        };
      }
    }, {
      key: "collectExtraData",
      value: function collectExtraData() {
        var extraData = {};

        for (var _iterator = BugReporting._extraSources, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
          var _ref3;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref3 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref3 = _i.value;
          }

          var _ref7 = _ref3;

          var _ref2 = _slicedToArray(_ref7, 2);

          var _key3 = _ref2[0];
          var _callback2 = _ref2[1];
          extraData[_key3] = _callback2();
        }

        var fileData = {};

        for (var _iterator2 = BugReporting._fileSources, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();;) {
          var _ref6;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref6 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref6 = _i2.value;
          }

          var _ref8 = _ref6;

          var _ref5 = _slicedToArray(_ref8, 2);

          var _key4 = _ref5[0];
          var _callback3 = _ref5[1];
          fileData[_key4] = _callback3();
        }

        infoLog('BugReporting extraData:', extraData);

        var BugReportingNativeModule = _$$_REQUIRE(_dependencyMap[8], "NativeModules").BugReporting;

        BugReportingNativeModule && BugReportingNativeModule.setExtraData && BugReportingNativeModule.setExtraData(extraData, fileData);

        var RedBoxNativeModule = _$$_REQUIRE(_dependencyMap[8], "NativeModules").RedBox;

        RedBoxNativeModule && RedBoxNativeModule.setExtraData && RedBoxNativeModule.setExtraData(extraData, 'From BugReporting.js');
        return {
          extras: extraData,
          files: fileData
        };
      }
    }]);

    return BugReporting;
  }();

  _defineProperty(BugReporting, "_extraSources", new Map());

  _defineProperty(BugReporting, "_fileSources", new Map());

  _defineProperty(BugReporting, "_subscription", null);

  _defineProperty(BugReporting, "_redboxSubscription", null);

  module.exports = BugReporting;
},609,[122,24,25,32,137,183,242,610,119],"node_modules\\react-native\\Libraries\\BugReporting\\BugReporting.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function dumpReactTree() {
    try {
      return getReactTree();
    } catch (e) {
      return 'Failed to dump react tree: ' + e;
    }
  }

  function getReactTree() {
    return 'React tree dumps have been temporarily disabled while React is ' + 'upgraded to Fiber.';
  }

  module.exports = dumpReactTree;
},610,[],"node_modules\\react-native\\Libraries\\BugReporting\\dumpReactTree.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _listeners = [];
  var _activeScene = {
    name: 'default'
  };
  var SceneTracker = {
    setActiveScene: function setActiveScene(scene) {
      _activeScene = scene;

      _listeners.forEach(function (listener) {
        return listener(_activeScene);
      });
    },
    getActiveScene: function getActiveScene() {
      return _activeScene;
    },
    addActiveSceneChangedListener: function addActiveSceneChangedListener(callback) {
      _listeners.push(callback);

      return {
        remove: function remove() {
          _listeners = _listeners.filter(function (listener) {
            return callback !== listener;
          });
        }
      };
    }
  };
  module.exports = SceneTracker;
},611,[],"node_modules\\react-native\\Libraries\\Utilities\\SceneTracker.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\ReactNative\\renderApplication.js";

  var AppContainer = _$$_REQUIRE(_dependencyMap[1], "AppContainer");

  var React = _$$_REQUIRE(_dependencyMap[2], "React");

  var ReactFabricIndicator = _$$_REQUIRE(_dependencyMap[3], "ReactFabricIndicator");

  var invariant = _$$_REQUIRE(_dependencyMap[4], "fbjs/lib/invariant");

  _$$_REQUIRE(_dependencyMap[5], "BackHandler");

  function renderApplication(RootComponent, initialProps, rootTag, WrapperComponent, fabric, showFabricIndicator) {
    invariant(rootTag, 'Expect to have a valid rootTag, instead got ', rootTag);
    var renderable = React.createElement(AppContainer, {
      rootTag: rootTag,
      WrapperComponent: WrapperComponent,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 33
      }
    }, React.createElement(RootComponent, _extends({}, initialProps, {
      rootTag: rootTag,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 34
      }
    })), fabric === true && showFabricIndicator === true ? React.createElement(ReactFabricIndicator, {
      __source: {
        fileName: _jsxFileName,
        lineNumber: 36
      }
    }) : null);

    if (RootComponent.prototype != null && RootComponent.prototype.unstable_isAsyncReactComponent === true) {
      var AsyncMode = React.unstable_AsyncMode;
      renderable = React.createElement(AsyncMode, {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 53
        }
      }, renderable);
    }

    if (fabric) {
      _$$_REQUIRE(_dependencyMap[6], "ReactFabric").render(renderable, rootTag);
    } else {
      _$$_REQUIRE(_dependencyMap[7], "ReactNative").render(renderable, rootTag);
    }
  }

  module.exports = renderApplication;
},612,[112,541,149,613,117,614,615,178],"node_modules\\react-native\\Libraries\\ReactNative\\renderApplication.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native\\Libraries\\ReactNative\\ReactFabricIndicator.js";

  var React = _$$_REQUIRE(_dependencyMap[0], "React");

  var StyleSheet = _$$_REQUIRE(_dependencyMap[1], "StyleSheet");

  var Text = _$$_REQUIRE(_dependencyMap[2], "Text");

  var View = _$$_REQUIRE(_dependencyMap[3], "View");

  function ReactFabricIndicator() {
    return React.createElement(View, {
      style: styles.container,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 20
      }
    }, React.createElement(Text, {
      style: styles.text,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 21
      }
    }, "FABRIC"));
  }

  var styles = StyleSheet.create({
    container: {
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: 'rgba(0,0,0, 0.25)',
      position: 'absolute',
      top: 0,
      right: 0,
      padding: 2
    },
    text: {
      fontSize: 6,
      color: '#ffffff'
    }
  });
  module.exports = ReactFabricIndicator;
},613,[149,150,444,175],"node_modules\\react-native\\Libraries\\ReactNative\\ReactFabricIndicator.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var DeviceEventManager = _$$_REQUIRE(_dependencyMap[0], "NativeModules").DeviceEventManager;

  var RCTDeviceEventEmitter = _$$_REQUIRE(_dependencyMap[1], "RCTDeviceEventEmitter");

  var DEVICE_BACK_EVENT = 'hardwareBackPress';

  var _backPressSubscriptions = new Set();

  RCTDeviceEventEmitter.addListener(DEVICE_BACK_EVENT, function () {
    var invokeDefault = true;
    var subscriptions = Array.from(_backPressSubscriptions.values()).reverse();

    for (var i = 0; i < subscriptions.length; ++i) {
      if (subscriptions[i]()) {
        invokeDefault = false;
        break;
      }
    }

    if (invokeDefault) {
      BackHandler.exitApp();
    }
  });
  var BackHandler = {
    exitApp: function exitApp() {
      DeviceEventManager.invokeDefaultBackPressHandler();
    },
    addEventListener: function addEventListener(eventName, handler) {
      _backPressSubscriptions.add(handler);

      return {
        remove: function remove() {
          return BackHandler.removeEventListener(eventName, handler);
        }
      };
    },
    removeEventListener: function removeEventListener(eventName, handler) {
      _backPressSubscriptions.delete(handler);
    }
  };
  module.exports = BackHandler;
},614,[119,137],"node_modules\\react-native\\Libraries\\Utilities\\BackHandler.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var BatchedBridge = _$$_REQUIRE(_dependencyMap[0], "BatchedBridge");

  var ReactFabric;

  if (__DEV__) {
    ReactFabric = _$$_REQUIRE(_dependencyMap[1], "ReactFabric-dev");
  } else {
    ReactFabric = _$$_REQUIRE(_dependencyMap[2], "ReactFabric-prod");
  }

  BatchedBridge.registerCallableModule('ReactFabric', ReactFabric);
  module.exports = ReactFabric;
},615,[126,616,618],"node_modules\\react-native\\Libraries\\Renderer\\shims\\ReactFabric.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  if (__DEV__) {
    (function () {
      "use strict";

      _$$_REQUIRE(_dependencyMap[1], "InitializeCore");

      var ReactNativeViewConfigRegistry = _$$_REQUIRE(_dependencyMap[2], "ReactNativeViewConfigRegistry");

      var UIManager = _$$_REQUIRE(_dependencyMap[3], "UIManager");

      var React = _$$_REQUIRE(_dependencyMap[4], "react");

      var deepDiffer = _$$_REQUIRE(_dependencyMap[5], "deepDiffer");

      var flattenStyle = _$$_REQUIRE(_dependencyMap[6], "flattenStyle");

      var deepFreezeAndThrowOnMutationInDev = _$$_REQUIRE(_dependencyMap[7], "deepFreezeAndThrowOnMutationInDev");

      var TextInputState = _$$_REQUIRE(_dependencyMap[8], "TextInputState");

      var FabricUIManager = _$$_REQUIRE(_dependencyMap[9], "FabricUIManager");

      var checkPropTypes = _$$_REQUIRE(_dependencyMap[10], "prop-types/checkPropTypes");

      var tracing = _$$_REQUIRE(_dependencyMap[11], "scheduler/tracing");

      var scheduler = _$$_REQUIRE(_dependencyMap[12], "scheduler");

      var ExceptionsManager = _$$_REQUIRE(_dependencyMap[13], "ExceptionsManager");

      var validateFormat = function validateFormat() {};

      {
        validateFormat = function validateFormat(format) {
          if (format === undefined) {
            throw new Error("invariant requires an error message argument");
          }
        };
      }

      function invariant(condition, format, a, b, c, d, e, f) {
        validateFormat(format);

        if (!condition) {
          var error = void 0;

          if (format === undefined) {
            error = new Error("Minified exception occurred; use the non-minified dev environment " + "for the full error message and additional helpful warnings.");
          } else {
            var args = [a, b, c, d, e, f];
            var argIndex = 0;
            error = new Error(format.replace(/%s/g, function () {
              return args[argIndex++];
            }));
            error.name = "Invariant Violation";
          }

          error.framesToPop = 1;
          throw error;
        }
      }

      var invokeGuardedCallbackImpl = function invokeGuardedCallbackImpl(name, func, context, a, b, c, d, e, f) {
        var funcArgs = Array.prototype.slice.call(arguments, 3);

        try {
          func.apply(context, funcArgs);
        } catch (error) {
          this.onError(error);
        }
      };

      {
        if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
          var fakeNode = document.createElement("react");

          var invokeGuardedCallbackDev = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
            invariant(typeof document !== "undefined", "The `document` global was defined when React was initialized, but is not " + "defined anymore. This can happen in a test environment if a component " + "schedules an update from an asynchronous callback, but the test has already " + "finished running. To solve this, you can either unmount the component at " + "the end of your test (and ensure that any asynchronous operations get " + "canceled in `componentWillUnmount`), or you can change the test itself " + "to be asynchronous.");
            var evt = document.createEvent("Event");
            var didError = true;
            var windowEvent = window.event;
            var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
            var funcArgs = Array.prototype.slice.call(arguments, 3);

            function callCallback() {
              fakeNode.removeEventListener(evtType, callCallback, false);

              if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                window.event = windowEvent;
              }

              func.apply(context, funcArgs);
              didError = false;
            }

            var error = void 0;
            var didSetError = false;
            var isCrossOriginError = false;

            function handleWindowError(event) {
              error = event.error;
              didSetError = true;

              if (error === null && event.colno === 0 && event.lineno === 0) {
                isCrossOriginError = true;
              }

              if (event.defaultPrevented) {
                if (error != null && typeof error === "object") {
                  try {
                    error._suppressLogging = true;
                  } catch (inner) {}
                }
              }
            }

            var evtType = "react-" + (name ? name : "invokeguardedcallback");
            window.addEventListener("error", handleWindowError);
            fakeNode.addEventListener(evtType, callCallback, false);
            evt.initEvent(evtType, false, false);
            fakeNode.dispatchEvent(evt);

            if (windowEventDescriptor) {
              Object.defineProperty(window, "event", windowEventDescriptor);
            }

            if (didError) {
              if (!didSetError) {
                error = new Error("An error was thrown inside one of your components, but React " + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + "your browser. Try triggering the error in production mode, " + "or switching to a modern browser. If you suspect that this is " + "actually an issue with React, please file an issue.");
              } else if (isCrossOriginError) {
                error = new Error("A cross-origin error was thrown. React doesn't have access to " + "the actual error object in development. " + "See https://fb.me/react-crossorigin-error for more information.");
              }

              this.onError(error);
            }

            window.removeEventListener("error", handleWindowError);
          };

          invokeGuardedCallbackImpl = invokeGuardedCallbackDev;
        }
      }
      var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
      var hasError = false;
      var caughtError = null;
      var hasRethrowError = false;
      var rethrowError = null;
      var reporter = {
        onError: function onError(error) {
          hasError = true;
          caughtError = error;
        }
      };

      function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
        hasError = false;
        caughtError = null;
        invokeGuardedCallbackImpl$1.apply(reporter, arguments);
      }

      function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
        invokeGuardedCallback.apply(this, arguments);

        if (hasError) {
          var error = clearCaughtError();

          if (!hasRethrowError) {
            hasRethrowError = true;
            rethrowError = error;
          }
        }
      }

      function rethrowCaughtError() {
        if (hasRethrowError) {
          var error = rethrowError;
          hasRethrowError = false;
          rethrowError = null;
          throw error;
        }
      }

      function hasCaughtError() {
        return hasError;
      }

      function clearCaughtError() {
        if (hasError) {
          var error = caughtError;
          hasError = false;
          caughtError = null;
          return error;
        } else {
          invariant(false, "clearCaughtError was called but no error was captured. This error " + "is likely caused by a bug in React. Please file an issue.");
        }
      }

      var eventPluginOrder = null;
      var namesToPlugins = {};

      function recomputePluginOrdering() {
        if (!eventPluginOrder) {
          return;
        }

        for (var pluginName in namesToPlugins) {
          var pluginModule = namesToPlugins[pluginName];
          var pluginIndex = eventPluginOrder.indexOf(pluginName);
          invariant(pluginIndex > -1, "EventPluginRegistry: Cannot inject event plugins that do not exist in " + "the plugin ordering, `%s`.", pluginName);

          if (plugins[pluginIndex]) {
            continue;
          }

          invariant(pluginModule.extractEvents, "EventPluginRegistry: Event plugins must implement an `extractEvents` " + "method, but `%s` does not.", pluginName);
          plugins[pluginIndex] = pluginModule;
          var publishedEvents = pluginModule.eventTypes;

          for (var eventName in publishedEvents) {
            invariant(publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName), "EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.", eventName, pluginName);
          }
        }
      }

      function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
        invariant(!eventNameDispatchConfigs.hasOwnProperty(eventName), "EventPluginHub: More than one plugin attempted to publish the same " + "event name, `%s`.", eventName);
        eventNameDispatchConfigs[eventName] = dispatchConfig;
        var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

        if (phasedRegistrationNames) {
          for (var phaseName in phasedRegistrationNames) {
            if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
              var phasedRegistrationName = phasedRegistrationNames[phaseName];
              publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
            }
          }

          return true;
        } else if (dispatchConfig.registrationName) {
          publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
          return true;
        }

        return false;
      }

      function publishRegistrationName(registrationName, pluginModule, eventName) {
        invariant(!registrationNameModules[registrationName], "EventPluginHub: More than one plugin attempted to publish the same " + "registration name, `%s`.", registrationName);
        registrationNameModules[registrationName] = pluginModule;
        registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;
        {
          var lowerCasedName = registrationName.toLowerCase();
        }
      }

      var plugins = [];
      var eventNameDispatchConfigs = {};
      var registrationNameModules = {};
      var registrationNameDependencies = {};

      function injectEventPluginOrder(injectedEventPluginOrder) {
        invariant(!eventPluginOrder, "EventPluginRegistry: Cannot inject event plugin ordering more than " + "once. You are likely trying to load more than one copy of React.");
        eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
        recomputePluginOrdering();
      }

      function injectEventPluginsByName(injectedNamesToPlugins) {
        var isOrderingDirty = false;

        for (var pluginName in injectedNamesToPlugins) {
          if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
            continue;
          }

          var pluginModule = injectedNamesToPlugins[pluginName];

          if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
            invariant(!namesToPlugins[pluginName], "EventPluginRegistry: Cannot inject two different event plugins " + "using the same name, `%s`.", pluginName);
            namesToPlugins[pluginName] = pluginModule;
            isOrderingDirty = true;
          }
        }

        if (isOrderingDirty) {
          recomputePluginOrdering();
        }
      }

      var warningWithoutStack = function warningWithoutStack() {};

      {
        warningWithoutStack = function warningWithoutStack(condition, format) {
          for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          if (format === undefined) {
            throw new Error("`warningWithoutStack(condition, format, ...args)` requires a warning " + "message argument");
          }

          if (args.length > 8) {
            throw new Error("warningWithoutStack() currently supports at most 8 arguments.");
          }

          if (condition) {
            return;
          }

          if (typeof console !== "undefined") {
            var argsWithFormat = args.map(function (item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console.error, console, argsWithFormat);
          }

          try {
            var argIndex = 0;
            var message = "Warning: " + format.replace(/%s/g, function () {
              return args[argIndex++];
            });
            throw new Error(message);
          } catch (x) {}
        };
      }
      var warningWithoutStack$1 = warningWithoutStack;
      var getFiberCurrentPropsFromNode = null;
      var getInstanceFromNode = null;
      var getNodeFromInstance = null;

      function setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {
        getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;
        getInstanceFromNode = getInstanceFromNodeImpl;
        getNodeFromInstance = getNodeFromInstanceImpl;
        {
          !(getNodeFromInstance && getInstanceFromNode) ? warningWithoutStack$1(false, "EventPluginUtils.setComponentTree(...): Injected " + "module is missing getNodeFromInstance or getInstanceFromNode.") : void 0;
        }
      }

      var validateEventDispatches = void 0;
      {
        validateEventDispatches = function validateEventDispatches(event) {
          var dispatchListeners = event._dispatchListeners;
          var dispatchInstances = event._dispatchInstances;
          var listenersIsArr = Array.isArray(dispatchListeners);
          var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
          var instancesIsArr = Array.isArray(dispatchInstances);
          var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
          !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warningWithoutStack$1(false, "EventPluginUtils: Invalid `event`.") : void 0;
        };
      }

      function executeDispatch(event, listener, inst) {
        var type = event.type || "unknown-event";
        event.currentTarget = getNodeFromInstance(inst);
        invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
        event.currentTarget = null;
      }

      function executeDispatchesInOrder(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchInstances = event._dispatchInstances;
        {
          validateEventDispatches(event);
        }

        if (Array.isArray(dispatchListeners)) {
          for (var i = 0; i < dispatchListeners.length; i++) {
            if (event.isPropagationStopped()) {
              break;
            }

            executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);
          }
        } else if (dispatchListeners) {
          executeDispatch(event, dispatchListeners, dispatchInstances);
        }

        event._dispatchListeners = null;
        event._dispatchInstances = null;
      }

      function executeDispatchesInOrderStopAtTrueImpl(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchInstances = event._dispatchInstances;
        {
          validateEventDispatches(event);
        }

        if (Array.isArray(dispatchListeners)) {
          for (var i = 0; i < dispatchListeners.length; i++) {
            if (event.isPropagationStopped()) {
              break;
            }

            if (dispatchListeners[i](event, dispatchInstances[i])) {
              return dispatchInstances[i];
            }
          }
        } else if (dispatchListeners) {
          if (dispatchListeners(event, dispatchInstances)) {
            return dispatchInstances;
          }
        }

        return null;
      }

      function executeDispatchesInOrderStopAtTrue(event) {
        var ret = executeDispatchesInOrderStopAtTrueImpl(event);
        event._dispatchInstances = null;
        event._dispatchListeners = null;
        return ret;
      }

      function executeDirectDispatch(event) {
        {
          validateEventDispatches(event);
        }
        var dispatchListener = event._dispatchListeners;
        var dispatchInstance = event._dispatchInstances;
        invariant(!Array.isArray(dispatchListener), "executeDirectDispatch(...): Invalid `event`.");
        event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;
        var res = dispatchListener ? dispatchListener(event) : null;
        event.currentTarget = null;
        event._dispatchListeners = null;
        event._dispatchInstances = null;
        return res;
      }

      function hasDispatches(event) {
        return !!event._dispatchListeners;
      }

      function accumulateInto(current, next) {
        invariant(next != null, "accumulateInto(...): Accumulated items must not be null or undefined.");

        if (current == null) {
          return next;
        }

        if (Array.isArray(current)) {
          if (Array.isArray(next)) {
            current.push.apply(current, next);
            return current;
          }

          current.push(next);
          return current;
        }

        if (Array.isArray(next)) {
          return [current].concat(next);
        }

        return [current, next];
      }

      function forEachAccumulated(arr, cb, scope) {
        if (Array.isArray(arr)) {
          arr.forEach(cb, scope);
        } else if (arr) {
          cb.call(scope, arr);
        }
      }

      var eventQueue = null;

      var executeDispatchesAndRelease = function executeDispatchesAndRelease(event) {
        if (event) {
          executeDispatchesInOrder(event);

          if (!event.isPersistent()) {
            event.constructor.release(event);
          }
        }
      };

      var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
        return executeDispatchesAndRelease(e);
      };

      function isInteractive(tag) {
        return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
      }

      function shouldPreventMouseEvent(name, type, props) {
        switch (name) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
            return !!(props.disabled && isInteractive(type));

          default:
            return false;
        }
      }

      var injection = {
        injectEventPluginOrder: injectEventPluginOrder,
        injectEventPluginsByName: injectEventPluginsByName
      };

      function getListener(inst, registrationName) {
        var listener = void 0;
        var stateNode = inst.stateNode;

        if (!stateNode) {
          return null;
        }

        var props = getFiberCurrentPropsFromNode(stateNode);

        if (!props) {
          return null;
        }

        listener = props[registrationName];

        if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
          return null;
        }

        invariant(!listener || typeof listener === "function", "Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
        return listener;
      }

      function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var events = null;

        for (var i = 0; i < plugins.length; i++) {
          var possiblePlugin = plugins[i];

          if (possiblePlugin) {
            var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);

            if (extractedEvents) {
              events = accumulateInto(events, extractedEvents);
            }
          }
        }

        return events;
      }

      function runEventsInBatch(events) {
        if (events !== null) {
          eventQueue = accumulateInto(eventQueue, events);
        }

        var processingEventQueue = eventQueue;
        eventQueue = null;

        if (!processingEventQueue) {
          return;
        }

        forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
        invariant(!eventQueue, "processEventQueue(): Additional events were enqueued while processing " + "an event queue. Support for this has not yet been implemented.");
        rethrowCaughtError();
      }

      function runExtractedEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        runEventsInBatch(events);
      }

      var FunctionComponent = 0;
      var ClassComponent = 1;
      var IndeterminateComponent = 2;
      var HostRoot = 3;
      var HostPortal = 4;
      var HostComponent = 5;
      var HostText = 6;
      var Fragment = 7;
      var Mode = 8;
      var ContextConsumer = 9;
      var ContextProvider = 10;
      var ForwardRef = 11;
      var Profiler = 12;
      var SuspenseComponent = 13;
      var MemoComponent = 14;
      var SimpleMemoComponent = 15;
      var LazyComponent = 16;
      var IncompleteClassComponent = 17;

      function getParent(inst) {
        do {
          inst = inst.return;
        } while (inst && inst.tag !== HostComponent);

        if (inst) {
          return inst;
        }

        return null;
      }

      function getLowestCommonAncestor(instA, instB) {
        var depthA = 0;

        for (var tempA = instA; tempA; tempA = getParent(tempA)) {
          depthA++;
        }

        var depthB = 0;

        for (var tempB = instB; tempB; tempB = getParent(tempB)) {
          depthB++;
        }

        while (depthA - depthB > 0) {
          instA = getParent(instA);
          depthA--;
        }

        while (depthB - depthA > 0) {
          instB = getParent(instB);
          depthB--;
        }

        var depth = depthA;

        while (depth--) {
          if (instA === instB || instA === instB.alternate) {
            return instA;
          }

          instA = getParent(instA);
          instB = getParent(instB);
        }

        return null;
      }

      function isAncestor(instA, instB) {
        while (instB) {
          if (instA === instB || instA === instB.alternate) {
            return true;
          }

          instB = getParent(instB);
        }

        return false;
      }

      function getParentInstance(inst) {
        return getParent(inst);
      }

      function traverseTwoPhase(inst, fn, arg) {
        var path = [];

        while (inst) {
          path.push(inst);
          inst = getParent(inst);
        }

        var i = void 0;

        for (i = path.length; i-- > 0;) {
          fn(path[i], "captured", arg);
        }

        for (i = 0; i < path.length; i++) {
          fn(path[i], "bubbled", arg);
        }
      }

      function listenerAtPhase(inst, event, propagationPhase) {
        var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
        return getListener(inst, registrationName);
      }

      function accumulateDirectionalDispatches(inst, phase, event) {
        {
          !inst ? warningWithoutStack$1(false, "Dispatching inst must not be null") : void 0;
        }
        var listener = listenerAtPhase(inst, event, phase);

        if (listener) {
          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
          event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
        }
      }

      function accumulateTwoPhaseDispatchesSingle(event) {
        if (event && event.dispatchConfig.phasedRegistrationNames) {
          traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
        }
      }

      function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
        if (event && event.dispatchConfig.phasedRegistrationNames) {
          var targetInst = event._targetInst;
          var parentInst = targetInst ? getParentInstance(targetInst) : null;
          traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
        }
      }

      function accumulateDispatches(inst, ignoredDirection, event) {
        if (inst && event && event.dispatchConfig.registrationName) {
          var registrationName = event.dispatchConfig.registrationName;
          var listener = getListener(inst, registrationName);

          if (listener) {
            event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
            event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
          }
        }
      }

      function accumulateDirectDispatchesSingle(event) {
        if (event && event.dispatchConfig.registrationName) {
          accumulateDispatches(event._targetInst, null, event);
        }
      }

      function accumulateTwoPhaseDispatches(events) {
        forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
      }

      function accumulateTwoPhaseDispatchesSkipTarget(events) {
        forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
      }

      function accumulateDirectDispatches(events) {
        forEachAccumulated(events, accumulateDirectDispatchesSingle);
      }

      var EVENT_POOL_SIZE = 10;
      var EventInterface = {
        type: null,
        target: null,
        currentTarget: function currentTarget() {
          return null;
        },
        eventPhase: null,
        bubbles: null,
        cancelable: null,
        timeStamp: function timeStamp(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: null,
        isTrusted: null
      };

      function functionThatReturnsTrue() {
        return true;
      }

      function functionThatReturnsFalse() {
        return false;
      }

      function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
        {
          delete this.nativeEvent;
          delete this.preventDefault;
          delete this.stopPropagation;
          delete this.isDefaultPrevented;
          delete this.isPropagationStopped;
        }
        this.dispatchConfig = dispatchConfig;
        this._targetInst = targetInst;
        this.nativeEvent = nativeEvent;
        var Interface = this.constructor.Interface;

        for (var propName in Interface) {
          if (!Interface.hasOwnProperty(propName)) {
            continue;
          }

          {
            delete this[propName];
          }
          var normalize = Interface[propName];

          if (normalize) {
            this[propName] = normalize(nativeEvent);
          } else {
            if (propName === "target") {
              this.target = nativeEventTarget;
            } else {
              this[propName] = nativeEvent[propName];
            }
          }
        }

        var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;

        if (defaultPrevented) {
          this.isDefaultPrevented = functionThatReturnsTrue;
        } else {
          this.isDefaultPrevented = functionThatReturnsFalse;
        }

        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }

      _extends(SyntheticEvent.prototype, {
        preventDefault: function preventDefault() {
          this.defaultPrevented = true;
          var event = this.nativeEvent;

          if (!event) {
            return;
          }

          if (event.preventDefault) {
            event.preventDefault();
          } else if (typeof event.returnValue !== "unknown") {
            event.returnValue = false;
          }

          this.isDefaultPrevented = functionThatReturnsTrue;
        },
        stopPropagation: function stopPropagation() {
          var event = this.nativeEvent;

          if (!event) {
            return;
          }

          if (event.stopPropagation) {
            event.stopPropagation();
          } else if (typeof event.cancelBubble !== "unknown") {
            event.cancelBubble = true;
          }

          this.isPropagationStopped = functionThatReturnsTrue;
        },
        persist: function persist() {
          this.isPersistent = functionThatReturnsTrue;
        },
        isPersistent: functionThatReturnsFalse,
        destructor: function destructor() {
          var Interface = this.constructor.Interface;

          for (var propName in Interface) {
            {
              Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
            }
          }

          this.dispatchConfig = null;
          this._targetInst = null;
          this.nativeEvent = null;
          this.isDefaultPrevented = functionThatReturnsFalse;
          this.isPropagationStopped = functionThatReturnsFalse;
          this._dispatchListeners = null;
          this._dispatchInstances = null;
          {
            Object.defineProperty(this, "nativeEvent", getPooledWarningPropertyDefinition("nativeEvent", null));
            Object.defineProperty(this, "isDefaultPrevented", getPooledWarningPropertyDefinition("isDefaultPrevented", functionThatReturnsFalse));
            Object.defineProperty(this, "isPropagationStopped", getPooledWarningPropertyDefinition("isPropagationStopped", functionThatReturnsFalse));
            Object.defineProperty(this, "preventDefault", getPooledWarningPropertyDefinition("preventDefault", function () {}));
            Object.defineProperty(this, "stopPropagation", getPooledWarningPropertyDefinition("stopPropagation", function () {}));
          }
        }
      });

      SyntheticEvent.Interface = EventInterface;

      SyntheticEvent.extend = function (Interface) {
        var Super = this;

        var E = function E() {};

        E.prototype = Super.prototype;
        var prototype = new E();

        function Class() {
          return Super.apply(this, arguments);
        }

        _extends(prototype, Class.prototype);

        Class.prototype = prototype;
        Class.prototype.constructor = Class;
        Class.Interface = _extends({}, Super.Interface, Interface);
        Class.extend = Super.extend;
        addEventPoolingTo(Class);
        return Class;
      };

      addEventPoolingTo(SyntheticEvent);

      function getPooledWarningPropertyDefinition(propName, getVal) {
        var isFunction = typeof getVal === "function";
        return {
          configurable: true,
          set: set,
          get: get$$1
        };

        function set(val) {
          var action = isFunction ? "setting the method" : "setting the property";
          warn(action, "This is effectively a no-op");
          return val;
        }

        function get$$1() {
          var action = isFunction ? "accessing the method" : "accessing the property";
          var result = isFunction ? "This is a no-op function" : "This is set to null";
          warn(action, result);
          return getVal;
        }

        function warn(action, result) {
          var warningCondition = false;
          !warningCondition ? warningWithoutStack$1(false, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + "If you must keep the original synthetic event around, use event.persist(). " + "See https://fb.me/react-event-pooling for more information.", action, propName, result) : void 0;
        }
      }

      function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
        var EventConstructor = this;

        if (EventConstructor.eventPool.length) {
          var instance = EventConstructor.eventPool.pop();
          EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
          return instance;
        }

        return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
      }

      function releasePooledEvent(event) {
        var EventConstructor = this;
        invariant(event instanceof EventConstructor, "Trying to release an event instance into a pool of a different type.");
        event.destructor();

        if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
          EventConstructor.eventPool.push(event);
        }
      }

      function addEventPoolingTo(EventConstructor) {
        EventConstructor.eventPool = [];
        EventConstructor.getPooled = getPooledEvent;
        EventConstructor.release = releasePooledEvent;
      }

      var ResponderSyntheticEvent = SyntheticEvent.extend({
        touchHistory: function touchHistory(nativeEvent) {
          return null;
        }
      });
      var TOP_TOUCH_START = "topTouchStart";
      var TOP_TOUCH_MOVE = "topTouchMove";
      var TOP_TOUCH_END = "topTouchEnd";
      var TOP_TOUCH_CANCEL = "topTouchCancel";
      var TOP_SCROLL = "topScroll";
      var TOP_SELECTION_CHANGE = "topSelectionChange";

      function isStartish(topLevelType) {
        return topLevelType === TOP_TOUCH_START;
      }

      function isMoveish(topLevelType) {
        return topLevelType === TOP_TOUCH_MOVE;
      }

      function isEndish(topLevelType) {
        return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL;
      }

      var startDependencies = [TOP_TOUCH_START];
      var moveDependencies = [TOP_TOUCH_MOVE];
      var endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END];
      var MAX_TOUCH_BANK = 20;
      var touchBank = [];
      var touchHistory = {
        touchBank: touchBank,
        numberActiveTouches: 0,
        indexOfSingleActiveTouch: -1,
        mostRecentTimeStamp: 0
      };

      function timestampForTouch(touch) {
        return touch.timeStamp || touch.timestamp;
      }

      function createTouchRecord(touch) {
        return {
          touchActive: true,
          startPageX: touch.pageX,
          startPageY: touch.pageY,
          startTimeStamp: timestampForTouch(touch),
          currentPageX: touch.pageX,
          currentPageY: touch.pageY,
          currentTimeStamp: timestampForTouch(touch),
          previousPageX: touch.pageX,
          previousPageY: touch.pageY,
          previousTimeStamp: timestampForTouch(touch)
        };
      }

      function resetTouchRecord(touchRecord, touch) {
        touchRecord.touchActive = true;
        touchRecord.startPageX = touch.pageX;
        touchRecord.startPageY = touch.pageY;
        touchRecord.startTimeStamp = timestampForTouch(touch);
        touchRecord.currentPageX = touch.pageX;
        touchRecord.currentPageY = touch.pageY;
        touchRecord.currentTimeStamp = timestampForTouch(touch);
        touchRecord.previousPageX = touch.pageX;
        touchRecord.previousPageY = touch.pageY;
        touchRecord.previousTimeStamp = timestampForTouch(touch);
      }

      function getTouchIdentifier(_ref) {
        var identifier = _ref.identifier;
        invariant(identifier != null, "Touch object is missing identifier.");
        {
          !(identifier <= MAX_TOUCH_BANK) ? warningWithoutStack$1(false, "Touch identifier %s is greater than maximum supported %s which causes " + "performance issues backfilling array locations for all of the indices.", identifier, MAX_TOUCH_BANK) : void 0;
        }
        return identifier;
      }

      function recordTouchStart(touch) {
        var identifier = getTouchIdentifier(touch);
        var touchRecord = touchBank[identifier];

        if (touchRecord) {
          resetTouchRecord(touchRecord, touch);
        } else {
          touchBank[identifier] = createTouchRecord(touch);
        }

        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
      }

      function recordTouchMove(touch) {
        var touchRecord = touchBank[getTouchIdentifier(touch)];

        if (touchRecord) {
          touchRecord.touchActive = true;
          touchRecord.previousPageX = touchRecord.currentPageX;
          touchRecord.previousPageY = touchRecord.currentPageY;
          touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
          touchRecord.currentPageX = touch.pageX;
          touchRecord.currentPageY = touch.pageY;
          touchRecord.currentTimeStamp = timestampForTouch(touch);
          touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
        } else {
          console.error("Cannot record touch move without a touch start.\n" + "Touch Move: %s\n", "Touch Bank: %s", printTouch(touch), printTouchBank());
        }
      }

      function recordTouchEnd(touch) {
        var touchRecord = touchBank[getTouchIdentifier(touch)];

        if (touchRecord) {
          touchRecord.touchActive = false;
          touchRecord.previousPageX = touchRecord.currentPageX;
          touchRecord.previousPageY = touchRecord.currentPageY;
          touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
          touchRecord.currentPageX = touch.pageX;
          touchRecord.currentPageY = touch.pageY;
          touchRecord.currentTimeStamp = timestampForTouch(touch);
          touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
        } else {
          console.error("Cannot record touch end without a touch start.\n" + "Touch End: %s\n", "Touch Bank: %s", printTouch(touch), printTouchBank());
        }
      }

      function printTouch(touch) {
        return JSON.stringify({
          identifier: touch.identifier,
          pageX: touch.pageX,
          pageY: touch.pageY,
          timestamp: timestampForTouch(touch)
        });
      }

      function printTouchBank() {
        var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));

        if (touchBank.length > MAX_TOUCH_BANK) {
          printed += " (original size: " + touchBank.length + ")";
        }

        return printed;
      }

      var ResponderTouchHistoryStore = {
        recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {
          if (isMoveish(topLevelType)) {
            nativeEvent.changedTouches.forEach(recordTouchMove);
          } else if (isStartish(topLevelType)) {
            nativeEvent.changedTouches.forEach(recordTouchStart);
            touchHistory.numberActiveTouches = nativeEvent.touches.length;

            if (touchHistory.numberActiveTouches === 1) {
              touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;
            }
          } else if (isEndish(topLevelType)) {
            nativeEvent.changedTouches.forEach(recordTouchEnd);
            touchHistory.numberActiveTouches = nativeEvent.touches.length;

            if (touchHistory.numberActiveTouches === 1) {
              for (var i = 0; i < touchBank.length; i++) {
                var touchTrackToCheck = touchBank[i];

                if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {
                  touchHistory.indexOfSingleActiveTouch = i;
                  break;
                }
              }

              {
                var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];
                !(activeRecord != null && activeRecord.touchActive) ? warningWithoutStack$1(false, "Cannot find single active touch.") : void 0;
              }
            }
          }
        },
        touchHistory: touchHistory
      };

      function accumulate(current, next) {
        invariant(next != null, "accumulate(...): Accumulated items must be not be null or undefined.");

        if (current == null) {
          return next;
        }

        if (Array.isArray(current)) {
          return current.concat(next);
        }

        if (Array.isArray(next)) {
          return [current].concat(next);
        }

        return [current, next];
      }

      var responderInst = null;
      var trackedTouchCount = 0;

      var changeResponder = function changeResponder(nextResponderInst, blockHostResponder) {
        var oldResponderInst = responderInst;
        responderInst = nextResponderInst;

        if (ResponderEventPlugin.GlobalResponderHandler !== null) {
          ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);
        }
      };

      var eventTypes$1 = {
        startShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onStartShouldSetResponder",
            captured: "onStartShouldSetResponderCapture"
          },
          dependencies: startDependencies
        },
        scrollShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onScrollShouldSetResponder",
            captured: "onScrollShouldSetResponderCapture"
          },
          dependencies: [TOP_SCROLL]
        },
        selectionChangeShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onSelectionChangeShouldSetResponder",
            captured: "onSelectionChangeShouldSetResponderCapture"
          },
          dependencies: [TOP_SELECTION_CHANGE]
        },
        moveShouldSetResponder: {
          phasedRegistrationNames: {
            bubbled: "onMoveShouldSetResponder",
            captured: "onMoveShouldSetResponderCapture"
          },
          dependencies: moveDependencies
        },
        responderStart: {
          registrationName: "onResponderStart",
          dependencies: startDependencies
        },
        responderMove: {
          registrationName: "onResponderMove",
          dependencies: moveDependencies
        },
        responderEnd: {
          registrationName: "onResponderEnd",
          dependencies: endDependencies
        },
        responderRelease: {
          registrationName: "onResponderRelease",
          dependencies: endDependencies
        },
        responderTerminationRequest: {
          registrationName: "onResponderTerminationRequest",
          dependencies: []
        },
        responderGrant: {
          registrationName: "onResponderGrant",
          dependencies: []
        },
        responderReject: {
          registrationName: "onResponderReject",
          dependencies: []
        },
        responderTerminate: {
          registrationName: "onResponderTerminate",
          dependencies: []
        }
      };

      function setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var shouldSetEventType = isStartish(topLevelType) ? eventTypes$1.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes$1.moveShouldSetResponder : topLevelType === TOP_SELECTION_CHANGE ? eventTypes$1.selectionChangeShouldSetResponder : eventTypes$1.scrollShouldSetResponder;
        var bubbleShouldSetFrom = !responderInst ? targetInst : getLowestCommonAncestor(responderInst, targetInst);
        var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;
        var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);
        shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;

        if (skipOverBubbleShouldSetFrom) {
          accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);
        } else {
          accumulateTwoPhaseDispatches(shouldSetEvent);
        }

        var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);

        if (!shouldSetEvent.isPersistent()) {
          shouldSetEvent.constructor.release(shouldSetEvent);
        }

        if (!wantsResponderInst || wantsResponderInst === responderInst) {
          return null;
        }

        var extracted = void 0;
        var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget);
        grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
        accumulateDirectDispatches(grantEvent);
        var blockHostResponder = executeDirectDispatch(grantEvent) === true;

        if (responderInst) {
          var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget);
          terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
          accumulateDirectDispatches(terminationRequestEvent);
          var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);

          if (!terminationRequestEvent.isPersistent()) {
            terminationRequestEvent.constructor.release(terminationRequestEvent);
          }

          if (shouldSwitch) {
            var terminateEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderTerminate, responderInst, nativeEvent, nativeEventTarget);
            terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(terminateEvent);
            extracted = accumulate(extracted, [grantEvent, terminateEvent]);
            changeResponder(wantsResponderInst, blockHostResponder);
          } else {
            var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderReject, wantsResponderInst, nativeEvent, nativeEventTarget);
            rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(rejectEvent);
            extracted = accumulate(extracted, rejectEvent);
          }
        } else {
          extracted = accumulate(extracted, grantEvent);
          changeResponder(wantsResponderInst, blockHostResponder);
        }

        return extracted;
      }

      function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {
        return topLevelInst && (topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE || isStartish(topLevelType) || isMoveish(topLevelType));
      }

      function noResponderTouches(nativeEvent) {
        var touches = nativeEvent.touches;

        if (!touches || touches.length === 0) {
          return true;
        }

        for (var i = 0; i < touches.length; i++) {
          var activeTouch = touches[i];
          var target = activeTouch.target;

          if (target !== null && target !== undefined && target !== 0) {
            var targetInst = getInstanceFromNode(target);

            if (isAncestor(responderInst, targetInst)) {
              return false;
            }
          }
        }

        return true;
      }

      var ResponderEventPlugin = {
        _getResponder: function _getResponder() {
          return responderInst;
        },
        eventTypes: eventTypes$1,
        extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
          if (isStartish(topLevelType)) {
            trackedTouchCount += 1;
          } else if (isEndish(topLevelType)) {
            if (trackedTouchCount >= 0) {
              trackedTouchCount -= 1;
            } else {
              console.error("Ended a touch event which was not counted in `trackedTouchCount`.");
              return null;
            }
          }

          ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);
          var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) : null;
          var isResponderTouchStart = responderInst && isStartish(topLevelType);
          var isResponderTouchMove = responderInst && isMoveish(topLevelType);
          var isResponderTouchEnd = responderInst && isEndish(topLevelType);
          var incrementalTouch = isResponderTouchStart ? eventTypes$1.responderStart : isResponderTouchMove ? eventTypes$1.responderMove : isResponderTouchEnd ? eventTypes$1.responderEnd : null;

          if (incrementalTouch) {
            var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);
            gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(gesture);
            extracted = accumulate(extracted, gesture);
          }

          var isResponderTerminate = responderInst && topLevelType === TOP_TOUCH_CANCEL;
          var isResponderRelease = responderInst && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);
          var finalTouch = isResponderTerminate ? eventTypes$1.responderTerminate : isResponderRelease ? eventTypes$1.responderRelease : null;

          if (finalTouch) {
            var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);
            finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
            accumulateDirectDispatches(finalEvent);
            extracted = accumulate(extracted, finalEvent);
            changeResponder(null);
          }

          return extracted;
        },
        GlobalResponderHandler: null,
        injection: {
          injectGlobalResponderHandler: function injectGlobalResponderHandler(GlobalResponderHandler) {
            ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;
          }
        }
      };
      var customBubblingEventTypes$1 = ReactNativeViewConfigRegistry.customBubblingEventTypes;
      var customDirectEventTypes$1 = ReactNativeViewConfigRegistry.customDirectEventTypes;
      var eventTypes$2 = ReactNativeViewConfigRegistry.eventTypes;
      var ReactNativeBridgeEventPlugin = {
        eventTypes: eventTypes$2,
        extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
          if (targetInst == null) {
            return null;
          }

          var bubbleDispatchConfig = customBubblingEventTypes$1[topLevelType];
          var directDispatchConfig = customDirectEventTypes$1[topLevelType];
          invariant(bubbleDispatchConfig || directDispatchConfig, 'Unsupported top level event type "%s" dispatched', topLevelType);
          var event = SyntheticEvent.getPooled(bubbleDispatchConfig || directDispatchConfig, targetInst, nativeEvent, nativeEventTarget);

          if (bubbleDispatchConfig) {
            accumulateTwoPhaseDispatches(event);
          } else if (directDispatchConfig) {
            accumulateDirectDispatches(event);
          } else {
            return null;
          }

          return event;
        }
      };
      var ReactNativeEventPluginOrder = ["ResponderEventPlugin", "ReactNativeBridgeEventPlugin"];
      injection.injectEventPluginOrder(ReactNativeEventPluginOrder);
      injection.injectEventPluginsByName({
        ResponderEventPlugin: ResponderEventPlugin,
        ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin
      });

      function getInstanceFromInstance(instanceHandle) {
        return instanceHandle;
      }

      function getTagFromInstance(inst) {
        var tag = inst.stateNode.canonical._nativeTag;
        invariant(tag, "All native instances should have a tag.");
        return tag;
      }

      function getFiberCurrentPropsFromNode$1(inst) {
        return inst.canonical.currentProps;
      }

      var ReactFabricGlobalResponderHandler = {
        onChange: function onChange(from, to, blockNativeResponder) {
          if (to !== null) {
            var tag = to.stateNode.canonical._nativeTag;
            UIManager.setJSResponder(tag, blockNativeResponder);
          } else {
            UIManager.clearJSResponder();
          }
        }
      };
      setComponentTree(getFiberCurrentPropsFromNode$1, getInstanceFromInstance, getTagFromInstance);
      ResponderEventPlugin.injection.injectGlobalResponderHandler(ReactFabricGlobalResponderHandler);

      function get$1(key) {
        return key._reactInternalFiber;
      }

      function set(key, value) {
        key._reactInternalFiber = value;
      }

      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      var hasSymbol = typeof Symbol === "function" && (typeof Symbol === "function" ? Symbol.for : "@@for");
      var REACT_ELEMENT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.element") : 0xeac7;
      var REACT_PORTAL_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.portal") : 0xeaca;
      var REACT_FRAGMENT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.fragment") : 0xeacb;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.strict_mode") : 0xeacc;
      var REACT_PROFILER_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.profiler") : 0xead2;
      var REACT_PROVIDER_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.provider") : 0xeacd;
      var REACT_CONTEXT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.context") : 0xeace;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.concurrent_mode") : 0xeacf;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.forward_ref") : 0xead0;
      var REACT_SUSPENSE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.suspense") : 0xead1;
      var REACT_MEMO_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.memo") : 0xead3;
      var REACT_LAZY_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.lazy") : 0xead4;
      var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && (typeof Symbol === "function" ? Symbol.iterator : "@@iterator");
      var FAUX_ITERATOR_SYMBOL = "@@iterator";

      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }

        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }

        return null;
      }

      var Pending = 0;
      var Resolved = 1;
      var Rejected = 2;

      function refineResolvedLazyComponent(lazyComponent) {
        return lazyComponent._status === Resolved ? lazyComponent._result : null;
      }

      function getWrappedName(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || "";
        return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
      }

      function getComponentName(type) {
        if (type == null) {
          return null;
        }

        {
          if (typeof type.tag === "number") {
            warningWithoutStack$1(false, "Received an unexpected object in getComponentName(). " + "This is likely a bug in React. Please file an issue.");
          }
        }

        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }

        if (typeof type === "string") {
          return type;
        }

        switch (type) {
          case REACT_CONCURRENT_MODE_TYPE:
            return "ConcurrentMode";

          case REACT_FRAGMENT_TYPE:
            return "Fragment";

          case REACT_PORTAL_TYPE:
            return "Portal";

          case REACT_PROFILER_TYPE:
            return "Profiler";

          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";

          case REACT_SUSPENSE_TYPE:
            return "Suspense";
        }

        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              return "Context.Consumer";

            case REACT_PROVIDER_TYPE:
              return "Context.Provider";

            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");

            case REACT_MEMO_TYPE:
              return getComponentName(type.type);

            case REACT_LAZY_TYPE:
              {
                var thenable = type;
                var resolvedThenable = refineResolvedLazyComponent(thenable);

                if (resolvedThenable) {
                  return getComponentName(resolvedThenable);
                }
              }
          }
        }

        return null;
      }

      var NoEffect = 0;
      var PerformedWork = 1;
      var Placement = 2;
      var Update = 4;
      var PlacementAndUpdate = 6;
      var Deletion = 8;
      var ContentReset = 16;
      var Callback = 32;
      var DidCapture = 64;
      var Ref = 128;
      var Snapshot = 256;
      var Passive = 512;
      var LifecycleEffectMask = 932;
      var HostEffectMask = 1023;
      var Incomplete = 1024;
      var ShouldCapture = 2048;
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var MOUNTING = 1;
      var MOUNTED = 2;
      var UNMOUNTED = 3;

      function isFiberMountedImpl(fiber) {
        var node = fiber;

        if (!fiber.alternate) {
          if ((node.effectTag & Placement) !== NoEffect) {
            return MOUNTING;
          }

          while (node.return) {
            node = node.return;

            if ((node.effectTag & Placement) !== NoEffect) {
              return MOUNTING;
            }
          }
        } else {
          while (node.return) {
            node = node.return;
          }
        }

        if (node.tag === HostRoot) {
          return MOUNTED;
        }

        return UNMOUNTED;
      }

      function isFiberMounted(fiber) {
        return isFiberMountedImpl(fiber) === MOUNTED;
      }

      function isMounted(component) {
        {
          var owner = ReactCurrentOwner$1.current;

          if (owner !== null && owner.tag === ClassComponent) {
            var ownerFiber = owner;
            var instance = ownerFiber.stateNode;
            !instance._warnedAboutRefsInRender ? warningWithoutStack$1(false, "%s is accessing isMounted inside its render() function. " + "render() should be a pure function of props and state. It should " + "never access something that requires stale data from the previous " + "render, such as refs. Move this logic to componentDidMount and " + "componentDidUpdate instead.", getComponentName(ownerFiber.type) || "A component") : void 0;
            instance._warnedAboutRefsInRender = true;
          }
        }
        var fiber = get$1(component);

        if (!fiber) {
          return false;
        }

        return isFiberMountedImpl(fiber) === MOUNTED;
      }

      function assertIsMounted(fiber) {
        invariant(isFiberMountedImpl(fiber) === MOUNTED, "Unable to find node on an unmounted component.");
      }

      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;

        if (!alternate) {
          var state = isFiberMountedImpl(fiber);
          invariant(state !== UNMOUNTED, "Unable to find node on an unmounted component.");

          if (state === MOUNTING) {
            return null;
          }

          return fiber;
        }

        var a = fiber;
        var b = alternate;

        while (true) {
          var parentA = a.return;
          var parentB = parentA ? parentA.alternate : null;

          if (!parentA || !parentB) {
            break;
          }

          if (parentA.child === parentB.child) {
            var child = parentA.child;

            while (child) {
              if (child === a) {
                assertIsMounted(parentA);
                return fiber;
              }

              if (child === b) {
                assertIsMounted(parentA);
                return alternate;
              }

              child = child.sibling;
            }

            invariant(false, "Unable to find node on an unmounted component.");
          }

          if (a.return !== b.return) {
            a = parentA;
            b = parentB;
          } else {
            var didFindChild = false;
            var _child = parentA.child;

            while (_child) {
              if (_child === a) {
                didFindChild = true;
                a = parentA;
                b = parentB;
                break;
              }

              if (_child === b) {
                didFindChild = true;
                b = parentA;
                a = parentB;
                break;
              }

              _child = _child.sibling;
            }

            if (!didFindChild) {
              _child = parentB.child;

              while (_child) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentB;
                  b = parentA;
                  break;
                }

                if (_child === b) {
                  didFindChild = true;
                  b = parentB;
                  a = parentA;
                  break;
                }

                _child = _child.sibling;
              }

              invariant(didFindChild, "Child was not found in either parent set. This indicates a bug " + "in React related to the return pointer. Please file an issue.");
            }
          }

          invariant(a.alternate === b, "Return fibers should always be each others' alternates. " + "This error is likely caused by a bug in React. Please file an issue.");
        }

        invariant(a.tag === HostRoot, "Unable to find node on an unmounted component.");

        if (a.stateNode.current === a) {
          return fiber;
        }

        return alternate;
      }

      function findCurrentHostFiber(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);

        if (!currentParent) {
          return null;
        }

        var node = currentParent;

        while (true) {
          if (node.tag === HostComponent || node.tag === HostText) {
            return node;
          } else if (node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }

          if (node === currentParent) {
            return null;
          }

          while (!node.sibling) {
            if (!node.return || node.return === currentParent) {
              return null;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }

        return null;
      }

      function mountSafeCallback_NOT_REALLY_SAFE(context, callback) {
        return function () {
          if (!callback) {
            return undefined;
          }

          if (typeof context.__isMounted === "boolean") {
            if (!context.__isMounted) {
              return undefined;
            }
          }

          return callback.apply(context, arguments);
        };
      }

      function throwOnStylesProp(component, props) {
        if (props.styles !== undefined) {
          var owner = component._owner || null;
          var name = component.constructor.displayName;
          var msg = "`styles` is not a supported property of `" + name + "`, did " + "you mean `style` (singular)?";

          if (owner && owner.constructor && owner.constructor.displayName) {
            msg += "\n\nCheck the `" + owner.constructor.displayName + "` parent " + " component.";
          }

          throw new Error(msg);
        }
      }

      function warnForStyleProps(props, validAttributes) {
        for (var key in validAttributes.style) {
          if (!(validAttributes[key] || props[key] === undefined)) {
            console.error("You are setting the style `{ " + key + ": ... }` as a prop. You " + "should nest it in a style object. " + "E.g. `{ style: { " + key + ": ... } }`");
          }
        }
      }

      var emptyObject = {};
      var removedKeys = null;
      var removedKeyCount = 0;

      function defaultDiffer(prevProp, nextProp) {
        if (typeof nextProp !== "object" || nextProp === null) {
          return true;
        } else {
          return deepDiffer(prevProp, nextProp);
        }
      }

      function restoreDeletedValuesInNestedArray(updatePayload, node, validAttributes) {
        if (Array.isArray(node)) {
          var i = node.length;

          while (i-- && removedKeyCount > 0) {
            restoreDeletedValuesInNestedArray(updatePayload, node[i], validAttributes);
          }
        } else if (node && removedKeyCount > 0) {
          var obj = node;

          for (var propKey in removedKeys) {
            if (!removedKeys[propKey]) {
              continue;
            }

            var nextProp = obj[propKey];

            if (nextProp === undefined) {
              continue;
            }

            var attributeConfig = validAttributes[propKey];

            if (!attributeConfig) {
              continue;
            }

            if (typeof nextProp === "function") {
              nextProp = true;
            }

            if (typeof nextProp === "undefined") {
              nextProp = null;
            }

            if (typeof attributeConfig !== "object") {
              updatePayload[propKey] = nextProp;
            } else if (typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
              var nextValue = typeof attributeConfig.process === "function" ? attributeConfig.process(nextProp) : nextProp;
              updatePayload[propKey] = nextValue;
            }

            removedKeys[propKey] = false;
            removedKeyCount--;
          }
        }
      }

      function diffNestedArrayProperty(updatePayload, prevArray, nextArray, validAttributes) {
        var minLength = prevArray.length < nextArray.length ? prevArray.length : nextArray.length;
        var i = void 0;

        for (i = 0; i < minLength; i++) {
          updatePayload = diffNestedProperty(updatePayload, prevArray[i], nextArray[i], validAttributes);
        }

        for (; i < prevArray.length; i++) {
          updatePayload = clearNestedProperty(updatePayload, prevArray[i], validAttributes);
        }

        for (; i < nextArray.length; i++) {
          updatePayload = addNestedProperty(updatePayload, nextArray[i], validAttributes);
        }

        return updatePayload;
      }

      function diffNestedProperty(updatePayload, prevProp, nextProp, validAttributes) {
        if (!updatePayload && prevProp === nextProp) {
          return updatePayload;
        }

        if (!prevProp || !nextProp) {
          if (nextProp) {
            return addNestedProperty(updatePayload, nextProp, validAttributes);
          }

          if (prevProp) {
            return clearNestedProperty(updatePayload, prevProp, validAttributes);
          }

          return updatePayload;
        }

        if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) {
          return diffProperties(updatePayload, prevProp, nextProp, validAttributes);
        }

        if (Array.isArray(prevProp) && Array.isArray(nextProp)) {
          return diffNestedArrayProperty(updatePayload, prevProp, nextProp, validAttributes);
        }

        if (Array.isArray(prevProp)) {
          return diffProperties(updatePayload, flattenStyle(prevProp), nextProp, validAttributes);
        }

        return diffProperties(updatePayload, prevProp, flattenStyle(nextProp), validAttributes);
      }

      function addNestedProperty(updatePayload, nextProp, validAttributes) {
        if (!nextProp) {
          return updatePayload;
        }

        if (!Array.isArray(nextProp)) {
          return addProperties(updatePayload, nextProp, validAttributes);
        }

        for (var i = 0; i < nextProp.length; i++) {
          updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);
        }

        return updatePayload;
      }

      function clearNestedProperty(updatePayload, prevProp, validAttributes) {
        if (!prevProp) {
          return updatePayload;
        }

        if (!Array.isArray(prevProp)) {
          return clearProperties(updatePayload, prevProp, validAttributes);
        }

        for (var i = 0; i < prevProp.length; i++) {
          updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);
        }

        return updatePayload;
      }

      function diffProperties(updatePayload, prevProps, nextProps, validAttributes) {
        var attributeConfig = void 0;
        var nextProp = void 0;
        var prevProp = void 0;

        for (var propKey in nextProps) {
          attributeConfig = validAttributes[propKey];

          if (!attributeConfig) {
            continue;
          }

          prevProp = prevProps[propKey];
          nextProp = nextProps[propKey];

          if (typeof nextProp === "function") {
            nextProp = true;

            if (typeof prevProp === "function") {
              prevProp = true;
            }
          }

          if (typeof nextProp === "undefined") {
            nextProp = null;

            if (typeof prevProp === "undefined") {
              prevProp = null;
            }
          }

          if (removedKeys) {
            removedKeys[propKey] = false;
          }

          if (updatePayload && updatePayload[propKey] !== undefined) {
            if (typeof attributeConfig !== "object") {
              updatePayload[propKey] = nextProp;
            } else if (typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
              var nextValue = typeof attributeConfig.process === "function" ? attributeConfig.process(nextProp) : nextProp;
              updatePayload[propKey] = nextValue;
            }

            continue;
          }

          if (prevProp === nextProp) {
            continue;
          }

          if (typeof attributeConfig !== "object") {
            if (defaultDiffer(prevProp, nextProp)) {
              (updatePayload || (updatePayload = {}))[propKey] = nextProp;
            }
          } else if (typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
            var shouldUpdate = prevProp === undefined || (typeof attributeConfig.diff === "function" ? attributeConfig.diff(prevProp, nextProp) : defaultDiffer(prevProp, nextProp));

            if (shouldUpdate) {
              var _nextValue = typeof attributeConfig.process === "function" ? attributeConfig.process(nextProp) : nextProp;

              (updatePayload || (updatePayload = {}))[propKey] = _nextValue;
            }
          } else {
            removedKeys = null;
            removedKeyCount = 0;
            updatePayload = diffNestedProperty(updatePayload, prevProp, nextProp, attributeConfig);

            if (removedKeyCount > 0 && updatePayload) {
              restoreDeletedValuesInNestedArray(updatePayload, nextProp, attributeConfig);
              removedKeys = null;
            }
          }
        }

        for (var _propKey in prevProps) {
          if (nextProps[_propKey] !== undefined) {
            continue;
          }

          attributeConfig = validAttributes[_propKey];

          if (!attributeConfig) {
            continue;
          }

          if (updatePayload && updatePayload[_propKey] !== undefined) {
            continue;
          }

          prevProp = prevProps[_propKey];

          if (prevProp === undefined) {
            continue;
          }

          if (typeof attributeConfig !== "object" || typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
            (updatePayload || (updatePayload = {}))[_propKey] = null;

            if (!removedKeys) {
              removedKeys = {};
            }

            if (!removedKeys[_propKey]) {
              removedKeys[_propKey] = true;
              removedKeyCount++;
            }
          } else {
            updatePayload = clearNestedProperty(updatePayload, prevProp, attributeConfig);
          }
        }

        return updatePayload;
      }

      function addProperties(updatePayload, props, validAttributes) {
        return diffProperties(updatePayload, emptyObject, props, validAttributes);
      }

      function clearProperties(updatePayload, prevProps, validAttributes) {
        return diffProperties(updatePayload, prevProps, emptyObject, validAttributes);
      }

      function create(props, validAttributes) {
        return addProperties(null, props, validAttributes);
      }

      function diff(prevProps, nextProps, validAttributes) {
        return diffProperties(null, prevProps, nextProps, validAttributes);
      }

      var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
      var now$1 = hasNativePerformanceNow ? function () {
        return performance.now();
      } : function () {
        return Date.now();
      };
      var scheduledCallback = null;
      var frameDeadline = 0;

      function setTimeoutCallback() {
        frameDeadline = now$1() + 5;
        var callback = scheduledCallback;
        scheduledCallback = null;

        if (callback !== null) {
          callback();
        }
      }

      function scheduleDeferredCallback$1(callback, options) {
        scheduledCallback = callback;
        var timeoutId = setTimeout(setTimeoutCallback, 1);
        return timeoutId;
      }

      function cancelDeferredCallback$1(callbackID) {
        scheduledCallback = null;
        clearTimeout(callbackID);
      }

      function shouldYield$1() {
        return frameDeadline <= now$1();
      }

      var restoreImpl = null;
      var restoreTarget = null;
      var restoreQueue = null;

      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);

        if (!internalInstance) {
          return;
        }

        invariant(typeof restoreImpl === "function", "setRestoreImplementation() needs to be called to handle a target for controlled " + "events. This error is likely caused by a bug in React. Please file an issue.");
        var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
        restoreImpl(internalInstance.stateNode, internalInstance.type, props);
      }

      function needsStateRestore() {
        return restoreTarget !== null || restoreQueue !== null;
      }

      function restoreStateIfNeeded() {
        if (!restoreTarget) {
          return;
        }

        var target = restoreTarget;
        var queuedTargets = restoreQueue;
        restoreTarget = null;
        restoreQueue = null;
        restoreStateOfTarget(target);

        if (queuedTargets) {
          for (var i = 0; i < queuedTargets.length; i++) {
            restoreStateOfTarget(queuedTargets[i]);
          }
        }
      }

      var _batchedUpdatesImpl = function _batchedUpdatesImpl(fn, bookkeeping) {
        return fn(bookkeeping);
      };

      var _flushInteractiveUpdatesImpl = function _flushInteractiveUpdatesImpl() {};

      var isBatching = false;

      function batchedUpdates(fn, bookkeeping) {
        if (isBatching) {
          return fn(bookkeeping);
        }

        isBatching = true;

        try {
          return _batchedUpdatesImpl(fn, bookkeeping);
        } finally {
          isBatching = false;
          var controlledComponentsHavePendingUpdates = needsStateRestore();

          if (controlledComponentsHavePendingUpdates) {
            _flushInteractiveUpdatesImpl();

            restoreStateIfNeeded();
          }
        }
      }

      function setBatchingImplementation(batchedUpdatesImpl, interactiveUpdatesImpl, flushInteractiveUpdatesImpl) {
        _batchedUpdatesImpl = batchedUpdatesImpl;
        _flushInteractiveUpdatesImpl = flushInteractiveUpdatesImpl;
      }

      function dispatchEvent(target, topLevelType, nativeEvent) {
        var targetFiber = target;
        batchedUpdates(function () {
          runExtractedEventsInBatch(topLevelType, targetFiber, nativeEvent, nativeEvent.target);
        });
      }

      function shim() {
        invariant(false, "The current renderer does not support mutation. " + "This error is likely caused by a bug in React. " + "Please file an issue.");
      }

      var supportsMutation = false;
      var appendChild$1 = shim;
      var appendChildToContainer = shim;
      var commitTextUpdate = shim;
      var commitMount = shim;
      var commitUpdate = shim;
      var insertBefore = shim;
      var insertInContainerBefore = shim;
      var removeChild = shim;
      var removeChildFromContainer = shim;
      var resetTextContent = shim;
      var hideInstance = shim;
      var hideTextInstance = shim;
      var unhideInstance = shim;
      var unhideTextInstance = shim;

      function shim$1() {
        invariant(false, "The current renderer does not support hyration. " + "This error is likely caused by a bug in React. " + "Please file an issue.");
      }

      var supportsHydration = false;
      var canHydrateInstance = shim$1;
      var canHydrateTextInstance = shim$1;
      var getNextHydratableSibling = shim$1;
      var getFirstHydratableChild = shim$1;
      var hydrateInstance = shim$1;
      var hydrateTextInstance = shim$1;
      var didNotMatchHydratedContainerTextInstance = shim$1;
      var didNotMatchHydratedTextInstance = shim$1;
      var didNotHydrateContainerInstance = shim$1;
      var didNotHydrateInstance = shim$1;
      var didNotFindHydratableContainerInstance = shim$1;
      var didNotFindHydratableContainerTextInstance = shim$1;
      var didNotFindHydratableInstance = shim$1;
      var didNotFindHydratableTextInstance = shim$1;

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var nextReactTag = 2;

      if (FabricUIManager.registerEventHandler) {
        FabricUIManager.registerEventHandler(dispatchEvent);
      }

      var ReactFabricHostComponent = function () {
        function ReactFabricHostComponent(tag, viewConfig, props) {
          _classCallCheck(this, ReactFabricHostComponent);

          this._nativeTag = tag;
          this.viewConfig = viewConfig;
          this.currentProps = props;
        }

        ReactFabricHostComponent.prototype.blur = function blur() {
          TextInputState.blurTextInput(this._nativeTag);
        };

        ReactFabricHostComponent.prototype.focus = function focus() {
          TextInputState.focusTextInput(this._nativeTag);
        };

        ReactFabricHostComponent.prototype.measure = function measure(callback) {
          UIManager.measure(this._nativeTag, mountSafeCallback_NOT_REALLY_SAFE(this, callback));
        };

        ReactFabricHostComponent.prototype.measureInWindow = function measureInWindow(callback) {
          UIManager.measureInWindow(this._nativeTag, mountSafeCallback_NOT_REALLY_SAFE(this, callback));
        };

        ReactFabricHostComponent.prototype.measureLayout = function measureLayout(relativeToNativeNode, onSuccess, onFail) {
          UIManager.measureLayout(this._nativeTag, relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
        };

        ReactFabricHostComponent.prototype.setNativeProps = function setNativeProps(nativeProps) {
          {
            warnForStyleProps(nativeProps, this.viewConfig.validAttributes);
          }
          var updatePayload = create(nativeProps, this.viewConfig.validAttributes);

          if (updatePayload != null) {
            UIManager.updateView(this._nativeTag, this.viewConfig.uiViewClassName, updatePayload);
          }
        };

        return ReactFabricHostComponent;
      }();

      function appendInitialChild(parentInstance, child) {
        FabricUIManager.appendChild(parentInstance.node, child.node);
      }

      function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
        var tag = nextReactTag;
        nextReactTag += 2;
        var viewConfig = ReactNativeViewConfigRegistry.get(type);
        {
          for (var key in viewConfig.validAttributes) {
            if (props.hasOwnProperty(key)) {
              deepFreezeAndThrowOnMutationInDev(props[key]);
            }
          }
        }
        invariant(type !== "RCTView" || !hostContext.isInAParentText, "Nesting of <View> within <Text> is not currently supported.");
        var updatePayload = create(props, viewConfig.validAttributes);
        var node = FabricUIManager.createNode(tag, viewConfig.uiViewClassName, rootContainerInstance, updatePayload, internalInstanceHandle);
        var component = new ReactFabricHostComponent(tag, viewConfig, props);
        return {
          node: node,
          canonical: component
        };
      }

      function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
        invariant(hostContext.isInAParentText, "Text strings must be rendered within a <Text> component.");
        var tag = nextReactTag;
        nextReactTag += 2;
        var node = FabricUIManager.createNode(tag, "RCTRawText", rootContainerInstance, {
          text: text
        }, internalInstanceHandle);
        return {
          node: node
        };
      }

      function finalizeInitialChildren(parentInstance, type, props, rootContainerInstance, hostContext) {
        return false;
      }

      function getRootHostContext(rootContainerInstance) {
        return {
          isInAParentText: false
        };
      }

      function getChildHostContext(parentHostContext, type, rootContainerInstance) {
        var prevIsInAParentText = parentHostContext.isInAParentText;
        var isInAParentText = type === "AndroidTextInput" || type === "RCTMultilineTextInputView" || type === "RCTSinglelineTextInputView" || type === "RCTText" || type === "RCTVirtualText";

        if (prevIsInAParentText !== isInAParentText) {
          return {
            isInAParentText: isInAParentText
          };
        } else {
          return parentHostContext;
        }
      }

      function getPublicInstance(instance) {
        return instance.canonical;
      }

      function prepareForCommit(containerInfo) {}

      function prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, hostContext) {
        var viewConfig = instance.canonical.viewConfig;
        var updatePayload = diff(oldProps, newProps, viewConfig.validAttributes);
        instance.canonical.currentProps = newProps;
        return updatePayload;
      }

      function resetAfterCommit(containerInfo) {}

      function shouldDeprioritizeSubtree(type, props) {
        return false;
      }

      function shouldSetTextContent(type, props) {
        return false;
      }

      var isPrimaryRenderer = false;
      var now = now$1;
      var scheduleDeferredCallback = scheduleDeferredCallback$1;
      var cancelDeferredCallback = cancelDeferredCallback$1;
      var shouldYield = shouldYield$1;
      var scheduleTimeout = setTimeout;
      var cancelTimeout = clearTimeout;
      var noTimeout = -1;
      var supportsPersistence = true;

      function cloneInstance(instance, updatePayload, type, oldProps, newProps, internalInstanceHandle, keepChildren, recyclableInstance) {
        var node = instance.node;
        var clone = void 0;

        if (keepChildren) {
          if (updatePayload !== null) {
            clone = FabricUIManager.cloneNodeWithNewProps(node, updatePayload);
          } else {
            clone = FabricUIManager.cloneNode(node);
          }
        } else {
          if (updatePayload !== null) {
            clone = FabricUIManager.cloneNodeWithNewChildrenAndProps(node, updatePayload);
          } else {
            clone = FabricUIManager.cloneNodeWithNewChildren(node);
          }
        }

        return {
          node: clone,
          canonical: instance.canonical
        };
      }

      function cloneHiddenInstance(instance, type, props, internalInstanceHandle) {
        var viewConfig = instance.canonical.viewConfig;
        var node = instance.node;
        var updatePayload = create({
          style: {
            display: "none"
          }
        }, viewConfig.validAttributes);
        return {
          node: FabricUIManager.cloneNodeWithNewProps(node, updatePayload),
          canonical: instance.canonical
        };
      }

      function cloneUnhiddenInstance(instance, type, props, internalInstanceHandle) {
        var viewConfig = instance.canonical.viewConfig;
        var node = instance.node;
        var updatePayload = diff(_extends({}, props, {
          style: [props.style, {
            display: "none"
          }]
        }), props, viewConfig.validAttributes);
        return {
          node: FabricUIManager.cloneNodeWithNewProps(node, updatePayload),
          canonical: instance.canonical
        };
      }

      function createHiddenTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
        throw new Error("Not yet implemented.");
      }

      function createContainerChildSet(container) {
        return FabricUIManager.createChildSet(container);
      }

      function appendChildToContainerChildSet(childSet, child) {
        FabricUIManager.appendChildToSet(childSet, child.node);
      }

      function finalizeContainerChildren(container, newChildren) {
        FabricUIManager.completeRoot(container, newChildren);
      }

      var BEFORE_SLASH_RE = /^(.*)[\\\/]/;

      var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
        var sourceInfo = "";

        if (source) {
          var path = source.fileName;
          var fileName = path.replace(BEFORE_SLASH_RE, "");
          {
            if (/^index\./.test(fileName)) {
              var match = path.match(BEFORE_SLASH_RE);

              if (match) {
                var pathBeforeSlash = match[1];

                if (pathBeforeSlash) {
                  var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, "");
                  fileName = folderName + "/" + fileName;
                }
              }
            }
          }
          sourceInfo = " (at " + fileName + ":" + source.lineNumber + ")";
        } else if (ownerName) {
          sourceInfo = " (created by " + ownerName + ")";
        }

        return "\n    in " + (name || "Unknown") + sourceInfo;
      };

      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

      function describeFiber(fiber) {
        switch (fiber.tag) {
          case IndeterminateComponent:
          case LazyComponent:
          case FunctionComponent:
          case ClassComponent:
          case HostComponent:
          case Mode:
          case SuspenseComponent:
            var owner = fiber._debugOwner;
            var source = fiber._debugSource;
            var name = getComponentName(fiber.type);
            var ownerName = null;

            if (owner) {
              ownerName = getComponentName(owner.type);
            }

            return describeComponentFrame(name, source, ownerName);

          default:
            return "";
        }
      }

      function getStackByFiberInDevAndProd(workInProgress) {
        var info = "";
        var node = workInProgress;

        do {
          info += describeFiber(node);
          node = node.return;
        } while (node);

        return info;
      }

      var current = null;
      var phase = null;

      function getCurrentFiberOwnerNameInDevOrNull() {
        {
          if (current === null) {
            return null;
          }

          var owner = current._debugOwner;

          if (owner !== null && typeof owner !== "undefined") {
            return getComponentName(owner.type);
          }
        }
        return null;
      }

      function getCurrentFiberStackInDev() {
        {
          if (current === null) {
            return "";
          }

          return getStackByFiberInDevAndProd(current);
        }
        return "";
      }

      function resetCurrentFiber() {
        {
          ReactDebugCurrentFrame.getCurrentStack = null;
          current = null;
          phase = null;
        }
      }

      function setCurrentFiber(fiber) {
        {
          ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
          current = fiber;
          phase = null;
        }
      }

      function setCurrentPhase(lifeCyclePhase) {
        {
          phase = lifeCyclePhase;
        }
      }

      var debugRenderPhaseSideEffects = false;
      var debugRenderPhaseSideEffectsForStrictMode = false;
      var enableUserTimingAPI = true;
      var enableHooks = false;
      var warnAboutDeprecatedLifecycles = false;
      var replayFailedUnitOfWorkWithInvokeGuardedCallback = true;
      var enableProfilerTimer = true;
      var enableSchedulerTracing = true;
      var reactEmoji = "\u269B";
      var warningEmoji = "\u26D4";
      var supportsUserTiming = typeof performance !== "undefined" && typeof performance.mark === "function" && typeof performance.clearMarks === "function" && typeof performance.measure === "function" && typeof performance.clearMeasures === "function";
      var currentFiber = null;
      var currentPhase = null;
      var currentPhaseFiber = null;
      var isCommitting = false;
      var hasScheduledUpdateInCurrentCommit = false;
      var hasScheduledUpdateInCurrentPhase = false;
      var commitCountInCurrentWorkLoop = 0;
      var effectCountInCurrentCommit = 0;
      var isWaitingForCallback = false;
      var labelsInCurrentCommit = new Set();

      var formatMarkName = function formatMarkName(markName) {
        return reactEmoji + " " + markName;
      };

      var formatLabel = function formatLabel(label, warning) {
        var prefix = warning ? warningEmoji + " " : reactEmoji + " ";
        var suffix = warning ? " Warning: " + warning : "";
        return "" + prefix + label + suffix;
      };

      var beginMark = function beginMark(markName) {
        performance.mark(formatMarkName(markName));
      };

      var clearMark = function clearMark(markName) {
        performance.clearMarks(formatMarkName(markName));
      };

      var endMark = function endMark(label, markName, warning) {
        var formattedMarkName = formatMarkName(markName);
        var formattedLabel = formatLabel(label, warning);

        try {
          performance.measure(formattedLabel, formattedMarkName);
        } catch (err) {}

        performance.clearMarks(formattedMarkName);
        performance.clearMeasures(formattedLabel);
      };

      var getFiberMarkName = function getFiberMarkName(label, debugID) {
        return label + " (#" + debugID + ")";
      };

      var getFiberLabel = function getFiberLabel(componentName, isMounted, phase) {
        if (phase === null) {
          return componentName + " [" + (isMounted ? "update" : "mount") + "]";
        } else {
          return componentName + "." + phase;
        }
      };

      var beginFiberMark = function beginFiberMark(fiber, phase) {
        var componentName = getComponentName(fiber.type) || "Unknown";
        var debugID = fiber._debugID;
        var isMounted = fiber.alternate !== null;
        var label = getFiberLabel(componentName, isMounted, phase);

        if (isCommitting && labelsInCurrentCommit.has(label)) {
          return false;
        }

        labelsInCurrentCommit.add(label);
        var markName = getFiberMarkName(label, debugID);
        beginMark(markName);
        return true;
      };

      var clearFiberMark = function clearFiberMark(fiber, phase) {
        var componentName = getComponentName(fiber.type) || "Unknown";
        var debugID = fiber._debugID;
        var isMounted = fiber.alternate !== null;
        var label = getFiberLabel(componentName, isMounted, phase);
        var markName = getFiberMarkName(label, debugID);
        clearMark(markName);
      };

      var endFiberMark = function endFiberMark(fiber, phase, warning) {
        var componentName = getComponentName(fiber.type) || "Unknown";
        var debugID = fiber._debugID;
        var isMounted = fiber.alternate !== null;
        var label = getFiberLabel(componentName, isMounted, phase);
        var markName = getFiberMarkName(label, debugID);
        endMark(label, markName, warning);
      };

      var shouldIgnoreFiber = function shouldIgnoreFiber(fiber) {
        switch (fiber.tag) {
          case HostRoot:
          case HostComponent:
          case HostText:
          case HostPortal:
          case Fragment:
          case ContextProvider:
          case ContextConsumer:
          case Mode:
            return true;

          default:
            return false;
        }
      };

      var clearPendingPhaseMeasurement = function clearPendingPhaseMeasurement() {
        if (currentPhase !== null && currentPhaseFiber !== null) {
          clearFiberMark(currentPhaseFiber, currentPhase);
        }

        currentPhaseFiber = null;
        currentPhase = null;
        hasScheduledUpdateInCurrentPhase = false;
      };

      var pauseTimers = function pauseTimers() {
        var fiber = currentFiber;

        while (fiber) {
          if (fiber._debugIsCurrentlyTiming) {
            endFiberMark(fiber, null, null);
          }

          fiber = fiber.return;
        }
      };

      var resumeTimersRecursively = function resumeTimersRecursively(fiber) {
        if (fiber.return !== null) {
          resumeTimersRecursively(fiber.return);
        }

        if (fiber._debugIsCurrentlyTiming) {
          beginFiberMark(fiber, null);
        }
      };

      var resumeTimers = function resumeTimers() {
        if (currentFiber !== null) {
          resumeTimersRecursively(currentFiber);
        }
      };

      function recordEffect() {
        if (enableUserTimingAPI) {
          effectCountInCurrentCommit++;
        }
      }

      function recordScheduleUpdate() {
        if (enableUserTimingAPI) {
          if (isCommitting) {
            hasScheduledUpdateInCurrentCommit = true;
          }

          if (currentPhase !== null && currentPhase !== "componentWillMount" && currentPhase !== "componentWillReceiveProps") {
            hasScheduledUpdateInCurrentPhase = true;
          }
        }
      }

      function startRequestCallbackTimer() {
        if (enableUserTimingAPI) {
          if (supportsUserTiming && !isWaitingForCallback) {
            isWaitingForCallback = true;
            beginMark("(Waiting for async callback...)");
          }
        }
      }

      function stopRequestCallbackTimer(didExpire, expirationTime) {
        if (enableUserTimingAPI) {
          if (supportsUserTiming) {
            isWaitingForCallback = false;
            var warning = didExpire ? "React was blocked by main thread" : null;
            endMark("(Waiting for async callback... will force flush in " + expirationTime + " ms)", "(Waiting for async callback...)", warning);
          }
        }
      }

      function startWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          currentFiber = fiber;

          if (!beginFiberMark(fiber, null)) {
            return;
          }

          fiber._debugIsCurrentlyTiming = true;
        }
      }

      function cancelWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          fiber._debugIsCurrentlyTiming = false;
          clearFiberMark(fiber, null);
        }
      }

      function stopWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          currentFiber = fiber.return;

          if (!fiber._debugIsCurrentlyTiming) {
            return;
          }

          fiber._debugIsCurrentlyTiming = false;
          endFiberMark(fiber, null, null);
        }
      }

      function stopFailedWorkTimer(fiber) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
            return;
          }

          currentFiber = fiber.return;

          if (!fiber._debugIsCurrentlyTiming) {
            return;
          }

          fiber._debugIsCurrentlyTiming = false;
          var warning = fiber.tag === SuspenseComponent ? "Rendering was suspended" : "An error was thrown inside this error boundary";
          endFiberMark(fiber, null, warning);
        }
      }

      function startPhaseTimer(fiber, phase) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          clearPendingPhaseMeasurement();

          if (!beginFiberMark(fiber, phase)) {
            return;
          }

          currentPhaseFiber = fiber;
          currentPhase = phase;
        }
      }

      function stopPhaseTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          if (currentPhase !== null && currentPhaseFiber !== null) {
            var warning = hasScheduledUpdateInCurrentPhase ? "Scheduled a cascading update" : null;
            endFiberMark(currentPhaseFiber, currentPhase, warning);
          }

          currentPhase = null;
          currentPhaseFiber = null;
        }
      }

      function startWorkLoopTimer(nextUnitOfWork) {
        if (enableUserTimingAPI) {
          currentFiber = nextUnitOfWork;

          if (!supportsUserTiming) {
            return;
          }

          commitCountInCurrentWorkLoop = 0;
          beginMark("(React Tree Reconciliation)");
          resumeTimers();
        }
      }

      function stopWorkLoopTimer(interruptedBy, didCompleteRoot) {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var warning = null;

          if (interruptedBy !== null) {
            if (interruptedBy.tag === HostRoot) {
              warning = "A top-level update interrupted the previous render";
            } else {
              var componentName = getComponentName(interruptedBy.type) || "Unknown";
              warning = "An update to " + componentName + " interrupted the previous render";
            }
          } else if (commitCountInCurrentWorkLoop > 1) {
            warning = "There were cascading updates";
          }

          commitCountInCurrentWorkLoop = 0;
          var label = didCompleteRoot ? "(React Tree Reconciliation: Completed Root)" : "(React Tree Reconciliation: Yielded)";
          pauseTimers();
          endMark(label, "(React Tree Reconciliation)", warning);
        }
      }

      function startCommitTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          isCommitting = true;
          hasScheduledUpdateInCurrentCommit = false;
          labelsInCurrentCommit.clear();
          beginMark("(Committing Changes)");
        }
      }

      function stopCommitTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var warning = null;

          if (hasScheduledUpdateInCurrentCommit) {
            warning = "Lifecycle hook scheduled a cascading update";
          } else if (commitCountInCurrentWorkLoop > 0) {
            warning = "Caused by a cascading update in earlier commit";
          }

          hasScheduledUpdateInCurrentCommit = false;
          commitCountInCurrentWorkLoop++;
          isCommitting = false;
          labelsInCurrentCommit.clear();
          endMark("(Committing Changes)", "(Committing Changes)", warning);
        }
      }

      function startCommitSnapshotEffectsTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          effectCountInCurrentCommit = 0;
          beginMark("(Committing Snapshot Effects)");
        }
      }

      function stopCommitSnapshotEffectsTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var count = effectCountInCurrentCommit;
          effectCountInCurrentCommit = 0;
          endMark("(Committing Snapshot Effects: " + count + " Total)", "(Committing Snapshot Effects)", null);
        }
      }

      function startCommitHostEffectsTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          effectCountInCurrentCommit = 0;
          beginMark("(Committing Host Effects)");
        }
      }

      function stopCommitHostEffectsTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var count = effectCountInCurrentCommit;
          effectCountInCurrentCommit = 0;
          endMark("(Committing Host Effects: " + count + " Total)", "(Committing Host Effects)", null);
        }
      }

      function startCommitLifeCyclesTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          effectCountInCurrentCommit = 0;
          beginMark("(Calling Lifecycle Methods)");
        }
      }

      function stopCommitLifeCyclesTimer() {
        if (enableUserTimingAPI) {
          if (!supportsUserTiming) {
            return;
          }

          var count = effectCountInCurrentCommit;
          effectCountInCurrentCommit = 0;
          endMark("(Calling Lifecycle Methods: " + count + " Total)", "(Calling Lifecycle Methods)", null);
        }
      }

      var valueStack = [];
      var fiberStack = void 0;
      {
        fiberStack = [];
      }
      var index = -1;

      function createCursor(defaultValue) {
        return {
          current: defaultValue
        };
      }

      function pop(cursor, fiber) {
        if (index < 0) {
          {
            warningWithoutStack$1(false, "Unexpected pop.");
          }
          return;
        }

        {
          if (fiber !== fiberStack[index]) {
            warningWithoutStack$1(false, "Unexpected Fiber popped.");
          }
        }
        cursor.current = valueStack[index];
        valueStack[index] = null;
        {
          fiberStack[index] = null;
        }
        index--;
      }

      function push(cursor, value, fiber) {
        index++;
        valueStack[index] = cursor.current;
        {
          fiberStack[index] = fiber;
        }
        cursor.current = value;
      }

      function checkThatStackIsEmpty() {
        {
          if (index !== -1) {
            warningWithoutStack$1(false, "Expected an empty stack. Something was not reset properly.");
          }
        }
      }

      function resetStackAfterFatalErrorInDev() {
        {
          index = -1;
          valueStack.length = 0;
          fiberStack.length = 0;
        }
      }

      var warnedAboutMissingGetChildContext = void 0;
      {
        warnedAboutMissingGetChildContext = {};
      }
      var emptyContextObject = {};
      {
        Object.freeze(emptyContextObject);
      }
      var contextStackCursor = createCursor(emptyContextObject);
      var didPerformWorkStackCursor = createCursor(false);
      var previousContext = emptyContextObject;

      function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {
        if (didPushOwnContextIfProvider && isContextProvider(Component)) {
          return previousContext;
        }

        return contextStackCursor.current;
      }

      function cacheContext(workInProgress, unmaskedContext, maskedContext) {
        var instance = workInProgress.stateNode;
        instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
        instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
      }

      function getMaskedContext(workInProgress, unmaskedContext) {
        var type = workInProgress.type;
        var contextTypes = type.contextTypes;

        if (!contextTypes) {
          return emptyContextObject;
        }

        var instance = workInProgress.stateNode;

        if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
          return instance.__reactInternalMemoizedMaskedChildContext;
        }

        var context = {};

        for (var key in contextTypes) {
          context[key] = unmaskedContext[key];
        }

        {
          var name = getComponentName(type) || "Unknown";
          checkPropTypes(contextTypes, context, "context", name, getCurrentFiberStackInDev);
        }

        if (instance) {
          cacheContext(workInProgress, unmaskedContext, context);
        }

        return context;
      }

      function hasContextChanged() {
        return didPerformWorkStackCursor.current;
      }

      function isContextProvider(type) {
        var childContextTypes = type.childContextTypes;
        return childContextTypes !== null && childContextTypes !== undefined;
      }

      function popContext(fiber) {
        pop(didPerformWorkStackCursor, fiber);
        pop(contextStackCursor, fiber);
      }

      function popTopLevelContextObject(fiber) {
        pop(didPerformWorkStackCursor, fiber);
        pop(contextStackCursor, fiber);
      }

      function pushTopLevelContextObject(fiber, context, didChange) {
        invariant(contextStackCursor.current === emptyContextObject, "Unexpected context found on stack. " + "This error is likely caused by a bug in React. Please file an issue.");
        push(contextStackCursor, context, fiber);
        push(didPerformWorkStackCursor, didChange, fiber);
      }

      function processChildContext(fiber, type, parentContext) {
        var instance = fiber.stateNode;
        var childContextTypes = type.childContextTypes;

        if (typeof instance.getChildContext !== "function") {
          {
            var componentName = getComponentName(type) || "Unknown";

            if (!warnedAboutMissingGetChildContext[componentName]) {
              warnedAboutMissingGetChildContext[componentName] = true;
              warningWithoutStack$1(false, "%s.childContextTypes is specified but there is no getChildContext() method " + "on the instance. You can either define getChildContext() on %s or remove " + "childContextTypes from it.", componentName, componentName);
            }
          }
          return parentContext;
        }

        var childContext = void 0;
        {
          setCurrentPhase("getChildContext");
        }
        startPhaseTimer(fiber, "getChildContext");
        childContext = instance.getChildContext();
        stopPhaseTimer();
        {
          setCurrentPhase(null);
        }

        for (var contextKey in childContext) {
          invariant(contextKey in childContextTypes, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(type) || "Unknown", contextKey);
        }

        {
          var name = getComponentName(type) || "Unknown";
          checkPropTypes(childContextTypes, childContext, "child context", name, getCurrentFiberStackInDev);
        }
        return _extends({}, parentContext, childContext);
      }

      function pushContextProvider(workInProgress) {
        var instance = workInProgress.stateNode;
        var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
        previousContext = contextStackCursor.current;
        push(contextStackCursor, memoizedMergedChildContext, workInProgress);
        push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
        return true;
      }

      function invalidateContextProvider(workInProgress, type, didChange) {
        var instance = workInProgress.stateNode;
        invariant(instance, "Expected to have an instance by this point. " + "This error is likely caused by a bug in React. Please file an issue.");

        if (didChange) {
          var mergedContext = processChildContext(workInProgress, type, previousContext);
          instance.__reactInternalMemoizedMergedChildContext = mergedContext;
          pop(didPerformWorkStackCursor, workInProgress);
          pop(contextStackCursor, workInProgress);
          push(contextStackCursor, mergedContext, workInProgress);
          push(didPerformWorkStackCursor, didChange, workInProgress);
        } else {
          pop(didPerformWorkStackCursor, workInProgress);
          push(didPerformWorkStackCursor, didChange, workInProgress);
        }
      }

      function findCurrentUnmaskedContext(fiber) {
        invariant(isFiberMounted(fiber) && fiber.tag === ClassComponent, "Expected subtree parent to be a mounted class component. " + "This error is likely caused by a bug in React. Please file an issue.");
        var node = fiber;

        do {
          switch (node.tag) {
            case HostRoot:
              return node.stateNode.context;

            case ClassComponent:
              {
                var Component = node.type;

                if (isContextProvider(Component)) {
                  return node.stateNode.__reactInternalMemoizedMergedChildContext;
                }

                break;
              }
          }

          node = node.return;
        } while (node !== null);

        invariant(false, "Found unexpected detached subtree parent. " + "This error is likely caused by a bug in React. Please file an issue.");
      }

      var onCommitFiberRoot = null;
      var onCommitFiberUnmount = null;
      var hasLoggedError = false;

      function catchErrors(fn) {
        return function (arg) {
          try {
            return fn(arg);
          } catch (err) {
            if (true && !hasLoggedError) {
              hasLoggedError = true;
              warningWithoutStack$1(false, "React DevTools encountered an error: %s", err);
            }
          }
        };
      }

      var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";

      function injectInternals(internals) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
          return false;
        }

        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;

        if (hook.isDisabled) {
          return true;
        }

        if (!hook.supportsFiber) {
          {
            warningWithoutStack$1(false, "The installed version of React DevTools is too old and will not work " + "with the current version of React. Please update React DevTools. " + "https://fb.me/react-devtools");
          }
          return true;
        }

        try {
          var rendererID = hook.inject(internals);
          onCommitFiberRoot = catchErrors(function (root) {
            return hook.onCommitFiberRoot(rendererID, root);
          });
          onCommitFiberUnmount = catchErrors(function (fiber) {
            return hook.onCommitFiberUnmount(rendererID, fiber);
          });
        } catch (err) {
          {
            warningWithoutStack$1(false, "React DevTools encountered an error: %s.", err);
          }
        }

        return true;
      }

      function onCommitRoot(root) {
        if (typeof onCommitFiberRoot === "function") {
          onCommitFiberRoot(root);
        }
      }

      function onCommitUnmount(fiber) {
        if (typeof onCommitFiberUnmount === "function") {
          onCommitFiberUnmount(fiber);
        }
      }

      var maxSigned31BitInt = 1073741823;
      var NoWork = 0;
      var Never = 1;
      var Sync = maxSigned31BitInt;
      var UNIT_SIZE = 10;
      var MAGIC_NUMBER_OFFSET = maxSigned31BitInt - 1;

      function msToExpirationTime(ms) {
        return MAGIC_NUMBER_OFFSET - (ms / UNIT_SIZE | 0);
      }

      function expirationTimeToMs(expirationTime) {
        return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;
      }

      function ceiling(num, precision) {
        return ((num / precision | 0) + 1) * precision;
      }

      function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
        return MAGIC_NUMBER_OFFSET - ceiling(MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
      }

      var LOW_PRIORITY_EXPIRATION = 5000;
      var LOW_PRIORITY_BATCH_SIZE = 250;

      function computeAsyncExpiration(currentTime) {
        return computeExpirationBucket(currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE);
      }

      var HIGH_PRIORITY_EXPIRATION = 500;
      var HIGH_PRIORITY_BATCH_SIZE = 100;

      function computeInteractiveExpiration(currentTime) {
        return computeExpirationBucket(currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE);
      }

      var NoContext = 0;
      var ConcurrentMode = 1;
      var StrictMode = 2;
      var ProfileMode = 4;
      var hasBadMapPolyfill = void 0;
      {
        hasBadMapPolyfill = false;

        try {
          var nonExtensibleObject = Object.preventExtensions({});
          var testMap = new Map([[nonExtensibleObject, null]]);
          var testSet = new Set([nonExtensibleObject]);
          testMap.set(0, 0);
          testSet.add(0);
        } catch (e) {
          hasBadMapPolyfill = true;
        }
      }
      var debugCounter = void 0;
      {
        debugCounter = 1;
      }

      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.elementType = null;
        this.type = null;
        this.stateNode = null;
        this.return = null;
        this.child = null;
        this.sibling = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = pendingProps;
        this.memoizedProps = null;
        this.updateQueue = null;
        this.memoizedState = null;
        this.firstContextDependency = null;
        this.mode = mode;
        this.effectTag = NoEffect;
        this.nextEffect = null;
        this.firstEffect = null;
        this.lastEffect = null;
        this.expirationTime = NoWork;
        this.childExpirationTime = NoWork;
        this.alternate = null;

        if (enableProfilerTimer) {
          this.actualDuration = 0;
          this.actualStartTime = -1;
          this.selfBaseDuration = 0;
          this.treeBaseDuration = 0;
        }

        {
          this._debugID = debugCounter++;
          this._debugSource = null;
          this._debugOwner = null;
          this._debugIsCurrentlyTiming = false;

          if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
            Object.preventExtensions(this);
          }
        }
      }

      var createFiber = function createFiber(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      };

      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }

      function isSimpleFunctionComponent(type) {
        return typeof type === "function" && !shouldConstruct(type) && type.defaultProps === undefined;
      }

      function resolveLazyComponentTag(Component) {
        if (typeof Component === "function") {
          return shouldConstruct(Component) ? ClassComponent : FunctionComponent;
        } else if (Component !== undefined && Component !== null) {
          var $$typeof = Component.$$typeof;

          if ($$typeof === REACT_FORWARD_REF_TYPE) {
            return ForwardRef;
          }

          if ($$typeof === REACT_MEMO_TYPE) {
            return MemoComponent;
          }
        }

        return IndeterminateComponent;
      }

      function createWorkInProgress(current, pendingProps, expirationTime) {
        var workInProgress = current.alternate;

        if (workInProgress === null) {
          workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);
          workInProgress.elementType = current.elementType;
          workInProgress.type = current.type;
          workInProgress.stateNode = current.stateNode;
          {
            workInProgress._debugID = current._debugID;
            workInProgress._debugSource = current._debugSource;
            workInProgress._debugOwner = current._debugOwner;
          }
          workInProgress.alternate = current;
          current.alternate = workInProgress;
        } else {
          workInProgress.pendingProps = pendingProps;
          workInProgress.effectTag = NoEffect;
          workInProgress.nextEffect = null;
          workInProgress.firstEffect = null;
          workInProgress.lastEffect = null;

          if (enableProfilerTimer) {
            workInProgress.actualDuration = 0;
            workInProgress.actualStartTime = -1;
          }
        }

        workInProgress.childExpirationTime = current.childExpirationTime;
        workInProgress.expirationTime = current.expirationTime;
        workInProgress.child = current.child;
        workInProgress.memoizedProps = current.memoizedProps;
        workInProgress.memoizedState = current.memoizedState;
        workInProgress.updateQueue = current.updateQueue;
        workInProgress.firstContextDependency = current.firstContextDependency;
        workInProgress.sibling = current.sibling;
        workInProgress.index = current.index;
        workInProgress.ref = current.ref;

        if (enableProfilerTimer) {
          workInProgress.selfBaseDuration = current.selfBaseDuration;
          workInProgress.treeBaseDuration = current.treeBaseDuration;
        }

        return workInProgress;
      }

      function createHostRootFiber(isConcurrent) {
        var mode = isConcurrent ? ConcurrentMode | StrictMode : NoContext;

        if (enableProfilerTimer && isDevToolsPresent) {
          mode |= ProfileMode;
        }

        return createFiber(HostRoot, null, null, mode);
      }

      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime) {
        var fiber = void 0;
        var fiberTag = IndeterminateComponent;
        var resolvedType = type;

        if (typeof type === "function") {
          if (shouldConstruct(type)) {
            fiberTag = ClassComponent;
          }
        } else if (typeof type === "string") {
          fiberTag = HostComponent;
        } else {
          getTag: switch (type) {
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);

            case REACT_CONCURRENT_MODE_TYPE:
              return createFiberFromMode(pendingProps, mode | ConcurrentMode | StrictMode, expirationTime, key);

            case REACT_STRICT_MODE_TYPE:
              return createFiberFromMode(pendingProps, mode | StrictMode, expirationTime, key);

            case REACT_PROFILER_TYPE:
              return createFiberFromProfiler(pendingProps, mode, expirationTime, key);

            case REACT_SUSPENSE_TYPE:
              return createFiberFromSuspense(pendingProps, mode, expirationTime, key);

            default:
              {
                if (typeof type === "object" && type !== null) {
                  switch (type.$$typeof) {
                    case REACT_PROVIDER_TYPE:
                      fiberTag = ContextProvider;
                      break getTag;

                    case REACT_CONTEXT_TYPE:
                      fiberTag = ContextConsumer;
                      break getTag;

                    case REACT_FORWARD_REF_TYPE:
                      fiberTag = ForwardRef;
                      break getTag;

                    case REACT_MEMO_TYPE:
                      fiberTag = MemoComponent;
                      break getTag;

                    case REACT_LAZY_TYPE:
                      fiberTag = LazyComponent;
                      resolvedType = null;
                      break getTag;
                  }
                }

                var info = "";
                {
                  if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                    info += " You likely forgot to export your component from the file " + "it's defined in, or you might have mixed up default and " + "named imports.";
                  }

                  var ownerName = owner ? getComponentName(owner.type) : null;

                  if (ownerName) {
                    info += "\n\nCheck the render method of `" + ownerName + "`.";
                  }
                }
                invariant(false, "Element type is invalid: expected a string (for built-in " + "components) or a class/function (for composite components) " + "but got: %s.%s", type == null ? type : typeof type, info);
              }
          }
        }

        fiber = createFiber(fiberTag, pendingProps, key, mode);
        fiber.elementType = type;
        fiber.type = resolvedType;
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromElement(element, mode, expirationTime) {
        var owner = null;
        {
          owner = element._owner;
        }
        var type = element.type;
        var key = element.key;
        var pendingProps = element.props;
        var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime);
        {
          fiber._debugSource = element._source;
          fiber._debugOwner = element._owner;
        }
        return fiber;
      }

      function createFiberFromFragment(elements, mode, expirationTime, key) {
        var fiber = createFiber(Fragment, elements, key, mode);
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
        {
          if (typeof pendingProps.id !== "string" || typeof pendingProps.onRender !== "function") {
            warningWithoutStack$1(false, 'Profiler must specify an "id" string and "onRender" function as props');
          }
        }
        var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
        fiber.elementType = REACT_PROFILER_TYPE;
        fiber.type = REACT_PROFILER_TYPE;
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromMode(pendingProps, mode, expirationTime, key) {
        var fiber = createFiber(Mode, pendingProps, key, mode);
        var type = (mode & ConcurrentMode) === NoContext ? REACT_STRICT_MODE_TYPE : REACT_CONCURRENT_MODE_TYPE;
        fiber.elementType = type;
        fiber.type = type;
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromSuspense(pendingProps, mode, expirationTime, key) {
        var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
        var type = REACT_SUSPENSE_TYPE;
        fiber.elementType = type;
        fiber.type = type;
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromText(content, mode, expirationTime) {
        var fiber = createFiber(HostText, content, null, mode);
        fiber.expirationTime = expirationTime;
        return fiber;
      }

      function createFiberFromHostInstanceForDeletion() {
        var fiber = createFiber(HostComponent, null, null, NoContext);
        fiber.elementType = "DELETED";
        fiber.type = "DELETED";
        return fiber;
      }

      function createFiberFromPortal(portal, mode, expirationTime) {
        var pendingProps = portal.children !== null ? portal.children : [];
        var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
        fiber.expirationTime = expirationTime;
        fiber.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return fiber;
      }

      function assignFiberPropertiesInDEV(target, source) {
        if (target === null) {
          target = createFiber(IndeterminateComponent, null, null, NoContext);
        }

        target.tag = source.tag;
        target.key = source.key;
        target.elementType = source.elementType;
        target.type = source.type;
        target.stateNode = source.stateNode;
        target.return = source.return;
        target.child = source.child;
        target.sibling = source.sibling;
        target.index = source.index;
        target.ref = source.ref;
        target.pendingProps = source.pendingProps;
        target.memoizedProps = source.memoizedProps;
        target.updateQueue = source.updateQueue;
        target.memoizedState = source.memoizedState;
        target.firstContextDependency = source.firstContextDependency;
        target.mode = source.mode;
        target.effectTag = source.effectTag;
        target.nextEffect = source.nextEffect;
        target.firstEffect = source.firstEffect;
        target.lastEffect = source.lastEffect;
        target.expirationTime = source.expirationTime;
        target.childExpirationTime = source.childExpirationTime;
        target.alternate = source.alternate;

        if (enableProfilerTimer) {
          target.actualDuration = source.actualDuration;
          target.actualStartTime = source.actualStartTime;
          target.selfBaseDuration = source.selfBaseDuration;
          target.treeBaseDuration = source.treeBaseDuration;
        }

        target._debugID = source._debugID;
        target._debugSource = source._debugSource;
        target._debugOwner = source._debugOwner;
        target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;
        return target;
      }

      function createFiberRoot(containerInfo, isConcurrent, hydrate) {
        var uninitializedFiber = createHostRootFiber(isConcurrent);
        var root = void 0;

        if (enableSchedulerTracing) {
          root = {
            current: uninitializedFiber,
            containerInfo: containerInfo,
            pendingChildren: null,
            earliestPendingTime: NoWork,
            latestPendingTime: NoWork,
            earliestSuspendedTime: NoWork,
            latestSuspendedTime: NoWork,
            latestPingedTime: NoWork,
            didError: false,
            pendingCommitExpirationTime: NoWork,
            finishedWork: null,
            timeoutHandle: noTimeout,
            context: null,
            pendingContext: null,
            hydrate: hydrate,
            nextExpirationTimeToWorkOn: NoWork,
            expirationTime: NoWork,
            firstBatch: null,
            nextScheduledRoot: null,
            interactionThreadID: tracing.unstable_getThreadID(),
            memoizedInteractions: new Set(),
            pendingInteractionMap: new Map()
          };
        } else {
          root = {
            current: uninitializedFiber,
            containerInfo: containerInfo,
            pendingChildren: null,
            earliestPendingTime: NoWork,
            latestPendingTime: NoWork,
            earliestSuspendedTime: NoWork,
            latestSuspendedTime: NoWork,
            latestPingedTime: NoWork,
            didError: false,
            pendingCommitExpirationTime: NoWork,
            finishedWork: null,
            timeoutHandle: noTimeout,
            context: null,
            pendingContext: null,
            hydrate: hydrate,
            nextExpirationTimeToWorkOn: NoWork,
            expirationTime: NoWork,
            firstBatch: null,
            nextScheduledRoot: null
          };
        }

        uninitializedFiber.stateNode = root;
        return root;
      }

      var lowPriorityWarning = function lowPriorityWarning() {};

      {
        var printWarning = function printWarning(format) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          var argIndex = 0;
          var message = "Warning: " + format.replace(/%s/g, function () {
            return args[argIndex++];
          });

          if (typeof console !== "undefined") {
            console.warn(message);
          }

          try {
            throw new Error(message);
          } catch (x) {}
        };

        lowPriorityWarning = function lowPriorityWarning(condition, format) {
          if (format === undefined) {
            throw new Error("`lowPriorityWarning(condition, format, ...args)` requires a warning " + "message argument");
          }

          if (!condition) {
            for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
              args[_key2 - 2] = arguments[_key2];
            }

            printWarning.apply(undefined, [format].concat(args));
          }
        };
      }
      var lowPriorityWarning$1 = lowPriorityWarning;
      var ReactStrictModeWarnings = {
        discardPendingWarnings: function discardPendingWarnings() {},
        flushPendingDeprecationWarnings: function flushPendingDeprecationWarnings() {},
        flushPendingUnsafeLifecycleWarnings: function flushPendingUnsafeLifecycleWarnings() {},
        recordDeprecationWarnings: function recordDeprecationWarnings(fiber, instance) {},
        recordUnsafeLifecycleWarnings: function recordUnsafeLifecycleWarnings(fiber, instance) {},
        recordLegacyContextWarning: function recordLegacyContextWarning(fiber, instance) {},
        flushLegacyContextWarning: function flushLegacyContextWarning() {}
      };
      {
        var LIFECYCLE_SUGGESTIONS = {
          UNSAFE_componentWillMount: "componentDidMount",
          UNSAFE_componentWillReceiveProps: "static getDerivedStateFromProps",
          UNSAFE_componentWillUpdate: "componentDidUpdate"
        };
        var pendingComponentWillMountWarnings = [];
        var pendingComponentWillReceivePropsWarnings = [];
        var pendingComponentWillUpdateWarnings = [];
        var pendingUnsafeLifecycleWarnings = new Map();
        var pendingLegacyContextWarning = new Map();
        var didWarnAboutDeprecatedLifecycles = new Set();
        var didWarnAboutUnsafeLifecycles = new Set();
        var didWarnAboutLegacyContext = new Set();

        var setToSortedString = function setToSortedString(set) {
          var array = [];
          set.forEach(function (value) {
            array.push(value);
          });
          return array.sort().join(", ");
        };

        ReactStrictModeWarnings.discardPendingWarnings = function () {
          pendingComponentWillMountWarnings = [];
          pendingComponentWillReceivePropsWarnings = [];
          pendingComponentWillUpdateWarnings = [];
          pendingUnsafeLifecycleWarnings = new Map();
          pendingLegacyContextWarning = new Map();
        };

        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
          pendingUnsafeLifecycleWarnings.forEach(function (lifecycleWarningsMap, strictRoot) {
            var lifecyclesWarningMesages = [];
            Object.keys(lifecycleWarningsMap).forEach(function (lifecycle) {
              var lifecycleWarnings = lifecycleWarningsMap[lifecycle];

              if (lifecycleWarnings.length > 0) {
                var componentNames = new Set();
                lifecycleWarnings.forEach(function (fiber) {
                  componentNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                var formatted = lifecycle.replace("UNSAFE_", "");
                var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];
                var sortedComponentNames = setToSortedString(componentNames);
                lifecyclesWarningMesages.push(formatted + ": Please update the following components to use " + (suggestion + " instead: " + sortedComponentNames));
              }
            });

            if (lifecyclesWarningMesages.length > 0) {
              var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);
              warningWithoutStack$1(false, "Unsafe lifecycle methods were found within a strict-mode tree:%s" + "\n\n%s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-strict-mode-warnings", strictRootComponentStack, lifecyclesWarningMesages.join("\n\n"));
            }
          });
          pendingUnsafeLifecycleWarnings = new Map();
        };

        var findStrictRoot = function findStrictRoot(fiber) {
          var maybeStrictRoot = null;
          var node = fiber;

          while (node !== null) {
            if (node.mode & StrictMode) {
              maybeStrictRoot = node;
            }

            node = node.return;
          }

          return maybeStrictRoot;
        };

        ReactStrictModeWarnings.flushPendingDeprecationWarnings = function () {
          if (pendingComponentWillMountWarnings.length > 0) {
            var uniqueNames = new Set();
            pendingComponentWillMountWarnings.forEach(function (fiber) {
              uniqueNames.add(getComponentName(fiber.type) || "Component");
              didWarnAboutDeprecatedLifecycles.add(fiber.type);
            });
            var sortedNames = setToSortedString(uniqueNames);
            lowPriorityWarning$1(false, "componentWillMount is deprecated and will be removed in the next major version. " + "Use componentDidMount instead. As a temporary workaround, " + "you can rename to UNSAFE_componentWillMount." + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-async-component-lifecycle-hooks", sortedNames);
            pendingComponentWillMountWarnings = [];
          }

          if (pendingComponentWillReceivePropsWarnings.length > 0) {
            var _uniqueNames = new Set();

            pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
              _uniqueNames.add(getComponentName(fiber.type) || "Component");

              didWarnAboutDeprecatedLifecycles.add(fiber.type);
            });

            var _sortedNames = setToSortedString(_uniqueNames);

            lowPriorityWarning$1(false, "componentWillReceiveProps is deprecated and will be removed in the next major version. " + "Use static getDerivedStateFromProps instead." + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-async-component-lifecycle-hooks", _sortedNames);
            pendingComponentWillReceivePropsWarnings = [];
          }

          if (pendingComponentWillUpdateWarnings.length > 0) {
            var _uniqueNames2 = new Set();

            pendingComponentWillUpdateWarnings.forEach(function (fiber) {
              _uniqueNames2.add(getComponentName(fiber.type) || "Component");

              didWarnAboutDeprecatedLifecycles.add(fiber.type);
            });

            var _sortedNames2 = setToSortedString(_uniqueNames2);

            lowPriorityWarning$1(false, "componentWillUpdate is deprecated and will be removed in the next major version. " + "Use componentDidUpdate instead. As a temporary workaround, " + "you can rename to UNSAFE_componentWillUpdate." + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-async-component-lifecycle-hooks", _sortedNames2);
            pendingComponentWillUpdateWarnings = [];
          }
        };

        ReactStrictModeWarnings.recordDeprecationWarnings = function (fiber, instance) {
          if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {
            return;
          }

          if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
            pendingComponentWillMountWarnings.push(fiber);
          }

          if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
            pendingComponentWillReceivePropsWarnings.push(fiber);
          }

          if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
            pendingComponentWillUpdateWarnings.push(fiber);
          }
        };

        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {
          var strictRoot = findStrictRoot(fiber);

          if (strictRoot === null) {
            warningWithoutStack$1(false, "Expected to find a StrictMode component in a strict mode tree. " + "This error is likely caused by a bug in React. Please file an issue.");
            return;
          }

          if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
            return;
          }

          var warningsForRoot = void 0;

          if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {
            warningsForRoot = {
              UNSAFE_componentWillMount: [],
              UNSAFE_componentWillReceiveProps: [],
              UNSAFE_componentWillUpdate: []
            };
            pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);
          } else {
            warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);
          }

          var unsafeLifecycles = [];

          if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillMount === "function") {
            unsafeLifecycles.push("UNSAFE_componentWillMount");
          }

          if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillReceiveProps === "function") {
            unsafeLifecycles.push("UNSAFE_componentWillReceiveProps");
          }

          if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillUpdate === "function") {
            unsafeLifecycles.push("UNSAFE_componentWillUpdate");
          }

          if (unsafeLifecycles.length > 0) {
            unsafeLifecycles.forEach(function (lifecycle) {
              warningsForRoot[lifecycle].push(fiber);
            });
          }
        };

        ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {
          var strictRoot = findStrictRoot(fiber);

          if (strictRoot === null) {
            warningWithoutStack$1(false, "Expected to find a StrictMode component in a strict mode tree. " + "This error is likely caused by a bug in React. Please file an issue.");
            return;
          }

          if (didWarnAboutLegacyContext.has(fiber.type)) {
            return;
          }

          var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);

          if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
            if (warningsForRoot === undefined) {
              warningsForRoot = [];
              pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
            }

            warningsForRoot.push(fiber);
          }
        };

        ReactStrictModeWarnings.flushLegacyContextWarning = function () {
          pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {
            var uniqueNames = new Set();
            fiberArray.forEach(function (fiber) {
              uniqueNames.add(getComponentName(fiber.type) || "Component");
              didWarnAboutLegacyContext.add(fiber.type);
            });
            var sortedNames = setToSortedString(uniqueNames);
            var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);
            warningWithoutStack$1(false, "Legacy context API has been detected within a strict-mode tree: %s" + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-strict-mode-warnings", strictRootComponentStack, sortedNames);
          });
        };
      }
      var ReactFiberInstrumentation = {
        debugTool: null
      };
      var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;

      function markPendingPriorityLevel(root, expirationTime) {
        root.didError = false;
        var earliestPendingTime = root.earliestPendingTime;

        if (earliestPendingTime === NoWork) {
          root.earliestPendingTime = root.latestPendingTime = expirationTime;
        } else {
          if (earliestPendingTime < expirationTime) {
            root.earliestPendingTime = expirationTime;
          } else {
            var latestPendingTime = root.latestPendingTime;

            if (latestPendingTime > expirationTime) {
              root.latestPendingTime = expirationTime;
            }
          }
        }

        findNextExpirationTimeToWorkOn(expirationTime, root);
      }

      function markCommittedPriorityLevels(root, earliestRemainingTime) {
        root.didError = false;

        if (earliestRemainingTime === NoWork) {
          root.earliestPendingTime = NoWork;
          root.latestPendingTime = NoWork;
          root.earliestSuspendedTime = NoWork;
          root.latestSuspendedTime = NoWork;
          root.latestPingedTime = NoWork;
          findNextExpirationTimeToWorkOn(NoWork, root);
          return;
        }

        var latestPendingTime = root.latestPendingTime;

        if (latestPendingTime !== NoWork) {
          if (latestPendingTime > earliestRemainingTime) {
            root.earliestPendingTime = root.latestPendingTime = NoWork;
          } else {
            var earliestPendingTime = root.earliestPendingTime;

            if (earliestPendingTime > earliestRemainingTime) {
              root.earliestPendingTime = root.latestPendingTime;
            }
          }
        }

        var earliestSuspendedTime = root.earliestSuspendedTime;

        if (earliestSuspendedTime === NoWork) {
          markPendingPriorityLevel(root, earliestRemainingTime);
          findNextExpirationTimeToWorkOn(NoWork, root);
          return;
        }

        var latestSuspendedTime = root.latestSuspendedTime;

        if (earliestRemainingTime < latestSuspendedTime) {
          root.earliestSuspendedTime = NoWork;
          root.latestSuspendedTime = NoWork;
          root.latestPingedTime = NoWork;
          markPendingPriorityLevel(root, earliestRemainingTime);
          findNextExpirationTimeToWorkOn(NoWork, root);
          return;
        }

        if (earliestRemainingTime > earliestSuspendedTime) {
          markPendingPriorityLevel(root, earliestRemainingTime);
          findNextExpirationTimeToWorkOn(NoWork, root);
          return;
        }

        findNextExpirationTimeToWorkOn(NoWork, root);
      }

      function hasLowerPriorityWork(root, erroredExpirationTime) {
        var latestPendingTime = root.latestPendingTime;
        var latestSuspendedTime = root.latestSuspendedTime;
        var latestPingedTime = root.latestPingedTime;
        return latestPendingTime !== NoWork && latestPendingTime < erroredExpirationTime || latestSuspendedTime !== NoWork && latestSuspendedTime < erroredExpirationTime || latestPingedTime !== NoWork && latestPingedTime < erroredExpirationTime;
      }

      function isPriorityLevelSuspended(root, expirationTime) {
        var earliestSuspendedTime = root.earliestSuspendedTime;
        var latestSuspendedTime = root.latestSuspendedTime;
        return earliestSuspendedTime !== NoWork && expirationTime <= earliestSuspendedTime && expirationTime >= latestSuspendedTime;
      }

      function markSuspendedPriorityLevel(root, suspendedTime) {
        root.didError = false;
        clearPing(root, suspendedTime);
        var earliestPendingTime = root.earliestPendingTime;
        var latestPendingTime = root.latestPendingTime;

        if (earliestPendingTime === suspendedTime) {
          if (latestPendingTime === suspendedTime) {
            root.earliestPendingTime = root.latestPendingTime = NoWork;
          } else {
            root.earliestPendingTime = latestPendingTime;
          }
        } else if (latestPendingTime === suspendedTime) {
          root.latestPendingTime = earliestPendingTime;
        }

        var earliestSuspendedTime = root.earliestSuspendedTime;
        var latestSuspendedTime = root.latestSuspendedTime;

        if (earliestSuspendedTime === NoWork) {
          root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;
        } else {
          if (earliestSuspendedTime < suspendedTime) {
            root.earliestSuspendedTime = suspendedTime;
          } else if (latestSuspendedTime > suspendedTime) {
            root.latestSuspendedTime = suspendedTime;
          }
        }

        findNextExpirationTimeToWorkOn(suspendedTime, root);
      }

      function markPingedPriorityLevel(root, pingedTime) {
        root.didError = false;
        var latestPingedTime = root.latestPingedTime;

        if (latestPingedTime === NoWork || latestPingedTime > pingedTime) {
          root.latestPingedTime = pingedTime;
        }

        findNextExpirationTimeToWorkOn(pingedTime, root);
      }

      function clearPing(root, completedTime) {
        var latestPingedTime = root.latestPingedTime;

        if (latestPingedTime !== NoWork && latestPingedTime >= completedTime) {
          root.latestPingedTime = NoWork;
        }
      }

      function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
        var earliestExpirationTime = renderExpirationTime;
        var earliestPendingTime = root.earliestPendingTime;
        var earliestSuspendedTime = root.earliestSuspendedTime;

        if (earliestPendingTime > earliestExpirationTime) {
          earliestExpirationTime = earliestPendingTime;
        }

        if (earliestSuspendedTime > earliestExpirationTime) {
          earliestExpirationTime = earliestSuspendedTime;
        }

        return earliestExpirationTime;
      }

      function didExpireAtExpirationTime(root, currentTime) {
        var expirationTime = root.expirationTime;

        if (expirationTime !== NoWork && currentTime <= expirationTime) {
          root.nextExpirationTimeToWorkOn = currentTime;
        }
      }

      function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
        var earliestSuspendedTime = root.earliestSuspendedTime;
        var latestSuspendedTime = root.latestSuspendedTime;
        var earliestPendingTime = root.earliestPendingTime;
        var latestPingedTime = root.latestPingedTime;
        var nextExpirationTimeToWorkOn = earliestPendingTime !== NoWork ? earliestPendingTime : latestPingedTime;

        if (nextExpirationTimeToWorkOn === NoWork && (completedExpirationTime === NoWork || latestSuspendedTime < completedExpirationTime)) {
          nextExpirationTimeToWorkOn = latestSuspendedTime;
        }

        var expirationTime = nextExpirationTimeToWorkOn;

        if (expirationTime !== NoWork && earliestSuspendedTime > expirationTime) {
          expirationTime = earliestSuspendedTime;
        }

        root.nextExpirationTimeToWorkOn = nextExpirationTimeToWorkOn;
        root.expirationTime = expirationTime;
      }

      var UpdateState = 0;
      var ReplaceState = 1;
      var ForceUpdate = 2;
      var CaptureUpdate = 3;
      var hasForceUpdate = false;
      var didWarnUpdateInsideUpdate = void 0;
      var currentlyProcessingQueue = void 0;
      var resetCurrentlyProcessingQueue = void 0;
      {
        didWarnUpdateInsideUpdate = false;
        currentlyProcessingQueue = null;

        resetCurrentlyProcessingQueue = function resetCurrentlyProcessingQueue() {
          currentlyProcessingQueue = null;
        };
      }

      function createUpdateQueue(baseState) {
        var queue = {
          baseState: baseState,
          firstUpdate: null,
          lastUpdate: null,
          firstCapturedUpdate: null,
          lastCapturedUpdate: null,
          firstEffect: null,
          lastEffect: null,
          firstCapturedEffect: null,
          lastCapturedEffect: null
        };
        return queue;
      }

      function cloneUpdateQueue(currentQueue) {
        var queue = {
          baseState: currentQueue.baseState,
          firstUpdate: currentQueue.firstUpdate,
          lastUpdate: currentQueue.lastUpdate,
          firstCapturedUpdate: null,
          lastCapturedUpdate: null,
          firstEffect: null,
          lastEffect: null,
          firstCapturedEffect: null,
          lastCapturedEffect: null
        };
        return queue;
      }

      function createUpdate(expirationTime) {
        return {
          expirationTime: expirationTime,
          tag: UpdateState,
          payload: null,
          callback: null,
          next: null,
          nextEffect: null
        };
      }

      function appendUpdateToQueue(queue, update) {
        if (queue.lastUpdate === null) {
          queue.firstUpdate = queue.lastUpdate = update;
        } else {
          queue.lastUpdate.next = update;
          queue.lastUpdate = update;
        }
      }

      function enqueueUpdate(fiber, update) {
        var alternate = fiber.alternate;
        var queue1 = void 0;
        var queue2 = void 0;

        if (alternate === null) {
          queue1 = fiber.updateQueue;
          queue2 = null;

          if (queue1 === null) {
            queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
          }
        } else {
          queue1 = fiber.updateQueue;
          queue2 = alternate.updateQueue;

          if (queue1 === null) {
            if (queue2 === null) {
              queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
              queue2 = alternate.updateQueue = createUpdateQueue(alternate.memoizedState);
            } else {
              queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);
            }
          } else {
            if (queue2 === null) {
              queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);
            } else {}
          }
        }

        if (queue2 === null || queue1 === queue2) {
          appendUpdateToQueue(queue1, update);
        } else {
          if (queue1.lastUpdate === null || queue2.lastUpdate === null) {
            appendUpdateToQueue(queue1, update);
            appendUpdateToQueue(queue2, update);
          } else {
            appendUpdateToQueue(queue1, update);
            queue2.lastUpdate = update;
          }
        }

        {
          if (fiber.tag === ClassComponent && (currentlyProcessingQueue === queue1 || queue2 !== null && currentlyProcessingQueue === queue2) && !didWarnUpdateInsideUpdate) {
            warningWithoutStack$1(false, "An update (setState, replaceState, or forceUpdate) was scheduled " + "from inside an update function. Update functions should be pure, " + "with zero side-effects. Consider using componentDidUpdate or a " + "callback.");
            didWarnUpdateInsideUpdate = true;
          }
        }
      }

      function enqueueCapturedUpdate(workInProgress, update) {
        var workInProgressQueue = workInProgress.updateQueue;

        if (workInProgressQueue === null) {
          workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(workInProgress.memoizedState);
        } else {
          workInProgressQueue = ensureWorkInProgressQueueIsAClone(workInProgress, workInProgressQueue);
        }

        if (workInProgressQueue.lastCapturedUpdate === null) {
          workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;
        } else {
          workInProgressQueue.lastCapturedUpdate.next = update;
          workInProgressQueue.lastCapturedUpdate = update;
        }
      }

      function ensureWorkInProgressQueueIsAClone(workInProgress, queue) {
        var current = workInProgress.alternate;

        if (current !== null) {
          if (queue === current.updateQueue) {
            queue = workInProgress.updateQueue = cloneUpdateQueue(queue);
          }
        }

        return queue;
      }

      function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
        switch (update.tag) {
          case ReplaceState:
            {
              var _payload = update.payload;

              if (typeof _payload === "function") {
                {
                  if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
                    _payload.call(instance, prevState, nextProps);
                  }
                }
                return _payload.call(instance, prevState, nextProps);
              }

              return _payload;
            }

          case CaptureUpdate:
            {
              workInProgress.effectTag = workInProgress.effectTag & ~ShouldCapture | DidCapture;
            }

          case UpdateState:
            {
              var _payload2 = update.payload;
              var partialState = void 0;

              if (typeof _payload2 === "function") {
                {
                  if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
                    _payload2.call(instance, prevState, nextProps);
                  }
                }
                partialState = _payload2.call(instance, prevState, nextProps);
              } else {
                partialState = _payload2;
              }

              if (partialState === null || partialState === undefined) {
                return prevState;
              }

              return _extends({}, prevState, partialState);
            }

          case ForceUpdate:
            {
              hasForceUpdate = true;
              return prevState;
            }
        }

        return prevState;
      }

      function processUpdateQueue(workInProgress, queue, props, instance, renderExpirationTime) {
        hasForceUpdate = false;
        queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);
        {
          currentlyProcessingQueue = queue;
        }
        var newBaseState = queue.baseState;
        var newFirstUpdate = null;
        var newExpirationTime = NoWork;
        var update = queue.firstUpdate;
        var resultState = newBaseState;

        while (update !== null) {
          var updateExpirationTime = update.expirationTime;

          if (updateExpirationTime < renderExpirationTime) {
            if (newFirstUpdate === null) {
              newFirstUpdate = update;
              newBaseState = resultState;
            }

            if (newExpirationTime < updateExpirationTime) {
              newExpirationTime = updateExpirationTime;
            }
          } else {
            resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);
            var _callback = update.callback;

            if (_callback !== null) {
              workInProgress.effectTag |= Callback;
              update.nextEffect = null;

              if (queue.lastEffect === null) {
                queue.firstEffect = queue.lastEffect = update;
              } else {
                queue.lastEffect.nextEffect = update;
                queue.lastEffect = update;
              }
            }
          }

          update = update.next;
        }

        var newFirstCapturedUpdate = null;
        update = queue.firstCapturedUpdate;

        while (update !== null) {
          var _updateExpirationTime = update.expirationTime;

          if (_updateExpirationTime < renderExpirationTime) {
            if (newFirstCapturedUpdate === null) {
              newFirstCapturedUpdate = update;

              if (newFirstUpdate === null) {
                newBaseState = resultState;
              }
            }

            if (newExpirationTime < _updateExpirationTime) {
              newExpirationTime = _updateExpirationTime;
            }
          } else {
            resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);
            var _callback2 = update.callback;

            if (_callback2 !== null) {
              workInProgress.effectTag |= Callback;
              update.nextEffect = null;

              if (queue.lastCapturedEffect === null) {
                queue.firstCapturedEffect = queue.lastCapturedEffect = update;
              } else {
                queue.lastCapturedEffect.nextEffect = update;
                queue.lastCapturedEffect = update;
              }
            }
          }

          update = update.next;
        }

        if (newFirstUpdate === null) {
          queue.lastUpdate = null;
        }

        if (newFirstCapturedUpdate === null) {
          queue.lastCapturedUpdate = null;
        } else {
          workInProgress.effectTag |= Callback;
        }

        if (newFirstUpdate === null && newFirstCapturedUpdate === null) {
          newBaseState = resultState;
        }

        queue.baseState = newBaseState;
        queue.firstUpdate = newFirstUpdate;
        queue.firstCapturedUpdate = newFirstCapturedUpdate;
        workInProgress.expirationTime = newExpirationTime;
        workInProgress.memoizedState = resultState;
        {
          currentlyProcessingQueue = null;
        }
      }

      function callCallback(callback, context) {
        invariant(typeof callback === "function", "Invalid argument passed as callback. Expected a function. Instead " + "received: %s", callback);
        callback.call(context);
      }

      function resetHasForceUpdateBeforeProcessing() {
        hasForceUpdate = false;
      }

      function checkHasForceUpdateAfterProcessing() {
        return hasForceUpdate;
      }

      function commitUpdateQueue(finishedWork, finishedQueue, instance, renderExpirationTime) {
        if (finishedQueue.firstCapturedUpdate !== null) {
          if (finishedQueue.lastUpdate !== null) {
            finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;
            finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;
          }

          finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;
        }

        commitUpdateEffects(finishedQueue.firstEffect, instance);
        finishedQueue.firstEffect = finishedQueue.lastEffect = null;
        commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);
        finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;
      }

      function commitUpdateEffects(effect, instance) {
        while (effect !== null) {
          var _callback3 = effect.callback;

          if (_callback3 !== null) {
            effect.callback = null;
            callCallback(_callback3, instance);
          }

          effect = effect.nextEffect;
        }
      }

      function createCapturedValue(value, source) {
        return {
          value: value,
          source: source,
          stack: getStackByFiberInDevAndProd(source)
        };
      }

      var warning = warningWithoutStack$1;
      {
        warning = function warning(condition, format) {
          if (condition) {
            return;
          }

          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame.getStackAddendum();

          for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          warningWithoutStack$1.apply(undefined, [false, format + "%s"].concat(args, [stack]));
        };
      }
      var warning$1 = warning;
      var valueCursor = createCursor(null);
      var rendererSigil = void 0;
      {
        rendererSigil = {};
      }
      var currentlyRenderingFiber = null;
      var lastContextDependency = null;
      var lastContextWithAllBitsObserved = null;

      function resetContextDependences() {
        currentlyRenderingFiber = null;
        lastContextDependency = null;
        lastContextWithAllBitsObserved = null;
      }

      function pushProvider(providerFiber, nextValue) {
        var context = providerFiber.type._context;

        if (isPrimaryRenderer) {
          push(valueCursor, context._currentValue, providerFiber);
          context._currentValue = nextValue;
          {
            !(context._currentRenderer === undefined || context._currentRenderer === null || context._currentRenderer === rendererSigil) ? warningWithoutStack$1(false, "Detected multiple renderers concurrently rendering the " + "same context provider. This is currently unsupported.") : void 0;
            context._currentRenderer = rendererSigil;
          }
        } else {
          push(valueCursor, context._currentValue2, providerFiber);
          context._currentValue2 = nextValue;
          {
            !(context._currentRenderer2 === undefined || context._currentRenderer2 === null || context._currentRenderer2 === rendererSigil) ? warningWithoutStack$1(false, "Detected multiple renderers concurrently rendering the " + "same context provider. This is currently unsupported.") : void 0;
            context._currentRenderer2 = rendererSigil;
          }
        }
      }

      function popProvider(providerFiber) {
        var currentValue = valueCursor.current;
        pop(valueCursor, providerFiber);
        var context = providerFiber.type._context;

        if (isPrimaryRenderer) {
          context._currentValue = currentValue;
        } else {
          context._currentValue2 = currentValue;
        }
      }

      function calculateChangedBits(context, newValue, oldValue) {
        if (oldValue === newValue && (oldValue !== 0 || 1 / oldValue === 1 / newValue) || oldValue !== oldValue && newValue !== newValue) {
            return 0;
          } else {
          var changedBits = typeof context._calculateChangedBits === "function" ? context._calculateChangedBits(oldValue, newValue) : maxSigned31BitInt;
          {
            !((changedBits & maxSigned31BitInt) === changedBits) ? warning$1(false, "calculateChangedBits: Expected the return value to be a " + "31-bit integer. Instead received: %s", changedBits) : void 0;
          }
          return changedBits | 0;
        }
      }

      function propagateContextChange(workInProgress, context, changedBits, renderExpirationTime) {
        var fiber = workInProgress.child;

        if (fiber !== null) {
          fiber.return = workInProgress;
        }

        while (fiber !== null) {
          var nextFiber = void 0;
          var dependency = fiber.firstContextDependency;

          if (dependency !== null) {
            do {
              if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {
                if (fiber.tag === ClassComponent) {
                  var update = createUpdate(renderExpirationTime);
                  update.tag = ForceUpdate;
                  enqueueUpdate(fiber, update);
                }

                if (fiber.expirationTime < renderExpirationTime) {
                  fiber.expirationTime = renderExpirationTime;
                }

                var alternate = fiber.alternate;

                if (alternate !== null && alternate.expirationTime < renderExpirationTime) {
                  alternate.expirationTime = renderExpirationTime;
                }

                var node = fiber.return;

                while (node !== null) {
                  alternate = node.alternate;

                  if (node.childExpirationTime < renderExpirationTime) {
                    node.childExpirationTime = renderExpirationTime;

                    if (alternate !== null && alternate.childExpirationTime < renderExpirationTime) {
                      alternate.childExpirationTime = renderExpirationTime;
                    }
                  } else if (alternate !== null && alternate.childExpirationTime < renderExpirationTime) {
                    alternate.childExpirationTime = renderExpirationTime;
                  } else {
                    break;
                  }

                  node = node.return;
                }
              }

              nextFiber = fiber.child;
              dependency = dependency.next;
            } while (dependency !== null);
          } else if (fiber.tag === ContextProvider) {
            nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
          } else {
            nextFiber = fiber.child;
          }

          if (nextFiber !== null) {
            nextFiber.return = fiber;
          } else {
            nextFiber = fiber;

            while (nextFiber !== null) {
              if (nextFiber === workInProgress) {
                nextFiber = null;
                break;
              }

              var sibling = nextFiber.sibling;

              if (sibling !== null) {
                sibling.return = nextFiber.return;
                nextFiber = sibling;
                break;
              }

              nextFiber = nextFiber.return;
            }
          }

          fiber = nextFiber;
        }
      }

      function prepareToReadContext(workInProgress, renderExpirationTime) {
        currentlyRenderingFiber = workInProgress;
        lastContextDependency = null;
        lastContextWithAllBitsObserved = null;
        workInProgress.firstContextDependency = null;
      }

      function readContext(context, observedBits) {
        if (lastContextWithAllBitsObserved === context) {} else if (observedBits === false || observedBits === 0) {} else {
          var resolvedObservedBits = void 0;

          if (typeof observedBits !== "number" || observedBits === maxSigned31BitInt) {
            lastContextWithAllBitsObserved = context;
            resolvedObservedBits = maxSigned31BitInt;
          } else {
            resolvedObservedBits = observedBits;
          }

          var contextItem = {
            context: context,
            observedBits: resolvedObservedBits,
            next: null
          };

          if (lastContextDependency === null) {
            invariant(currentlyRenderingFiber !== null, "Context can only be read while React is " + "rendering, e.g. inside the render method or getDerivedStateFromProps.");
            currentlyRenderingFiber.firstContextDependency = lastContextDependency = contextItem;
          } else {
            lastContextDependency = lastContextDependency.next = contextItem;
          }
        }

        return isPrimaryRenderer ? context._currentValue : context._currentValue2;
      }

      var NoEffect$1 = 0;
      var UnmountSnapshot = 2;
      var UnmountMutation = 4;
      var MountMutation = 8;
      var UnmountLayout = 16;
      var MountLayout = 32;
      var MountPassive = 64;
      var UnmountPassive = 128;

      function areHookInputsEqual(arr1, arr2) {
        {
          !(arr1.length === arr2.length) ? warning$1(false, "Detected a variable number of hook dependencies. The length of the " + "dependencies array should be constant between renders.\n\n" + "Previous: %s\n" + "Incoming: %s", arr1.join(", "), arr2.join(", ")) : void 0;
        }

        for (var i = 0; i < arr1.length; i++) {
          var val1 = arr1[i];
          var val2 = arr2[i];

          if (val1 === val2 && (val1 !== 0 || 1 / val1 === 1 / val2) || val1 !== val1 && val2 !== val2) {
              continue;
            }

          return false;
        }

        return true;
      }

      var renderExpirationTime = NoWork;
      var currentlyRenderingFiber$1 = null;
      var firstCurrentHook = null;
      var currentHook = null;
      var firstWorkInProgressHook = null;
      var workInProgressHook = null;
      var remainingExpirationTime = NoWork;
      var componentUpdateQueue = null;
      var isReRender = false;
      var didScheduleRenderPhaseUpdate = false;
      var renderPhaseUpdates = null;
      var numberOfReRenders = 0;
      var RE_RENDER_LIMIT = 25;

      function resolveCurrentlyRenderingFiber() {
        invariant(currentlyRenderingFiber$1 !== null, "Hooks can only be called inside the body of a function component.");
        return currentlyRenderingFiber$1;
      }

      function prepareToUseHooks(current, workInProgress, nextRenderExpirationTime) {
        if (!enableHooks) {
          return;
        }

        renderExpirationTime = nextRenderExpirationTime;
        currentlyRenderingFiber$1 = workInProgress;
        firstCurrentHook = current !== null ? current.memoizedState : null;
      }

      function finishHooks(Component, props, children, refOrContext) {
        if (!enableHooks) {
          return children;
        }

        while (didScheduleRenderPhaseUpdate) {
          didScheduleRenderPhaseUpdate = false;
          numberOfReRenders += 1;
          currentHook = null;
          workInProgressHook = null;
          componentUpdateQueue = null;
          children = Component(props, refOrContext);
        }

        renderPhaseUpdates = null;
        numberOfReRenders = 0;
        var renderedWork = currentlyRenderingFiber$1;
        renderedWork.memoizedState = firstWorkInProgressHook;
        renderedWork.expirationTime = remainingExpirationTime;
        renderedWork.updateQueue = componentUpdateQueue;
        var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
        renderExpirationTime = NoWork;
        currentlyRenderingFiber$1 = null;
        firstCurrentHook = null;
        currentHook = null;
        firstWorkInProgressHook = null;
        workInProgressHook = null;
        remainingExpirationTime = NoWork;
        componentUpdateQueue = null;
        invariant(!didRenderTooFewHooks, "Rendered fewer hooks than expected. This may be caused by an accidental " + "early return statement.");
        return children;
      }

      function resetHooks() {
        if (!enableHooks) {
          return;
        }

        renderExpirationTime = NoWork;
        currentlyRenderingFiber$1 = null;
        firstCurrentHook = null;
        currentHook = null;
        firstWorkInProgressHook = null;
        workInProgressHook = null;
        remainingExpirationTime = NoWork;
        componentUpdateQueue = null;
        didScheduleRenderPhaseUpdate = false;
        renderPhaseUpdates = null;
        numberOfReRenders = 0;
      }

      function createHook() {
        return {
          memoizedState: null,
          baseState: null,
          queue: null,
          baseUpdate: null,
          next: null
        };
      }

      function cloneHook(hook) {
        return {
          memoizedState: hook.memoizedState,
          baseState: hook.memoizedState,
          queue: hook.queue,
          baseUpdate: hook.baseUpdate,
          next: null
        };
      }

      function createWorkInProgressHook() {
        if (workInProgressHook === null) {
          if (firstWorkInProgressHook === null) {
            isReRender = false;
            currentHook = firstCurrentHook;

            if (currentHook === null) {
              workInProgressHook = createHook();
            } else {
              workInProgressHook = cloneHook(currentHook);
            }

            firstWorkInProgressHook = workInProgressHook;
          } else {
            isReRender = true;
            currentHook = firstCurrentHook;
            workInProgressHook = firstWorkInProgressHook;
          }
        } else {
          if (workInProgressHook.next === null) {
            isReRender = false;
            var hook = void 0;

            if (currentHook === null) {
              hook = createHook();
            } else {
              currentHook = currentHook.next;

              if (currentHook === null) {
                hook = createHook();
              } else {
                hook = cloneHook(currentHook);
              }
            }

            workInProgressHook = workInProgressHook.next = hook;
          } else {
            isReRender = true;
            workInProgressHook = workInProgressHook.next;
            currentHook = currentHook !== null ? currentHook.next : null;
          }
        }

        return workInProgressHook;
      }

      function createFunctionComponentUpdateQueue() {
        return {
          lastEffect: null
        };
      }

      function basicStateReducer(state, action) {
        return typeof action === "function" ? action(state) : action;
      }

      function useContext(context, observedBits) {
        resolveCurrentlyRenderingFiber();
        return readContext(context, observedBits);
      }

      function useState(initialState) {
        return useReducer(basicStateReducer, initialState);
      }

      function useReducer(reducer, initialState, initialAction) {
        currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
        workInProgressHook = createWorkInProgressHook();
        var queue = workInProgressHook.queue;

        if (queue !== null) {
          if (isReRender) {
            var _dispatch2 = queue.dispatch;

            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);

              if (firstRenderPhaseUpdate !== undefined) {
                renderPhaseUpdates.delete(queue);
                var newState = workInProgressHook.memoizedState;
                var update = firstRenderPhaseUpdate;

                do {
                  var _action = update.action;
                  newState = reducer(newState, _action);
                  update = update.next;
                } while (update !== null);

                workInProgressHook.memoizedState = newState;

                if (workInProgressHook.baseUpdate === queue.last) {
                  workInProgressHook.baseState = newState;
                }

                return [newState, _dispatch2];
              }
            }

            return [workInProgressHook.memoizedState, _dispatch2];
          }

          var _last = queue.last;
          var _baseUpdate = workInProgressHook.baseUpdate;
          var first = void 0;

          if (_baseUpdate !== null) {
            if (_last !== null) {
              _last.next = null;
            }

            first = _baseUpdate.next;
          } else {
            first = _last !== null ? _last.next : null;
          }

          if (first !== null) {
            var _newState = workInProgressHook.baseState;
            var newBaseState = null;
            var newBaseUpdate = null;
            var prevUpdate = _baseUpdate;
            var _update = first;
            var didSkip = false;

            do {
              var updateExpirationTime = _update.expirationTime;

              if (updateExpirationTime < renderExpirationTime) {
                if (!didSkip) {
                  didSkip = true;
                  newBaseUpdate = prevUpdate;
                  newBaseState = _newState;
                }

                if (updateExpirationTime > remainingExpirationTime) {
                  remainingExpirationTime = updateExpirationTime;
                }
              } else {
                var _action2 = _update.action;
                _newState = reducer(_newState, _action2);
              }

              prevUpdate = _update;
              _update = _update.next;
            } while (_update !== null && _update !== first);

            if (!didSkip) {
              newBaseUpdate = prevUpdate;
              newBaseState = _newState;
            }

            workInProgressHook.memoizedState = _newState;
            workInProgressHook.baseUpdate = newBaseUpdate;
            workInProgressHook.baseState = newBaseState;
          }

          var _dispatch = queue.dispatch;
          return [workInProgressHook.memoizedState, _dispatch];
        }

        if (reducer === basicStateReducer) {
          if (typeof initialState === "function") {
            initialState = initialState();
          }
        } else if (initialAction !== undefined && initialAction !== null) {
          initialState = reducer(initialState, initialAction);
        }

        workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;
        queue = workInProgressHook.queue = {
          last: null,
          dispatch: null
        };
        var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
        return [workInProgressHook.memoizedState, dispatch];
      }

      function pushEffect(tag, create, destroy, inputs) {
        var effect = {
          tag: tag,
          create: create,
          destroy: destroy,
          inputs: inputs,
          next: null
        };

        if (componentUpdateQueue === null) {
          componentUpdateQueue = createFunctionComponentUpdateQueue();
          componentUpdateQueue.lastEffect = effect.next = effect;
        } else {
          var _lastEffect = componentUpdateQueue.lastEffect;

          if (_lastEffect === null) {
            componentUpdateQueue.lastEffect = effect.next = effect;
          } else {
            var firstEffect = _lastEffect.next;
            _lastEffect.next = effect;
            effect.next = firstEffect;
            componentUpdateQueue.lastEffect = effect;
          }
        }

        return effect;
      }

      function useRef(initialValue) {
        currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
        workInProgressHook = createWorkInProgressHook();
        var ref = void 0;

        if (workInProgressHook.memoizedState === null) {
          ref = {
            current: initialValue
          };
          {
            Object.seal(ref);
          }
          workInProgressHook.memoizedState = ref;
        } else {
          ref = workInProgressHook.memoizedState;
        }

        return ref;
      }

      function useMutationEffect(create, inputs) {
        useEffectImpl(Snapshot | Update, UnmountSnapshot | MountMutation, create, inputs);
      }

      function useLayoutEffect(create, inputs) {
        useEffectImpl(Update, UnmountMutation | MountLayout, create, inputs);
      }

      function useEffect(create, inputs) {
        useEffectImpl(Update | Passive, UnmountPassive | MountPassive, create, inputs);
      }

      function useEffectImpl(fiberEffectTag, hookEffectTag, create, inputs) {
        currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
        workInProgressHook = createWorkInProgressHook();
        var nextInputs = inputs !== undefined && inputs !== null ? inputs : [create];
        var destroy = null;

        if (currentHook !== null) {
          var prevEffect = currentHook.memoizedState;
          destroy = prevEffect.destroy;

          if (areHookInputsEqual(nextInputs, prevEffect.inputs)) {
            pushEffect(NoEffect$1, create, destroy, nextInputs);
            return;
          }
        }

        currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
        workInProgressHook.memoizedState = pushEffect(hookEffectTag, create, destroy, nextInputs);
      }

      function useImperativeMethods(ref, create, inputs) {
        var nextInputs = inputs !== null && inputs !== undefined ? inputs.concat([ref]) : [ref, create];
        useEffectImpl(Update, UnmountMutation | MountLayout, function () {
          if (typeof ref === "function") {
            var refCallback = ref;

            var _inst = create();

            refCallback(_inst);
            return function () {
              return refCallback(null);
            };
          } else if (ref !== null && ref !== undefined) {
            var refObject = ref;

            var _inst2 = create();

            refObject.current = _inst2;
            return function () {
              refObject.current = null;
            };
          }
        }, nextInputs);
      }

      function useCallback(callback, inputs) {
        currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
        workInProgressHook = createWorkInProgressHook();
        var nextInputs = inputs !== undefined && inputs !== null ? inputs : [callback];
        var prevState = workInProgressHook.memoizedState;

        if (prevState !== null) {
          var prevInputs = prevState[1];

          if (areHookInputsEqual(nextInputs, prevInputs)) {
            return prevState[0];
          }
        }

        workInProgressHook.memoizedState = [callback, nextInputs];
        return callback;
      }

      function useMemo(nextCreate, inputs) {
        currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
        workInProgressHook = createWorkInProgressHook();
        var nextInputs = inputs !== undefined && inputs !== null ? inputs : [nextCreate];
        var prevState = workInProgressHook.memoizedState;

        if (prevState !== null) {
          var prevInputs = prevState[1];

          if (areHookInputsEqual(nextInputs, prevInputs)) {
            return prevState[0];
          }
        }

        var nextValue = nextCreate();
        workInProgressHook.memoizedState = [nextValue, nextInputs];
        return nextValue;
      }

      function dispatchAction(fiber, queue, action) {
        invariant(numberOfReRenders < RE_RENDER_LIMIT, "Too many re-renders. React limits the number of renders to prevent " + "an infinite loop.");
        var alternate = fiber.alternate;

        if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) {
          didScheduleRenderPhaseUpdate = true;
          var update = {
            expirationTime: renderExpirationTime,
            action: action,
            next: null
          };

          if (renderPhaseUpdates === null) {
            renderPhaseUpdates = new Map();
          }

          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);

          if (firstRenderPhaseUpdate === undefined) {
            renderPhaseUpdates.set(queue, update);
          } else {
            var lastRenderPhaseUpdate = firstRenderPhaseUpdate;

            while (lastRenderPhaseUpdate.next !== null) {
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            }

            lastRenderPhaseUpdate.next = update;
          }
        } else {
          var currentTime = requestCurrentTime();

          var _expirationTime = computeExpirationForFiber(currentTime, fiber);

          var _update2 = {
            expirationTime: _expirationTime,
            action: action,
            next: null
          };
          flushPassiveEffects();
          var _last2 = queue.last;

          if (_last2 === null) {
            _update2.next = _update2;
          } else {
            var first = _last2.next;

            if (first !== null) {
              _update2.next = first;
            }

            _last2.next = _update2;
          }

          queue.last = _update2;
          scheduleWork(fiber, _expirationTime);
        }
      }

      var NO_CONTEXT = {};
      var contextStackCursor$1 = createCursor(NO_CONTEXT);
      var contextFiberStackCursor = createCursor(NO_CONTEXT);
      var rootInstanceStackCursor = createCursor(NO_CONTEXT);

      function requiredContext(c) {
        invariant(c !== NO_CONTEXT, "Expected host context to exist. This error is likely caused by a bug " + "in React. Please file an issue.");
        return c;
      }

      function getRootHostContainer() {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        return rootInstance;
      }

      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance, fiber);
        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor$1, NO_CONTEXT, fiber);
        var nextRootContext = getRootHostContext(nextRootInstance);
        pop(contextStackCursor$1, fiber);
        push(contextStackCursor$1, nextRootContext, fiber);
      }

      function popHostContainer(fiber) {
        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
        pop(rootInstanceStackCursor, fiber);
      }

      function getHostContext() {
        var context = requiredContext(contextStackCursor$1.current);
        return context;
      }

      function pushHostContext(fiber) {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        var context = requiredContext(contextStackCursor$1.current);
        var nextContext = getChildHostContext(context, fiber.type, rootInstance);

        if (context === nextContext) {
          return;
        }

        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor$1, nextContext, fiber);
      }

      function popHostContext(fiber) {
        if (contextFiberStackCursor.current !== fiber) {
          return;
        }

        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
      }

      var commitTime = 0;
      var profilerStartTime = -1;

      function getCommitTime() {
        return commitTime;
      }

      function recordCommitTime() {
        if (!enableProfilerTimer) {
          return;
        }

        commitTime = now();
      }

      function startProfilerTimer(fiber) {
        if (!enableProfilerTimer) {
          return;
        }

        profilerStartTime = now();

        if (fiber.actualStartTime < 0) {
          fiber.actualStartTime = now();
        }
      }

      function stopProfilerTimerIfRunning(fiber) {
        if (!enableProfilerTimer) {
          return;
        }

        profilerStartTime = -1;
      }

      function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
        if (!enableProfilerTimer) {
          return;
        }

        if (profilerStartTime >= 0) {
          var elapsedTime = now() - profilerStartTime;
          fiber.actualDuration += elapsedTime;

          if (overrideBaseTime) {
            fiber.selfBaseDuration = elapsedTime;
          }

          profilerStartTime = -1;
        }
      }

      var hasOwnProperty = Object.prototype.hasOwnProperty;

      function is(x, y) {
        if (x === y) {
          return x !== 0 || y !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }

      function shallowEqual(objA, objB) {
        if (is(objA, objB)) {
          return true;
        }

        if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
          return false;
        }

        var keysA = Object.keys(objA);
        var keysB = Object.keys(objB);

        if (keysA.length !== keysB.length) {
          return false;
        }

        for (var i = 0; i < keysA.length; i++) {
          if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
            return false;
          }
        }

        return true;
      }

      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = _extends({}, baseProps);

          var defaultProps = Component.defaultProps;

          for (var propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }

          return props;
        }

        return baseProps;
      }

      function readLazyComponentType(lazyComponent) {
        var status = lazyComponent._status;
        var result = lazyComponent._result;

        switch (status) {
          case Resolved:
            {
              var Component = result;
              return Component;
            }

          case Rejected:
            {
              var error = result;
              throw error;
            }

          case Pending:
            {
              var thenable = result;
              throw thenable;
            }

          default:
            {
              lazyComponent._status = Pending;
              var ctor = lazyComponent._ctor;

              var _thenable = ctor();

              _thenable.then(function (moduleObject) {
                if (lazyComponent._status === Pending) {
                  var defaultExport = moduleObject.default;
                  {
                    if (defaultExport === undefined) {
                      warning$1(false, "lazy: Expected the result of a dynamic import() call. " + "Instead received: %s\n\nYour code should look like: \n  " + "const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                    }
                  }
                  lazyComponent._status = Resolved;
                  lazyComponent._result = defaultExport;
                }
              }, function (error) {
                if (lazyComponent._status === Pending) {
                  lazyComponent._status = Rejected;
                  lazyComponent._result = error;
                }
              });

              lazyComponent._result = _thenable;
              throw _thenable;
            }
        }
      }

      var ReactCurrentOwner$4 = ReactSharedInternals.ReactCurrentOwner;

      function readContext$1(contextType) {
        var dispatcher = ReactCurrentOwner$4.currentDispatcher;
        return dispatcher.readContext(contextType);
      }

      var fakeInternalInstance = {};
      var isArray$1 = Array.isArray;
      var emptyRefsObject = new React.Component().refs;
      var didWarnAboutStateAssignmentForComponent = void 0;
      var didWarnAboutUninitializedState = void 0;
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;
      var didWarnAboutLegacyLifecyclesAndDerivedState = void 0;
      var didWarnAboutUndefinedDerivedState = void 0;
      var warnOnUndefinedDerivedState = void 0;
      var warnOnInvalidCallback = void 0;
      var didWarnAboutDirectlyAssigningPropsToState = void 0;
      var didWarnAboutContextTypeAndContextTypes = void 0;
      var didWarnAboutInvalidateContextType = void 0;
      {
        didWarnAboutStateAssignmentForComponent = new Set();
        didWarnAboutUninitializedState = new Set();
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
        didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
        didWarnAboutDirectlyAssigningPropsToState = new Set();
        didWarnAboutUndefinedDerivedState = new Set();
        didWarnAboutContextTypeAndContextTypes = new Set();
        didWarnAboutInvalidateContextType = new Set();
        var didWarnOnInvalidCallback = new Set();

        warnOnInvalidCallback = function warnOnInvalidCallback(callback, callerName) {
          if (callback === null || typeof callback === "function") {
            return;
          }

          var key = callerName + "_" + callback;

          if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            warningWithoutStack$1(false, "%s(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callerName, callback);
          }
        };

        warnOnUndefinedDerivedState = function warnOnUndefinedDerivedState(type, partialState) {
          if (partialState === undefined) {
            var componentName = getComponentName(type) || "Component";

            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
              didWarnAboutUndefinedDerivedState.add(componentName);
              warningWithoutStack$1(false, "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. " + "You have returned undefined.", componentName);
            }
          }
        };

        Object.defineProperty(fakeInternalInstance, "_processChildContext", {
          enumerable: false,
          value: function value() {
            invariant(false, "_processChildContext is not available in React 16+. This likely " + "means you have multiple copies of React and are attempting to nest " + "a React 15 tree inside a React 16 tree using " + "unstable_renderSubtreeIntoContainer, which isn't supported. Try " + "to make sure you have only one copy of React (and ideally, switch " + "to ReactDOM.createPortal).");
          }
        });
        Object.freeze(fakeInternalInstance);
      }

      function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
        var prevState = workInProgress.memoizedState;
        {
          if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
            getDerivedStateFromProps(nextProps, prevState);
          }
        }
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        {
          warnOnUndefinedDerivedState(ctor, partialState);
        }
        var memoizedState = partialState === null || partialState === undefined ? prevState : _extends({}, prevState, partialState);
        workInProgress.memoizedState = memoizedState;
        var updateQueue = workInProgress.updateQueue;

        if (updateQueue !== null && workInProgress.expirationTime === NoWork) {
          updateQueue.baseState = memoizedState;
        }
      }

      var classComponentUpdater = {
        isMounted: isMounted,
        enqueueSetState: function enqueueSetState(inst, payload, callback) {
          var fiber = get$1(inst);
          var currentTime = requestCurrentTime();
          var expirationTime = computeExpirationForFiber(currentTime, fiber);
          var update = createUpdate(expirationTime);
          update.payload = payload;

          if (callback !== undefined && callback !== null) {
            {
              warnOnInvalidCallback(callback, "setState");
            }
            update.callback = callback;
          }

          flushPassiveEffects();
          enqueueUpdate(fiber, update);
          scheduleWork(fiber, expirationTime);
        },
        enqueueReplaceState: function enqueueReplaceState(inst, payload, callback) {
          var fiber = get$1(inst);
          var currentTime = requestCurrentTime();
          var expirationTime = computeExpirationForFiber(currentTime, fiber);
          var update = createUpdate(expirationTime);
          update.tag = ReplaceState;
          update.payload = payload;

          if (callback !== undefined && callback !== null) {
            {
              warnOnInvalidCallback(callback, "replaceState");
            }
            update.callback = callback;
          }

          flushPassiveEffects();
          enqueueUpdate(fiber, update);
          scheduleWork(fiber, expirationTime);
        },
        enqueueForceUpdate: function enqueueForceUpdate(inst, callback) {
          var fiber = get$1(inst);
          var currentTime = requestCurrentTime();
          var expirationTime = computeExpirationForFiber(currentTime, fiber);
          var update = createUpdate(expirationTime);
          update.tag = ForceUpdate;

          if (callback !== undefined && callback !== null) {
            {
              warnOnInvalidCallback(callback, "forceUpdate");
            }
            update.callback = callback;
          }

          flushPassiveEffects();
          enqueueUpdate(fiber, update);
          scheduleWork(fiber, expirationTime);
        }
      };

      function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
        var instance = workInProgress.stateNode;

        if (typeof instance.shouldComponentUpdate === "function") {
          startPhaseTimer(workInProgress, "shouldComponentUpdate");
          var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
          stopPhaseTimer();
          {
            !(shouldUpdate !== undefined) ? warningWithoutStack$1(false, "%s.shouldComponentUpdate(): Returned undefined instead of a " + "boolean value. Make sure to return true or false.", getComponentName(ctor) || "Component") : void 0;
          }
          return shouldUpdate;
        }

        if (ctor.prototype && ctor.prototype.isPureReactComponent) {
          return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
        }

        return true;
      }

      function checkClassInstance(workInProgress, ctor, newProps) {
        var instance = workInProgress.stateNode;
        {
          var name = getComponentName(ctor) || "Component";
          var renderPresent = instance.render;

          if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === "function") {
              warningWithoutStack$1(false, "%s(...): No `render` method found on the returned component " + "instance: did you accidentally return an object from the constructor?", name);
            } else {
              warningWithoutStack$1(false, "%s(...): No `render` method found on the returned component " + "instance: you may have forgotten to define `render`.", name);
            }
          }

          var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
          !noGetInitialStateOnES6 ? warningWithoutStack$1(false, "getInitialState was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Did you mean to define a state property instead?", name) : void 0;
          var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
          !noGetDefaultPropsOnES6 ? warningWithoutStack$1(false, "getDefaultProps was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Use a static property to define defaultProps instead.", name) : void 0;
          var noInstancePropTypes = !instance.propTypes;
          !noInstancePropTypes ? warningWithoutStack$1(false, "propTypes was defined as an instance property on %s. Use a static " + "property to define propTypes instead.", name) : void 0;
          var noInstanceContextType = !instance.contextType;
          !noInstanceContextType ? warningWithoutStack$1(false, "contextType was defined as an instance property on %s. Use a static " + "property to define contextType instead.", name) : void 0;
          var noInstanceContextTypes = !instance.contextTypes;
          !noInstanceContextTypes ? warningWithoutStack$1(false, "contextTypes was defined as an instance property on %s. Use a static " + "property to define contextTypes instead.", name) : void 0;

          if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
            didWarnAboutContextTypeAndContextTypes.add(ctor);
            warningWithoutStack$1(false, "%s declares both contextTypes and contextType static properties. " + "The legacy contextTypes property will be ignored.", name);
          }

          var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== "function";
          !noComponentShouldUpdate ? warningWithoutStack$1(false, "%s has a method called " + "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " + "The name is phrased as a question because the function is " + "expected to return a value.", name) : void 0;

          if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
            warningWithoutStack$1(false, "%s has a method called shouldComponentUpdate(). " + "shouldComponentUpdate should not be used when extending React.PureComponent. " + "Please extend React.Component if shouldComponentUpdate is used.", getComponentName(ctor) || "A pure component");
          }

          var noComponentDidUnmount = typeof instance.componentDidUnmount !== "function";
          !noComponentDidUnmount ? warningWithoutStack$1(false, "%s has a method called " + "componentDidUnmount(). But there is no such lifecycle method. " + "Did you mean componentWillUnmount()?", name) : void 0;
          var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== "function";
          !noComponentDidReceiveProps ? warningWithoutStack$1(false, "%s has a method called " + "componentDidReceiveProps(). But there is no such lifecycle method. " + "If you meant to update the state in response to changing props, " + "use componentWillReceiveProps(). If you meant to fetch data or " + "run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name) : void 0;
          var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== "function";
          !noComponentWillRecieveProps ? warningWithoutStack$1(false, "%s has a method called " + "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name) : void 0;
          var noUnsafeComponentWillRecieveProps = typeof instance.UNSAFE_componentWillRecieveProps !== "function";
          !noUnsafeComponentWillRecieveProps ? warningWithoutStack$1(false, "%s has a method called " + "UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name) : void 0;
          var hasMutatedProps = instance.props !== newProps;
          !(instance.props === undefined || !hasMutatedProps) ? warningWithoutStack$1(false, "%s(...): When calling super() in `%s`, make sure to pass " + "up the same props that your component's constructor was passed.", name, name) : void 0;
          var noInstanceDefaultProps = !instance.defaultProps;
          !noInstanceDefaultProps ? warningWithoutStack$1(false, "Setting defaultProps as an instance property on %s is not supported and will be ignored." + " Instead, define defaultProps as a static property on %s.", name, name) : void 0;

          if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            warningWithoutStack$1(false, "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). " + "This component defines getSnapshotBeforeUpdate() only.", getComponentName(ctor));
          }

          var noInstanceGetDerivedStateFromProps = typeof instance.getDerivedStateFromProps !== "function";
          !noInstanceGetDerivedStateFromProps ? warningWithoutStack$1(false, "%s: getDerivedStateFromProps() is defined as an instance method " + "and will be ignored. Instead, declare it as a static method.", name) : void 0;
          var noInstanceGetDerivedStateFromCatch = typeof instance.getDerivedStateFromError !== "function";
          !noInstanceGetDerivedStateFromCatch ? warningWithoutStack$1(false, "%s: getDerivedStateFromError() is defined as an instance method " + "and will be ignored. Instead, declare it as a static method.", name) : void 0;
          var noStaticGetSnapshotBeforeUpdate = typeof ctor.getSnapshotBeforeUpdate !== "function";
          !noStaticGetSnapshotBeforeUpdate ? warningWithoutStack$1(false, "%s: getSnapshotBeforeUpdate() is defined as a static method " + "and will be ignored. Instead, declare it as an instance method.", name) : void 0;
          var _state = instance.state;

          if (_state && (typeof _state !== "object" || isArray$1(_state))) {
            warningWithoutStack$1(false, "%s.state: must be set to an object or null", name);
          }

          if (typeof instance.getChildContext === "function") {
            !(typeof ctor.childContextTypes === "object") ? warningWithoutStack$1(false, "%s.getChildContext(): childContextTypes must be defined in order to " + "use getChildContext().", name) : void 0;
          }
        }
      }

      function adoptClassInstance(workInProgress, instance) {
        instance.updater = classComponentUpdater;
        workInProgress.stateNode = instance;
        set(instance, workInProgress);
        {
          instance._reactInternalInstance = fakeInternalInstance;
        }
      }

      function constructClassInstance(workInProgress, ctor, props, renderExpirationTime) {
        var isLegacyContextConsumer = false;
        var unmaskedContext = emptyContextObject;
        var context = null;
        var contextType = ctor.contextType;

        if (typeof contextType === "object" && contextType !== null) {
          {
            if (contextType.$$typeof !== REACT_CONTEXT_TYPE && !didWarnAboutInvalidateContextType.has(ctor)) {
              didWarnAboutInvalidateContextType.add(ctor);
              warningWithoutStack$1(false, "%s defines an invalid contextType. " + "contextType should point to the Context object returned by React.createContext(). " + "Did you accidentally pass the Context.Provider instead?", getComponentName(ctor) || "Component");
            }
          }
          context = readContext$1(contextType);
        } else {
          unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
          var contextTypes = ctor.contextTypes;
          isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;
          context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;
        }

        {
          if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
            new ctor(props, context);
          }
        }
        var instance = new ctor(props, context);
        var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;
        adoptClassInstance(workInProgress, instance);
        {
          if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
            var componentName = getComponentName(ctor) || "Component";

            if (!didWarnAboutUninitializedState.has(componentName)) {
              didWarnAboutUninitializedState.add(componentName);
              warningWithoutStack$1(false, "`%s` uses `getDerivedStateFromProps` but its initial state is " + "%s. This is not recommended. Instead, define the initial state by " + "assigning an object to `this.state` in the constructor of `%s`. " + "This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
            }
          }

          if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;

            if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
              foundWillMountName = "componentWillMount";
            } else if (typeof instance.UNSAFE_componentWillMount === "function") {
              foundWillMountName = "UNSAFE_componentWillMount";
            }

            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              foundWillReceivePropsName = "componentWillReceiveProps";
            } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
            }

            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              foundWillUpdateName = "componentWillUpdate";
            } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              foundWillUpdateName = "UNSAFE_componentWillUpdate";
            }

            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentName(ctor) || "Component";

              var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";

              if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                warningWithoutStack$1(false, "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + "%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n" + "The above lifecycles should be removed. Learn more about this warning here:\n" + "https://fb.me/react-async-component-lifecycle-hooks", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
              }
            }
          }
        }

        if (isLegacyContextConsumer) {
          cacheContext(workInProgress, unmaskedContext, context);
        }

        return instance;
      }

      function callComponentWillMount(workInProgress, instance) {
        startPhaseTimer(workInProgress, "componentWillMount");
        var oldState = instance.state;

        if (typeof instance.componentWillMount === "function") {
          instance.componentWillMount();
        }

        if (typeof instance.UNSAFE_componentWillMount === "function") {
          instance.UNSAFE_componentWillMount();
        }

        stopPhaseTimer();

        if (oldState !== instance.state) {
          {
            warningWithoutStack$1(false, "%s.componentWillMount(): Assigning directly to this.state is " + "deprecated (except inside a component's " + "constructor). Use setState instead.", getComponentName(workInProgress.type) || "Component");
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }

      function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
        var oldState = instance.state;
        startPhaseTimer(workInProgress, "componentWillReceiveProps");

        if (typeof instance.componentWillReceiveProps === "function") {
          instance.componentWillReceiveProps(newProps, nextContext);
        }

        if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
          instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        }

        stopPhaseTimer();

        if (instance.state !== oldState) {
          {
            var componentName = getComponentName(workInProgress.type) || "Component";

            if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
              didWarnAboutStateAssignmentForComponent.add(componentName);
              warningWithoutStack$1(false, "%s.componentWillReceiveProps(): Assigning directly to " + "this.state is deprecated (except inside a component's " + "constructor). Use setState instead.", componentName);
            }
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }

      function mountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
        {
          checkClassInstance(workInProgress, ctor, newProps);
        }
        var instance = workInProgress.stateNode;
        instance.props = newProps;
        instance.state = workInProgress.memoizedState;
        instance.refs = emptyRefsObject;
        var contextType = ctor.contextType;

        if (typeof contextType === "object" && contextType !== null) {
          instance.context = readContext$1(contextType);
        } else {
          var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
          instance.context = getMaskedContext(workInProgress, unmaskedContext);
        }

        {
          if (instance.state === newProps) {
            var componentName = getComponentName(ctor) || "Component";

            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
              didWarnAboutDirectlyAssigningPropsToState.add(componentName);
              warningWithoutStack$1(false, "%s: It is not recommended to assign props directly to state " + "because updates to props won't be reflected in state. " + "In most cases, it is better to use props directly.", componentName);
            }
          }

          if (workInProgress.mode & StrictMode) {
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);
            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);
          }

          if (warnAboutDeprecatedLifecycles) {
            ReactStrictModeWarnings.recordDeprecationWarnings(workInProgress, instance);
          }
        }
        var updateQueue = workInProgress.updateQueue;

        if (updateQueue !== null) {
          processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
          instance.state = workInProgress.memoizedState;
        }

        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;

        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
          instance.state = workInProgress.memoizedState;
        }

        if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
          callComponentWillMount(workInProgress, instance);
          updateQueue = workInProgress.updateQueue;

          if (updateQueue !== null) {
            processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
            instance.state = workInProgress.memoizedState;
          }
        }

        if (typeof instance.componentDidMount === "function") {
          workInProgress.effectTag |= Update;
        }
      }

      function resumeMountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
        var instance = workInProgress.stateNode;
        var oldProps = workInProgress.memoizedProps;
        instance.props = oldProps;
        var oldContext = instance.context;
        var contextType = ctor.contextType;
        var nextContext = void 0;

        if (typeof contextType === "object" && contextType !== null) {
          nextContext = readContext$1(contextType);
        } else {
          var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
          nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
        }

        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";

        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
          if (oldProps !== newProps || oldContext !== nextContext) {
            callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
          }
        }

        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress.memoizedState;
        var newState = instance.state = oldState;
        var updateQueue = workInProgress.updateQueue;

        if (updateQueue !== null) {
          processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
          newState = workInProgress.memoizedState;
        }

        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
          if (typeof instance.componentDidMount === "function") {
            workInProgress.effectTag |= Update;
          }

          return false;
        }

        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
          newState = workInProgress.memoizedState;
        }

        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

        if (shouldUpdate) {
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            startPhaseTimer(workInProgress, "componentWillMount");

            if (typeof instance.componentWillMount === "function") {
              instance.componentWillMount();
            }

            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }

            stopPhaseTimer();
          }

          if (typeof instance.componentDidMount === "function") {
            workInProgress.effectTag |= Update;
          }
        } else {
          if (typeof instance.componentDidMount === "function") {
            workInProgress.effectTag |= Update;
          }

          workInProgress.memoizedProps = newProps;
          workInProgress.memoizedState = newState;
        }

        instance.props = newProps;
        instance.state = newState;
        instance.context = nextContext;
        return shouldUpdate;
      }

      function updateClassInstance(current, workInProgress, ctor, newProps, renderExpirationTime) {
        var instance = workInProgress.stateNode;
        var oldProps = workInProgress.memoizedProps;
        instance.props = workInProgress.type === workInProgress.elementType ? oldProps : resolveDefaultProps(workInProgress.type, oldProps);
        var oldContext = instance.context;
        var contextType = ctor.contextType;
        var nextContext = void 0;

        if (typeof contextType === "object" && contextType !== null) {
          nextContext = readContext$1(contextType);
        } else {
          var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
          nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
        }

        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";

        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
          if (oldProps !== newProps || oldContext !== nextContext) {
            callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
          }
        }

        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress.memoizedState;
        var newState = instance.state = oldState;
        var updateQueue = workInProgress.updateQueue;

        if (updateQueue !== null) {
          processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
          newState = workInProgress.memoizedState;
        }

        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
          if (typeof instance.componentDidUpdate === "function") {
            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
              workInProgress.effectTag |= Update;
            }
          }

          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
              workInProgress.effectTag |= Snapshot;
            }
          }

          return false;
        }

        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
          newState = workInProgress.memoizedState;
        }

        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

        if (shouldUpdate) {
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
            startPhaseTimer(workInProgress, "componentWillUpdate");

            if (typeof instance.componentWillUpdate === "function") {
              instance.componentWillUpdate(newProps, newState, nextContext);
            }

            if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
            }

            stopPhaseTimer();
          }

          if (typeof instance.componentDidUpdate === "function") {
            workInProgress.effectTag |= Update;
          }

          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            workInProgress.effectTag |= Snapshot;
          }
        } else {
          if (typeof instance.componentDidUpdate === "function") {
            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
              workInProgress.effectTag |= Update;
            }
          }

          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
              workInProgress.effectTag |= Snapshot;
            }
          }

          workInProgress.memoizedProps = newProps;
          workInProgress.memoizedState = newState;
        }

        instance.props = newProps;
        instance.state = newState;
        instance.context = nextContext;
        return shouldUpdate;
      }

      var didWarnAboutMaps = void 0;
      var didWarnAboutGenerators = void 0;
      var didWarnAboutStringRefInStrictMode = void 0;
      var ownerHasKeyUseWarning = void 0;
      var ownerHasFunctionTypeWarning = void 0;

      var warnForMissingKey = function warnForMissingKey(child) {};

      {
        didWarnAboutMaps = false;
        didWarnAboutGenerators = false;
        didWarnAboutStringRefInStrictMode = {};
        ownerHasKeyUseWarning = {};
        ownerHasFunctionTypeWarning = {};

        warnForMissingKey = function warnForMissingKey(child) {
          if (child === null || typeof child !== "object") {
            return;
          }

          if (!child._store || child._store.validated || child.key != null) {
            return;
          }

          invariant(typeof child._store === "object", "React Component in warnForMissingKey should have a _store. " + "This error is likely caused by a bug in React. Please file an issue.");
          child._store.validated = true;
          var currentComponentErrorInfo = "Each child in an array or iterator should have a unique " + '"key" prop. See https://fb.me/react-warning-keys for ' + "more information." + getCurrentFiberStackInDev();

          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }

          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          warning$1(false, "Each child in an array or iterator should have a unique " + '"key" prop. See https://fb.me/react-warning-keys for ' + "more information.");
        };
      }
      var isArray = Array.isArray;

      function coerceRef(returnFiber, current$$1, element) {
        var mixedRef = element.ref;

        if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
          {
            if (returnFiber.mode & StrictMode) {
              var componentName = getComponentName(returnFiber.type) || "Component";

              if (!didWarnAboutStringRefInStrictMode[componentName]) {
                warningWithoutStack$1(false, 'A string ref, "%s", has been found within a strict mode tree. ' + "String refs are a source of potential bugs and should be avoided. " + "We recommend using createRef() instead." + "\n%s" + "\n\nLearn more about using refs safely here:" + "\nhttps://fb.me/react-strict-mode-string-ref", mixedRef, getStackByFiberInDevAndProd(returnFiber));
                didWarnAboutStringRefInStrictMode[componentName] = true;
              }
            }
          }

          if (element._owner) {
            var owner = element._owner;
            var inst = void 0;

            if (owner) {
              var ownerFiber = owner;
              invariant(ownerFiber.tag === ClassComponent, "Function components cannot have refs.");
              inst = ownerFiber.stateNode;
            }

            invariant(inst, "Missing owner for string ref %s. This error is likely caused by a " + "bug in React. Please file an issue.", mixedRef);
            var stringRef = "" + mixedRef;

            if (current$$1 !== null && current$$1.ref !== null && typeof current$$1.ref === "function" && current$$1.ref._stringRef === stringRef) {
              return current$$1.ref;
            }

            var ref = function ref(value) {
              var refs = inst.refs;

              if (refs === emptyRefsObject) {
                refs = inst.refs = {};
              }

              if (value === null) {
                delete refs[stringRef];
              } else {
                refs[stringRef] = value;
              }
            };

            ref._stringRef = stringRef;
            return ref;
          } else {
            invariant(typeof mixedRef === "string", "Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
            invariant(element._owner, "Element ref was specified as a string (%s) but no owner was set. This could happen for one of" + " the following reasons:\n" + "1. You may be adding a ref to a function component\n" + "2. You may be adding a ref to a component that was not created inside a component's render method\n" + "3. You have multiple copies of React loaded\n" + "See https://fb.me/react-refs-must-have-owner for more information.", mixedRef);
          }
        }

        return mixedRef;
      }

      function throwOnInvalidObjectType(returnFiber, newChild) {
        if (returnFiber.type !== "textarea") {
          var addendum = "";
          {
            addendum = " If you meant to render a collection of children, use an array " + "instead." + getCurrentFiberStackInDev();
          }
          invariant(false, "Objects are not valid as a React child (found: %s).%s", Object.prototype.toString.call(newChild) === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : newChild, addendum);
        }
      }

      function warnOnFunctionType() {
        var currentComponentErrorInfo = "Functions are not valid as a React child. This may happen if " + "you return a Component instead of <Component /> from render. " + "Or maybe you meant to call this function rather than return it." + getCurrentFiberStackInDev();

        if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
          return;
        }

        ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;
        warning$1(false, "Functions are not valid as a React child. This may happen if " + "you return a Component instead of <Component /> from render. " + "Or maybe you meant to call this function rather than return it.");
      }

      function ChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (!shouldTrackSideEffects) {
            return;
          }

          var last = returnFiber.lastEffect;

          if (last !== null) {
            last.nextEffect = childToDelete;
            returnFiber.lastEffect = childToDelete;
          } else {
            returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
          }

          childToDelete.nextEffect = null;
          childToDelete.effectTag = Deletion;
        }

        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) {
            return null;
          }

          var childToDelete = currentFirstChild;

          while (childToDelete !== null) {
            deleteChild(returnFiber, childToDelete);
            childToDelete = childToDelete.sibling;
          }

          return null;
        }

        function mapRemainingChildren(returnFiber, currentFirstChild) {
          var existingChildren = new Map();
          var existingChild = currentFirstChild;

          while (existingChild !== null) {
            if (existingChild.key !== null) {
              existingChildren.set(existingChild.key, existingChild);
            } else {
              existingChildren.set(existingChild.index, existingChild);
            }

            existingChild = existingChild.sibling;
          }

          return existingChildren;
        }

        function useFiber(fiber, pendingProps, expirationTime) {
          var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
          clone.index = 0;
          clone.sibling = null;
          return clone;
        }

        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;

          if (!shouldTrackSideEffects) {
            return lastPlacedIndex;
          }

          var current$$1 = newFiber.alternate;

          if (current$$1 !== null) {
            var oldIndex = current$$1.index;

            if (oldIndex < lastPlacedIndex) {
              newFiber.effectTag = Placement;
              return lastPlacedIndex;
            } else {
              return oldIndex;
            }
          } else {
            newFiber.effectTag = Placement;
            return lastPlacedIndex;
          }
        }

        function placeSingleChild(newFiber) {
          if (shouldTrackSideEffects && newFiber.alternate === null) {
            newFiber.effectTag = Placement;
          }

          return newFiber;
        }

        function updateTextNode(returnFiber, current$$1, textContent, expirationTime) {
          if (current$$1 === null || current$$1.tag !== HostText) {
            var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current$$1, textContent, expirationTime);
            existing.return = returnFiber;
            return existing;
          }
        }

        function updateElement(returnFiber, current$$1, element, expirationTime) {
          if (current$$1 !== null && current$$1.elementType === element.type) {
            var existing = useFiber(current$$1, element.props, expirationTime);
            existing.ref = coerceRef(returnFiber, current$$1, element);
            existing.return = returnFiber;
            {
              existing._debugSource = element._source;
              existing._debugOwner = element._owner;
            }
            return existing;
          } else {
            var created = createFiberFromElement(element, returnFiber.mode, expirationTime);
            created.ref = coerceRef(returnFiber, current$$1, element);
            created.return = returnFiber;
            return created;
          }
        }

        function updatePortal(returnFiber, current$$1, portal, expirationTime) {
          if (current$$1 === null || current$$1.tag !== HostPortal || current$$1.stateNode.containerInfo !== portal.containerInfo || current$$1.stateNode.implementation !== portal.implementation) {
            var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current$$1, portal.children || [], expirationTime);
            existing.return = returnFiber;
            return existing;
          }
        }

        function updateFragment(returnFiber, current$$1, fragment, expirationTime, key) {
          if (current$$1 === null || current$$1.tag !== Fragment) {
            var created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current$$1, fragment, expirationTime);
            existing.return = returnFiber;
            return existing;
          }
        }

        function createChild(returnFiber, newChild, expirationTime) {
          if (typeof newChild === "string" || typeof newChild === "number") {
            var created = createFiberFromText("" + newChild, returnFiber.mode, expirationTime);
            created.return = returnFiber;
            return created;
          }

          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                {
                  var _created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);

                  _created.ref = coerceRef(returnFiber, null, newChild);
                  _created.return = returnFiber;
                  return _created;
                }

              case REACT_PORTAL_TYPE:
                {
                  var _created2 = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);

                  _created2.return = returnFiber;
                  return _created2;
                }
            }

            if (isArray(newChild) || getIteratorFn(newChild)) {
              var _created3 = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null);

              _created3.return = returnFiber;
              return _created3;
            }

            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }
          return null;
        }

        function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
          var key = oldFiber !== null ? oldFiber.key : null;

          if (typeof newChild === "string" || typeof newChild === "number") {
            if (key !== null) {
              return null;
            }

            return updateTextNode(returnFiber, oldFiber, "" + newChild, expirationTime);
          }

          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                {
                  if (newChild.key === key) {
                    if (newChild.type === REACT_FRAGMENT_TYPE) {
                      return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
                    }

                    return updateElement(returnFiber, oldFiber, newChild, expirationTime);
                  } else {
                    return null;
                  }
                }

              case REACT_PORTAL_TYPE:
                {
                  if (newChild.key === key) {
                    return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
                  } else {
                    return null;
                  }
                }
            }

            if (isArray(newChild) || getIteratorFn(newChild)) {
              if (key !== null) {
                return null;
              }

              return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
            }

            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }
          return null;
        }

        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
          if (typeof newChild === "string" || typeof newChild === "number") {
            var matchedFiber = existingChildren.get(newIdx) || null;
            return updateTextNode(returnFiber, matchedFiber, "" + newChild, expirationTime);
          }

          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                {
                  var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

                  if (newChild.type === REACT_FRAGMENT_TYPE) {
                    return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
                  }

                  return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
                }

              case REACT_PORTAL_TYPE:
                {
                  var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

                  return updatePortal(returnFiber, _matchedFiber2, newChild, expirationTime);
                }
            }

            if (isArray(newChild) || getIteratorFn(newChild)) {
              var _matchedFiber3 = existingChildren.get(newIdx) || null;

              return updateFragment(returnFiber, _matchedFiber3, newChild, expirationTime, null);
            }

            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }
          return null;
        }

        function warnOnInvalidKey(child, knownKeys) {
          {
            if (typeof child !== "object" || child === null) {
              return knownKeys;
            }

            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(child);
                var key = child.key;

                if (typeof key !== "string") {
                  break;
                }

                if (knownKeys === null) {
                  knownKeys = new Set();
                  knownKeys.add(key);
                  break;
                }

                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }

                warning$1(false, "Encountered two children with the same key, `%s`. " + "Keys should be unique so that components maintain their identity " + "across updates. Non-unique keys may cause children to be " + "duplicated and/or omitted — the behavior is unsupported and " + "could change in a future version.", key);
                break;

              default:
                break;
            }
          }
          return knownKeys;
        }

        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
          {
            var knownKeys = null;

            for (var i = 0; i < newChildren.length; i++) {
              var child = newChildren[i];
              knownKeys = warnOnInvalidKey(child, knownKeys);
            }
          }
          var resultingFirstChild = null;
          var previousNewFiber = null;
          var oldFiber = currentFirstChild;
          var lastPlacedIndex = 0;
          var newIdx = 0;
          var nextOldFiber = null;

          for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
            if (oldFiber.index > newIdx) {
              nextOldFiber = oldFiber;
              oldFiber = null;
            } else {
              nextOldFiber = oldFiber.sibling;
            }

            var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);

            if (newFiber === null) {
              if (oldFiber === null) {
                oldFiber = nextOldFiber;
              }

              break;
            }

            if (shouldTrackSideEffects) {
              if (oldFiber && newFiber.alternate === null) {
                deleteChild(returnFiber, oldFiber);
              }
            }

            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

            if (previousNewFiber === null) {
              resultingFirstChild = newFiber;
            } else {
              previousNewFiber.sibling = newFiber;
            }

            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }

          if (newIdx === newChildren.length) {
            deleteRemainingChildren(returnFiber, oldFiber);
            return resultingFirstChild;
          }

          if (oldFiber === null) {
            for (; newIdx < newChildren.length; newIdx++) {
              var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);

              if (!_newFiber) {
                continue;
              }

              lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber;
              } else {
                previousNewFiber.sibling = _newFiber;
              }

              previousNewFiber = _newFiber;
            }

            return resultingFirstChild;
          }

          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

          for (; newIdx < newChildren.length; newIdx++) {
            var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);

            if (_newFiber2) {
              if (shouldTrackSideEffects) {
                if (_newFiber2.alternate !== null) {
                  existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                }
              }

              lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber2;
              } else {
                previousNewFiber.sibling = _newFiber2;
              }

              previousNewFiber = _newFiber2;
            }
          }

          if (shouldTrackSideEffects) {
            existingChildren.forEach(function (child) {
              return deleteChild(returnFiber, child);
            });
          }

          return resultingFirstChild;
        }

        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
          var iteratorFn = getIteratorFn(newChildrenIterable);
          invariant(typeof iteratorFn === "function", "An object is not an iterable. This error is likely caused by a bug in " + "React. Please file an issue.");
          {
            if (typeof Symbol === "function" && newChildrenIterable[typeof Symbol === "function" ? Symbol.toStringTag : "@@toStringTag"] === "Generator") {
              !didWarnAboutGenerators ? warning$1(false, "Using Generators as children is unsupported and will likely yield " + "unexpected results because enumerating a generator mutates it. " + "You may convert it to an array with `Array.from()` or the " + "`[...spread]` operator before rendering. Keep in mind " + "you might need to polyfill these features for older browsers.") : void 0;
              didWarnAboutGenerators = true;
            }

            if (newChildrenIterable.entries === iteratorFn) {
              !didWarnAboutMaps ? warning$1(false, "Using Maps as children is unsupported and will likely yield " + "unexpected results. Convert it to a sequence/iterable of keyed " + "ReactElements instead.") : void 0;
              didWarnAboutMaps = true;
            }

            var _newChildren = iteratorFn.call(newChildrenIterable);

            if (_newChildren) {
              var knownKeys = null;

              var _step = _newChildren.next();

              for (; !_step.done; _step = _newChildren.next()) {
                var child = _step.value;
                knownKeys = warnOnInvalidKey(child, knownKeys);
              }
            }
          }
          var newChildren = iteratorFn.call(newChildrenIterable);
          invariant(newChildren != null, "An iterable object provided no iterator.");
          var resultingFirstChild = null;
          var previousNewFiber = null;
          var oldFiber = currentFirstChild;
          var lastPlacedIndex = 0;
          var newIdx = 0;
          var nextOldFiber = null;
          var step = newChildren.next();

          for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
            if (oldFiber.index > newIdx) {
              nextOldFiber = oldFiber;
              oldFiber = null;
            } else {
              nextOldFiber = oldFiber.sibling;
            }

            var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);

            if (newFiber === null) {
              if (!oldFiber) {
                oldFiber = nextOldFiber;
              }

              break;
            }

            if (shouldTrackSideEffects) {
              if (oldFiber && newFiber.alternate === null) {
                deleteChild(returnFiber, oldFiber);
              }
            }

            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

            if (previousNewFiber === null) {
              resultingFirstChild = newFiber;
            } else {
              previousNewFiber.sibling = newFiber;
            }

            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }

          if (step.done) {
            deleteRemainingChildren(returnFiber, oldFiber);
            return resultingFirstChild;
          }

          if (oldFiber === null) {
            for (; !step.done; newIdx++, step = newChildren.next()) {
              var _newFiber3 = createChild(returnFiber, step.value, expirationTime);

              if (_newFiber3 === null) {
                continue;
              }

              lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber3;
              } else {
                previousNewFiber.sibling = _newFiber3;
              }

              previousNewFiber = _newFiber3;
            }

            return resultingFirstChild;
          }

          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

          for (; !step.done; newIdx++, step = newChildren.next()) {
            var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);

            if (_newFiber4 !== null) {
              if (shouldTrackSideEffects) {
                if (_newFiber4.alternate !== null) {
                  existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                }
              }

              lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);

              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber4;
              } else {
                previousNewFiber.sibling = _newFiber4;
              }

              previousNewFiber = _newFiber4;
            }
          }

          if (shouldTrackSideEffects) {
            existingChildren.forEach(function (child) {
              return deleteChild(returnFiber, child);
            });
          }

          return resultingFirstChild;
        }

        function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
          if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
            var existing = useFiber(currentFirstChild, textContent, expirationTime);
            existing.return = returnFiber;
            return existing;
          }

          deleteRemainingChildren(returnFiber, currentFirstChild);
          var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
          created.return = returnFiber;
          return created;
        }

        function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
          var key = element.key;
          var child = currentFirstChild;

          while (child !== null) {
            if (child.key === key) {
              if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.elementType === element.type) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
                existing.ref = coerceRef(returnFiber, child, element);
                existing.return = returnFiber;
                {
                  existing._debugSource = element._source;
                  existing._debugOwner = element._owner;
                }
                return existing;
              } else {
                deleteRemainingChildren(returnFiber, child);
                break;
              }
            } else {
              deleteChild(returnFiber, child);
            }

            child = child.sibling;
          }

          if (element.type === REACT_FRAGMENT_TYPE) {
            var created = createFiberFromFragment(element.props.children, returnFiber.mode, expirationTime, element.key);
            created.return = returnFiber;
            return created;
          } else {
            var _created4 = createFiberFromElement(element, returnFiber.mode, expirationTime);

            _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
            _created4.return = returnFiber;
            return _created4;
          }
        }

        function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
          var key = portal.key;
          var child = currentFirstChild;

          while (child !== null) {
            if (child.key === key) {
              if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, portal.children || [], expirationTime);
                existing.return = returnFiber;
                return existing;
              } else {
                deleteRemainingChildren(returnFiber, child);
                break;
              }
            } else {
              deleteChild(returnFiber, child);
            }

            child = child.sibling;
          }

          var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);
          created.return = returnFiber;
          return created;
        }

        function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
          var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;

          if (isUnkeyedTopLevelFragment) {
            newChild = newChild.props.children;
          }

          var isObject = typeof newChild === "object" && newChild !== null;

          if (isObject) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));

              case REACT_PORTAL_TYPE:
                return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
            }
          }

          if (typeof newChild === "string" || typeof newChild === "number") {
            return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, expirationTime));
          }

          if (isArray(newChild)) {
            return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
          }

          if (getIteratorFn(newChild)) {
            return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
          }

          if (isObject) {
            throwOnInvalidObjectType(returnFiber, newChild);
          }

          {
            if (typeof newChild === "function") {
              warnOnFunctionType();
            }
          }

          if (typeof newChild === "undefined" && !isUnkeyedTopLevelFragment) {
            switch (returnFiber.tag) {
              case ClassComponent:
                {
                  {
                    var instance = returnFiber.stateNode;

                    if (instance.render._isMockFunction) {
                      break;
                    }
                  }
                }

              case FunctionComponent:
                {
                  var Component = returnFiber.type;
                  invariant(false, "%s(...): Nothing was returned from render. This usually means a " + "return statement is missing. Or, to render nothing, " + "return null.", Component.displayName || Component.name || "Component");
                }
            }
          }

          return deleteRemainingChildren(returnFiber, currentFirstChild);
        }

        return reconcileChildFibers;
      }

      var reconcileChildFibers = ChildReconciler(true);
      var mountChildFibers = ChildReconciler(false);

      function cloneChildFibers(current$$1, workInProgress) {
        invariant(current$$1 === null || workInProgress.child === current$$1.child, "Resuming work not yet implemented.");

        if (workInProgress.child === null) {
          return;
        }

        var currentChild = workInProgress.child;
        var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
        workInProgress.child = newChild;
        newChild.return = workInProgress;

        while (currentChild.sibling !== null) {
          currentChild = currentChild.sibling;
          newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
          newChild.return = workInProgress;
        }

        newChild.sibling = null;
      }

      var hydrationParentFiber = null;
      var nextHydratableInstance = null;
      var isHydrating = false;

      function enterHydrationState(fiber) {
        if (!supportsHydration) {
          return false;
        }

        var parentInstance = fiber.stateNode.containerInfo;
        nextHydratableInstance = getFirstHydratableChild(parentInstance);
        hydrationParentFiber = fiber;
        isHydrating = true;
        return true;
      }

      function deleteHydratableInstance(returnFiber, instance) {
        {
          switch (returnFiber.tag) {
            case HostRoot:
              didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
              break;

            case HostComponent:
              didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
              break;
          }
        }
        var childToDelete = createFiberFromHostInstanceForDeletion();
        childToDelete.stateNode = instance;
        childToDelete.return = returnFiber;
        childToDelete.effectTag = Deletion;

        if (returnFiber.lastEffect !== null) {
          returnFiber.lastEffect.nextEffect = childToDelete;
          returnFiber.lastEffect = childToDelete;
        } else {
          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
        }
      }

      function insertNonHydratedInstance(returnFiber, fiber) {
        fiber.effectTag |= Placement;
        {
          switch (returnFiber.tag) {
            case HostRoot:
              {
                var parentContainer = returnFiber.stateNode.containerInfo;

                switch (fiber.tag) {
                  case HostComponent:
                    var type = fiber.type;
                    var props = fiber.pendingProps;
                    didNotFindHydratableContainerInstance(parentContainer, type, props);
                    break;

                  case HostText:
                    var text = fiber.pendingProps;
                    didNotFindHydratableContainerTextInstance(parentContainer, text);
                    break;
                }

                break;
              }

            case HostComponent:
              {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;

                switch (fiber.tag) {
                  case HostComponent:
                    var _type = fiber.type;
                    var _props = fiber.pendingProps;
                    didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
                    break;

                  case HostText:
                    var _text = fiber.pendingProps;
                    didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                    break;
                }

                break;
              }

            default:
              return;
          }
        }
      }

      function tryHydrate(fiber, nextInstance) {
        switch (fiber.tag) {
          case HostComponent:
            {
              var type = fiber.type;
              var props = fiber.pendingProps;
              var instance = canHydrateInstance(nextInstance, type, props);

              if (instance !== null) {
                fiber.stateNode = instance;
                return true;
              }

              return false;
            }

          case HostText:
            {
              var text = fiber.pendingProps;
              var textInstance = canHydrateTextInstance(nextInstance, text);

              if (textInstance !== null) {
                fiber.stateNode = textInstance;
                return true;
              }

              return false;
            }

          default:
            return false;
        }
      }

      function tryToClaimNextHydratableInstance(fiber) {
        if (!isHydrating) {
          return;
        }

        var nextInstance = nextHydratableInstance;

        if (!nextInstance) {
          insertNonHydratedInstance(hydrationParentFiber, fiber);
          isHydrating = false;
          hydrationParentFiber = fiber;
          return;
        }

        var firstAttemptedInstance = nextInstance;

        if (!tryHydrate(fiber, nextInstance)) {
          nextInstance = getNextHydratableSibling(firstAttemptedInstance);

          if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
          }

          deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
        }

        hydrationParentFiber = fiber;
        nextHydratableInstance = getFirstHydratableChild(nextInstance);
      }

      function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
        if (!supportsHydration) {
          invariant(false, "Expected prepareToHydrateHostInstance() to never be called. " + "This error is likely caused by a bug in React. Please file an issue.");
        }

        var instance = fiber.stateNode;
        var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
        fiber.updateQueue = updatePayload;

        if (updatePayload !== null) {
          return true;
        }

        return false;
      }

      function prepareToHydrateHostTextInstance(fiber) {
        if (!supportsHydration) {
          invariant(false, "Expected prepareToHydrateHostTextInstance() to never be called. " + "This error is likely caused by a bug in React. Please file an issue.");
        }

        var textInstance = fiber.stateNode;
        var textContent = fiber.memoizedProps;
        var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
        {
          if (shouldUpdate) {
            var returnFiber = hydrationParentFiber;

            if (returnFiber !== null) {
              switch (returnFiber.tag) {
                case HostRoot:
                  {
                    var parentContainer = returnFiber.stateNode.containerInfo;
                    didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                    break;
                  }

                case HostComponent:
                  {
                    var parentType = returnFiber.type;
                    var parentProps = returnFiber.memoizedProps;
                    var parentInstance = returnFiber.stateNode;
                    didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                    break;
                  }
              }
            }
          }
        }
        return shouldUpdate;
      }

      function popToNextHostParent(fiber) {
        var parent = fiber.return;

        while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {
          parent = parent.return;
        }

        hydrationParentFiber = parent;
      }

      function popHydrationState(fiber) {
        if (!supportsHydration) {
          return false;
        }

        if (fiber !== hydrationParentFiber) {
          return false;
        }

        if (!isHydrating) {
          popToNextHostParent(fiber);
          isHydrating = true;
          return false;
        }

        var type = fiber.type;

        if (fiber.tag !== HostComponent || type !== "head" && type !== "body" && !shouldSetTextContent(type, fiber.memoizedProps)) {
          var nextInstance = nextHydratableInstance;

          while (nextInstance) {
            deleteHydratableInstance(fiber, nextInstance);
            nextInstance = getNextHydratableSibling(nextInstance);
          }
        }

        popToNextHostParent(fiber);
        nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
        return true;
      }

      function resetHydrationState() {
        if (!supportsHydration) {
          return;
        }

        hydrationParentFiber = null;
        nextHydratableInstance = null;
        isHydrating = false;
      }

      var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
      var didWarnAboutBadClass = void 0;
      var didWarnAboutContextTypeOnFunctionComponent = void 0;
      var didWarnAboutGetDerivedStateOnFunctionComponent = void 0;
      var didWarnAboutFunctionRefs = void 0;
      {
        didWarnAboutBadClass = {};
        didWarnAboutContextTypeOnFunctionComponent = {};
        didWarnAboutGetDerivedStateOnFunctionComponent = {};
        didWarnAboutFunctionRefs = {};
      }

      function reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime) {
        if (current$$1 === null) {
          workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
        } else {
          workInProgress.child = reconcileChildFibers(workInProgress, current$$1.child, nextChildren, renderExpirationTime);
        }
      }

      function forceUnmountCurrentAndReconcile(current$$1, workInProgress, nextChildren, renderExpirationTime) {
        workInProgress.child = reconcileChildFibers(workInProgress, current$$1.child, null, renderExpirationTime);
        workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
      }

      function updateForwardRef(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
        var render = Component.render;
        var ref = workInProgress.ref;
        var nextChildren = void 0;
        prepareToReadContext(workInProgress, renderExpirationTime);
        prepareToUseHooks(current$$1, workInProgress, renderExpirationTime);
        {
          ReactCurrentOwner$3.current = workInProgress;
          setCurrentPhase("render");
          nextChildren = render(nextProps, ref);
          setCurrentPhase(null);
        }
        nextChildren = finishHooks(render, nextProps, nextChildren, ref);
        workInProgress.effectTag |= PerformedWork;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateMemoComponent(current$$1, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {
        if (current$$1 === null) {
          var type = Component.type;

          if (isSimpleFunctionComponent(type) && Component.compare === null) {
            workInProgress.tag = SimpleMemoComponent;
            workInProgress.type = type;
            return updateSimpleMemoComponent(current$$1, workInProgress, type, nextProps, updateExpirationTime, renderExpirationTime);
          }

          var child = createFiberFromTypeAndProps(Component.type, null, nextProps, null, workInProgress.mode, renderExpirationTime);
          child.ref = workInProgress.ref;
          child.return = workInProgress;
          workInProgress.child = child;
          return child;
        }

        var currentChild = current$$1.child;

        if (updateExpirationTime < renderExpirationTime) {
          var prevProps = currentChild.memoizedProps;
          var compare = Component.compare;
          compare = compare !== null ? compare : shallowEqual;

          if (compare(prevProps, nextProps) && current$$1.ref === workInProgress.ref) {
            return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
          }
        }

        workInProgress.effectTag |= PerformedWork;
        var newChild = createWorkInProgress(currentChild, nextProps, renderExpirationTime);
        newChild.ref = workInProgress.ref;
        newChild.return = workInProgress;
        workInProgress.child = newChild;
        return newChild;
      }

      function updateSimpleMemoComponent(current$$1, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {
        if (current$$1 !== null && updateExpirationTime < renderExpirationTime) {
          var prevProps = current$$1.memoizedProps;

          if (shallowEqual(prevProps, nextProps) && current$$1.ref === workInProgress.ref) {
            return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
          }
        }

        return updateFunctionComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime);
      }

      function updateFragment(current$$1, workInProgress, renderExpirationTime) {
        var nextChildren = workInProgress.pendingProps;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateMode(current$$1, workInProgress, renderExpirationTime) {
        var nextChildren = workInProgress.pendingProps.children;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateProfiler(current$$1, workInProgress, renderExpirationTime) {
        if (enableProfilerTimer) {
          workInProgress.effectTag |= Update;
        }

        var nextProps = workInProgress.pendingProps;
        var nextChildren = nextProps.children;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function markRef(current$$1, workInProgress) {
        var ref = workInProgress.ref;

        if (current$$1 === null && ref !== null || current$$1 !== null && current$$1.ref !== ref) {
          workInProgress.effectTag |= Ref;
        }
      }

      function updateFunctionComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
        var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
        var context = getMaskedContext(workInProgress, unmaskedContext);
        var nextChildren = void 0;
        prepareToReadContext(workInProgress, renderExpirationTime);
        prepareToUseHooks(current$$1, workInProgress, renderExpirationTime);
        {
          ReactCurrentOwner$3.current = workInProgress;
          setCurrentPhase("render");
          nextChildren = Component(nextProps, context);
          setCurrentPhase(null);
        }
        nextChildren = finishHooks(Component, nextProps, nextChildren, context);
        workInProgress.effectTag |= PerformedWork;
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateClassComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
        var hasContext = void 0;

        if (isContextProvider(Component)) {
          hasContext = true;
          pushContextProvider(workInProgress);
        } else {
          hasContext = false;
        }

        prepareToReadContext(workInProgress, renderExpirationTime);
        var instance = workInProgress.stateNode;
        var shouldUpdate = void 0;

        if (instance === null) {
          if (current$$1 !== null) {
            current$$1.alternate = null;
            workInProgress.alternate = null;
            workInProgress.effectTag |= Placement;
          }

          constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
          mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
          shouldUpdate = true;
        } else if (current$$1 === null) {
          shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
        } else {
          shouldUpdate = updateClassInstance(current$$1, workInProgress, Component, nextProps, renderExpirationTime);
        }

        return finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime);
      }

      function finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime) {
        markRef(current$$1, workInProgress);
        var didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;

        if (!shouldUpdate && !didCaptureError) {
          if (hasContext) {
            invalidateContextProvider(workInProgress, Component, false);
          }

          return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
        }

        var instance = workInProgress.stateNode;
        ReactCurrentOwner$3.current = workInProgress;
        var nextChildren = void 0;

        if (didCaptureError && typeof Component.getDerivedStateFromError !== "function") {
          nextChildren = null;

          if (enableProfilerTimer) {
            stopProfilerTimerIfRunning(workInProgress);
          }
        } else {
          {
            setCurrentPhase("render");
            nextChildren = instance.render();

            if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
              instance.render();
            }

            setCurrentPhase(null);
          }
        }

        workInProgress.effectTag |= PerformedWork;

        if (current$$1 !== null && didCaptureError) {
          forceUnmountCurrentAndReconcile(current$$1, workInProgress, nextChildren, renderExpirationTime);
        } else {
          reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        }

        workInProgress.memoizedState = instance.state;

        if (hasContext) {
          invalidateContextProvider(workInProgress, Component, true);
        }

        return workInProgress.child;
      }

      function pushHostRootContext(workInProgress) {
        var root = workInProgress.stateNode;

        if (root.pendingContext) {
          pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
        } else if (root.context) {
          pushTopLevelContextObject(workInProgress, root.context, false);
        }

        pushHostContainer(workInProgress, root.containerInfo);
      }

      function updateHostRoot(current$$1, workInProgress, renderExpirationTime) {
        pushHostRootContext(workInProgress);
        var updateQueue = workInProgress.updateQueue;
        invariant(updateQueue !== null, "If the root does not have an updateQueue, we should have already " + "bailed out. This error is likely caused by a bug in React. Please " + "file an issue.");
        var nextProps = workInProgress.pendingProps;
        var prevState = workInProgress.memoizedState;
        var prevChildren = prevState !== null ? prevState.element : null;
        processUpdateQueue(workInProgress, updateQueue, nextProps, null, renderExpirationTime);
        var nextState = workInProgress.memoizedState;
        var nextChildren = nextState.element;

        if (nextChildren === prevChildren) {
          resetHydrationState();
          return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
        }

        var root = workInProgress.stateNode;

        if ((current$$1 === null || current$$1.child === null) && root.hydrate && enterHydrationState(workInProgress)) {
          workInProgress.effectTag |= Placement;
          workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
        } else {
          reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
          resetHydrationState();
        }

        return workInProgress.child;
      }

      function updateHostComponent(current$$1, workInProgress, renderExpirationTime) {
        pushHostContext(workInProgress);

        if (current$$1 === null) {
          tryToClaimNextHydratableInstance(workInProgress);
        }

        var type = workInProgress.type;
        var nextProps = workInProgress.pendingProps;
        var prevProps = current$$1 !== null ? current$$1.memoizedProps : null;
        var nextChildren = nextProps.children;
        var isDirectTextChild = shouldSetTextContent(type, nextProps);

        if (isDirectTextChild) {
          nextChildren = null;
        } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
          workInProgress.effectTag |= ContentReset;
        }

        markRef(current$$1, workInProgress);

        if (renderExpirationTime !== Never && workInProgress.mode & ConcurrentMode && shouldDeprioritizeSubtree(type, nextProps)) {
          workInProgress.expirationTime = Never;
          return null;
        }

        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function updateHostText(current$$1, workInProgress) {
        if (current$$1 === null) {
          tryToClaimNextHydratableInstance(workInProgress);
        }

        return null;
      }

      function mountLazyComponent(_current, workInProgress, elementType, updateExpirationTime, renderExpirationTime) {
        if (_current !== null) {
          _current.alternate = null;
          workInProgress.alternate = null;
          workInProgress.effectTag |= Placement;
        }

        var props = workInProgress.pendingProps;
        cancelWorkTimer(workInProgress);
        var Component = readLazyComponentType(elementType);
        workInProgress.type = Component;
        var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);
        startWorkTimer(workInProgress);
        var resolvedProps = resolveDefaultProps(Component, props);
        var child = void 0;

        switch (resolvedTag) {
          case FunctionComponent:
            {
              child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderExpirationTime);
              break;
            }

          case ClassComponent:
            {
              child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderExpirationTime);
              break;
            }

          case ForwardRef:
            {
              child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderExpirationTime);
              break;
            }

          case MemoComponent:
            {
              child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), updateExpirationTime, renderExpirationTime);
              break;
            }

          default:
            {
              invariant(false, "Element type is invalid. Received a promise that resolves to: %s. " + "Promise elements must resolve to a class or function.", Component);
            }
        }

        return child;
      }

      function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderExpirationTime) {
        if (_current !== null) {
          _current.alternate = null;
          workInProgress.alternate = null;
          workInProgress.effectTag |= Placement;
        }

        workInProgress.tag = ClassComponent;
        var hasContext = void 0;

        if (isContextProvider(Component)) {
          hasContext = true;
          pushContextProvider(workInProgress);
        } else {
          hasContext = false;
        }

        prepareToReadContext(workInProgress, renderExpirationTime);
        constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
        mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
        return finishClassComponent(null, workInProgress, Component, true, hasContext, renderExpirationTime);
      }

      function mountIndeterminateComponent(_current, workInProgress, Component, renderExpirationTime) {
        if (_current !== null) {
          _current.alternate = null;
          workInProgress.alternate = null;
          workInProgress.effectTag |= Placement;
        }

        var props = workInProgress.pendingProps;
        var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);
        var context = getMaskedContext(workInProgress, unmaskedContext);
        prepareToReadContext(workInProgress, renderExpirationTime);
        prepareToUseHooks(null, workInProgress, renderExpirationTime);
        var value = void 0;
        {
          if (Component.prototype && typeof Component.prototype.render === "function") {
            var componentName = getComponentName(Component) || "Unknown";

            if (!didWarnAboutBadClass[componentName]) {
              warningWithoutStack$1(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + "This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
              didWarnAboutBadClass[componentName] = true;
            }
          }

          if (workInProgress.mode & StrictMode) {
            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
          }

          ReactCurrentOwner$3.current = workInProgress;
          value = Component(props, context);
        }
        workInProgress.effectTag |= PerformedWork;

        if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === undefined) {
          workInProgress.tag = ClassComponent;
          resetHooks();
          var hasContext = false;

          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress);
          } else {
            hasContext = false;
          }

          workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;
          var getDerivedStateFromProps = Component.getDerivedStateFromProps;

          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);
          }

          adoptClassInstance(workInProgress, value);
          mountClassInstance(workInProgress, Component, props, renderExpirationTime);
          return finishClassComponent(null, workInProgress, Component, true, hasContext, renderExpirationTime);
        } else {
          workInProgress.tag = FunctionComponent;
          value = finishHooks(Component, props, value, context);
          {
            if (Component) {
              !!Component.childContextTypes ? warningWithoutStack$1(false, "%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component") : void 0;
            }

            if (workInProgress.ref !== null) {
              var info = "";
              var ownerName = getCurrentFiberOwnerNameInDevOrNull();

              if (ownerName) {
                info += "\n\nCheck the render method of `" + ownerName + "`.";
              }

              var warningKey = ownerName || workInProgress._debugID || "";
              var debugSource = workInProgress._debugSource;

              if (debugSource) {
                warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
              }

              if (!didWarnAboutFunctionRefs[warningKey]) {
                didWarnAboutFunctionRefs[warningKey] = true;
                warning$1(false, "Function components cannot be given refs. " + "Attempts to access this ref will fail.%s", info);
              }
            }

            if (typeof Component.getDerivedStateFromProps === "function") {
              var _componentName = getComponentName(Component) || "Unknown";

              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName]) {
                warningWithoutStack$1(false, "%s: Function components do not support getDerivedStateFromProps.", _componentName);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName] = true;
              }
            }

            if (typeof Component.contextType === "object" && Component.contextType !== null) {
              var _componentName2 = getComponentName(Component) || "Unknown";

              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName2]) {
                warningWithoutStack$1(false, "%s: Function components do not support contextType.", _componentName2);
                didWarnAboutContextTypeOnFunctionComponent[_componentName2] = true;
              }
            }
          }
          reconcileChildren(null, workInProgress, value, renderExpirationTime);
          return workInProgress.child;
        }
      }

      function updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime) {
        var mode = workInProgress.mode;
        var nextProps = workInProgress.pendingProps;
        var nextState = workInProgress.memoizedState;
        var nextDidTimeout = void 0;

        if ((workInProgress.effectTag & DidCapture) === NoEffect) {
          nextState = null;
          nextDidTimeout = false;
        } else {
          nextState = {
            timedOutAt: nextState !== null ? nextState.timedOutAt : NoWork
          };
          nextDidTimeout = true;
          workInProgress.effectTag &= ~DidCapture;
        }

        var child = void 0;
        var next = void 0;

        if (current$$1 === null) {
          if (nextDidTimeout) {
            var nextFallbackChildren = nextProps.fallback;
            var primaryChildFragment = createFiberFromFragment(null, mode, NoWork, null);

            if ((workInProgress.mode & ConcurrentMode) === NoContext) {
              var progressedState = workInProgress.memoizedState;
              var progressedPrimaryChild = progressedState !== null ? workInProgress.child.child : workInProgress.child;
              primaryChildFragment.child = progressedPrimaryChild;
            }

            var fallbackChildFragment = createFiberFromFragment(nextFallbackChildren, mode, renderExpirationTime, null);
            primaryChildFragment.sibling = fallbackChildFragment;
            child = primaryChildFragment;
            next = fallbackChildFragment;
            child.return = next.return = workInProgress;
          } else {
            var nextPrimaryChildren = nextProps.children;
            child = next = mountChildFibers(workInProgress, null, nextPrimaryChildren, renderExpirationTime);
          }
        } else {
          var prevState = current$$1.memoizedState;
          var prevDidTimeout = prevState !== null;

          if (prevDidTimeout) {
            var currentPrimaryChildFragment = current$$1.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;

            if (nextDidTimeout) {
              var _nextFallbackChildren = nextProps.fallback;

              var _primaryChildFragment = createWorkInProgress(currentPrimaryChildFragment, currentPrimaryChildFragment.pendingProps, NoWork);

              _primaryChildFragment.effectTag |= Placement;

              if ((workInProgress.mode & ConcurrentMode) === NoContext) {
                var _progressedState = workInProgress.memoizedState;

                var _progressedPrimaryChild = _progressedState !== null ? workInProgress.child.child : workInProgress.child;

                if (_progressedPrimaryChild !== currentPrimaryChildFragment.child) {
                  _primaryChildFragment.child = _progressedPrimaryChild;
                }
              }

              if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
                var treeBaseDuration = 0;
                var hiddenChild = _primaryChildFragment.child;

                while (hiddenChild !== null) {
                  treeBaseDuration += hiddenChild.treeBaseDuration;
                  hiddenChild = hiddenChild.sibling;
                }

                _primaryChildFragment.treeBaseDuration = treeBaseDuration;
              }

              var _fallbackChildFragment = _primaryChildFragment.sibling = createWorkInProgress(currentFallbackChildFragment, _nextFallbackChildren, currentFallbackChildFragment.expirationTime);

              _fallbackChildFragment.effectTag |= Placement;
              child = _primaryChildFragment;
              _primaryChildFragment.childExpirationTime = NoWork;
              next = _fallbackChildFragment;
              child.return = next.return = workInProgress;
            } else {
              var _nextPrimaryChildren = nextProps.children;
              var currentPrimaryChild = currentPrimaryChildFragment.child;
              var primaryChild = reconcileChildFibers(workInProgress, currentPrimaryChild, _nextPrimaryChildren, renderExpirationTime);
              child = next = primaryChild;
            }
          } else {
            var _currentPrimaryChild = current$$1.child;

            if (nextDidTimeout) {
              var _nextFallbackChildren2 = nextProps.fallback;

              var _primaryChildFragment2 = createFiberFromFragment(null, mode, NoWork, null);

              _primaryChildFragment2.effectTag |= Placement;
              _primaryChildFragment2.child = _currentPrimaryChild;
              _currentPrimaryChild.return = _primaryChildFragment2;

              if ((workInProgress.mode & ConcurrentMode) === NoContext) {
                var _progressedState2 = workInProgress.memoizedState;

                var _progressedPrimaryChild2 = _progressedState2 !== null ? workInProgress.child.child : workInProgress.child;

                _primaryChildFragment2.child = _progressedPrimaryChild2;
              }

              if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
                var _treeBaseDuration = 0;
                var _hiddenChild = _primaryChildFragment2.child;

                while (_hiddenChild !== null) {
                  _treeBaseDuration += _hiddenChild.treeBaseDuration;
                  _hiddenChild = _hiddenChild.sibling;
                }

                _primaryChildFragment2.treeBaseDuration = _treeBaseDuration;
              }

              var _fallbackChildFragment2 = _primaryChildFragment2.sibling = createFiberFromFragment(_nextFallbackChildren2, mode, renderExpirationTime, null);

              _fallbackChildFragment2.effectTag |= Placement;
              child = _primaryChildFragment2;
              _primaryChildFragment2.childExpirationTime = NoWork;
              next = _fallbackChildFragment2;
              child.return = next.return = workInProgress;
            } else {
              var _nextPrimaryChildren2 = nextProps.children;
              next = child = reconcileChildFibers(workInProgress, _currentPrimaryChild, _nextPrimaryChildren2, renderExpirationTime);
            }
          }
        }

        workInProgress.memoizedState = nextState;
        workInProgress.child = child;
        return next;
      }

      function updatePortalComponent(current$$1, workInProgress, renderExpirationTime) {
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        var nextChildren = workInProgress.pendingProps;

        if (current$$1 === null) {
          workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
        } else {
          reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        }

        return workInProgress.child;
      }

      function updateContextProvider(current$$1, workInProgress, renderExpirationTime) {
        var providerType = workInProgress.type;
        var context = providerType._context;
        var newProps = workInProgress.pendingProps;
        var oldProps = workInProgress.memoizedProps;
        var newValue = newProps.value;
        {
          var providerPropTypes = workInProgress.type.propTypes;

          if (providerPropTypes) {
            checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider", getCurrentFiberStackInDev);
          }
        }
        pushProvider(workInProgress, newValue);

        if (oldProps !== null) {
          var oldValue = oldProps.value;
          var changedBits = calculateChangedBits(context, newValue, oldValue);

          if (changedBits === 0) {
            if (oldProps.children === newProps.children && !hasContextChanged()) {
              return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
            }
          } else {
            propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);
          }
        }

        var newChildren = newProps.children;
        reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);
        return workInProgress.child;
      }

      var hasWarnedAboutUsingContextAsConsumer = false;

      function updateContextConsumer(current$$1, workInProgress, renderExpirationTime) {
        var context = workInProgress.type;
        {
          if (context._context === undefined) {
            if (context !== context.Consumer) {
              if (!hasWarnedAboutUsingContextAsConsumer) {
                hasWarnedAboutUsingContextAsConsumer = true;
                warning$1(false, "Rendering <Context> directly is not supported and will be removed in " + "a future major release. Did you mean to render <Context.Consumer> instead?");
              }
            }
          } else {
            context = context._context;
          }
        }
        var newProps = workInProgress.pendingProps;
        var render = newProps.children;
        {
          !(typeof render === "function") ? warningWithoutStack$1(false, "A context consumer was rendered with multiple children, or a child " + "that isn't a function. A context consumer expects a single child " + "that is a function. If you did pass a function, make sure there " + "is no trailing or leading whitespace around it.") : void 0;
        }
        prepareToReadContext(workInProgress, renderExpirationTime);
        var newValue = readContext(context, newProps.unstable_observedBits);
        var newChildren = void 0;
        {
          ReactCurrentOwner$3.current = workInProgress;
          setCurrentPhase("render");
          newChildren = render(newValue);
          setCurrentPhase(null);
        }
        workInProgress.effectTag |= PerformedWork;
        reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);
        return workInProgress.child;
      }

      function bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime) {
        cancelWorkTimer(workInProgress);

        if (current$$1 !== null) {
          workInProgress.firstContextDependency = current$$1.firstContextDependency;
        }

        if (enableProfilerTimer) {
          stopProfilerTimerIfRunning(workInProgress);
        }

        var childExpirationTime = workInProgress.childExpirationTime;

        if (childExpirationTime < renderExpirationTime) {
          return null;
        } else {
          cloneChildFibers(current$$1, workInProgress);
          return workInProgress.child;
        }
      }

      function beginWork(current$$1, workInProgress, renderExpirationTime) {
        var updateExpirationTime = workInProgress.expirationTime;

        if (current$$1 !== null) {
          var oldProps = current$$1.memoizedProps;
          var newProps = workInProgress.pendingProps;

          if (oldProps === newProps && !hasContextChanged() && updateExpirationTime < renderExpirationTime) {
            switch (workInProgress.tag) {
              case HostRoot:
                pushHostRootContext(workInProgress);
                resetHydrationState();
                break;

              case HostComponent:
                pushHostContext(workInProgress);
                break;

              case ClassComponent:
                {
                  var Component = workInProgress.type;

                  if (isContextProvider(Component)) {
                    pushContextProvider(workInProgress);
                  }

                  break;
                }

              case HostPortal:
                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                break;

              case ContextProvider:
                {
                  var newValue = workInProgress.memoizedProps.value;
                  pushProvider(workInProgress, newValue);
                  break;
                }

              case Profiler:
                if (enableProfilerTimer) {
                  workInProgress.effectTag |= Update;
                }

                break;

              case SuspenseComponent:
                {
                  var state = workInProgress.memoizedState;
                  var didTimeout = state !== null;

                  if (didTimeout) {
                    var primaryChildFragment = workInProgress.child;
                    var primaryChildExpirationTime = primaryChildFragment.childExpirationTime;

                    if (primaryChildExpirationTime !== NoWork && primaryChildExpirationTime >= renderExpirationTime) {
                      return updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime);
                    } else {
                      var child = bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);

                      if (child !== null) {
                        return child.sibling;
                      } else {
                        return null;
                      }
                    }
                  }

                  break;
                }
            }

            return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
          }
        }

        workInProgress.expirationTime = NoWork;

        switch (workInProgress.tag) {
          case IndeterminateComponent:
            {
              var elementType = workInProgress.elementType;
              return mountIndeterminateComponent(current$$1, workInProgress, elementType, renderExpirationTime);
            }

          case LazyComponent:
            {
              var _elementType = workInProgress.elementType;
              return mountLazyComponent(current$$1, workInProgress, _elementType, updateExpirationTime, renderExpirationTime);
            }

          case FunctionComponent:
            {
              var _Component = workInProgress.type;
              var unresolvedProps = workInProgress.pendingProps;
              var resolvedProps = workInProgress.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);
              return updateFunctionComponent(current$$1, workInProgress, _Component, resolvedProps, renderExpirationTime);
            }

          case ClassComponent:
            {
              var _Component2 = workInProgress.type;
              var _unresolvedProps = workInProgress.pendingProps;

              var _resolvedProps = workInProgress.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);

              return updateClassComponent(current$$1, workInProgress, _Component2, _resolvedProps, renderExpirationTime);
            }

          case HostRoot:
            return updateHostRoot(current$$1, workInProgress, renderExpirationTime);

          case HostComponent:
            return updateHostComponent(current$$1, workInProgress, renderExpirationTime);

          case HostText:
            return updateHostText(current$$1, workInProgress);

          case SuspenseComponent:
            return updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime);

          case HostPortal:
            return updatePortalComponent(current$$1, workInProgress, renderExpirationTime);

          case ForwardRef:
            {
              var type = workInProgress.type;
              var _unresolvedProps2 = workInProgress.pendingProps;

              var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);

              return updateForwardRef(current$$1, workInProgress, type, _resolvedProps2, renderExpirationTime);
            }

          case Fragment:
            return updateFragment(current$$1, workInProgress, renderExpirationTime);

          case Mode:
            return updateMode(current$$1, workInProgress, renderExpirationTime);

          case Profiler:
            return updateProfiler(current$$1, workInProgress, renderExpirationTime);

          case ContextProvider:
            return updateContextProvider(current$$1, workInProgress, renderExpirationTime);

          case ContextConsumer:
            return updateContextConsumer(current$$1, workInProgress, renderExpirationTime);

          case MemoComponent:
            {
              var _type = workInProgress.type;
              var _unresolvedProps3 = workInProgress.pendingProps;

              var _resolvedProps3 = resolveDefaultProps(_type.type, _unresolvedProps3);

              return updateMemoComponent(current$$1, workInProgress, _type, _resolvedProps3, updateExpirationTime, renderExpirationTime);
            }

          case SimpleMemoComponent:
            {
              return updateSimpleMemoComponent(current$$1, workInProgress, workInProgress.type, workInProgress.pendingProps, updateExpirationTime, renderExpirationTime);
            }

          case IncompleteClassComponent:
            {
              var _Component3 = workInProgress.type;
              var _unresolvedProps4 = workInProgress.pendingProps;

              var _resolvedProps4 = workInProgress.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);

              return mountIncompleteClassComponent(current$$1, workInProgress, _Component3, _resolvedProps4, renderExpirationTime);
            }

          default:
            invariant(false, "Unknown unit of work tag. This error is likely caused by a bug in " + "React. Please file an issue.");
        }
      }

      function markUpdate(workInProgress) {
        workInProgress.effectTag |= Update;
      }

      function markRef$1(workInProgress) {
        workInProgress.effectTag |= Ref;
      }

      var _appendAllChildren = void 0;

      var updateHostContainer = void 0;
      var updateHostComponent$1 = void 0;
      var updateHostText$1 = void 0;

      if (supportsMutation) {
        _appendAllChildren = function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {
          var node = workInProgress.child;

          while (node !== null) {
            if (node.tag === HostComponent || node.tag === HostText) {
              appendInitialChild(parent, node.stateNode);
            } else if (node.tag === HostPortal) {} else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }

            if (node === workInProgress) {
              return;
            }

            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress) {
                return;
              }

              node = node.return;
            }

            node.sibling.return = node.return;
            node = node.sibling;
          }
        };

        updateHostContainer = function updateHostContainer(workInProgress) {};

        updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {
          var oldProps = current.memoizedProps;

          if (oldProps === newProps) {
            return;
          }

          var instance = workInProgress.stateNode;
          var currentHostContext = getHostContext();
          var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
          workInProgress.updateQueue = updatePayload;

          if (updatePayload) {
            markUpdate(workInProgress);
          }
        };

        updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {
          if (oldText !== newText) {
            markUpdate(workInProgress);
          }
        };
      } else if (supportsPersistence) {
        _appendAllChildren = function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {
          var node = workInProgress.child;

          while (node !== null) {
            branches: if (node.tag === HostComponent) {
              var instance = node.stateNode;

              if (needsVisibilityToggle) {
                var props = node.memoizedProps;
                var type = node.type;

                if (isHidden) {
                  instance = cloneHiddenInstance(instance, type, props, node);
                } else {
                  instance = cloneUnhiddenInstance(instance, type, props, node);
                }

                node.stateNode = instance;
              }

              appendInitialChild(parent, instance);
            } else if (node.tag === HostText) {
              var _instance = node.stateNode;

              if (needsVisibilityToggle) {
                var text = node.memoizedProps;
                var rootContainerInstance = getRootHostContainer();
                var currentHostContext = getHostContext();

                if (isHidden) {
                  _instance = createHiddenTextInstance(text, rootContainerInstance, currentHostContext, workInProgress);
                } else {
                  _instance = createTextInstance(text, rootContainerInstance, currentHostContext, workInProgress);
                }

                node.stateNode = _instance;
              }

              appendInitialChild(parent, _instance);
            } else if (node.tag === HostPortal) {} else if (node.tag === SuspenseComponent) {
              var current = node.alternate;

              if (current !== null) {
                var oldState = current.memoizedState;
                var newState = node.memoizedState;
                var oldIsHidden = oldState !== null;
                var newIsHidden = newState !== null;

                if (oldIsHidden !== newIsHidden) {
                  var primaryChildParent = newIsHidden ? node.child : node;

                  if (primaryChildParent !== null) {
                    _appendAllChildren(parent, primaryChildParent, true, newIsHidden);
                  }

                  break branches;
                }
              }

              if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }

            node = node;

            if (node === workInProgress) {
              return;
            }

            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress) {
                return;
              }

              node = node.return;
            }

            node.sibling.return = node.return;
            node = node.sibling;
          }
        };

        var appendAllChildrenToContainer = function appendAllChildrenToContainer(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {
          var node = workInProgress.child;

          while (node !== null) {
            branches: if (node.tag === HostComponent) {
              var instance = node.stateNode;

              if (needsVisibilityToggle) {
                var props = node.memoizedProps;
                var type = node.type;

                if (isHidden) {
                  instance = cloneHiddenInstance(instance, type, props, node);
                } else {
                  instance = cloneUnhiddenInstance(instance, type, props, node);
                }

                node.stateNode = instance;
              }

              appendChildToContainerChildSet(containerChildSet, instance);
            } else if (node.tag === HostText) {
              var _instance2 = node.stateNode;

              if (needsVisibilityToggle) {
                var text = node.memoizedProps;
                var rootContainerInstance = getRootHostContainer();
                var currentHostContext = getHostContext();

                if (isHidden) {
                  _instance2 = createHiddenTextInstance(text, rootContainerInstance, currentHostContext, workInProgress);
                } else {
                  _instance2 = createTextInstance(text, rootContainerInstance, currentHostContext, workInProgress);
                }

                node.stateNode = _instance2;
              }

              appendChildToContainerChildSet(containerChildSet, _instance2);
            } else if (node.tag === HostPortal) {} else if (node.tag === SuspenseComponent) {
              var current = node.alternate;

              if (current !== null) {
                var oldState = current.memoizedState;
                var newState = node.memoizedState;
                var oldIsHidden = oldState !== null;
                var newIsHidden = newState !== null;

                if (oldIsHidden !== newIsHidden) {
                  var primaryChildParent = newIsHidden ? node.child : node;

                  if (primaryChildParent !== null) {
                    appendAllChildrenToContainer(containerChildSet, primaryChildParent, true, newIsHidden);
                  }

                  break branches;
                }
              }

              if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }

            node = node;

            if (node === workInProgress) {
              return;
            }

            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress) {
                return;
              }

              node = node.return;
            }

            node.sibling.return = node.return;
            node = node.sibling;
          }
        };

        updateHostContainer = function updateHostContainer(workInProgress) {
          var portalOrRoot = workInProgress.stateNode;
          var childrenUnchanged = workInProgress.firstEffect === null;

          if (childrenUnchanged) {} else {
            var container = portalOrRoot.containerInfo;
            var newChildSet = createContainerChildSet(container);
            appendAllChildrenToContainer(newChildSet, workInProgress, false, false);
            portalOrRoot.pendingChildren = newChildSet;
            markUpdate(workInProgress);
            finalizeContainerChildren(container, newChildSet);
          }
        };

        updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {
          var currentInstance = current.stateNode;
          var oldProps = current.memoizedProps;
          var childrenUnchanged = workInProgress.firstEffect === null;

          if (childrenUnchanged && oldProps === newProps) {
            workInProgress.stateNode = currentInstance;
            return;
          }

          var recyclableInstance = workInProgress.stateNode;
          var currentHostContext = getHostContext();
          var updatePayload = null;

          if (oldProps !== newProps) {
            updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
          }

          if (childrenUnchanged && updatePayload === null) {
            workInProgress.stateNode = currentInstance;
            return;
          }

          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);

          if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {
            markUpdate(workInProgress);
          }

          workInProgress.stateNode = newInstance;

          if (childrenUnchanged) {
            markUpdate(workInProgress);
          } else {
            _appendAllChildren(newInstance, workInProgress, false, false);
          }
        };

        updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {
          if (oldText !== newText) {
            var rootContainerInstance = getRootHostContainer();
            var currentHostContext = getHostContext();
            workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);
            markUpdate(workInProgress);
          }
        };
      } else {
        updateHostContainer = function updateHostContainer(workInProgress) {};

        updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {};

        updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {};
      }

      function completeWork(current, workInProgress, renderExpirationTime) {
        var newProps = workInProgress.pendingProps;

        switch (workInProgress.tag) {
          case IndeterminateComponent:
            break;

          case LazyComponent:
            break;

          case SimpleMemoComponent:
          case FunctionComponent:
            break;

          case ClassComponent:
            {
              var Component = workInProgress.type;

              if (isContextProvider(Component)) {
                popContext(workInProgress);
              }

              break;
            }

          case HostRoot:
            {
              popHostContainer(workInProgress);
              popTopLevelContextObject(workInProgress);
              var fiberRoot = workInProgress.stateNode;

              if (fiberRoot.pendingContext) {
                fiberRoot.context = fiberRoot.pendingContext;
                fiberRoot.pendingContext = null;
              }

              if (current === null || current.child === null) {
                popHydrationState(workInProgress);
                workInProgress.effectTag &= ~Placement;
              }

              updateHostContainer(workInProgress);
              break;
            }

          case HostComponent:
            {
              popHostContext(workInProgress);
              var rootContainerInstance = getRootHostContainer();
              var type = workInProgress.type;

              if (current !== null && workInProgress.stateNode != null) {
                updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);

                if (current.ref !== workInProgress.ref) {
                  markRef$1(workInProgress);
                }
              } else {
                if (!newProps) {
                  invariant(workInProgress.stateNode !== null, "We must have new props for new mounts. This error is likely " + "caused by a bug in React. Please file an issue.");
                  break;
                }

                var currentHostContext = getHostContext();
                var wasHydrated = popHydrationState(workInProgress);

                if (wasHydrated) {
                  if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {
                    markUpdate(workInProgress);
                  }
                } else {
                  var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);

                  _appendAllChildren(instance, workInProgress, false, false);

                  if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {
                    markUpdate(workInProgress);
                  }

                  workInProgress.stateNode = instance;
                }

                if (workInProgress.ref !== null) {
                  markRef$1(workInProgress);
                }
              }

              break;
            }

          case HostText:
            {
              var newText = newProps;

              if (current && workInProgress.stateNode != null) {
                var oldText = current.memoizedProps;
                updateHostText$1(current, workInProgress, oldText, newText);
              } else {
                if (typeof newText !== "string") {
                  invariant(workInProgress.stateNode !== null, "We must have new props for new mounts. This error is likely " + "caused by a bug in React. Please file an issue.");
                }

                var _rootContainerInstance = getRootHostContainer();

                var _currentHostContext = getHostContext();

                var _wasHydrated = popHydrationState(workInProgress);

                if (_wasHydrated) {
                  if (prepareToHydrateHostTextInstance(workInProgress)) {
                    markUpdate(workInProgress);
                  }
                } else {
                  workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);
                }
              }

              break;
            }

          case ForwardRef:
            break;

          case SuspenseComponent:
            {
              var nextState = workInProgress.memoizedState;

              if ((workInProgress.effectTag & DidCapture) !== NoEffect) {
                workInProgress.expirationTime = renderExpirationTime;
                return workInProgress;
              }

              var nextDidTimeout = nextState !== null;
              var prevDidTimeout = current !== null && current.memoizedState !== null;

              if (current !== null && !nextDidTimeout && prevDidTimeout) {
                var currentFallbackChild = current.child.sibling;

                if (currentFallbackChild !== null) {
                  reconcileChildFibers(workInProgress, currentFallbackChild, null, renderExpirationTime);
                }
              }

              if (nextDidTimeout !== prevDidTimeout || (workInProgress.effectTag & ConcurrentMode) === NoContext && nextDidTimeout) {
                workInProgress.effectTag |= Update;
              }

              break;
            }

          case Fragment:
            break;

          case Mode:
            break;

          case Profiler:
            break;

          case HostPortal:
            popHostContainer(workInProgress);
            updateHostContainer(workInProgress);
            break;

          case ContextProvider:
            popProvider(workInProgress);
            break;

          case ContextConsumer:
            break;

          case MemoComponent:
            break;

          case IncompleteClassComponent:
            {
              var _Component = workInProgress.type;

              if (isContextProvider(_Component)) {
                popContext(workInProgress);
              }

              break;
            }

          default:
            invariant(false, "Unknown unit of work tag. This error is likely caused by a bug in " + "React. Please file an issue.");
        }

        return null;
      }

      function shouldCaptureSuspense(current, workInProgress) {
        if (workInProgress.memoizedProps.fallback === undefined) {
          return false;
        }

        var nextState = workInProgress.memoizedState;
        return nextState === null;
      }

      function showErrorDialog(capturedError) {
        var componentStack = capturedError.componentStack,
            error = capturedError.error;
        var errorToHandle = void 0;

        if (error instanceof Error) {
          var message = error.message,
              name = error.name;
          var summary = message ? name + ": " + message : name;
          errorToHandle = error;

          try {
            errorToHandle.message = summary + "\n\nThis error is located at:" + componentStack;
          } catch (e) {}
        } else if (typeof error === "string") {
          errorToHandle = new Error(error + "\n\nThis error is located at:" + componentStack);
        } else {
          errorToHandle = new Error("Unspecified error at:" + componentStack);
        }

        ExceptionsManager.handleException(errorToHandle, false);
        return false;
      }

      function logCapturedError(capturedError) {
        var logError = showErrorDialog(capturedError);

        if (logError === false) {
          return;
        }

        var error = capturedError.error;
        {
          var componentName = capturedError.componentName,
              componentStack = capturedError.componentStack,
              errorBoundaryName = capturedError.errorBoundaryName,
              errorBoundaryFound = capturedError.errorBoundaryFound,
              willRetry = capturedError.willRetry;

          if (error != null && error._suppressLogging) {
            if (errorBoundaryFound && willRetry) {
              return;
            }

            console.error(error);
          }

          var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
          var errorBoundaryMessage = void 0;

          if (errorBoundaryFound && errorBoundaryName) {
            if (willRetry) {
              errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
            } else {
              errorBoundaryMessage = "This error was initially handled by the error boundary " + errorBoundaryName + ".\n" + "Recreating the tree from scratch failed so React will unmount the tree.";
            }
          } else {
            errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\n" + "Visit https://fb.me/react-error-boundaries to learn more about error boundaries.";
          }

          var combinedMessage = "" + componentNameMessage + componentStack + "\n\n" + ("" + errorBoundaryMessage);
          console.error(combinedMessage);
        }
      }

      var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
      {
        didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
      }

      function logError(boundary, errorInfo) {
        var source = errorInfo.source;
        var stack = errorInfo.stack;

        if (stack === null && source !== null) {
          stack = getStackByFiberInDevAndProd(source);
        }

        var capturedError = {
          componentName: source !== null ? getComponentName(source.type) : null,
          componentStack: stack !== null ? stack : "",
          error: errorInfo.value,
          errorBoundary: null,
          errorBoundaryName: null,
          errorBoundaryFound: false,
          willRetry: false
        };

        if (boundary !== null && boundary.tag === ClassComponent) {
          capturedError.errorBoundary = boundary.stateNode;
          capturedError.errorBoundaryName = getComponentName(boundary.type);
          capturedError.errorBoundaryFound = true;
          capturedError.willRetry = true;
        }

        try {
          logCapturedError(capturedError);
        } catch (e) {
          setTimeout(function () {
            throw e;
          });
        }
      }

      var callComponentWillUnmountWithTimer = function callComponentWillUnmountWithTimer(current$$1, instance) {
        startPhaseTimer(current$$1, "componentWillUnmount");
        instance.props = current$$1.memoizedProps;
        instance.state = current$$1.memoizedState;
        instance.componentWillUnmount();
        stopPhaseTimer();
      };

      function safelyCallComponentWillUnmount(current$$1, instance) {
        {
          invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current$$1, instance);

          if (hasCaughtError()) {
            var unmountError = clearCaughtError();
            captureCommitPhaseError(current$$1, unmountError);
          }
        }
      }

      function safelyDetachRef(current$$1) {
        var ref = current$$1.ref;

        if (ref !== null) {
          if (typeof ref === "function") {
            {
              invokeGuardedCallback(null, ref, null, null);

              if (hasCaughtError()) {
                var refError = clearCaughtError();
                captureCommitPhaseError(current$$1, refError);
              }
            }
          } else {
            ref.current = null;
          }
        }
      }

      function safelyCallDestroy(current$$1, destroy) {
        {
          invokeGuardedCallback(null, destroy, null);

          if (hasCaughtError()) {
            var error = clearCaughtError();
            captureCommitPhaseError(current$$1, error);
          }
        }
      }

      function commitBeforeMutationLifeCycles(current$$1, finishedWork) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent:
            {
              commitHookEffectList(UnmountSnapshot, NoEffect$1, finishedWork);
              return;
            }

          case ClassComponent:
            {
              if (finishedWork.effectTag & Snapshot) {
                if (current$$1 !== null) {
                  var prevProps = current$$1.memoizedProps;
                  var prevState = current$$1.memoizedState;
                  startPhaseTimer(finishedWork, "getSnapshotBeforeUpdate");
                  var instance = finishedWork.stateNode;
                  {
                    if (finishedWork.type === finishedWork.elementType) {
                      !(instance.props === finishedWork.memoizedProps) ? warning$1(false, "Expected instance props to match memoized props before " + "getSnapshotBeforeUpdate. This is likely due to a bug in React. " + "Please file an issue.") : void 0;
                      !(instance.state === finishedWork.memoizedState) ? warning$1(false, "Expected instance state to match memoized state before " + "getSnapshotBeforeUpdate. This is likely due to a bug in React. " + "Please file an issue.") : void 0;
                    }
                  }
                  var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                  {
                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;

                    if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
                      didWarnSet.add(finishedWork.type);
                      warningWithoutStack$1(false, "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) " + "must be returned. You have returned undefined.", getComponentName(finishedWork.type));
                    }
                  }
                  instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                  stopPhaseTimer();
                }
              }

              return;
            }

          case HostRoot:
          case HostComponent:
          case HostText:
          case HostPortal:
          case IncompleteClassComponent:
            return;

          default:
            {
              invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
            }
        }
      }

      function commitHookEffectList(unmountTag, mountTag, finishedWork) {
        if (!enableHooks) {
          return;
        }

        var updateQueue = finishedWork.updateQueue;
        var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

        if (lastEffect !== null) {
          var firstEffect = lastEffect.next;
          var effect = firstEffect;

          do {
            if ((effect.tag & unmountTag) !== NoEffect$1) {
              var destroy = effect.destroy;
              effect.destroy = null;

              if (destroy !== null) {
                destroy();
              }
            }

            if ((effect.tag & mountTag) !== NoEffect$1) {
              var create = effect.create;

              var _destroy = create();

              if (typeof _destroy !== "function") {
                {
                  if (_destroy !== null && _destroy !== undefined) {
                    warningWithoutStack$1(false, "useEffect function must return a cleanup function or " + "nothing.%s%s", typeof _destroy.then === "function" ? " Promises and useEffect(async () => ...) are not " + "supported, but you can call an async function inside an " + "effect." : "", getStackByFiberInDevAndProd(finishedWork));
                  }
                }
                _destroy = null;
              }

              effect.destroy = _destroy;
            }

            effect = effect.next;
          } while (effect !== firstEffect);
        }
      }

      function commitPassiveHookEffects(finishedWork) {
        commitHookEffectList(UnmountPassive, NoEffect$1, finishedWork);
        commitHookEffectList(NoEffect$1, MountPassive, finishedWork);
      }

      function commitLifeCycles(finishedRoot, current$$1, finishedWork, committedExpirationTime) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent:
            {
              commitHookEffectList(UnmountLayout, MountLayout, finishedWork);
              break;
            }

          case ClassComponent:
            {
              var instance = finishedWork.stateNode;

              if (finishedWork.effectTag & Update) {
                if (current$$1 === null) {
                  startPhaseTimer(finishedWork, "componentDidMount");
                  {
                    if (finishedWork.type === finishedWork.elementType) {
                      !(instance.props === finishedWork.memoizedProps) ? warning$1(false, "Expected instance props to match memoized props before " + "componentDidMount. This is likely due to a bug in React. " + "Please file an issue.") : void 0;
                      !(instance.state === finishedWork.memoizedState) ? warning$1(false, "Expected instance state to match memoized state before " + "componentDidMount. This is likely due to a bug in React. " + "Please file an issue.") : void 0;
                    }
                  }
                  instance.componentDidMount();
                  stopPhaseTimer();
                } else {
                  var prevProps = finishedWork.elementType === finishedWork.type ? current$$1.memoizedProps : resolveDefaultProps(finishedWork.type, current$$1.memoizedProps);
                  var prevState = current$$1.memoizedState;
                  startPhaseTimer(finishedWork, "componentDidUpdate");
                  {
                    if (finishedWork.type === finishedWork.elementType) {
                      !(instance.props === finishedWork.memoizedProps) ? warning$1(false, "Expected instance props to match memoized props before " + "componentDidUpdate. This is likely due to a bug in React. " + "Please file an issue.") : void 0;
                      !(instance.state === finishedWork.memoizedState) ? warning$1(false, "Expected instance state to match memoized state before " + "componentDidUpdate. This is likely due to a bug in React. " + "Please file an issue.") : void 0;
                    }
                  }
                  instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                  stopPhaseTimer();
                }
              }

              var updateQueue = finishedWork.updateQueue;

              if (updateQueue !== null) {
                {
                  if (finishedWork.type === finishedWork.elementType) {
                    !(instance.props === finishedWork.memoizedProps) ? warning$1(false, "Expected instance props to match memoized props before " + "processing the update queue. This is likely due to a bug in React. " + "Please file an issue.") : void 0;
                    !(instance.state === finishedWork.memoizedState) ? warning$1(false, "Expected instance state to match memoized state before " + "processing the update queue. This is likely due to a bug in React. " + "Please file an issue.") : void 0;
                  }
                }
                commitUpdateQueue(finishedWork, updateQueue, instance, committedExpirationTime);
              }

              return;
            }

          case HostRoot:
            {
              var _updateQueue = finishedWork.updateQueue;

              if (_updateQueue !== null) {
                var _instance = null;

                if (finishedWork.child !== null) {
                  switch (finishedWork.child.tag) {
                    case HostComponent:
                      _instance = getPublicInstance(finishedWork.child.stateNode);
                      break;

                    case ClassComponent:
                      _instance = finishedWork.child.stateNode;
                      break;
                  }
                }

                commitUpdateQueue(finishedWork, _updateQueue, _instance, committedExpirationTime);
              }

              return;
            }

          case HostComponent:
            {
              var _instance2 = finishedWork.stateNode;

              if (current$$1 === null && finishedWork.effectTag & Update) {
                var type = finishedWork.type;
                var props = finishedWork.memoizedProps;
                commitMount(_instance2, type, props, finishedWork);
              }

              return;
            }

          case HostText:
            {
              return;
            }

          case HostPortal:
            {
              return;
            }

          case Profiler:
            {
              if (enableProfilerTimer) {
                var onRender = finishedWork.memoizedProps.onRender;

                if (enableSchedulerTracing) {
                  onRender(finishedWork.memoizedProps.id, current$$1 === null ? "mount" : "update", finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime(), finishedRoot.memoizedInteractions);
                } else {
                  onRender(finishedWork.memoizedProps.id, current$$1 === null ? "mount" : "update", finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime());
                }
              }

              return;
            }

          case SuspenseComponent:
            break;

          case IncompleteClassComponent:
            break;

          default:
            {
              invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
            }
        }
      }

      function hideOrUnhideAllChildren(finishedWork, isHidden) {
        if (supportsMutation) {
          var node = finishedWork;

          while (true) {
            if (node.tag === HostComponent) {
              var instance = node.stateNode;

              if (isHidden) {
                hideInstance(instance);
              } else {
                unhideInstance(node.stateNode, node.memoizedProps);
              }
            } else if (node.tag === HostText) {
              var _instance3 = node.stateNode;

              if (isHidden) {
                hideTextInstance(_instance3);
              } else {
                unhideTextInstance(_instance3, node.memoizedProps);
              }
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }

            if (node === finishedWork) {
              return;
            }

            while (node.sibling === null) {
              if (node.return === null || node.return === finishedWork) {
                return;
              }

              node = node.return;
            }

            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
      }

      function commitAttachRef(finishedWork) {
        var ref = finishedWork.ref;

        if (ref !== null) {
          var instance = finishedWork.stateNode;
          var instanceToUse = void 0;

          switch (finishedWork.tag) {
            case HostComponent:
              instanceToUse = getPublicInstance(instance);
              break;

            default:
              instanceToUse = instance;
          }

          if (typeof ref === "function") {
            ref(instanceToUse);
          } else {
            {
              if (!ref.hasOwnProperty("current")) {
                warningWithoutStack$1(false, "Unexpected ref object provided for %s. " + "Use either a ref-setter function or React.createRef().%s", getComponentName(finishedWork.type), getStackByFiberInDevAndProd(finishedWork));
              }
            }
            ref.current = instanceToUse;
          }
        }
      }

      function commitDetachRef(current$$1) {
        var currentRef = current$$1.ref;

        if (currentRef !== null) {
          if (typeof currentRef === "function") {
            currentRef(null);
          } else {
            currentRef.current = null;
          }
        }
      }

      function commitUnmount(current$$1) {
        onCommitUnmount(current$$1);

        switch (current$$1.tag) {
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent:
            {
              var updateQueue = current$$1.updateQueue;

              if (updateQueue !== null) {
                var lastEffect = updateQueue.lastEffect;

                if (lastEffect !== null) {
                  var firstEffect = lastEffect.next;
                  var effect = firstEffect;

                  do {
                    var destroy = effect.destroy;

                    if (destroy !== null) {
                      safelyCallDestroy(current$$1, destroy);
                    }

                    effect = effect.next;
                  } while (effect !== firstEffect);
                }
              }

              break;
            }

          case ClassComponent:
            {
              safelyDetachRef(current$$1);
              var instance = current$$1.stateNode;

              if (typeof instance.componentWillUnmount === "function") {
                safelyCallComponentWillUnmount(current$$1, instance);
              }

              return;
            }

          case HostComponent:
            {
              safelyDetachRef(current$$1);
              return;
            }

          case HostPortal:
            {
              if (supportsMutation) {
                unmountHostComponents(current$$1);
              } else if (supportsPersistence) {
                emptyPortalContainer(current$$1);
              }

              return;
            }
        }
      }

      function commitNestedUnmounts(root) {
        var node = root;

        while (true) {
          commitUnmount(node);

          if (node.child !== null && (!supportsMutation || node.tag !== HostPortal)) {
            node.child.return = node;
            node = node.child;
            continue;
          }

          if (node === root) {
            return;
          }

          while (node.sibling === null) {
            if (node.return === null || node.return === root) {
              return;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }
      }

      function detachFiber(current$$1) {
        current$$1.return = null;
        current$$1.child = null;

        if (current$$1.alternate) {
          current$$1.alternate.child = null;
          current$$1.alternate.return = null;
        }
      }

      function emptyPortalContainer(current$$1) {
        if (!supportsPersistence) {
          return;
        }

        var portal = current$$1.stateNode;
        var containerInfo = portal.containerInfo;
        var emptyChildSet = createContainerChildSet(containerInfo);
      }

      function commitContainer(finishedWork) {
        if (!supportsPersistence) {
          return;
        }

        switch (finishedWork.tag) {
          case ClassComponent:
            {
              return;
            }

          case HostComponent:
            {
              return;
            }

          case HostText:
            {
              return;
            }

          case HostRoot:
          case HostPortal:
            {
              var portalOrRoot = finishedWork.stateNode;
              var containerInfo = portalOrRoot.containerInfo,
                  _pendingChildren = portalOrRoot.pendingChildren;
              return;
            }

          default:
            {
              invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
            }
        }
      }

      function getHostParentFiber(fiber) {
        var parent = fiber.return;

        while (parent !== null) {
          if (isHostParent(parent)) {
            return parent;
          }

          parent = parent.return;
        }

        invariant(false, "Expected to find a host parent. This error is likely caused by a bug " + "in React. Please file an issue.");
      }

      function isHostParent(fiber) {
        return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
      }

      function getHostSibling(fiber) {
        var node = fiber;

        siblings: while (true) {
          while (node.sibling === null) {
            if (node.return === null || isHostParent(node.return)) {
              return null;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;

          while (node.tag !== HostComponent && node.tag !== HostText) {
            if (node.effectTag & Placement) {
              continue siblings;
            }

            if (node.child === null || node.tag === HostPortal) {
              continue siblings;
            } else {
              node.child.return = node;
              node = node.child;
            }
          }

          if (!(node.effectTag & Placement)) {
            return node.stateNode;
          }
        }
      }

      function commitPlacement(finishedWork) {
        if (!supportsMutation) {
          return;
        }

        var parentFiber = getHostParentFiber(finishedWork);
        var parent = void 0;
        var isContainer = void 0;

        switch (parentFiber.tag) {
          case HostComponent:
            parent = parentFiber.stateNode;
            isContainer = false;
            break;

          case HostRoot:
            parent = parentFiber.stateNode.containerInfo;
            isContainer = true;
            break;

          case HostPortal:
            parent = parentFiber.stateNode.containerInfo;
            isContainer = true;
            break;

          default:
            invariant(false, "Invalid host parent fiber. This error is likely caused by a bug " + "in React. Please file an issue.");
        }

        if (parentFiber.effectTag & ContentReset) {
          resetTextContent(parent);
          parentFiber.effectTag &= ~ContentReset;
        }

        var before = getHostSibling(finishedWork);
        var node = finishedWork;

        while (true) {
          if (node.tag === HostComponent || node.tag === HostText) {
            if (before) {
              if (isContainer) {
                insertInContainerBefore(parent, node.stateNode, before);
              } else {
                insertBefore(parent, node.stateNode, before);
              }
            } else {
              if (isContainer) {
                appendChildToContainer(parent, node.stateNode);
              } else {
                appendChild$1(parent, node.stateNode);
              }
            }
          } else if (node.tag === HostPortal) {} else if (node.child !== null) {
            node.child.return = node;
            node = node.child;
            continue;
          }

          if (node === finishedWork) {
            return;
          }

          while (node.sibling === null) {
            if (node.return === null || node.return === finishedWork) {
              return;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }
      }

      function unmountHostComponents(current$$1) {
        var node = current$$1;
        var currentParentIsValid = false;
        var currentParent = void 0;
        var currentParentIsContainer = void 0;

        while (true) {
          if (!currentParentIsValid) {
            var parent = node.return;

            findParent: while (true) {
              invariant(parent !== null, "Expected to find a host parent. This error is likely caused by " + "a bug in React. Please file an issue.");

              switch (parent.tag) {
                case HostComponent:
                  currentParent = parent.stateNode;
                  currentParentIsContainer = false;
                  break findParent;

                case HostRoot:
                  currentParent = parent.stateNode.containerInfo;
                  currentParentIsContainer = true;
                  break findParent;

                case HostPortal:
                  currentParent = parent.stateNode.containerInfo;
                  currentParentIsContainer = true;
                  break findParent;
              }

              parent = parent.return;
            }

            currentParentIsValid = true;
          }

          if (node.tag === HostComponent || node.tag === HostText) {
            commitNestedUnmounts(node);

            if (currentParentIsContainer) {
              removeChildFromContainer(currentParent, node.stateNode);
            } else {
              removeChild(currentParent, node.stateNode);
            }
          } else if (node.tag === HostPortal) {
            currentParent = node.stateNode.containerInfo;
            currentParentIsContainer = true;

            if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
          } else {
            commitUnmount(node);

            if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
          }

          if (node === current$$1) {
            return;
          }

          while (node.sibling === null) {
            if (node.return === null || node.return === current$$1) {
              return;
            }

            node = node.return;

            if (node.tag === HostPortal) {
              currentParentIsValid = false;
            }
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }
      }

      function commitDeletion(current$$1) {
        if (supportsMutation) {
          unmountHostComponents(current$$1);
        } else {
          commitNestedUnmounts(current$$1);
        }

        detachFiber(current$$1);
      }

      function commitWork(current$$1, finishedWork) {
        if (!supportsMutation) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent:
              {
                commitHookEffectList(UnmountMutation, MountMutation, finishedWork);
                return;
              }
          }

          commitContainer(finishedWork);
          return;
        }

        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent:
            {
              commitHookEffectList(UnmountMutation, MountMutation, finishedWork);
              return;
            }

          case ClassComponent:
            {
              return;
            }

          case HostComponent:
            {
              var instance = finishedWork.stateNode;

              if (instance != null) {
                var newProps = finishedWork.memoizedProps;
                var oldProps = current$$1 !== null ? current$$1.memoizedProps : newProps;
                var type = finishedWork.type;
                var updatePayload = finishedWork.updateQueue;
                finishedWork.updateQueue = null;

                if (updatePayload !== null) {
                  commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
                }
              }

              return;
            }

          case HostText:
            {
              invariant(finishedWork.stateNode !== null, "This should have a text node initialized. This error is likely " + "caused by a bug in React. Please file an issue.");
              var textInstance = finishedWork.stateNode;
              var newText = finishedWork.memoizedProps;
              var oldText = current$$1 !== null ? current$$1.memoizedProps : newText;
              commitTextUpdate(textInstance, oldText, newText);
              return;
            }

          case HostRoot:
            {
              return;
            }

          case Profiler:
            {
              return;
            }

          case SuspenseComponent:
            {
              var newState = finishedWork.memoizedState;
              var newDidTimeout = void 0;
              var primaryChildParent = finishedWork;

              if (newState === null) {
                newDidTimeout = false;
              } else {
                newDidTimeout = true;
                primaryChildParent = finishedWork.child;

                if (newState.timedOutAt === NoWork) {
                  newState.timedOutAt = requestCurrentTime();
                }
              }

              if (primaryChildParent !== null) {
                hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);
              }

              return;
            }

          case IncompleteClassComponent:
            {
              return;
            }

          default:
            {
              invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
            }
        }
      }

      function commitResetTextContent(current$$1) {
        if (!supportsMutation) {
          return;
        }

        resetTextContent(current$$1.stateNode);
      }

      function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
        var update = createUpdate(expirationTime);
        update.tag = CaptureUpdate;
        update.payload = {
          element: null
        };
        var error = errorInfo.value;

        update.callback = function () {
          onUncaughtError(error);
          logError(fiber, errorInfo);
        };

        return update;
      }

      function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
        var update = createUpdate(expirationTime);
        update.tag = CaptureUpdate;
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;

        if (typeof getDerivedStateFromError === "function") {
          var error = errorInfo.value;

          update.payload = function () {
            return getDerivedStateFromError(error);
          };
        }

        var inst = fiber.stateNode;

        if (inst !== null && typeof inst.componentDidCatch === "function") {
          update.callback = function callback() {
            if (typeof getDerivedStateFromError !== "function") {
              markLegacyErrorBoundaryAsFailed(this);
            }

            var error = errorInfo.value;
            var stack = errorInfo.stack;
            logError(fiber, errorInfo);
            this.componentDidCatch(error, {
              componentStack: stack !== null ? stack : ""
            });
            {
              if (typeof getDerivedStateFromError !== "function") {
                !(fiber.expirationTime === Sync) ? warningWithoutStack$1(false, "%s: Error boundaries should implement getDerivedStateFromError(). " + "In that method, return a state update to display an error message or fallback UI.", getComponentName(fiber.type) || "Unknown") : void 0;
              }
            }
          };
        }

        return update;
      }

      function throwException(root, returnFiber, sourceFiber, value, renderExpirationTime) {
        sourceFiber.effectTag |= Incomplete;
        sourceFiber.firstEffect = sourceFiber.lastEffect = null;

        if (value !== null && typeof value === "object" && typeof value.then === "function") {
          var thenable = value;
          var _workInProgress = returnFiber;
          var earliestTimeoutMs = -1;
          var startTimeMs = -1;

          do {
            if (_workInProgress.tag === SuspenseComponent) {
              var current$$1 = _workInProgress.alternate;

              if (current$$1 !== null) {
                var currentState = current$$1.memoizedState;

                if (currentState !== null) {
                  var timedOutAt = currentState.timedOutAt;
                  startTimeMs = expirationTimeToMs(timedOutAt);
                  break;
                }
              }

              var timeoutPropMs = _workInProgress.pendingProps.maxDuration;

              if (typeof timeoutPropMs === "number") {
                if (timeoutPropMs <= 0) {
                  earliestTimeoutMs = 0;
                } else if (earliestTimeoutMs === -1 || timeoutPropMs < earliestTimeoutMs) {
                  earliestTimeoutMs = timeoutPropMs;
                }
              }
            }

            _workInProgress = _workInProgress.return;
          } while (_workInProgress !== null);

          _workInProgress = returnFiber;

          do {
            if (_workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(_workInProgress.alternate, _workInProgress)) {
              var pingTime = (_workInProgress.mode & ConcurrentMode) === NoEffect ? Sync : renderExpirationTime;
              var onResolveOrReject = retrySuspendedRoot.bind(null, root, _workInProgress, sourceFiber, pingTime);

              if (enableSchedulerTracing) {
                onResolveOrReject = tracing.unstable_wrap(onResolveOrReject);
              }

              thenable.then(onResolveOrReject, onResolveOrReject);

              if ((_workInProgress.mode & ConcurrentMode) === NoEffect) {
                _workInProgress.effectTag |= DidCapture;
                var nextChildren = null;
                reconcileChildren(sourceFiber.alternate, sourceFiber, nextChildren, renderExpirationTime);
                sourceFiber.effectTag &= ~Incomplete;
                sourceFiber.effectTag &= ~LifecycleEffectMask;

                if (sourceFiber.tag === ClassComponent) {
                  var _current = sourceFiber.alternate;

                  if (_current === null) {
                    sourceFiber.tag = IncompleteClassComponent;
                  }
                }

                sourceFiber.expirationTime = renderExpirationTime;
                return;
              }

              var absoluteTimeoutMs = void 0;

              if (earliestTimeoutMs === -1) {
                absoluteTimeoutMs = maxSigned31BitInt;
              } else {
                if (startTimeMs === -1) {
                  var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, renderExpirationTime);
                  var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);
                  startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
                }

                absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
              }

              renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);
              _workInProgress.effectTag |= ShouldCapture;
              _workInProgress.expirationTime = renderExpirationTime;
              return;
            }

            _workInProgress = _workInProgress.return;
          } while (_workInProgress !== null);

          value = new Error((getComponentName(sourceFiber.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n" + "\n" + "Add a <Suspense fallback=...> component higher in the tree to " + "provide a loading indicator or placeholder to display." + getStackByFiberInDevAndProd(sourceFiber));
        }

        renderDidError();
        value = createCapturedValue(value, sourceFiber);
        var workInProgress = returnFiber;

        do {
          switch (workInProgress.tag) {
            case HostRoot:
              {
                var _errorInfo = value;
                workInProgress.effectTag |= ShouldCapture;
                workInProgress.expirationTime = renderExpirationTime;
                var update = createRootErrorUpdate(workInProgress, _errorInfo, renderExpirationTime);
                enqueueCapturedUpdate(workInProgress, update);
                return;
              }

            case ClassComponent:
              var errorInfo = value;
              var ctor = workInProgress.type;
              var instance = workInProgress.stateNode;

              if ((workInProgress.effectTag & DidCapture) === NoEffect && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                workInProgress.effectTag |= ShouldCapture;
                workInProgress.expirationTime = renderExpirationTime;

                var _update = createClassErrorUpdate(workInProgress, errorInfo, renderExpirationTime);

                enqueueCapturedUpdate(workInProgress, _update);
                return;
              }

              break;

            default:
              break;
          }

          workInProgress = workInProgress.return;
        } while (workInProgress !== null);
      }

      function unwindWork(workInProgress, renderExpirationTime) {
        switch (workInProgress.tag) {
          case ClassComponent:
            {
              var Component = workInProgress.type;

              if (isContextProvider(Component)) {
                popContext(workInProgress);
              }

              var effectTag = workInProgress.effectTag;

              if (effectTag & ShouldCapture) {
                workInProgress.effectTag = effectTag & ~ShouldCapture | DidCapture;
                return workInProgress;
              }

              return null;
            }

          case HostRoot:
            {
              popHostContainer(workInProgress);
              popTopLevelContextObject(workInProgress);
              var _effectTag = workInProgress.effectTag;
              invariant((_effectTag & DidCapture) === NoEffect, "The root failed to unmount after an error. This is likely a bug in " + "React. Please file an issue.");
              workInProgress.effectTag = _effectTag & ~ShouldCapture | DidCapture;
              return workInProgress;
            }

          case HostComponent:
            {
              popHostContext(workInProgress);
              return null;
            }

          case SuspenseComponent:
            {
              var _effectTag2 = workInProgress.effectTag;

              if (_effectTag2 & ShouldCapture) {
                workInProgress.effectTag = _effectTag2 & ~ShouldCapture | DidCapture;
                return workInProgress;
              }

              return null;
            }

          case HostPortal:
            popHostContainer(workInProgress);
            return null;

          case ContextProvider:
            popProvider(workInProgress);
            return null;

          default:
            return null;
        }
      }

      function unwindInterruptedWork(interruptedWork) {
        switch (interruptedWork.tag) {
          case ClassComponent:
            {
              var childContextTypes = interruptedWork.type.childContextTypes;

              if (childContextTypes !== null && childContextTypes !== undefined) {
                popContext(interruptedWork);
              }

              break;
            }

          case HostRoot:
            {
              popHostContainer(interruptedWork);
              popTopLevelContextObject(interruptedWork);
              break;
            }

          case HostComponent:
            {
              popHostContext(interruptedWork);
              break;
            }

          case HostPortal:
            popHostContainer(interruptedWork);
            break;

          case ContextProvider:
            popProvider(interruptedWork);
            break;

          default:
            break;
        }
      }

      var Dispatcher = {
        readContext: readContext,
        useCallback: useCallback,
        useContext: useContext,
        useEffect: useEffect,
        useImperativeMethods: useImperativeMethods,
        useLayoutEffect: useLayoutEffect,
        useMemo: useMemo,
        useMutationEffect: useMutationEffect,
        useReducer: useReducer,
        useRef: useRef,
        useState: useState
      };
      var DispatcherWithoutHooks = {
        readContext: readContext
      };
      var ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;
      var didWarnAboutStateTransition = void 0;
      var didWarnSetStateChildContext = void 0;
      var warnAboutUpdateOnUnmounted = void 0;
      var warnAboutInvalidUpdates = void 0;

      if (enableSchedulerTracing) {
        invariant(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null, "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) " + "without also replacing the `schedule/tracing` module with `schedule/tracing-profiling`. " + "Your bundler might have a setting for aliasing both modules. " + "Learn more at http://fb.me/react-profiling");
      }

      {
        didWarnAboutStateTransition = false;
        didWarnSetStateChildContext = false;
        var didWarnStateUpdateForUnmountedComponent = {};

        warnAboutUpdateOnUnmounted = function warnAboutUpdateOnUnmounted(fiber, isClass) {
          var componentName = getComponentName(fiber.type) || "ReactComponent";

          if (didWarnStateUpdateForUnmountedComponent[componentName]) {
            return;
          }

          warningWithoutStack$1(false, "Can't perform a React state update on an unmounted component. This " + "is a no-op, but it indicates a memory leak in your application. To " + "fix, cancel all subscriptions and asynchronous tasks in %s.%s", isClass ? "the componentWillUnmount method" : "a useEffect cleanup function", getStackByFiberInDevAndProd(fiber));
          didWarnStateUpdateForUnmountedComponent[componentName] = true;
        };

        warnAboutInvalidUpdates = function warnAboutInvalidUpdates(instance) {
          switch (phase) {
            case "getChildContext":
              if (didWarnSetStateChildContext) {
                return;
              }

              warningWithoutStack$1(false, "setState(...): Cannot call setState() inside getChildContext()");
              didWarnSetStateChildContext = true;
              break;

            case "render":
              if (didWarnAboutStateTransition) {
                return;
              }

              warningWithoutStack$1(false, "Cannot update during an existing state transition (such as within " + "`render`). Render methods should be a pure function of props and state.");
              didWarnAboutStateTransition = true;
              break;
          }
        };
      }
      var expirationContext = NoWork;
      var isWorking = false;
      var nextUnitOfWork = null;
      var nextRoot = null;
      var nextRenderExpirationTime = NoWork;
      var nextLatestAbsoluteTimeoutMs = -1;
      var nextRenderDidError = false;
      var nextEffect = null;
      var isCommitting$1 = false;
      var rootWithPendingPassiveEffects = null;
      var passiveEffectCallbackHandle = null;
      var passiveEffectCallback = null;
      var legacyErrorBoundariesThatAlreadyFailed = null;
      var interruptedBy = null;
      var stashedWorkInProgressProperties = void 0;
      var replayUnitOfWork = void 0;
      var mayReplayFailedUnitOfWork = void 0;
      var isReplayingFailedUnitOfWork = void 0;
      var originalReplayError = void 0;
      var rethrowOriginalError = void 0;

      if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
        stashedWorkInProgressProperties = null;
        mayReplayFailedUnitOfWork = true;
        isReplayingFailedUnitOfWork = false;
        originalReplayError = null;

        replayUnitOfWork = function replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy) {
          if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
            return;
          }

          if (stashedWorkInProgressProperties === null) {
            warningWithoutStack$1(false, "Could not replay rendering after an error. This is likely a bug in React. " + "Please file an issue.");
            return;
          }

          assignFiberPropertiesInDEV(failedUnitOfWork, stashedWorkInProgressProperties);

          switch (failedUnitOfWork.tag) {
            case HostRoot:
              popHostContainer(failedUnitOfWork);
              popTopLevelContextObject(failedUnitOfWork);
              break;

            case HostComponent:
              popHostContext(failedUnitOfWork);
              break;

            case ClassComponent:
              {
                var Component = failedUnitOfWork.type;

                if (isContextProvider(Component)) {
                  popContext(failedUnitOfWork);
                }

                break;
              }

            case HostPortal:
              popHostContainer(failedUnitOfWork);
              break;

            case ContextProvider:
              popProvider(failedUnitOfWork);
              break;
          }

          isReplayingFailedUnitOfWork = true;
          originalReplayError = thrownValue;
          invokeGuardedCallback(null, workLoop, null, isYieldy);
          isReplayingFailedUnitOfWork = false;
          originalReplayError = null;

          if (hasCaughtError()) {
            var replayError = clearCaughtError();

            if (replayError != null && thrownValue != null) {
              try {
                if (replayError._suppressLogging) {
                  thrownValue._suppressLogging = true;
                }
              } catch (inner) {}
            }
          } else {
            nextUnitOfWork = failedUnitOfWork;
          }
        };

        rethrowOriginalError = function rethrowOriginalError() {
          throw originalReplayError;
        };
      }

      function resetStack() {
        if (nextUnitOfWork !== null) {
          var interruptedWork = nextUnitOfWork.return;

          while (interruptedWork !== null) {
            unwindInterruptedWork(interruptedWork);
            interruptedWork = interruptedWork.return;
          }
        }

        {
          ReactStrictModeWarnings.discardPendingWarnings();
          checkThatStackIsEmpty();
        }
        nextRoot = null;
        nextRenderExpirationTime = NoWork;
        nextLatestAbsoluteTimeoutMs = -1;
        nextRenderDidError = false;
        nextUnitOfWork = null;
      }

      function commitAllHostEffects() {
        while (nextEffect !== null) {
          {
            setCurrentFiber(nextEffect);
          }
          recordEffect();
          var effectTag = nextEffect.effectTag;

          if (effectTag & ContentReset) {
            commitResetTextContent(nextEffect);
          }

          if (effectTag & Ref) {
            var current$$1 = nextEffect.alternate;

            if (current$$1 !== null) {
              commitDetachRef(current$$1);
            }
          }

          var primaryEffectTag = effectTag & (Placement | Update | Deletion);

          switch (primaryEffectTag) {
            case Placement:
              {
                commitPlacement(nextEffect);
                nextEffect.effectTag &= ~Placement;
                break;
              }

            case PlacementAndUpdate:
              {
                commitPlacement(nextEffect);
                nextEffect.effectTag &= ~Placement;
                var _current = nextEffect.alternate;
                commitWork(_current, nextEffect);
                break;
              }

            case Update:
              {
                var _current2 = nextEffect.alternate;
                commitWork(_current2, nextEffect);
                break;
              }

            case Deletion:
              {
                commitDeletion(nextEffect);
                break;
              }
          }

          nextEffect = nextEffect.nextEffect;
        }

        {
          resetCurrentFiber();
        }
      }

      function commitBeforeMutationLifecycles() {
        while (nextEffect !== null) {
          {
            setCurrentFiber(nextEffect);
          }
          var effectTag = nextEffect.effectTag;

          if (effectTag & Snapshot) {
            recordEffect();
            var current$$1 = nextEffect.alternate;
            commitBeforeMutationLifeCycles(current$$1, nextEffect);
          }

          nextEffect = nextEffect.nextEffect;
        }

        {
          resetCurrentFiber();
        }
      }

      function commitAllLifeCycles(finishedRoot, committedExpirationTime) {
        {
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
          ReactStrictModeWarnings.flushLegacyContextWarning();

          if (warnAboutDeprecatedLifecycles) {
            ReactStrictModeWarnings.flushPendingDeprecationWarnings();
          }
        }

        while (nextEffect !== null) {
          var effectTag = nextEffect.effectTag;

          if (effectTag & (Update | Callback)) {
            recordEffect();
            var current$$1 = nextEffect.alternate;
            commitLifeCycles(finishedRoot, current$$1, nextEffect, committedExpirationTime);
          }

          if (effectTag & Ref) {
            recordEffect();
            commitAttachRef(nextEffect);
          }

          if (enableHooks && effectTag & Passive) {
            rootWithPendingPassiveEffects = finishedRoot;
          }

          nextEffect = nextEffect.nextEffect;
        }
      }

      function commitPassiveEffects(root, firstEffect) {
        rootWithPendingPassiveEffects = null;
        passiveEffectCallbackHandle = null;
        passiveEffectCallback = null;
        var previousIsRendering = isRendering;
        isRendering = true;
        var effect = firstEffect;

        do {
          if (effect.effectTag & Passive) {
            var didError = false;
            var error = void 0;
            {
              invokeGuardedCallback(null, commitPassiveHookEffects, null, effect);

              if (hasCaughtError()) {
                didError = true;
                error = clearCaughtError();
              }
            }

            if (didError) {
              captureCommitPhaseError(effect, error);
            }
          }

          effect = effect.nextEffect;
        } while (effect !== null);

        isRendering = previousIsRendering;
        var rootExpirationTime = root.expirationTime;

        if (rootExpirationTime !== NoWork) {
          requestWork(root, rootExpirationTime);
        }
      }

      function isAlreadyFailedLegacyErrorBoundary(instance) {
        return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
      }

      function markLegacyErrorBoundaryAsFailed(instance) {
        if (legacyErrorBoundariesThatAlreadyFailed === null) {
          legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
        } else {
          legacyErrorBoundariesThatAlreadyFailed.add(instance);
        }
      }

      function flushPassiveEffects() {
        if (passiveEffectCallback !== null) {
          scheduler.unstable_cancelCallback(passiveEffectCallbackHandle);
          passiveEffectCallback();
        }
      }

      function commitRoot(root, finishedWork) {
        isWorking = true;
        isCommitting$1 = true;
        startCommitTimer();
        invariant(root.current !== finishedWork, "Cannot commit the same tree as before. This is probably a bug " + "related to the return field. This error is likely caused by a bug " + "in React. Please file an issue.");
        var committedExpirationTime = root.pendingCommitExpirationTime;
        invariant(committedExpirationTime !== NoWork, "Cannot commit an incomplete root. This error is likely caused by a " + "bug in React. Please file an issue.");
        root.pendingCommitExpirationTime = NoWork;
        var updateExpirationTimeBeforeCommit = finishedWork.expirationTime;
        var childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;
        var earliestRemainingTimeBeforeCommit = childExpirationTimeBeforeCommit > updateExpirationTimeBeforeCommit ? childExpirationTimeBeforeCommit : updateExpirationTimeBeforeCommit;
        markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);
        var prevInteractions = null;

        if (enableSchedulerTracing) {
          prevInteractions = tracing.__interactionsRef.current;
          tracing.__interactionsRef.current = root.memoizedInteractions;
        }

        ReactCurrentOwner$2.current = null;
        var firstEffect = void 0;

        if (finishedWork.effectTag > PerformedWork) {
          if (finishedWork.lastEffect !== null) {
            finishedWork.lastEffect.nextEffect = finishedWork;
            firstEffect = finishedWork.firstEffect;
          } else {
            firstEffect = finishedWork;
          }
        } else {
          firstEffect = finishedWork.firstEffect;
        }

        prepareForCommit(root.containerInfo);
        nextEffect = firstEffect;
        startCommitSnapshotEffectsTimer();

        while (nextEffect !== null) {
          var didError = false;
          var error = void 0;
          {
            invokeGuardedCallback(null, commitBeforeMutationLifecycles, null);

            if (hasCaughtError()) {
              didError = true;
              error = clearCaughtError();
            }
          }

          if (didError) {
            invariant(nextEffect !== null, "Should have next effect. This error is likely caused by a bug " + "in React. Please file an issue.");
            captureCommitPhaseError(nextEffect, error);

            if (nextEffect !== null) {
              nextEffect = nextEffect.nextEffect;
            }
          }
        }

        stopCommitSnapshotEffectsTimer();

        if (enableProfilerTimer) {
          recordCommitTime();
        }

        nextEffect = firstEffect;
        startCommitHostEffectsTimer();

        while (nextEffect !== null) {
          var _didError = false;

          var _error = void 0;

          {
            invokeGuardedCallback(null, commitAllHostEffects, null);

            if (hasCaughtError()) {
              _didError = true;
              _error = clearCaughtError();
            }
          }

          if (_didError) {
            invariant(nextEffect !== null, "Should have next effect. This error is likely caused by a bug " + "in React. Please file an issue.");
            captureCommitPhaseError(nextEffect, _error);

            if (nextEffect !== null) {
              nextEffect = nextEffect.nextEffect;
            }
          }
        }

        stopCommitHostEffectsTimer();
        resetAfterCommit(root.containerInfo);
        root.current = finishedWork;
        nextEffect = firstEffect;
        startCommitLifeCyclesTimer();

        while (nextEffect !== null) {
          var _didError2 = false;

          var _error2 = void 0;

          {
            invokeGuardedCallback(null, commitAllLifeCycles, null, root, committedExpirationTime);

            if (hasCaughtError()) {
              _didError2 = true;
              _error2 = clearCaughtError();
            }
          }

          if (_didError2) {
            invariant(nextEffect !== null, "Should have next effect. This error is likely caused by a bug " + "in React. Please file an issue.");
            captureCommitPhaseError(nextEffect, _error2);

            if (nextEffect !== null) {
              nextEffect = nextEffect.nextEffect;
            }
          }
        }

        if (enableHooks && firstEffect !== null && rootWithPendingPassiveEffects !== null) {
          var callback = commitPassiveEffects.bind(null, root, firstEffect);

          if (enableSchedulerTracing) {
            callback = tracing.unstable_wrap(callback);
          }

          passiveEffectCallbackHandle = scheduler.unstable_scheduleCallback(callback);
          passiveEffectCallback = callback;
        }

        isCommitting$1 = false;
        isWorking = false;
        stopCommitLifeCyclesTimer();
        stopCommitTimer();
        onCommitRoot(finishedWork.stateNode);

        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);
        }

        var updateExpirationTimeAfterCommit = finishedWork.expirationTime;
        var childExpirationTimeAfterCommit = finishedWork.childExpirationTime;
        var earliestRemainingTimeAfterCommit = childExpirationTimeAfterCommit > updateExpirationTimeAfterCommit ? childExpirationTimeAfterCommit : updateExpirationTimeAfterCommit;

        if (earliestRemainingTimeAfterCommit === NoWork) {
          legacyErrorBoundariesThatAlreadyFailed = null;
        }

        onCommit(root, earliestRemainingTimeAfterCommit);

        if (enableSchedulerTracing) {
          tracing.__interactionsRef.current = prevInteractions;
          var subscriber = void 0;

          try {
            subscriber = tracing.__subscriberRef.current;

            if (subscriber !== null && root.memoizedInteractions.size > 0) {
              var threadID = computeThreadID(committedExpirationTime, root.interactionThreadID);
              subscriber.onWorkStopped(root.memoizedInteractions, threadID);
            }
          } catch (error) {
            if (!hasUnhandledError) {
              hasUnhandledError = true;
              unhandledError = error;
            }
          } finally {
            var pendingInteractionMap = root.pendingInteractionMap;
            pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {
              if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {
                pendingInteractionMap.delete(scheduledExpirationTime);
                scheduledInteractions.forEach(function (interaction) {
                  interaction.__count--;

                  if (subscriber !== null && interaction.__count === 0) {
                    try {
                      subscriber.onInteractionScheduledWorkCompleted(interaction);
                    } catch (error) {
                      if (!hasUnhandledError) {
                        hasUnhandledError = true;
                        unhandledError = error;
                      }
                    }
                  }
                });
              }
            });
          }
        }
      }

      function resetChildExpirationTime(workInProgress, renderTime) {
        if (renderTime !== Never && workInProgress.childExpirationTime === Never) {
          return;
        }

        var newChildExpirationTime = NoWork;

        if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
          var actualDuration = workInProgress.actualDuration;
          var treeBaseDuration = workInProgress.selfBaseDuration;
          var shouldBubbleActualDurations = workInProgress.alternate === null || workInProgress.child !== workInProgress.alternate.child;
          var child = workInProgress.child;

          while (child !== null) {
            var childUpdateExpirationTime = child.expirationTime;
            var childChildExpirationTime = child.childExpirationTime;

            if (childUpdateExpirationTime > newChildExpirationTime) {
              newChildExpirationTime = childUpdateExpirationTime;
            }

            if (childChildExpirationTime > newChildExpirationTime) {
              newChildExpirationTime = childChildExpirationTime;
            }

            if (shouldBubbleActualDurations) {
              actualDuration += child.actualDuration;
            }

            treeBaseDuration += child.treeBaseDuration;
            child = child.sibling;
          }

          workInProgress.actualDuration = actualDuration;
          workInProgress.treeBaseDuration = treeBaseDuration;
        } else {
          var _child = workInProgress.child;

          while (_child !== null) {
            var _childUpdateExpirationTime = _child.expirationTime;
            var _childChildExpirationTime = _child.childExpirationTime;

            if (_childUpdateExpirationTime > newChildExpirationTime) {
              newChildExpirationTime = _childUpdateExpirationTime;
            }

            if (_childChildExpirationTime > newChildExpirationTime) {
              newChildExpirationTime = _childChildExpirationTime;
            }

            _child = _child.sibling;
          }
        }

        workInProgress.childExpirationTime = newChildExpirationTime;
      }

      function completeUnitOfWork(workInProgress) {
        while (true) {
          var current$$1 = workInProgress.alternate;
          {
            setCurrentFiber(workInProgress);
          }
          var returnFiber = workInProgress.return;
          var siblingFiber = workInProgress.sibling;

          if ((workInProgress.effectTag & Incomplete) === NoEffect) {
            if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
              mayReplayFailedUnitOfWork = false;
            }

            nextUnitOfWork = workInProgress;

            if (enableProfilerTimer) {
              if (workInProgress.mode & ProfileMode) {
                startProfilerTimer(workInProgress);
              }

              nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);

              if (workInProgress.mode & ProfileMode) {
                stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
              }
            } else {
              nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);
            }

            if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
              mayReplayFailedUnitOfWork = true;
            }

            stopWorkTimer(workInProgress);
            resetChildExpirationTime(workInProgress, nextRenderExpirationTime);
            {
              resetCurrentFiber();
            }

            if (nextUnitOfWork !== null) {
              return nextUnitOfWork;
            }

            if (returnFiber !== null && (returnFiber.effectTag & Incomplete) === NoEffect) {
              if (returnFiber.firstEffect === null) {
                returnFiber.firstEffect = workInProgress.firstEffect;
              }

              if (workInProgress.lastEffect !== null) {
                if (returnFiber.lastEffect !== null) {
                  returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
                }

                returnFiber.lastEffect = workInProgress.lastEffect;
              }

              var effectTag = workInProgress.effectTag;

              if (effectTag > PerformedWork) {
                if (returnFiber.lastEffect !== null) {
                  returnFiber.lastEffect.nextEffect = workInProgress;
                } else {
                  returnFiber.firstEffect = workInProgress;
                }

                returnFiber.lastEffect = workInProgress;
              }
            }

            if (true && ReactFiberInstrumentation_1.debugTool) {
              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
            }

            if (siblingFiber !== null) {
              return siblingFiber;
            } else if (returnFiber !== null) {
              workInProgress = returnFiber;
              continue;
            } else {
              return null;
            }
          } else {
            if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
              stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
              var actualDuration = workInProgress.actualDuration;
              var child = workInProgress.child;

              while (child !== null) {
                actualDuration += child.actualDuration;
                child = child.sibling;
              }

              workInProgress.actualDuration = actualDuration;
            }

            var next = unwindWork(workInProgress, nextRenderExpirationTime);

            if (workInProgress.effectTag & DidCapture) {
              stopFailedWorkTimer(workInProgress);
            } else {
              stopWorkTimer(workInProgress);
            }

            {
              resetCurrentFiber();
            }

            if (next !== null) {
              stopWorkTimer(workInProgress);

              if (true && ReactFiberInstrumentation_1.debugTool) {
                ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
              }

              next.effectTag &= HostEffectMask;
              return next;
            }

            if (returnFiber !== null) {
              returnFiber.firstEffect = returnFiber.lastEffect = null;
              returnFiber.effectTag |= Incomplete;
            }

            if (true && ReactFiberInstrumentation_1.debugTool) {
              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
            }

            if (siblingFiber !== null) {
              return siblingFiber;
            } else if (returnFiber !== null) {
              workInProgress = returnFiber;
              continue;
            } else {
              return null;
            }
          }
        }

        return null;
      }

      function performUnitOfWork(workInProgress) {
        var current$$1 = workInProgress.alternate;
        startWorkTimer(workInProgress);
        {
          setCurrentFiber(workInProgress);
        }

        if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
          stashedWorkInProgressProperties = assignFiberPropertiesInDEV(stashedWorkInProgressProperties, workInProgress);
        }

        var next = void 0;

        if (enableProfilerTimer) {
          if (workInProgress.mode & ProfileMode) {
            startProfilerTimer(workInProgress);
          }

          next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
          workInProgress.memoizedProps = workInProgress.pendingProps;

          if (workInProgress.mode & ProfileMode) {
            stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);
          }
        } else {
          next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
          workInProgress.memoizedProps = workInProgress.pendingProps;
        }

        {
          resetCurrentFiber();

          if (isReplayingFailedUnitOfWork) {
            rethrowOriginalError();
          }
        }

        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
        }

        if (next === null) {
          next = completeUnitOfWork(workInProgress);
        }

        ReactCurrentOwner$2.current = null;
        return next;
      }

      function workLoop(isYieldy) {
        if (!isYieldy) {
          while (nextUnitOfWork !== null) {
            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
          }
        } else {
          while (nextUnitOfWork !== null && !shouldYieldToRenderer()) {
            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
          }
        }
      }

      function renderRoot(root, isYieldy) {
        invariant(!isWorking, "renderRoot was called recursively. This error is likely caused " + "by a bug in React. Please file an issue.");
        flushPassiveEffects();
        isWorking = true;

        if (enableHooks) {
          ReactCurrentOwner$2.currentDispatcher = Dispatcher;
        } else {
          ReactCurrentOwner$2.currentDispatcher = DispatcherWithoutHooks;
        }

        var expirationTime = root.nextExpirationTimeToWorkOn;

        if (expirationTime !== nextRenderExpirationTime || root !== nextRoot || nextUnitOfWork === null) {
          resetStack();
          nextRoot = root;
          nextRenderExpirationTime = expirationTime;
          nextUnitOfWork = createWorkInProgress(nextRoot.current, null, nextRenderExpirationTime);
          root.pendingCommitExpirationTime = NoWork;

          if (enableSchedulerTracing) {
            var interactions = new Set();
            root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {
              if (scheduledExpirationTime >= expirationTime) {
                scheduledInteractions.forEach(function (interaction) {
                  return interactions.add(interaction);
                });
              }
            });
            root.memoizedInteractions = interactions;

            if (interactions.size > 0) {
              var subscriber = tracing.__subscriberRef.current;

              if (subscriber !== null) {
                var threadID = computeThreadID(expirationTime, root.interactionThreadID);

                try {
                  subscriber.onWorkStarted(interactions, threadID);
                } catch (error) {
                  if (!hasUnhandledError) {
                    hasUnhandledError = true;
                    unhandledError = error;
                  }
                }
              }
            }
          }
        }

        var prevInteractions = null;

        if (enableSchedulerTracing) {
          prevInteractions = tracing.__interactionsRef.current;
          tracing.__interactionsRef.current = root.memoizedInteractions;
        }

        var didFatal = false;
        startWorkLoopTimer(nextUnitOfWork);

        do {
          try {
            workLoop(isYieldy);
          } catch (thrownValue) {
            resetContextDependences();
            resetHooks();
            var mayReplay = void 0;

            if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
              mayReplay = mayReplayFailedUnitOfWork;
              mayReplayFailedUnitOfWork = true;
            }

            if (nextUnitOfWork === null) {
              didFatal = true;
              onUncaughtError(thrownValue);
            } else {
              if (enableProfilerTimer && nextUnitOfWork.mode & ProfileMode) {
                stopProfilerTimerIfRunningAndRecordDelta(nextUnitOfWork, true);
              }

              {
                resetCurrentlyProcessingQueue();
              }

              if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
                if (mayReplay) {
                  var failedUnitOfWork = nextUnitOfWork;
                  replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);
                }
              }

              invariant(nextUnitOfWork !== null, "Failed to replay rendering after an error. This " + "is likely caused by a bug in React. Please file an issue " + "with a reproducing case to help us find it.");
              var sourceFiber = nextUnitOfWork;
              var returnFiber = sourceFiber.return;

              if (returnFiber === null) {
                didFatal = true;
                onUncaughtError(thrownValue);
              } else {
                throwException(root, returnFiber, sourceFiber, thrownValue, nextRenderExpirationTime);
                nextUnitOfWork = completeUnitOfWork(sourceFiber);
                continue;
              }
            }
          }

          break;
        } while (true);

        if (enableSchedulerTracing) {
          tracing.__interactionsRef.current = prevInteractions;
        }

        isWorking = false;
        ReactCurrentOwner$2.currentDispatcher = null;
        resetContextDependences();
        resetHooks();

        if (didFatal) {
          var _didCompleteRoot = false;
          stopWorkLoopTimer(interruptedBy, _didCompleteRoot);
          interruptedBy = null;
          {
            resetStackAfterFatalErrorInDev();
          }
          nextRoot = null;
          onFatal(root);
          return;
        }

        if (nextUnitOfWork !== null) {
          var _didCompleteRoot2 = false;
          stopWorkLoopTimer(interruptedBy, _didCompleteRoot2);
          interruptedBy = null;
          onYield(root);
          return;
        }

        var didCompleteRoot = true;
        stopWorkLoopTimer(interruptedBy, didCompleteRoot);
        var rootWorkInProgress = root.current.alternate;
        invariant(rootWorkInProgress !== null, "Finished root should have a work-in-progress. This error is likely " + "caused by a bug in React. Please file an issue.");
        nextRoot = null;
        interruptedBy = null;

        if (nextRenderDidError) {
          if (hasLowerPriorityWork(root, expirationTime)) {
            markSuspendedPriorityLevel(root, expirationTime);
            var suspendedExpirationTime = expirationTime;
            var rootExpirationTime = root.expirationTime;
            onSuspend(root, rootWorkInProgress, suspendedExpirationTime, rootExpirationTime, -1);
            return;
          } else if (!root.didError && isYieldy) {
            root.didError = true;

            var _suspendedExpirationTime = root.nextExpirationTimeToWorkOn = expirationTime;

            var _rootExpirationTime = root.expirationTime = Sync;

            onSuspend(root, rootWorkInProgress, _suspendedExpirationTime, _rootExpirationTime, -1);
            return;
          }
        }

        if (isYieldy && nextLatestAbsoluteTimeoutMs !== -1) {
          var _suspendedExpirationTime2 = expirationTime;
          markSuspendedPriorityLevel(root, _suspendedExpirationTime2);
          var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, expirationTime);
          var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);

          if (earliestExpirationTimeMs < nextLatestAbsoluteTimeoutMs) {
            nextLatestAbsoluteTimeoutMs = earliestExpirationTimeMs;
          }

          var currentTimeMs = expirationTimeToMs(requestCurrentTime());
          var msUntilTimeout = nextLatestAbsoluteTimeoutMs - currentTimeMs;
          msUntilTimeout = msUntilTimeout < 0 ? 0 : msUntilTimeout;
          var _rootExpirationTime2 = root.expirationTime;
          onSuspend(root, rootWorkInProgress, _suspendedExpirationTime2, _rootExpirationTime2, msUntilTimeout);
          return;
        }

        onComplete(root, rootWorkInProgress, expirationTime);
      }

      function captureCommitPhaseError(sourceFiber, value) {
        var expirationTime = Sync;
        var fiber = sourceFiber.return;

        while (fiber !== null) {
          switch (fiber.tag) {
            case ClassComponent:
              var ctor = fiber.type;
              var instance = fiber.stateNode;

              if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                var errorInfo = createCapturedValue(value, sourceFiber);
                var update = createClassErrorUpdate(fiber, errorInfo, expirationTime);
                enqueueUpdate(fiber, update);
                scheduleWork(fiber, expirationTime);
                return;
              }

              break;

            case HostRoot:
              {
                var _errorInfo = createCapturedValue(value, sourceFiber);

                var _update = createRootErrorUpdate(fiber, _errorInfo, expirationTime);

                enqueueUpdate(fiber, _update);
                scheduleWork(fiber, expirationTime);
                return;
              }
          }

          fiber = fiber.return;
        }

        if (sourceFiber.tag === HostRoot) {
          var rootFiber = sourceFiber;

          var _errorInfo2 = createCapturedValue(value, rootFiber);

          var _update2 = createRootErrorUpdate(rootFiber, _errorInfo2, expirationTime);

          enqueueUpdate(rootFiber, _update2);
          scheduleWork(rootFiber, expirationTime);
        }
      }

      function computeThreadID(expirationTime, interactionThreadID) {
        return expirationTime * 1000 + interactionThreadID;
      }

      function computeExpirationForFiber(currentTime, fiber) {
        var expirationTime = void 0;

        if (expirationContext !== NoWork) {
          expirationTime = expirationContext;
        } else if (isWorking) {
          if (isCommitting$1) {
            expirationTime = Sync;
          } else {
            expirationTime = nextRenderExpirationTime;
          }
        } else {
          if (fiber.mode & ConcurrentMode) {
            if (isBatchingInteractiveUpdates) {
              expirationTime = computeInteractiveExpiration(currentTime);
            } else {
              expirationTime = computeAsyncExpiration(currentTime);
            }

            if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {
              expirationTime -= 1;
            }
          } else {
            expirationTime = Sync;
          }
        }

        if (isBatchingInteractiveUpdates) {
          if (lowestPriorityPendingInteractiveExpirationTime === NoWork || expirationTime < lowestPriorityPendingInteractiveExpirationTime) {
            lowestPriorityPendingInteractiveExpirationTime = expirationTime;
          }
        }

        return expirationTime;
      }

      function renderDidSuspend(root, absoluteTimeoutMs, suspendedTime) {
        if (absoluteTimeoutMs >= 0 && nextLatestAbsoluteTimeoutMs < absoluteTimeoutMs) {
          nextLatestAbsoluteTimeoutMs = absoluteTimeoutMs;
        }
      }

      function renderDidError() {
        nextRenderDidError = true;
      }

      function retrySuspendedRoot(root, boundaryFiber, sourceFiber, suspendedTime) {
        var retryTime = void 0;

        if (isPriorityLevelSuspended(root, suspendedTime)) {
          retryTime = suspendedTime;
          markPingedPriorityLevel(root, retryTime);
        } else {
          var currentTime = requestCurrentTime();
          retryTime = computeExpirationForFiber(currentTime, boundaryFiber);
          markPendingPriorityLevel(root, retryTime);
        }

        if ((boundaryFiber.mode & ConcurrentMode) !== NoContext) {
          if (root === nextRoot && nextRenderExpirationTime === suspendedTime) {
            nextRoot = null;
          }
        }

        scheduleWorkToRoot(boundaryFiber, retryTime);

        if ((boundaryFiber.mode & ConcurrentMode) === NoContext) {
          scheduleWorkToRoot(sourceFiber, retryTime);
          var sourceTag = sourceFiber.tag;

          if (sourceTag === ClassComponent && sourceFiber.stateNode !== null) {
            var update = createUpdate(retryTime);
            update.tag = ForceUpdate;
            enqueueUpdate(sourceFiber, update);
          }
        }

        var rootExpirationTime = root.expirationTime;

        if (rootExpirationTime !== NoWork) {
          requestWork(root, rootExpirationTime);
        }
      }

      function scheduleWorkToRoot(fiber, expirationTime) {
        recordScheduleUpdate();
        {
          if (fiber.tag === ClassComponent) {
            var instance = fiber.stateNode;
            warnAboutInvalidUpdates(instance);
          }
        }

        if (fiber.expirationTime < expirationTime) {
          fiber.expirationTime = expirationTime;
        }

        var alternate = fiber.alternate;

        if (alternate !== null && alternate.expirationTime < expirationTime) {
          alternate.expirationTime = expirationTime;
        }

        var node = fiber.return;
        var root = null;

        if (node === null && fiber.tag === HostRoot) {
          root = fiber.stateNode;
        } else {
          while (node !== null) {
            alternate = node.alternate;

            if (node.childExpirationTime < expirationTime) {
              node.childExpirationTime = expirationTime;

              if (alternate !== null && alternate.childExpirationTime < expirationTime) {
                alternate.childExpirationTime = expirationTime;
              }
            } else if (alternate !== null && alternate.childExpirationTime < expirationTime) {
              alternate.childExpirationTime = expirationTime;
            }

            if (node.return === null && node.tag === HostRoot) {
              root = node.stateNode;
              break;
            }

            node = node.return;
          }
        }

        if (root === null) {
          {
            switch (fiber.tag) {
              case ClassComponent:
                warnAboutUpdateOnUnmounted(fiber, true);
                break;

              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent:
                warnAboutUpdateOnUnmounted(fiber, false);
                break;
            }
          }
          return null;
        }

        if (enableSchedulerTracing) {
          var interactions = tracing.__interactionsRef.current;

          if (interactions.size > 0) {
            var pendingInteractionMap = root.pendingInteractionMap;
            var pendingInteractions = pendingInteractionMap.get(expirationTime);

            if (pendingInteractions != null) {
              interactions.forEach(function (interaction) {
                if (!pendingInteractions.has(interaction)) {
                  interaction.__count++;
                }

                pendingInteractions.add(interaction);
              });
            } else {
              pendingInteractionMap.set(expirationTime, new Set(interactions));
              interactions.forEach(function (interaction) {
                interaction.__count++;
              });
            }

            var subscriber = tracing.__subscriberRef.current;

            if (subscriber !== null) {
              var threadID = computeThreadID(expirationTime, root.interactionThreadID);
              subscriber.onWorkScheduled(interactions, threadID);
            }
          }
        }

        return root;
      }

      function scheduleWork(fiber, expirationTime) {
        var root = scheduleWorkToRoot(fiber, expirationTime);

        if (root === null) {
          return;
        }

        if (!isWorking && nextRenderExpirationTime !== NoWork && expirationTime > nextRenderExpirationTime) {
          interruptedBy = fiber;
          resetStack();
        }

        markPendingPriorityLevel(root, expirationTime);

        if (!isWorking || isCommitting$1 || nextRoot !== root) {
          var rootExpirationTime = root.expirationTime;
          requestWork(root, rootExpirationTime);
        }

        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
          nestedUpdateCount = 0;
          invariant(false, "Maximum update depth exceeded. This can happen when a " + "component repeatedly calls setState inside " + "componentWillUpdate or componentDidUpdate. React limits " + "the number of nested updates to prevent infinite loops.");
        }
      }

      var firstScheduledRoot = null;
      var lastScheduledRoot = null;
      var callbackExpirationTime = NoWork;
      var callbackID = void 0;
      var isRendering = false;
      var nextFlushedRoot = null;
      var nextFlushedExpirationTime = NoWork;
      var lowestPriorityPendingInteractiveExpirationTime = NoWork;
      var hasUnhandledError = false;
      var unhandledError = null;
      var isBatchingUpdates = false;
      var isUnbatchingUpdates = false;
      var isBatchingInteractiveUpdates = false;
      var completedBatches = null;
      var originalStartTimeMs = now();
      var currentRendererTime = msToExpirationTime(originalStartTimeMs);
      var currentSchedulerTime = currentRendererTime;
      var NESTED_UPDATE_LIMIT = 50;
      var nestedUpdateCount = 0;
      var lastCommittedRootDuringThisBatch = null;

      function recomputeCurrentRendererTime() {
        var currentTimeMs = now() - originalStartTimeMs;
        currentRendererTime = msToExpirationTime(currentTimeMs);
      }

      function scheduleCallbackWithExpirationTime(root, expirationTime) {
        if (callbackExpirationTime !== NoWork) {
          if (expirationTime < callbackExpirationTime) {
            return;
          } else {
            if (callbackID !== null) {
              cancelDeferredCallback(callbackID);
            }
          }
        } else {
          startRequestCallbackTimer();
        }

        callbackExpirationTime = expirationTime;
        var currentMs = now() - originalStartTimeMs;
        var expirationTimeMs = expirationTimeToMs(expirationTime);
        var timeout = expirationTimeMs - currentMs;
        callbackID = scheduleDeferredCallback(performAsyncWork, {
          timeout: timeout
        });
      }

      function onFatal(root) {
        root.finishedWork = null;
      }

      function onComplete(root, finishedWork, expirationTime) {
        root.pendingCommitExpirationTime = expirationTime;
        root.finishedWork = finishedWork;
      }

      function onSuspend(root, finishedWork, suspendedExpirationTime, rootExpirationTime, msUntilTimeout) {
        root.expirationTime = rootExpirationTime;

        if (msUntilTimeout === 0 && !shouldYieldToRenderer()) {
          root.pendingCommitExpirationTime = suspendedExpirationTime;
          root.finishedWork = finishedWork;
        } else if (msUntilTimeout > 0) {
          root.timeoutHandle = scheduleTimeout(onTimeout.bind(null, root, finishedWork, suspendedExpirationTime), msUntilTimeout);
        }
      }

      function onYield(root) {
        root.finishedWork = null;
      }

      function onTimeout(root, finishedWork, suspendedExpirationTime) {
        root.pendingCommitExpirationTime = suspendedExpirationTime;
        root.finishedWork = finishedWork;
        recomputeCurrentRendererTime();
        currentSchedulerTime = currentRendererTime;
        flushRoot(root, suspendedExpirationTime);
      }

      function onCommit(root, expirationTime) {
        root.expirationTime = expirationTime;
        root.finishedWork = null;
      }

      function requestCurrentTime() {
        if (isRendering) {
          return currentSchedulerTime;
        }

        findHighestPriorityRoot();

        if (nextFlushedExpirationTime === NoWork || nextFlushedExpirationTime === Never) {
          recomputeCurrentRendererTime();
          currentSchedulerTime = currentRendererTime;
          return currentSchedulerTime;
        }

        return currentSchedulerTime;
      }

      function requestWork(root, expirationTime) {
        addRootToSchedule(root, expirationTime);

        if (isRendering) {
          return;
        }

        if (isBatchingUpdates) {
          if (isUnbatchingUpdates) {
            nextFlushedRoot = root;
            nextFlushedExpirationTime = Sync;
            performWorkOnRoot(root, Sync, false);
          }

          return;
        }

        if (expirationTime === Sync) {
          performSyncWork();
        } else {
          scheduleCallbackWithExpirationTime(root, expirationTime);
        }
      }

      function addRootToSchedule(root, expirationTime) {
        if (root.nextScheduledRoot === null) {
          root.expirationTime = expirationTime;

          if (lastScheduledRoot === null) {
            firstScheduledRoot = lastScheduledRoot = root;
            root.nextScheduledRoot = root;
          } else {
            lastScheduledRoot.nextScheduledRoot = root;
            lastScheduledRoot = root;
            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
          }
        } else {
          var remainingExpirationTime = root.expirationTime;

          if (expirationTime > remainingExpirationTime) {
            root.expirationTime = expirationTime;
          }
        }
      }

      function findHighestPriorityRoot() {
        var highestPriorityWork = NoWork;
        var highestPriorityRoot = null;

        if (lastScheduledRoot !== null) {
          var previousScheduledRoot = lastScheduledRoot;
          var root = firstScheduledRoot;

          while (root !== null) {
            var remainingExpirationTime = root.expirationTime;

            if (remainingExpirationTime === NoWork) {
              invariant(previousScheduledRoot !== null && lastScheduledRoot !== null, "Should have a previous and last root. This error is likely " + "caused by a bug in React. Please file an issue.");

              if (root === root.nextScheduledRoot) {
                root.nextScheduledRoot = null;
                firstScheduledRoot = lastScheduledRoot = null;
                break;
              } else if (root === firstScheduledRoot) {
                var next = root.nextScheduledRoot;
                firstScheduledRoot = next;
                lastScheduledRoot.nextScheduledRoot = next;
                root.nextScheduledRoot = null;
              } else if (root === lastScheduledRoot) {
                lastScheduledRoot = previousScheduledRoot;
                lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
                root.nextScheduledRoot = null;
                break;
              } else {
                previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
                root.nextScheduledRoot = null;
              }

              root = previousScheduledRoot.nextScheduledRoot;
            } else {
              if (remainingExpirationTime > highestPriorityWork) {
                highestPriorityWork = remainingExpirationTime;
                highestPriorityRoot = root;
              }

              if (root === lastScheduledRoot) {
                break;
              }

              if (highestPriorityWork === Sync) {
                break;
              }

              previousScheduledRoot = root;
              root = root.nextScheduledRoot;
            }
          }
        }

        nextFlushedRoot = highestPriorityRoot;
        nextFlushedExpirationTime = highestPriorityWork;
      }

      var didYield = false;

      function shouldYieldToRenderer() {
        if (didYield) {
          return true;
        }

        if (shouldYield()) {
          didYield = true;
          return true;
        }

        return false;
      }

      function performAsyncWork() {
        try {
          if (!shouldYieldToRenderer()) {
            if (firstScheduledRoot !== null) {
              recomputeCurrentRendererTime();
              var root = firstScheduledRoot;

              do {
                didExpireAtExpirationTime(root, currentRendererTime);
                root = root.nextScheduledRoot;
              } while (root !== firstScheduledRoot);
            }
          }

          performWork(NoWork, true);
        } finally {
          didYield = false;
        }
      }

      function performSyncWork() {
        performWork(Sync, false);
      }

      function performWork(minExpirationTime, isYieldy) {
        findHighestPriorityRoot();

        if (isYieldy) {
          recomputeCurrentRendererTime();
          currentSchedulerTime = currentRendererTime;

          if (enableUserTimingAPI) {
            var didExpire = nextFlushedExpirationTime > currentRendererTime;
            var timeout = expirationTimeToMs(nextFlushedExpirationTime);
            stopRequestCallbackTimer(didExpire, timeout);
          }

          while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && minExpirationTime <= nextFlushedExpirationTime && !(didYield && currentRendererTime > nextFlushedExpirationTime)) {
            performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, currentRendererTime > nextFlushedExpirationTime);
            findHighestPriorityRoot();
            recomputeCurrentRendererTime();
            currentSchedulerTime = currentRendererTime;
          }
        } else {
          while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && minExpirationTime <= nextFlushedExpirationTime) {
            performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);
            findHighestPriorityRoot();
          }
        }

        if (isYieldy) {
          callbackExpirationTime = NoWork;
          callbackID = null;
        }

        if (nextFlushedExpirationTime !== NoWork) {
          scheduleCallbackWithExpirationTime(nextFlushedRoot, nextFlushedExpirationTime);
        }

        finishRendering();
      }

      function flushRoot(root, expirationTime) {
        invariant(!isRendering, "work.commit(): Cannot commit while already rendering. This likely " + "means you attempted to commit from inside a lifecycle method.");
        nextFlushedRoot = root;
        nextFlushedExpirationTime = expirationTime;
        performWorkOnRoot(root, expirationTime, false);
        performSyncWork();
      }

      function finishRendering() {
        nestedUpdateCount = 0;
        lastCommittedRootDuringThisBatch = null;

        if (completedBatches !== null) {
          var batches = completedBatches;
          completedBatches = null;

          for (var i = 0; i < batches.length; i++) {
            var batch = batches[i];

            try {
              batch._onComplete();
            } catch (error) {
              if (!hasUnhandledError) {
                hasUnhandledError = true;
                unhandledError = error;
              }
            }
          }
        }

        if (hasUnhandledError) {
          var error = unhandledError;
          unhandledError = null;
          hasUnhandledError = false;
          throw error;
        }
      }

      function performWorkOnRoot(root, expirationTime, isYieldy) {
        invariant(!isRendering, "performWorkOnRoot was called recursively. This error is likely caused " + "by a bug in React. Please file an issue.");
        isRendering = true;

        if (!isYieldy) {
          var finishedWork = root.finishedWork;

          if (finishedWork !== null) {
            completeRoot$1(root, finishedWork, expirationTime);
          } else {
            root.finishedWork = null;
            var timeoutHandle = root.timeoutHandle;

            if (timeoutHandle !== noTimeout) {
              root.timeoutHandle = noTimeout;
              cancelTimeout(timeoutHandle);
            }

            renderRoot(root, isYieldy);
            finishedWork = root.finishedWork;

            if (finishedWork !== null) {
              completeRoot$1(root, finishedWork, expirationTime);
            }
          }
        } else {
          var _finishedWork = root.finishedWork;

          if (_finishedWork !== null) {
            completeRoot$1(root, _finishedWork, expirationTime);
          } else {
            root.finishedWork = null;
            var _timeoutHandle = root.timeoutHandle;

            if (_timeoutHandle !== noTimeout) {
              root.timeoutHandle = noTimeout;
              cancelTimeout(_timeoutHandle);
            }

            renderRoot(root, isYieldy);
            _finishedWork = root.finishedWork;

            if (_finishedWork !== null) {
              if (!shouldYieldToRenderer()) {
                completeRoot$1(root, _finishedWork, expirationTime);
              } else {
                root.finishedWork = _finishedWork;
              }
            }
          }
        }

        isRendering = false;
      }

      function completeRoot$1(root, finishedWork, expirationTime) {
        var firstBatch = root.firstBatch;

        if (firstBatch !== null && firstBatch._expirationTime >= expirationTime) {
          if (completedBatches === null) {
            completedBatches = [firstBatch];
          } else {
            completedBatches.push(firstBatch);
          }

          if (firstBatch._defer) {
            root.finishedWork = finishedWork;
            root.expirationTime = NoWork;
            return;
          }
        }

        root.finishedWork = null;

        if (root === lastCommittedRootDuringThisBatch) {
          nestedUpdateCount++;
        } else {
          lastCommittedRootDuringThisBatch = root;
          nestedUpdateCount = 0;
        }

        commitRoot(root, finishedWork);
      }

      function onUncaughtError(error) {
        invariant(nextFlushedRoot !== null, "Should be working on a root. This error is likely caused by a bug in " + "React. Please file an issue.");
        nextFlushedRoot.expirationTime = NoWork;

        if (!hasUnhandledError) {
          hasUnhandledError = true;
          unhandledError = error;
        }
      }

      function batchedUpdates$1(fn, a) {
        var previousIsBatchingUpdates = isBatchingUpdates;
        isBatchingUpdates = true;

        try {
          return fn(a);
        } finally {
          isBatchingUpdates = previousIsBatchingUpdates;

          if (!isBatchingUpdates && !isRendering) {
            performSyncWork();
          }
        }
      }

      function interactiveUpdates$1(fn, a, b) {
        if (isBatchingInteractiveUpdates) {
          return fn(a, b);
        }

        if (!isBatchingUpdates && !isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {
          performWork(lowestPriorityPendingInteractiveExpirationTime, false);
          lowestPriorityPendingInteractiveExpirationTime = NoWork;
        }

        var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;
        var previousIsBatchingUpdates = isBatchingUpdates;
        isBatchingInteractiveUpdates = true;
        isBatchingUpdates = true;

        try {
          return fn(a, b);
        } finally {
          isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;
          isBatchingUpdates = previousIsBatchingUpdates;

          if (!isBatchingUpdates && !isRendering) {
            performSyncWork();
          }
        }
      }

      function flushInteractiveUpdates$1() {
        if (!isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {
          performWork(lowestPriorityPendingInteractiveExpirationTime, false);
          lowestPriorityPendingInteractiveExpirationTime = NoWork;
        }
      }

      var didWarnAboutNestedUpdates = void 0;
      var didWarnAboutFindNodeInStrictMode = void 0;
      {
        didWarnAboutNestedUpdates = false;
        didWarnAboutFindNodeInStrictMode = {};
      }

      function getContextForSubtree(parentComponent) {
        if (!parentComponent) {
          return emptyContextObject;
        }

        var fiber = get$1(parentComponent);
        var parentContext = findCurrentUnmaskedContext(fiber);

        if (fiber.tag === ClassComponent) {
          var Component = fiber.type;

          if (isContextProvider(Component)) {
            return processChildContext(fiber, Component, parentContext);
          }
        }

        return parentContext;
      }

      function scheduleRootUpdate(current$$1, element, expirationTime, callback) {
        {
          if (phase === "render" && current !== null && !didWarnAboutNestedUpdates) {
            didWarnAboutNestedUpdates = true;
            warningWithoutStack$1(false, "Render methods should be a pure function of props and state; " + "triggering nested component updates from render is not allowed. " + "If necessary, trigger nested updates in componentDidUpdate.\n\n" + "Check the render method of %s.", getComponentName(current.type) || "Unknown");
          }
        }
        var update = createUpdate(expirationTime);
        update.payload = {
          element: element
        };
        callback = callback === undefined ? null : callback;

        if (callback !== null) {
          !(typeof callback === "function") ? warningWithoutStack$1(false, "render(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callback) : void 0;
          update.callback = callback;
        }

        flushPassiveEffects();
        enqueueUpdate(current$$1, update);
        scheduleWork(current$$1, expirationTime);
        return expirationTime;
      }

      function updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback) {
        var current$$1 = container.current;
        {
          if (ReactFiberInstrumentation_1.debugTool) {
            if (current$$1.alternate === null) {
              ReactFiberInstrumentation_1.debugTool.onMountContainer(container);
            } else if (element === null) {
              ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);
            } else {
              ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);
            }
          }
        }
        var context = getContextForSubtree(parentComponent);

        if (container.context === null) {
          container.context = context;
        } else {
          container.pendingContext = context;
        }

        return scheduleRootUpdate(current$$1, element, expirationTime, callback);
      }

      function findHostInstance$1(component) {
        var fiber = get$1(component);

        if (fiber === undefined) {
          if (typeof component.render === "function") {
            invariant(false, "Unable to find node on an unmounted component.");
          } else {
            invariant(false, "Argument appears to not be a ReactComponent. Keys: %s", Object.keys(component));
          }
        }

        var hostFiber = findCurrentHostFiber(fiber);

        if (hostFiber === null) {
          return null;
        }

        return hostFiber.stateNode;
      }

      function findHostInstanceWithWarning$1(component, methodName) {
        {
          var fiber = get$1(component);

          if (fiber === undefined) {
            if (typeof component.render === "function") {
              invariant(false, "Unable to find node on an unmounted component.");
            } else {
              invariant(false, "Argument appears to not be a ReactComponent. Keys: %s", Object.keys(component));
            }
          }

          var hostFiber = findCurrentHostFiber(fiber);

          if (hostFiber === null) {
            return null;
          }

          if (hostFiber.mode & StrictMode) {
            var componentName = getComponentName(fiber.type) || "Component";

            if (!didWarnAboutFindNodeInStrictMode[componentName]) {
              didWarnAboutFindNodeInStrictMode[componentName] = true;

              if (fiber.mode & StrictMode) {
                warningWithoutStack$1(false, "%s is deprecated in StrictMode. " + "%s was passed an instance of %s which is inside StrictMode. " + "Instead, add a ref directly to the element you want to reference." + "\n%s" + "\n\nLearn more about using refs safely here:" + "\nhttps://fb.me/react-strict-mode-find-node", methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));
              } else {
                warningWithoutStack$1(false, "%s is deprecated in StrictMode. " + "%s was passed an instance of %s which renders StrictMode children. " + "Instead, add a ref directly to the element you want to reference." + "\n%s" + "\n\nLearn more about using refs safely here:" + "\nhttps://fb.me/react-strict-mode-find-node", methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));
              }
            }
          }

          return hostFiber.stateNode;
        }
        return findHostInstance$1(component);
      }

      function createContainer(containerInfo, isConcurrent, hydrate) {
        return createFiberRoot(containerInfo, isConcurrent, hydrate);
      }

      function updateContainer(element, container, parentComponent, callback) {
        var current$$1 = container.current;
        var currentTime = requestCurrentTime();
        var expirationTime = computeExpirationForFiber(currentTime, current$$1);
        return updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback);
      }

      function getPublicRootInstance(container) {
        var containerFiber = container.current;

        if (!containerFiber.child) {
          return null;
        }

        switch (containerFiber.child.tag) {
          case HostComponent:
            return getPublicInstance(containerFiber.child.stateNode);

          default:
            return containerFiber.child.stateNode;
        }
      }

      function injectIntoDevTools(devToolsConfig) {
        var _findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
        return injectInternals(_extends({}, devToolsConfig, {
          findHostInstanceByFiber: function findHostInstanceByFiber(fiber) {
            var hostFiber = findCurrentHostFiber(fiber);

            if (hostFiber === null) {
              return null;
            }

            return hostFiber.stateNode;
          },
          findFiberByHostInstance: function findFiberByHostInstance(instance) {
            if (!_findFiberByHostInstance) {
              return null;
            }

            return _findFiberByHostInstance(instance);
          }
        }));
      }

      function _createPortal(children, containerInfo, implementation) {
        var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: key == null ? null : "" + key,
          children: children,
          containerInfo: containerInfo,
          implementation: implementation
        };
      }

      var ReactVersion = "16.6.1";

      var NativeMethodsMixin = function NativeMethodsMixin(findNodeHandle, findHostInstance) {
        var NativeMethodsMixin = {
          measure: function measure(callback) {
            UIManager.measure(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          },
          measureInWindow: function measureInWindow(callback) {
            UIManager.measureInWindow(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          },
          measureLayout: function measureLayout(relativeToNativeNode, onSuccess, onFail) {
            UIManager.measureLayout(findNodeHandle(this), relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
          },
          setNativeProps: function setNativeProps(nativeProps) {
            var maybeInstance = void 0;

            try {
              maybeInstance = findHostInstance(this);
            } catch (error) {}

            if (maybeInstance == null) {
              return;
            }

            var viewConfig = maybeInstance.viewConfig;
            {
              warnForStyleProps(nativeProps, viewConfig.validAttributes);
            }
            var updatePayload = create(nativeProps, viewConfig.validAttributes);

            if (updatePayload != null) {
              UIManager.updateView(maybeInstance._nativeTag, viewConfig.uiViewClassName, updatePayload);
            }
          },
          focus: function focus() {
            TextInputState.focusTextInput(findNodeHandle(this));
          },
          blur: function blur() {
            TextInputState.blurTextInput(findNodeHandle(this));
          }
        };
        {
          var NativeMethodsMixin_DEV = NativeMethodsMixin;
          invariant(!NativeMethodsMixin_DEV.componentWillMount && !NativeMethodsMixin_DEV.componentWillReceiveProps && !NativeMethodsMixin_DEV.UNSAFE_componentWillMount && !NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps, "Do not override existing functions.");

          NativeMethodsMixin_DEV.componentWillMount = function () {
            throwOnStylesProp(this, this.props);
          };

          NativeMethodsMixin_DEV.componentWillReceiveProps = function (newProps) {
            throwOnStylesProp(this, newProps);
          };

          NativeMethodsMixin_DEV.UNSAFE_componentWillMount = function () {
            throwOnStylesProp(this, this.props);
          };

          NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps = function (newProps) {
            throwOnStylesProp(this, newProps);
          };

          NativeMethodsMixin_DEV.componentWillMount.__suppressDeprecationWarning = true;
          NativeMethodsMixin_DEV.componentWillReceiveProps.__suppressDeprecationWarning = true;
        }
        return NativeMethodsMixin;
      };

      function _classCallCheck$1(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      var ReactNativeComponent = function ReactNativeComponent(findNodeHandle, findHostInstance) {
        var ReactNativeComponent = function (_React$Component) {
          _inherits(ReactNativeComponent, _React$Component);

          function ReactNativeComponent() {
            _classCallCheck$1(this, ReactNativeComponent);

            return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
          }

          ReactNativeComponent.prototype.blur = function blur() {
            TextInputState.blurTextInput(findNodeHandle(this));
          };

          ReactNativeComponent.prototype.focus = function focus() {
            TextInputState.focusTextInput(findNodeHandle(this));
          };

          ReactNativeComponent.prototype.measure = function measure(callback) {
            UIManager.measure(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          };

          ReactNativeComponent.prototype.measureInWindow = function measureInWindow(callback) {
            UIManager.measureInWindow(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          };

          ReactNativeComponent.prototype.measureLayout = function measureLayout(relativeToNativeNode, onSuccess, onFail) {
            UIManager.measureLayout(findNodeHandle(this), relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
          };

          ReactNativeComponent.prototype.setNativeProps = function setNativeProps(nativeProps) {
            var maybeInstance = void 0;

            try {
              maybeInstance = findHostInstance(this);
            } catch (error) {}

            if (maybeInstance == null) {
              return;
            }

            var viewConfig = maybeInstance.viewConfig || maybeInstance.canonical.viewConfig;
            var updatePayload = create(nativeProps, viewConfig.validAttributes);

            if (updatePayload != null) {
              UIManager.updateView(maybeInstance._nativeTag, viewConfig.uiViewClassName, updatePayload);
            }
          };

          return ReactNativeComponent;
        }(React.Component);

        return ReactNativeComponent;
      };

      var instanceCache = {};

      function getInstanceFromTag(tag) {
        return instanceCache[tag] || null;
      }

      var emptyObject$1 = {};
      {
        Object.freeze(emptyObject$1);
      }
      var getInspectorDataForViewTag = void 0;
      {
        var traverseOwnerTreeUp = function traverseOwnerTreeUp(hierarchy, instance) {
          if (instance) {
            hierarchy.unshift(instance);
            traverseOwnerTreeUp(hierarchy, instance._debugOwner);
          }
        };

        var getOwnerHierarchy = function getOwnerHierarchy(instance) {
          var hierarchy = [];
          traverseOwnerTreeUp(hierarchy, instance);
          return hierarchy;
        };

        var lastNonHostInstance = function lastNonHostInstance(hierarchy) {
          for (var i = hierarchy.length - 1; i > 1; i--) {
            var instance = hierarchy[i];

            if (instance.tag !== HostComponent) {
              return instance;
            }
          }

          return hierarchy[0];
        };

        var getHostProps = function getHostProps(fiber) {
          var host = findCurrentHostFiber(fiber);

          if (host) {
            return host.memoizedProps || emptyObject$1;
          }

          return emptyObject$1;
        };

        var getHostNode = function getHostNode(fiber, findNodeHandle) {
          var hostNode = void 0;

          while (fiber) {
            if (fiber.stateNode !== null && fiber.tag === HostComponent) {
              hostNode = findNodeHandle(fiber.stateNode);
            }

            if (hostNode) {
              return hostNode;
            }

            fiber = fiber.child;
          }

          return null;
        };

        var createHierarchy = function createHierarchy(fiberHierarchy) {
          return fiberHierarchy.map(function (fiber) {
            return {
              name: getComponentName(fiber.type),
              getInspectorData: function getInspectorData(findNodeHandle) {
                return {
                  measure: function measure(callback) {
                    return UIManager.measure(getHostNode(fiber, findNodeHandle), callback);
                  },
                  props: getHostProps(fiber),
                  source: fiber._debugSource
                };
              }
            };
          });
        };

        getInspectorDataForViewTag = function getInspectorDataForViewTag(viewTag) {
          var closestInstance = getInstanceFromTag(viewTag);

          if (!closestInstance) {
            return {
              hierarchy: [],
              props: emptyObject$1,
              selection: null,
              source: null
            };
          }

          var fiber = findCurrentFiberUsingSlowPath(closestInstance);
          var fiberHierarchy = getOwnerHierarchy(fiber);
          var instance = lastNonHostInstance(fiberHierarchy);
          var hierarchy = createHierarchy(fiberHierarchy);
          var props = getHostProps(instance);
          var source = instance._debugSource;
          var selection = fiberHierarchy.indexOf(instance);
          return {
            hierarchy: hierarchy,
            props: props,
            selection: selection,
            source: source
          };
        };
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var findHostInstance = findHostInstance$1;
      var findHostInstanceWithWarning = findHostInstanceWithWarning$1;

      function findNodeHandle(componentOrHandle) {
        {
          var owner = ReactCurrentOwner.current;

          if (owner !== null && owner.stateNode !== null) {
            !owner.stateNode._warnedAboutRefsInRender ? warningWithoutStack$1(false, "%s is accessing findNodeHandle inside its render(). " + "render() should be a pure function of props and state. It should " + "never access something that requires stale data from the previous " + "render, such as refs. Move this logic to componentDidMount and " + "componentDidUpdate instead.", getComponentName(owner.type) || "A component") : void 0;
            owner.stateNode._warnedAboutRefsInRender = true;
          }
        }

        if (componentOrHandle == null) {
          return null;
        }

        if (typeof componentOrHandle === "number") {
          return componentOrHandle;
        }

        if (componentOrHandle._nativeTag) {
          return componentOrHandle._nativeTag;
        }

        if (componentOrHandle.canonical && componentOrHandle.canonical._nativeTag) {
          return componentOrHandle.canonical._nativeTag;
        }

        var hostInstance = void 0;
        {
          hostInstance = findHostInstanceWithWarning(componentOrHandle, "findNodeHandle");
        }

        if (hostInstance == null) {
          return hostInstance;
        }

        if (hostInstance.canonical) {
          return hostInstance.canonical._nativeTag;
        }

        return hostInstance._nativeTag;
      }

      setBatchingImplementation(batchedUpdates$1, interactiveUpdates$1, flushInteractiveUpdates$1);
      var roots = new Map();
      var ReactFabric = {
        NativeComponent: ReactNativeComponent(findNodeHandle, findHostInstance),
        findNodeHandle: findNodeHandle,
        render: function render(element, containerTag, callback) {
          var root = roots.get(containerTag);

          if (!root) {
            root = createContainer(containerTag, false, false);
            roots.set(containerTag, root);
          }

          updateContainer(element, root, null, callback);
          return getPublicRootInstance(root);
        },
        unmountComponentAtNode: function unmountComponentAtNode(containerTag) {
          var root = roots.get(containerTag);

          if (root) {
            updateContainer(null, root, null, function () {
              roots.delete(containerTag);
            });
          }
        },
        createPortal: function createPortal(children, containerTag) {
          var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          return _createPortal(children, containerTag, null, key);
        },
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
          NativeMethodsMixin: NativeMethodsMixin(findNodeHandle, findHostInstance)
        }
      };
      injectIntoDevTools({
        findFiberByHostInstance: getInstanceFromInstance,
        getInspectorDataForViewTag: getInspectorDataForViewTag,
        bundleType: 1,
        version: ReactVersion,
        rendererPackageName: "react-native-renderer"
      });
      var ReactFabric$2 = Object.freeze({
        default: ReactFabric
      });
      var ReactFabric$3 = ReactFabric$2 && ReactFabric || ReactFabric$2;
      var fabric = ReactFabric$3.default || ReactFabric$3;
      module.exports = fabric;
    })();
  }
},616,[112,180,257,145,109,259,174,134,260,617,114,261,264,188],"node_modules\\react-native\\Libraries\\Renderer\\oss\\ReactFabric-dev.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var FabricUIManager = global.nativeFabricUIManager;
  module.exports = FabricUIManager;
},617,[],"node_modules\\react-native\\Libraries\\ReactNative\\FabricUIManager.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _extends = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/extends");

  _$$_REQUIRE(_dependencyMap[1], "InitializeCore");

  var ReactNativeViewConfigRegistry = _$$_REQUIRE(_dependencyMap[2], "ReactNativeViewConfigRegistry"),
      UIManager = _$$_REQUIRE(_dependencyMap[3], "UIManager"),
      React = _$$_REQUIRE(_dependencyMap[4], "react"),
      deepDiffer = _$$_REQUIRE(_dependencyMap[5], "deepDiffer"),
      flattenStyle = _$$_REQUIRE(_dependencyMap[6], "flattenStyle"),
      TextInputState = _$$_REQUIRE(_dependencyMap[7], "TextInputState"),
      FabricUIManager = _$$_REQUIRE(_dependencyMap[8], "FabricUIManager");

  var scheduler = _$$_REQUIRE(_dependencyMap[9], "scheduler"),
      ExceptionsManager = _$$_REQUIRE(_dependencyMap[10], "ExceptionsManager");

  function invariant(condition, format, a, b, c, d, e, f) {
    if (!condition) {
      condition = void 0;
      if (void 0 === format) condition = Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else {
        var args = [a, b, c, d, e, f],
            argIndex = 0;
        condition = Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        condition.name = "Invariant Violation";
      }
      condition.framesToPop = 1;
      throw condition;
    }
  }

  function invokeGuardedCallbackImpl(name, func, context, a, b, c, d, e, f) {
    var funcArgs = Array.prototype.slice.call(arguments, 3);

    try {
      func.apply(context, funcArgs);
    } catch (error) {
      this.onError(error);
    }
  }

  var hasError = !1,
      caughtError = null,
      hasRethrowError = !1,
      rethrowError = null,
      reporter = {
    onError: function onError(error) {
      hasError = !0;
      caughtError = error;
    }
  };

  function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
    hasError = !1;
    caughtError = null;
    invokeGuardedCallbackImpl.apply(reporter, arguments);
  }

  function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
    invokeGuardedCallback.apply(this, arguments);

    if (hasError) {
      if (hasError) {
        var error = caughtError;
        hasError = !1;
        caughtError = null;
      } else invariant(!1, "clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue."), error = void 0;

      hasRethrowError || (hasRethrowError = !0, rethrowError = error);
    }
  }

  var eventPluginOrder = null,
      namesToPlugins = {};

  function recomputePluginOrdering() {
    if (eventPluginOrder) for (var pluginName in namesToPlugins) {
      var pluginModule = namesToPlugins[pluginName],
          pluginIndex = eventPluginOrder.indexOf(pluginName);
      invariant(-1 < pluginIndex, "EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.", pluginName);

      if (!plugins[pluginIndex]) {
        invariant(pluginModule.extractEvents, "EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.", pluginName);
        plugins[pluginIndex] = pluginModule;
        pluginIndex = pluginModule.eventTypes;

        for (var eventName in pluginIndex) {
          var JSCompiler_inline_result = void 0;
          var dispatchConfig = pluginIndex[eventName],
              pluginModule$jscomp$0 = pluginModule,
              eventName$jscomp$0 = eventName;
          invariant(!eventNameDispatchConfigs.hasOwnProperty(eventName$jscomp$0), "EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.", eventName$jscomp$0);
          eventNameDispatchConfigs[eventName$jscomp$0] = dispatchConfig;
          var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

          if (phasedRegistrationNames) {
            for (JSCompiler_inline_result in phasedRegistrationNames) {
              phasedRegistrationNames.hasOwnProperty(JSCompiler_inline_result) && publishRegistrationName(phasedRegistrationNames[JSCompiler_inline_result], pluginModule$jscomp$0, eventName$jscomp$0);
            }

            JSCompiler_inline_result = !0;
          } else dispatchConfig.registrationName ? (publishRegistrationName(dispatchConfig.registrationName, pluginModule$jscomp$0, eventName$jscomp$0), JSCompiler_inline_result = !0) : JSCompiler_inline_result = !1;

          invariant(JSCompiler_inline_result, "EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.", eventName, pluginName);
        }
      }
    }
  }

  function publishRegistrationName(registrationName, pluginModule) {
    invariant(!registrationNameModules[registrationName], "EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
    registrationNameModules[registrationName] = pluginModule;
  }

  var plugins = [],
      eventNameDispatchConfigs = {},
      registrationNameModules = {},
      getFiberCurrentPropsFromNode = null,
      getInstanceFromNode = null,
      getNodeFromInstance = null;

  function executeDispatch(event, listener, inst) {
    var type = event.type || "unknown-event";
    event.currentTarget = getNodeFromInstance(inst);
    invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
    event.currentTarget = null;
  }

  function executeDirectDispatch(event) {
    var dispatchListener = event._dispatchListeners,
        dispatchInstance = event._dispatchInstances;
    invariant(!Array.isArray(dispatchListener), "executeDirectDispatch(...): Invalid `event`.");
    event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;
    dispatchListener = dispatchListener ? dispatchListener(event) : null;
    event.currentTarget = null;
    event._dispatchListeners = null;
    event._dispatchInstances = null;
    return dispatchListener;
  }

  function accumulateInto(current, next) {
    invariant(null != next, "accumulateInto(...): Accumulated items must not be null or undefined.");
    if (null == current) return next;

    if (Array.isArray(current)) {
      if (Array.isArray(next)) return current.push.apply(current, next), current;
      current.push(next);
      return current;
    }

    return Array.isArray(next) ? [current].concat(next) : [current, next];
  }

  function forEachAccumulated(arr, cb, scope) {
    Array.isArray(arr) ? arr.forEach(cb, scope) : arr && cb.call(scope, arr);
  }

  var eventQueue = null;

  function executeDispatchesAndReleaseTopLevel(e) {
    if (e) {
      var dispatchListeners = e._dispatchListeners,
          dispatchInstances = e._dispatchInstances;
      if (Array.isArray(dispatchListeners)) for (var i = 0; i < dispatchListeners.length && !e.isPropagationStopped(); i++) {
        executeDispatch(e, dispatchListeners[i], dispatchInstances[i]);
      } else dispatchListeners && executeDispatch(e, dispatchListeners, dispatchInstances);
      e._dispatchListeners = null;
      e._dispatchInstances = null;
      e.isPersistent() || e.constructor.release(e);
    }
  }

  var injection = {
    injectEventPluginOrder: function injectEventPluginOrder(injectedEventPluginOrder) {
      invariant(!eventPluginOrder, "EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.");
      eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
      recomputePluginOrdering();
    },
    injectEventPluginsByName: function injectEventPluginsByName(injectedNamesToPlugins) {
      var isOrderingDirty = !1,
          pluginName;

      for (pluginName in injectedNamesToPlugins) {
        if (injectedNamesToPlugins.hasOwnProperty(pluginName)) {
          var pluginModule = injectedNamesToPlugins[pluginName];
          namesToPlugins.hasOwnProperty(pluginName) && namesToPlugins[pluginName] === pluginModule || (invariant(!namesToPlugins[pluginName], "EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.", pluginName), namesToPlugins[pluginName] = pluginModule, isOrderingDirty = !0);
        }
      }

      isOrderingDirty && recomputePluginOrdering();
    }
  };

  function getListener(inst, registrationName) {
    var listener = inst.stateNode;
    if (!listener) return null;
    var props = getFiberCurrentPropsFromNode(listener);
    if (!props) return null;
    listener = props[registrationName];

    a: switch (registrationName) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
        (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
        inst = !props;
        break a;

      default:
        inst = !1;
    }

    if (inst) return null;
    invariant(!listener || "function" === typeof listener, "Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
    return listener;
  }

  function getParent(inst) {
    do {
      inst = inst.return;
    } while (inst && 5 !== inst.tag);

    return inst ? inst : null;
  }

  function traverseTwoPhase(inst, fn, arg) {
    for (var path = []; inst;) {
      path.push(inst), inst = getParent(inst);
    }

    for (inst = path.length; 0 < inst--;) {
      fn(path[inst], "captured", arg);
    }

    for (inst = 0; inst < path.length; inst++) {
      fn(path[inst], "bubbled", arg);
    }
  }

  function accumulateDirectionalDispatches(inst, phase, event) {
    if (phase = getListener(inst, event.dispatchConfig.phasedRegistrationNames[phase])) event._dispatchListeners = accumulateInto(event._dispatchListeners, phase), event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }

  function accumulateTwoPhaseDispatchesSingle(event) {
    event && event.dispatchConfig.phasedRegistrationNames && traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }

  function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
    if (event && event.dispatchConfig.phasedRegistrationNames) {
      var targetInst = event._targetInst;
      targetInst = targetInst ? getParent(targetInst) : null;
      traverseTwoPhase(targetInst, accumulateDirectionalDispatches, event);
    }
  }

  function accumulateDirectDispatchesSingle(event) {
    if (event && event.dispatchConfig.registrationName) {
      var inst = event._targetInst;

      if (inst && event && event.dispatchConfig.registrationName) {
        var listener = getListener(inst, event.dispatchConfig.registrationName);
        listener && (event._dispatchListeners = accumulateInto(event._dispatchListeners, listener), event._dispatchInstances = accumulateInto(event._dispatchInstances, inst));
      }
    }
  }

  function functionThatReturnsTrue() {
    return !0;
  }

  function functionThatReturnsFalse() {
    return !1;
  }

  function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
    this.dispatchConfig = dispatchConfig;
    this._targetInst = targetInst;
    this.nativeEvent = nativeEvent;
    dispatchConfig = this.constructor.Interface;

    for (var propName in dispatchConfig) {
      dispatchConfig.hasOwnProperty(propName) && ((targetInst = dispatchConfig[propName]) ? this[propName] = targetInst(nativeEvent) : "target" === propName ? this.target = nativeEventTarget : this[propName] = nativeEvent[propName]);
    }

    this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : !1 === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }

  _extends(SyntheticEvent.prototype, {
    preventDefault: function preventDefault() {
      this.defaultPrevented = !0;
      var event = this.nativeEvent;
      event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = !1), this.isDefaultPrevented = functionThatReturnsTrue);
    },
    stopPropagation: function stopPropagation() {
      var event = this.nativeEvent;
      event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = !0), this.isPropagationStopped = functionThatReturnsTrue);
    },
    persist: function persist() {
      this.isPersistent = functionThatReturnsTrue;
    },
    isPersistent: functionThatReturnsFalse,
    destructor: function destructor() {
      var Interface = this.constructor.Interface,
          propName;

      for (propName in Interface) {
        this[propName] = null;
      }

      this.nativeEvent = this._targetInst = this.dispatchConfig = null;
      this.isPropagationStopped = this.isDefaultPrevented = functionThatReturnsFalse;
      this._dispatchInstances = this._dispatchListeners = null;
    }
  });

  SyntheticEvent.Interface = {
    type: null,
    target: null,
    currentTarget: function currentTarget() {
      return null;
    },
    eventPhase: null,
    bubbles: null,
    cancelable: null,
    timeStamp: function timeStamp(event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: null,
    isTrusted: null
  };

  SyntheticEvent.extend = function (Interface) {
    function E() {}

    function Class() {
      return Super.apply(this, arguments);
    }

    var Super = this;
    E.prototype = Super.prototype;
    var prototype = new E();

    _extends(prototype, Class.prototype);

    Class.prototype = prototype;
    Class.prototype.constructor = Class;
    Class.Interface = _extends({}, Super.Interface, Interface);
    Class.extend = Super.extend;
    addEventPoolingTo(Class);
    return Class;
  };

  addEventPoolingTo(SyntheticEvent);

  function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
    if (this.eventPool.length) {
      var instance = this.eventPool.pop();
      this.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
      return instance;
    }

    return new this(dispatchConfig, targetInst, nativeEvent, nativeInst);
  }

  function releasePooledEvent(event) {
    invariant(event instanceof this, "Trying to release an event instance into a pool of a different type.");
    event.destructor();
    10 > this.eventPool.length && this.eventPool.push(event);
  }

  function addEventPoolingTo(EventConstructor) {
    EventConstructor.eventPool = [];
    EventConstructor.getPooled = getPooledEvent;
    EventConstructor.release = releasePooledEvent;
  }

  var ResponderSyntheticEvent = SyntheticEvent.extend({
    touchHistory: function touchHistory() {
      return null;
    }
  });

  function isStartish(topLevelType) {
    return "topTouchStart" === topLevelType;
  }

  function isMoveish(topLevelType) {
    return "topTouchMove" === topLevelType;
  }

  var startDependencies = ["topTouchStart"],
      moveDependencies = ["topTouchMove"],
      endDependencies = ["topTouchCancel", "topTouchEnd"],
      touchBank = [],
      touchHistory = {
    touchBank: touchBank,
    numberActiveTouches: 0,
    indexOfSingleActiveTouch: -1,
    mostRecentTimeStamp: 0
  };

  function timestampForTouch(touch) {
    return touch.timeStamp || touch.timestamp;
  }

  function getTouchIdentifier(_ref) {
    _ref = _ref.identifier;
    invariant(null != _ref, "Touch object is missing identifier.");
    return _ref;
  }

  function recordTouchStart(touch) {
    var identifier = getTouchIdentifier(touch),
        touchRecord = touchBank[identifier];
    touchRecord ? (touchRecord.touchActive = !0, touchRecord.startPageX = touch.pageX, touchRecord.startPageY = touch.pageY, touchRecord.startTimeStamp = timestampForTouch(touch), touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchRecord.previousPageX = touch.pageX, touchRecord.previousPageY = touch.pageY, touchRecord.previousTimeStamp = timestampForTouch(touch)) : (touchRecord = {
      touchActive: !0,
      startPageX: touch.pageX,
      startPageY: touch.pageY,
      startTimeStamp: timestampForTouch(touch),
      currentPageX: touch.pageX,
      currentPageY: touch.pageY,
      currentTimeStamp: timestampForTouch(touch),
      previousPageX: touch.pageX,
      previousPageY: touch.pageY,
      previousTimeStamp: timestampForTouch(touch)
    }, touchBank[identifier] = touchRecord);
    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
  }

  function recordTouchMove(touch) {
    var touchRecord = touchBank[getTouchIdentifier(touch)];
    touchRecord ? (touchRecord.touchActive = !0, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch)) : console.error("Cannot record touch move without a touch start.\nTouch Move: %s\n", "Touch Bank: %s", printTouch(touch), printTouchBank());
  }

  function recordTouchEnd(touch) {
    var touchRecord = touchBank[getTouchIdentifier(touch)];
    touchRecord ? (touchRecord.touchActive = !1, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch)) : console.error("Cannot record touch end without a touch start.\nTouch End: %s\n", "Touch Bank: %s", printTouch(touch), printTouchBank());
  }

  function printTouch(touch) {
    return JSON.stringify({
      identifier: touch.identifier,
      pageX: touch.pageX,
      pageY: touch.pageY,
      timestamp: timestampForTouch(touch)
    });
  }

  function printTouchBank() {
    var printed = JSON.stringify(touchBank.slice(0, 20));
    20 < touchBank.length && (printed += " (original size: " + touchBank.length + ")");
    return printed;
  }

  var ResponderTouchHistoryStore = {
    recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {
      if (isMoveish(topLevelType)) nativeEvent.changedTouches.forEach(recordTouchMove);else if (isStartish(topLevelType)) nativeEvent.changedTouches.forEach(recordTouchStart), touchHistory.numberActiveTouches = nativeEvent.touches.length, 1 === touchHistory.numberActiveTouches && (touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier);else if ("topTouchEnd" === topLevelType || "topTouchCancel" === topLevelType) if (nativeEvent.changedTouches.forEach(recordTouchEnd), touchHistory.numberActiveTouches = nativeEvent.touches.length, 1 === touchHistory.numberActiveTouches) for (topLevelType = 0; topLevelType < touchBank.length; topLevelType++) {
        if (nativeEvent = touchBank[topLevelType], null != nativeEvent && nativeEvent.touchActive) {
          touchHistory.indexOfSingleActiveTouch = topLevelType;
          break;
        }
      }
    },
    touchHistory: touchHistory
  };

  function accumulate(current, next) {
    invariant(null != next, "accumulate(...): Accumulated items must be not be null or undefined.");
    return null == current ? next : Array.isArray(current) ? current.concat(next) : Array.isArray(next) ? [current].concat(next) : [current, next];
  }

  var responderInst = null,
      trackedTouchCount = 0;

  function changeResponder(nextResponderInst, blockHostResponder) {
    var oldResponderInst = responderInst;
    responderInst = nextResponderInst;
    if (null !== ResponderEventPlugin.GlobalResponderHandler) ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);
  }

  var eventTypes$1 = {
    startShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onStartShouldSetResponder",
        captured: "onStartShouldSetResponderCapture"
      },
      dependencies: startDependencies
    },
    scrollShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onScrollShouldSetResponder",
        captured: "onScrollShouldSetResponderCapture"
      },
      dependencies: ["topScroll"]
    },
    selectionChangeShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onSelectionChangeShouldSetResponder",
        captured: "onSelectionChangeShouldSetResponderCapture"
      },
      dependencies: ["topSelectionChange"]
    },
    moveShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onMoveShouldSetResponder",
        captured: "onMoveShouldSetResponderCapture"
      },
      dependencies: moveDependencies
    },
    responderStart: {
      registrationName: "onResponderStart",
      dependencies: startDependencies
    },
    responderMove: {
      registrationName: "onResponderMove",
      dependencies: moveDependencies
    },
    responderEnd: {
      registrationName: "onResponderEnd",
      dependencies: endDependencies
    },
    responderRelease: {
      registrationName: "onResponderRelease",
      dependencies: endDependencies
    },
    responderTerminationRequest: {
      registrationName: "onResponderTerminationRequest",
      dependencies: []
    },
    responderGrant: {
      registrationName: "onResponderGrant",
      dependencies: []
    },
    responderReject: {
      registrationName: "onResponderReject",
      dependencies: []
    },
    responderTerminate: {
      registrationName: "onResponderTerminate",
      dependencies: []
    }
  },
      ResponderEventPlugin = {
    _getResponder: function _getResponder() {
      return responderInst;
    },
    eventTypes: eventTypes$1,
    extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      if (isStartish(topLevelType)) trackedTouchCount += 1;else if ("topTouchEnd" === topLevelType || "topTouchCancel" === topLevelType) if (0 <= trackedTouchCount) --trackedTouchCount;else return console.error("Ended a touch event which was not counted in `trackedTouchCount`."), null;
      ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);

      if (targetInst && ("topScroll" === topLevelType && !nativeEvent.responderIgnoreScroll || 0 < trackedTouchCount && "topSelectionChange" === topLevelType || isStartish(topLevelType) || isMoveish(topLevelType))) {
        var JSCompiler_temp = isStartish(topLevelType) ? eventTypes$1.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes$1.moveShouldSetResponder : "topSelectionChange" === topLevelType ? eventTypes$1.selectionChangeShouldSetResponder : eventTypes$1.scrollShouldSetResponder;
        if (responderInst) b: {
          var JSCompiler_temp$jscomp$0 = responderInst;

          for (var depthA = 0, tempA = JSCompiler_temp$jscomp$0; tempA; tempA = getParent(tempA)) {
            depthA++;
          }

          tempA = 0;

          for (var tempB = targetInst; tempB; tempB = getParent(tempB)) {
            tempA++;
          }

          for (; 0 < depthA - tempA;) {
            JSCompiler_temp$jscomp$0 = getParent(JSCompiler_temp$jscomp$0), depthA--;
          }

          for (; 0 < tempA - depthA;) {
            targetInst = getParent(targetInst), tempA--;
          }

          for (; depthA--;) {
            if (JSCompiler_temp$jscomp$0 === targetInst || JSCompiler_temp$jscomp$0 === targetInst.alternate) break b;
            JSCompiler_temp$jscomp$0 = getParent(JSCompiler_temp$jscomp$0);
            targetInst = getParent(targetInst);
          }

          JSCompiler_temp$jscomp$0 = null;
        } else JSCompiler_temp$jscomp$0 = targetInst;
        targetInst = JSCompiler_temp$jscomp$0 === responderInst;
        JSCompiler_temp$jscomp$0 = ResponderSyntheticEvent.getPooled(JSCompiler_temp, JSCompiler_temp$jscomp$0, nativeEvent, nativeEventTarget);
        JSCompiler_temp$jscomp$0.touchHistory = ResponderTouchHistoryStore.touchHistory;
        targetInst ? forEachAccumulated(JSCompiler_temp$jscomp$0, accumulateTwoPhaseDispatchesSingleSkipTarget) : forEachAccumulated(JSCompiler_temp$jscomp$0, accumulateTwoPhaseDispatchesSingle);

        b: {
          JSCompiler_temp = JSCompiler_temp$jscomp$0._dispatchListeners;
          targetInst = JSCompiler_temp$jscomp$0._dispatchInstances;
          if (Array.isArray(JSCompiler_temp)) for (depthA = 0; depthA < JSCompiler_temp.length && !JSCompiler_temp$jscomp$0.isPropagationStopped(); depthA++) {
            if (JSCompiler_temp[depthA](JSCompiler_temp$jscomp$0, targetInst[depthA])) {
              JSCompiler_temp = targetInst[depthA];
              break b;
            }
          } else if (JSCompiler_temp && JSCompiler_temp(JSCompiler_temp$jscomp$0, targetInst)) {
            JSCompiler_temp = targetInst;
            break b;
          }
          JSCompiler_temp = null;
        }

        JSCompiler_temp$jscomp$0._dispatchInstances = null;
        JSCompiler_temp$jscomp$0._dispatchListeners = null;
        JSCompiler_temp$jscomp$0.isPersistent() || JSCompiler_temp$jscomp$0.constructor.release(JSCompiler_temp$jscomp$0);
        JSCompiler_temp && JSCompiler_temp !== responderInst ? (JSCompiler_temp$jscomp$0 = void 0, targetInst = ResponderSyntheticEvent.getPooled(eventTypes$1.responderGrant, JSCompiler_temp, nativeEvent, nativeEventTarget), targetInst.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(targetInst, accumulateDirectDispatchesSingle), depthA = !0 === executeDirectDispatch(targetInst), responderInst ? (tempA = ResponderSyntheticEvent.getPooled(eventTypes$1.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget), tempA.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(tempA, accumulateDirectDispatchesSingle), tempB = !tempA._dispatchListeners || executeDirectDispatch(tempA), tempA.isPersistent() || tempA.constructor.release(tempA), tempB ? (tempA = ResponderSyntheticEvent.getPooled(eventTypes$1.responderTerminate, responderInst, nativeEvent, nativeEventTarget), tempA.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(tempA, accumulateDirectDispatchesSingle), JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, [targetInst, tempA]), changeResponder(JSCompiler_temp, depthA)) : (JSCompiler_temp = ResponderSyntheticEvent.getPooled(eventTypes$1.responderReject, JSCompiler_temp, nativeEvent, nativeEventTarget), JSCompiler_temp.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(JSCompiler_temp, accumulateDirectDispatchesSingle), JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, JSCompiler_temp))) : (JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, targetInst), changeResponder(JSCompiler_temp, depthA)), JSCompiler_temp = JSCompiler_temp$jscomp$0) : JSCompiler_temp = null;
      } else JSCompiler_temp = null;

      JSCompiler_temp$jscomp$0 = responderInst && isStartish(topLevelType);
      targetInst = responderInst && isMoveish(topLevelType);
      depthA = responderInst && ("topTouchEnd" === topLevelType || "topTouchCancel" === topLevelType);
      if (JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0 ? eventTypes$1.responderStart : targetInst ? eventTypes$1.responderMove : depthA ? eventTypes$1.responderEnd : null) JSCompiler_temp$jscomp$0 = ResponderSyntheticEvent.getPooled(JSCompiler_temp$jscomp$0, responderInst, nativeEvent, nativeEventTarget), JSCompiler_temp$jscomp$0.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(JSCompiler_temp$jscomp$0, accumulateDirectDispatchesSingle), JSCompiler_temp = accumulate(JSCompiler_temp, JSCompiler_temp$jscomp$0);
      JSCompiler_temp$jscomp$0 = responderInst && "topTouchCancel" === topLevelType;
      if (topLevelType = responderInst && !JSCompiler_temp$jscomp$0 && ("topTouchEnd" === topLevelType || "topTouchCancel" === topLevelType)) a: {
        if ((topLevelType = nativeEvent.touches) && 0 !== topLevelType.length) for (targetInst = 0; targetInst < topLevelType.length; targetInst++) {
          if (depthA = topLevelType[targetInst].target, null !== depthA && void 0 !== depthA && 0 !== depthA) {
            tempA = getInstanceFromNode(depthA);

            b: {
              for (depthA = responderInst; tempA;) {
                if (depthA === tempA || depthA === tempA.alternate) {
                  depthA = !0;
                  break b;
                }

                tempA = getParent(tempA);
              }

              depthA = !1;
            }

            if (depthA) {
              topLevelType = !1;
              break a;
            }
          }
        }
        topLevelType = !0;
      }
      if (topLevelType = JSCompiler_temp$jscomp$0 ? eventTypes$1.responderTerminate : topLevelType ? eventTypes$1.responderRelease : null) nativeEvent = ResponderSyntheticEvent.getPooled(topLevelType, responderInst, nativeEvent, nativeEventTarget), nativeEvent.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(nativeEvent, accumulateDirectDispatchesSingle), JSCompiler_temp = accumulate(JSCompiler_temp, nativeEvent), changeResponder(null);
      return JSCompiler_temp;
    },
    GlobalResponderHandler: null,
    injection: {
      injectGlobalResponderHandler: function injectGlobalResponderHandler(GlobalResponderHandler) {
        ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;
      }
    }
  },
      customBubblingEventTypes$1 = ReactNativeViewConfigRegistry.customBubblingEventTypes,
      customDirectEventTypes$1 = ReactNativeViewConfigRegistry.customDirectEventTypes,
      ReactNativeBridgeEventPlugin = {
    eventTypes: ReactNativeViewConfigRegistry.eventTypes,
    extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      if (null == targetInst) return null;
      var bubbleDispatchConfig = customBubblingEventTypes$1[topLevelType],
          directDispatchConfig = customDirectEventTypes$1[topLevelType];
      invariant(bubbleDispatchConfig || directDispatchConfig, 'Unsupported top level event type "%s" dispatched', topLevelType);
      topLevelType = SyntheticEvent.getPooled(bubbleDispatchConfig || directDispatchConfig, targetInst, nativeEvent, nativeEventTarget);
      if (bubbleDispatchConfig) forEachAccumulated(topLevelType, accumulateTwoPhaseDispatchesSingle);else if (directDispatchConfig) forEachAccumulated(topLevelType, accumulateDirectDispatchesSingle);else return null;
      return topLevelType;
    }
  };
  injection.injectEventPluginOrder(["ResponderEventPlugin", "ReactNativeBridgeEventPlugin"]);
  injection.injectEventPluginsByName({
    ResponderEventPlugin: ResponderEventPlugin,
    ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin
  });

  function getInstanceFromInstance(instanceHandle) {
    return instanceHandle;
  }

  getFiberCurrentPropsFromNode = function getFiberCurrentPropsFromNode(inst) {
    return inst.canonical.currentProps;
  };

  getInstanceFromNode = getInstanceFromInstance;

  getNodeFromInstance = function getNodeFromInstance(inst) {
    inst = inst.stateNode.canonical._nativeTag;
    invariant(inst, "All native instances should have a tag.");
    return inst;
  };

  ResponderEventPlugin.injection.injectGlobalResponderHandler({
    onChange: function onChange(from, to, blockNativeResponder) {
      null !== to ? UIManager.setJSResponder(to.stateNode.canonical._nativeTag, blockNativeResponder) : UIManager.clearJSResponder();
    }
  });
  var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
      hasSymbol = "function" === typeof Symbol && (typeof Symbol === "function" ? Symbol.for : "@@for"),
      REACT_ELEMENT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.element") : 60103,
      REACT_PORTAL_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.portal") : 60106,
      REACT_FRAGMENT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.fragment") : 60107,
      REACT_STRICT_MODE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.strict_mode") : 60108,
      REACT_PROFILER_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.profiler") : 60114,
      REACT_PROVIDER_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.provider") : 60109,
      REACT_CONTEXT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.context") : 60110,
      REACT_CONCURRENT_MODE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.concurrent_mode") : 60111,
      REACT_FORWARD_REF_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.forward_ref") : 60112,
      REACT_SUSPENSE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.suspense") : 60113,
      REACT_MEMO_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.memo") : 60115,
      REACT_LAZY_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.lazy") : 60116,
      MAYBE_ITERATOR_SYMBOL = "function" === typeof Symbol && (typeof Symbol === "function" ? Symbol.iterator : "@@iterator");

  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }

  function getComponentName(type) {
    if (null == type) return null;
    if ("function" === typeof type) return type.displayName || type.name || null;
    if ("string" === typeof type) return type;

    switch (type) {
      case REACT_CONCURRENT_MODE_TYPE:
        return "ConcurrentMode";

      case REACT_FRAGMENT_TYPE:
        return "Fragment";

      case REACT_PORTAL_TYPE:
        return "Portal";

      case REACT_PROFILER_TYPE:
        return "Profiler";

      case REACT_STRICT_MODE_TYPE:
        return "StrictMode";

      case REACT_SUSPENSE_TYPE:
        return "Suspense";
    }

    if ("object" === typeof type) switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        return "Context.Consumer";

      case REACT_PROVIDER_TYPE:
        return "Context.Provider";

      case REACT_FORWARD_REF_TYPE:
        var innerType = type.render;
        innerType = innerType.displayName || innerType.name || "";
        return type.displayName || ("" !== innerType ? "ForwardRef(" + innerType + ")" : "ForwardRef");

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_LAZY_TYPE:
        if (type = 1 === type._status ? type._result : null) return getComponentName(type);
    }
    return null;
  }

  function isFiberMountedImpl(fiber) {
    var node = fiber;
    if (fiber.alternate) for (; node.return;) {
      node = node.return;
    } else {
      if (0 !== (node.effectTag & 2)) return 1;

      for (; node.return;) {
        if (node = node.return, 0 !== (node.effectTag & 2)) return 1;
      }
    }
    return 3 === node.tag ? 2 : 3;
  }

  function assertIsMounted(fiber) {
    invariant(2 === isFiberMountedImpl(fiber), "Unable to find node on an unmounted component.");
  }

  function findCurrentFiberUsingSlowPath(fiber) {
    var alternate = fiber.alternate;
    if (!alternate) return alternate = isFiberMountedImpl(fiber), invariant(3 !== alternate, "Unable to find node on an unmounted component."), 1 === alternate ? null : fiber;

    for (var a = fiber, b = alternate;;) {
      var parentA = a.return,
          parentB = parentA ? parentA.alternate : null;
      if (!parentA || !parentB) break;

      if (parentA.child === parentB.child) {
        for (var child = parentA.child; child;) {
          if (child === a) return assertIsMounted(parentA), fiber;
          if (child === b) return assertIsMounted(parentA), alternate;
          child = child.sibling;
        }

        invariant(!1, "Unable to find node on an unmounted component.");
      }

      if (a.return !== b.return) a = parentA, b = parentB;else {
        child = !1;

        for (var _child = parentA.child; _child;) {
          if (_child === a) {
            child = !0;
            a = parentA;
            b = parentB;
            break;
          }

          if (_child === b) {
            child = !0;
            b = parentA;
            a = parentB;
            break;
          }

          _child = _child.sibling;
        }

        if (!child) {
          for (_child = parentB.child; _child;) {
            if (_child === a) {
              child = !0;
              a = parentB;
              b = parentA;
              break;
            }

            if (_child === b) {
              child = !0;
              b = parentB;
              a = parentA;
              break;
            }

            _child = _child.sibling;
          }

          invariant(child, "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
        }
      }
      invariant(a.alternate === b, "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
    }

    invariant(3 === a.tag, "Unable to find node on an unmounted component.");
    return a.stateNode.current === a ? fiber : alternate;
  }

  function findCurrentHostFiber(parent) {
    parent = findCurrentFiberUsingSlowPath(parent);
    if (!parent) return null;

    for (var node = parent;;) {
      if (5 === node.tag || 6 === node.tag) return node;
      if (node.child) node.child.return = node, node = node.child;else {
        if (node === parent) break;

        for (; !node.sibling;) {
          if (!node.return || node.return === parent) return null;
          node = node.return;
        }

        node.sibling.return = node.return;
        node = node.sibling;
      }
    }

    return null;
  }

  function mountSafeCallback_NOT_REALLY_SAFE(context, callback) {
    return function () {
      if (callback && ("boolean" !== typeof context.__isMounted || context.__isMounted)) return callback.apply(context, arguments);
    };
  }

  var emptyObject = {},
      removedKeys = null,
      removedKeyCount = 0;

  function restoreDeletedValuesInNestedArray(updatePayload, node, validAttributes) {
    if (Array.isArray(node)) for (var i = node.length; i-- && 0 < removedKeyCount;) {
      restoreDeletedValuesInNestedArray(updatePayload, node[i], validAttributes);
    } else if (node && 0 < removedKeyCount) for (i in removedKeys) {
      if (removedKeys[i]) {
        var nextProp = node[i];

        if (void 0 !== nextProp) {
          var attributeConfig = validAttributes[i];

          if (attributeConfig) {
            "function" === typeof nextProp && (nextProp = !0);
            "undefined" === typeof nextProp && (nextProp = null);
            if ("object" !== typeof attributeConfig) updatePayload[i] = nextProp;else if ("function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process) nextProp = "function" === typeof attributeConfig.process ? attributeConfig.process(nextProp) : nextProp, updatePayload[i] = nextProp;
            removedKeys[i] = !1;
            removedKeyCount--;
          }
        }
      }
    }
  }

  function diffNestedProperty(updatePayload, prevProp, nextProp, validAttributes) {
    if (!updatePayload && prevProp === nextProp) return updatePayload;
    if (!prevProp || !nextProp) return nextProp ? addNestedProperty(updatePayload, nextProp, validAttributes) : prevProp ? clearNestedProperty(updatePayload, prevProp, validAttributes) : updatePayload;
    if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) return diffProperties(updatePayload, prevProp, nextProp, validAttributes);

    if (Array.isArray(prevProp) && Array.isArray(nextProp)) {
      var minLength = prevProp.length < nextProp.length ? prevProp.length : nextProp.length,
          i;

      for (i = 0; i < minLength; i++) {
        updatePayload = diffNestedProperty(updatePayload, prevProp[i], nextProp[i], validAttributes);
      }

      for (; i < prevProp.length; i++) {
        updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);
      }

      for (; i < nextProp.length; i++) {
        updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);
      }

      return updatePayload;
    }

    return Array.isArray(prevProp) ? diffProperties(updatePayload, flattenStyle(prevProp), nextProp, validAttributes) : diffProperties(updatePayload, prevProp, flattenStyle(nextProp), validAttributes);
  }

  function addNestedProperty(updatePayload, nextProp, validAttributes) {
    if (!nextProp) return updatePayload;
    if (!Array.isArray(nextProp)) return diffProperties(updatePayload, emptyObject, nextProp, validAttributes);

    for (var i = 0; i < nextProp.length; i++) {
      updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);
    }

    return updatePayload;
  }

  function clearNestedProperty(updatePayload, prevProp, validAttributes) {
    if (!prevProp) return updatePayload;
    if (!Array.isArray(prevProp)) return diffProperties(updatePayload, prevProp, emptyObject, validAttributes);

    for (var i = 0; i < prevProp.length; i++) {
      updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);
    }

    return updatePayload;
  }

  function diffProperties(updatePayload, prevProps, nextProps, validAttributes) {
    var attributeConfig, propKey;

    for (propKey in nextProps) {
      if (attributeConfig = validAttributes[propKey]) {
        var prevProp = prevProps[propKey];
        var nextProp = nextProps[propKey];
        "function" === typeof nextProp && (nextProp = !0, "function" === typeof prevProp && (prevProp = !0));
        "undefined" === typeof nextProp && (nextProp = null, "undefined" === typeof prevProp && (prevProp = null));
        removedKeys && (removedKeys[propKey] = !1);
        if (updatePayload && void 0 !== updatePayload[propKey]) {
          if ("object" !== typeof attributeConfig) updatePayload[propKey] = nextProp;else {
            if ("function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process) attributeConfig = "function" === typeof attributeConfig.process ? attributeConfig.process(nextProp) : nextProp, updatePayload[propKey] = attributeConfig;
          }
        } else if (prevProp !== nextProp) if ("object" !== typeof attributeConfig) ("object" !== typeof nextProp || null === nextProp || deepDiffer(prevProp, nextProp)) && ((updatePayload || (updatePayload = {}))[propKey] = nextProp);else if ("function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process) {
          if (void 0 === prevProp || ("function" === typeof attributeConfig.diff ? attributeConfig.diff(prevProp, nextProp) : "object" !== typeof nextProp || null === nextProp || deepDiffer(prevProp, nextProp))) attributeConfig = "function" === typeof attributeConfig.process ? attributeConfig.process(nextProp) : nextProp, (updatePayload || (updatePayload = {}))[propKey] = attributeConfig;
        } else removedKeys = null, removedKeyCount = 0, updatePayload = diffNestedProperty(updatePayload, prevProp, nextProp, attributeConfig), 0 < removedKeyCount && updatePayload && (restoreDeletedValuesInNestedArray(updatePayload, nextProp, attributeConfig), removedKeys = null);
      }
    }

    for (var _propKey in prevProps) {
      void 0 === nextProps[_propKey] && (!(attributeConfig = validAttributes[_propKey]) || updatePayload && void 0 !== updatePayload[_propKey] || (prevProp = prevProps[_propKey], void 0 !== prevProp && ("object" !== typeof attributeConfig || "function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process ? ((updatePayload || (updatePayload = {}))[_propKey] = null, removedKeys || (removedKeys = {}), removedKeys[_propKey] || (removedKeys[_propKey] = !0, removedKeyCount++)) : updatePayload = clearNestedProperty(updatePayload, prevProp, attributeConfig))));
    }

    return updatePayload;
  }

  var now$1 = "object" === typeof performance && "function" === typeof performance.now ? function () {
    return performance.now();
  } : function () {
    return Date.now();
  },
      scheduledCallback = null,
      frameDeadline = 0;

  function setTimeoutCallback() {
    frameDeadline = now$1() + 5;
    var callback = scheduledCallback;
    scheduledCallback = null;
    null !== callback && callback();
  }

  var restoreTarget = null,
      restoreQueue = null;

  function restoreStateOfTarget(target) {
    if (target = getInstanceFromNode(target)) {
      invariant(!1, "setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
      var props = getFiberCurrentPropsFromNode(target.stateNode);
      null(target.stateNode, target.type, props);
    }
  }

  function _batchedUpdatesImpl(fn, bookkeeping) {
    return fn(bookkeeping);
  }

  function _flushInteractiveUpdatesImpl() {}

  var isBatching = !1;

  function batchedUpdates(fn, bookkeeping) {
    if (isBatching) return fn(bookkeeping);
    isBatching = !0;

    try {
      return _batchedUpdatesImpl(fn, bookkeeping);
    } finally {
      if (isBatching = !1, null !== restoreTarget || null !== restoreQueue) if (_flushInteractiveUpdatesImpl(), restoreTarget && (bookkeeping = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(bookkeeping), fn)) for (bookkeeping = 0; bookkeeping < fn.length; bookkeeping++) {
        restoreStateOfTarget(fn[bookkeeping]);
      }
    }
  }

  function dispatchEvent(target, topLevelType, nativeEvent) {
    batchedUpdates(function () {
      var events = nativeEvent.target;

      for (var events$jscomp$0 = null, i = 0; i < plugins.length; i++) {
        var possiblePlugin = plugins[i];
        possiblePlugin && (possiblePlugin = possiblePlugin.extractEvents(topLevelType, target, nativeEvent, events)) && (events$jscomp$0 = accumulateInto(events$jscomp$0, possiblePlugin));
      }

      events = events$jscomp$0;
      null !== events && (eventQueue = accumulateInto(eventQueue, events));
      events = eventQueue;
      eventQueue = null;
      if (events && (forEachAccumulated(events, executeDispatchesAndReleaseTopLevel), invariant(!eventQueue, "processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented."), hasRethrowError)) throw events = rethrowError, hasRethrowError = !1, rethrowError = null, events;
    });
  }

  function shim$1() {
    invariant(!1, "The current renderer does not support hyration. This error is likely caused by a bug in React. Please file an issue.");
  }

  var nextReactTag = 2;
  FabricUIManager.registerEventHandler && FabricUIManager.registerEventHandler(dispatchEvent);

  var ReactFabricHostComponent = function () {
    function ReactFabricHostComponent(tag, viewConfig, props) {
      if (!(this instanceof ReactFabricHostComponent)) throw new TypeError("Cannot call a class as a function");
      this._nativeTag = tag;
      this.viewConfig = viewConfig;
      this.currentProps = props;
    }

    ReactFabricHostComponent.prototype.blur = function () {
      TextInputState.blurTextInput(this._nativeTag);
    };

    ReactFabricHostComponent.prototype.focus = function () {
      TextInputState.focusTextInput(this._nativeTag);
    };

    ReactFabricHostComponent.prototype.measure = function (callback) {
      UIManager.measure(this._nativeTag, mountSafeCallback_NOT_REALLY_SAFE(this, callback));
    };

    ReactFabricHostComponent.prototype.measureInWindow = function (callback) {
      UIManager.measureInWindow(this._nativeTag, mountSafeCallback_NOT_REALLY_SAFE(this, callback));
    };

    ReactFabricHostComponent.prototype.measureLayout = function (relativeToNativeNode, onSuccess, onFail) {
      UIManager.measureLayout(this._nativeTag, relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
    };

    ReactFabricHostComponent.prototype.setNativeProps = function (nativeProps) {
      nativeProps = diffProperties(null, emptyObject, nativeProps, this.viewConfig.validAttributes);
      null != nativeProps && UIManager.updateView(this._nativeTag, this.viewConfig.uiViewClassName, nativeProps);
    };

    return ReactFabricHostComponent;
  }();

  function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
    invariant(hostContext.isInAParentText, "Text strings must be rendered within a <Text> component.");
    hostContext = nextReactTag;
    nextReactTag += 2;
    return {
      node: FabricUIManager.createNode(hostContext, "RCTRawText", rootContainerInstance, {
        text: text
      }, internalInstanceHandle)
    };
  }

  var scheduleTimeout = setTimeout,
      cancelTimeout = clearTimeout;

  function cloneHiddenInstance(instance) {
    var node = instance.node;
    var updatePayload = diffProperties(null, emptyObject, {
      style: {
        display: "none"
      }
    }, instance.canonical.viewConfig.validAttributes);
    return {
      node: FabricUIManager.cloneNodeWithNewProps(node, updatePayload),
      canonical: instance.canonical
    };
  }

  function cloneUnhiddenInstance(instance, type, props) {
    var viewConfig = instance.canonical.viewConfig;
    type = instance.node;

    var prevProps = _extends({}, props, {
      style: [props.style, {
        display: "none"
      }]
    });

    props = diffProperties(null, prevProps, props, viewConfig.validAttributes);
    return {
      node: FabricUIManager.cloneNodeWithNewProps(type, props),
      canonical: instance.canonical
    };
  }

  var BEFORE_SLASH_RE = /^(.*)[\\\/]/;

  function getStackByFiberInDevAndProd(workInProgress) {
    var info = "";

    do {
      a: switch (workInProgress.tag) {
        case 2:
        case 16:
        case 0:
        case 1:
        case 5:
        case 8:
        case 13:
          var owner = workInProgress._debugOwner,
              source = workInProgress._debugSource,
              name = getComponentName(workInProgress.type);
          var JSCompiler_inline_result = null;
          owner && (JSCompiler_inline_result = getComponentName(owner.type));
          owner = name;
          name = "";
          source ? name = " (at " + source.fileName.replace(BEFORE_SLASH_RE, "") + ":" + source.lineNumber + ")" : JSCompiler_inline_result && (name = " (created by " + JSCompiler_inline_result + ")");
          JSCompiler_inline_result = "\n    in " + (owner || "Unknown") + name;
          break a;

        default:
          JSCompiler_inline_result = "";
      }

      info += JSCompiler_inline_result;
      workInProgress = workInProgress.return;
    } while (workInProgress);

    return info;
  }

  new Set();
  var valueStack = [],
      index = -1;

  function pop(cursor) {
    0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
  }

  function push(cursor, value) {
    index++;
    valueStack[index] = cursor.current;
    cursor.current = value;
  }

  var emptyContextObject = {},
      contextStackCursor = {
    current: emptyContextObject
  },
      didPerformWorkStackCursor = {
    current: !1
  },
      previousContext = emptyContextObject;

  function getMaskedContext(workInProgress, unmaskedContext) {
    var contextTypes = workInProgress.type.contextTypes;
    if (!contextTypes) return emptyContextObject;
    var instance = workInProgress.stateNode;
    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) return instance.__reactInternalMemoizedMaskedChildContext;
    var context = {},
        key;

    for (key in contextTypes) {
      context[key] = unmaskedContext[key];
    }

    instance && (workInProgress = workInProgress.stateNode, workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext, workInProgress.__reactInternalMemoizedMaskedChildContext = context);
    return context;
  }

  function isContextProvider(type) {
    type = type.childContextTypes;
    return null !== type && void 0 !== type;
  }

  function popContext(fiber) {
    pop(didPerformWorkStackCursor, fiber);
    pop(contextStackCursor, fiber);
  }

  function popTopLevelContextObject(fiber) {
    pop(didPerformWorkStackCursor, fiber);
    pop(contextStackCursor, fiber);
  }

  function pushTopLevelContextObject(fiber, context, didChange) {
    invariant(contextStackCursor.current === emptyContextObject, "Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
    push(contextStackCursor, context, fiber);
    push(didPerformWorkStackCursor, didChange, fiber);
  }

  function processChildContext(fiber, type, parentContext) {
    var instance = fiber.stateNode;
    fiber = type.childContextTypes;
    if ("function" !== typeof instance.getChildContext) return parentContext;
    instance = instance.getChildContext();

    for (var contextKey in instance) {
      invariant(contextKey in fiber, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(type) || "Unknown", contextKey);
    }

    return _extends({}, parentContext, instance);
  }

  function pushContextProvider(workInProgress) {
    var instance = workInProgress.stateNode;
    instance = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
    previousContext = contextStackCursor.current;
    push(contextStackCursor, instance, workInProgress);
    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
    return !0;
  }

  function invalidateContextProvider(workInProgress, type, didChange) {
    var instance = workInProgress.stateNode;
    invariant(instance, "Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
    didChange ? (type = processChildContext(workInProgress, type, previousContext), instance.__reactInternalMemoizedMergedChildContext = type, pop(didPerformWorkStackCursor, workInProgress), pop(contextStackCursor, workInProgress), push(contextStackCursor, type, workInProgress)) : pop(didPerformWorkStackCursor, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  }

  var onCommitFiberRoot = null,
      onCommitFiberUnmount = null;

  function catchErrors(fn) {
    return function (arg) {
      try {
        return fn(arg);
      } catch (err) {}
    };
  }

  function injectInternals(internals) {
    if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
    var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (hook.isDisabled || !hook.supportsFiber) return !0;

    try {
      var rendererID = hook.inject(internals);
      onCommitFiberRoot = catchErrors(function (root) {
        return hook.onCommitFiberRoot(rendererID, root);
      });
      onCommitFiberUnmount = catchErrors(function (fiber) {
        return hook.onCommitFiberUnmount(rendererID, fiber);
      });
    } catch (err) {}

    return !0;
  }

  function FiberNode(tag, pendingProps, key, mode) {
    this.tag = tag;
    this.key = key;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = pendingProps;
    this.firstContextDependency = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = mode;
    this.effectTag = 0;
    this.lastEffect = this.firstEffect = this.nextEffect = null;
    this.childExpirationTime = this.expirationTime = 0;
    this.alternate = null;
  }

  function createFiber(tag, pendingProps, key, mode) {
    return new FiberNode(tag, pendingProps, key, mode);
  }

  function shouldConstruct(Component) {
    Component = Component.prototype;
    return !(!Component || !Component.isReactComponent);
  }

  function resolveLazyComponentTag(Component) {
    if ("function" === typeof Component) return shouldConstruct(Component) ? 1 : 0;

    if (void 0 !== Component && null !== Component) {
      Component = Component.$$typeof;
      if (Component === REACT_FORWARD_REF_TYPE) return 11;
      if (Component === REACT_MEMO_TYPE) return 14;
    }

    return 2;
  }

  function createWorkInProgress(current, pendingProps) {
    var workInProgress = current.alternate;
    null === workInProgress ? (workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.effectTag = 0, workInProgress.nextEffect = null, workInProgress.firstEffect = null, workInProgress.lastEffect = null);
    workInProgress.childExpirationTime = current.childExpirationTime;
    workInProgress.expirationTime = current.expirationTime;
    workInProgress.child = current.child;
    workInProgress.memoizedProps = current.memoizedProps;
    workInProgress.memoizedState = current.memoizedState;
    workInProgress.updateQueue = current.updateQueue;
    workInProgress.firstContextDependency = current.firstContextDependency;
    workInProgress.sibling = current.sibling;
    workInProgress.index = current.index;
    workInProgress.ref = current.ref;
    return workInProgress;
  }

  function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime) {
    var fiberTag = 2;
    owner = type;
    if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);else if ("string" === typeof type) fiberTag = 5;else a: switch (type) {
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);

      case REACT_CONCURRENT_MODE_TYPE:
        return createFiberFromMode(pendingProps, mode | 3, expirationTime, key);

      case REACT_STRICT_MODE_TYPE:
        return createFiberFromMode(pendingProps, mode | 2, expirationTime, key);

      case REACT_PROFILER_TYPE:
        return type = createFiber(12, pendingProps, key, mode | 4), type.elementType = REACT_PROFILER_TYPE, type.type = REACT_PROFILER_TYPE, type.expirationTime = expirationTime, type;

      case REACT_SUSPENSE_TYPE:
        return type = createFiber(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.type = REACT_SUSPENSE_TYPE, type.expirationTime = expirationTime, type;

      default:
        if ("object" === typeof type && null !== type) switch (type.$$typeof) {
          case REACT_PROVIDER_TYPE:
            fiberTag = 10;
            break a;

          case REACT_CONTEXT_TYPE:
            fiberTag = 9;
            break a;

          case REACT_FORWARD_REF_TYPE:
            fiberTag = 11;
            break a;

          case REACT_MEMO_TYPE:
            fiberTag = 14;
            break a;

          case REACT_LAZY_TYPE:
            fiberTag = 16;
            owner = null;
            break a;
        }
        invariant(!1, "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", null == type ? type : typeof type, "");
    }
    key = createFiber(fiberTag, pendingProps, key, mode);
    key.elementType = type;
    key.type = owner;
    key.expirationTime = expirationTime;
    return key;
  }

  function createFiberFromFragment(elements, mode, expirationTime, key) {
    elements = createFiber(7, elements, key, mode);
    elements.expirationTime = expirationTime;
    return elements;
  }

  function createFiberFromMode(pendingProps, mode, expirationTime, key) {
    pendingProps = createFiber(8, pendingProps, key, mode);
    mode = 0 === (mode & 1) ? REACT_STRICT_MODE_TYPE : REACT_CONCURRENT_MODE_TYPE;
    pendingProps.elementType = mode;
    pendingProps.type = mode;
    pendingProps.expirationTime = expirationTime;
    return pendingProps;
  }

  function createFiberFromText(content, mode, expirationTime) {
    content = createFiber(6, content, null, mode);
    content.expirationTime = expirationTime;
    return content;
  }

  function createFiberFromPortal(portal, mode, expirationTime) {
    mode = createFiber(4, null !== portal.children ? portal.children : [], portal.key, mode);
    mode.expirationTime = expirationTime;
    mode.stateNode = {
      containerInfo: portal.containerInfo,
      pendingChildren: null,
      implementation: portal.implementation
    };
    return mode;
  }

  function markPendingPriorityLevel(root, expirationTime) {
    root.didError = !1;
    var earliestPendingTime = root.earliestPendingTime;
    0 === earliestPendingTime ? root.earliestPendingTime = root.latestPendingTime = expirationTime : earliestPendingTime < expirationTime ? root.earliestPendingTime = expirationTime : root.latestPendingTime > expirationTime && (root.latestPendingTime = expirationTime);
    findNextExpirationTimeToWorkOn(expirationTime, root);
  }

  function markSuspendedPriorityLevel(root, suspendedTime) {
    root.didError = !1;
    var latestPingedTime = root.latestPingedTime;
    0 !== latestPingedTime && latestPingedTime >= suspendedTime && (root.latestPingedTime = 0);
    latestPingedTime = root.earliestPendingTime;
    var latestPendingTime = root.latestPendingTime;
    latestPingedTime === suspendedTime ? root.earliestPendingTime = latestPendingTime === suspendedTime ? root.latestPendingTime = 0 : latestPendingTime : latestPendingTime === suspendedTime && (root.latestPendingTime = latestPingedTime);
    latestPingedTime = root.earliestSuspendedTime;
    latestPendingTime = root.latestSuspendedTime;
    0 === latestPingedTime ? root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime : latestPingedTime < suspendedTime ? root.earliestSuspendedTime = suspendedTime : latestPendingTime > suspendedTime && (root.latestSuspendedTime = suspendedTime);
    findNextExpirationTimeToWorkOn(suspendedTime, root);
  }

  function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
    var earliestPendingTime = root.earliestPendingTime;
    root = root.earliestSuspendedTime;
    earliestPendingTime > renderExpirationTime && (renderExpirationTime = earliestPendingTime);
    root > renderExpirationTime && (renderExpirationTime = root);
    return renderExpirationTime;
  }

  function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
    var earliestSuspendedTime = root.earliestSuspendedTime,
        latestSuspendedTime = root.latestSuspendedTime,
        earliestPendingTime = root.earliestPendingTime,
        latestPingedTime = root.latestPingedTime;
    earliestPendingTime = 0 !== earliestPendingTime ? earliestPendingTime : latestPingedTime;
    0 === earliestPendingTime && (0 === completedExpirationTime || latestSuspendedTime < completedExpirationTime) && (earliestPendingTime = latestSuspendedTime);
    completedExpirationTime = earliestPendingTime;
    0 !== completedExpirationTime && earliestSuspendedTime > completedExpirationTime && (completedExpirationTime = earliestSuspendedTime);
    root.nextExpirationTimeToWorkOn = earliestPendingTime;
    root.expirationTime = completedExpirationTime;
  }

  var hasForceUpdate = !1;

  function createUpdateQueue(baseState) {
    return {
      baseState: baseState,
      firstUpdate: null,
      lastUpdate: null,
      firstCapturedUpdate: null,
      lastCapturedUpdate: null,
      firstEffect: null,
      lastEffect: null,
      firstCapturedEffect: null,
      lastCapturedEffect: null
    };
  }

  function cloneUpdateQueue(currentQueue) {
    return {
      baseState: currentQueue.baseState,
      firstUpdate: currentQueue.firstUpdate,
      lastUpdate: currentQueue.lastUpdate,
      firstCapturedUpdate: null,
      lastCapturedUpdate: null,
      firstEffect: null,
      lastEffect: null,
      firstCapturedEffect: null,
      lastCapturedEffect: null
    };
  }

  function createUpdate(expirationTime) {
    return {
      expirationTime: expirationTime,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
      nextEffect: null
    };
  }

  function appendUpdateToQueue(queue, update) {
    null === queue.lastUpdate ? queue.firstUpdate = queue.lastUpdate = update : (queue.lastUpdate.next = update, queue.lastUpdate = update);
  }

  function enqueueUpdate(fiber, update) {
    var alternate = fiber.alternate;

    if (null === alternate) {
      var queue1 = fiber.updateQueue;
      var queue2 = null;
      null === queue1 && (queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState));
    } else queue1 = fiber.updateQueue, queue2 = alternate.updateQueue, null === queue1 ? null === queue2 ? (queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState), queue2 = alternate.updateQueue = createUpdateQueue(alternate.memoizedState)) : queue1 = fiber.updateQueue = cloneUpdateQueue(queue2) : null === queue2 && (queue2 = alternate.updateQueue = cloneUpdateQueue(queue1));

    null === queue2 || queue1 === queue2 ? appendUpdateToQueue(queue1, update) : null === queue1.lastUpdate || null === queue2.lastUpdate ? (appendUpdateToQueue(queue1, update), appendUpdateToQueue(queue2, update)) : (appendUpdateToQueue(queue1, update), queue2.lastUpdate = update);
  }

  function enqueueCapturedUpdate(workInProgress, update) {
    var workInProgressQueue = workInProgress.updateQueue;
    workInProgressQueue = null === workInProgressQueue ? workInProgress.updateQueue = createUpdateQueue(workInProgress.memoizedState) : ensureWorkInProgressQueueIsAClone(workInProgress, workInProgressQueue);
    null === workInProgressQueue.lastCapturedUpdate ? workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update : (workInProgressQueue.lastCapturedUpdate.next = update, workInProgressQueue.lastCapturedUpdate = update);
  }

  function ensureWorkInProgressQueueIsAClone(workInProgress, queue) {
    var current = workInProgress.alternate;
    null !== current && queue === current.updateQueue && (queue = workInProgress.updateQueue = cloneUpdateQueue(queue));
    return queue;
  }

  function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
    switch (update.tag) {
      case 1:
        return workInProgress = update.payload, "function" === typeof workInProgress ? workInProgress.call(instance, prevState, nextProps) : workInProgress;

      case 3:
        workInProgress.effectTag = workInProgress.effectTag & -2049 | 64;

      case 0:
        workInProgress = update.payload;
        nextProps = "function" === typeof workInProgress ? workInProgress.call(instance, prevState, nextProps) : workInProgress;
        if (null === nextProps || void 0 === nextProps) break;
        return _extends({}, prevState, nextProps);

      case 2:
        hasForceUpdate = !0;
    }

    return prevState;
  }

  function processUpdateQueue(workInProgress, queue, props, instance, renderExpirationTime) {
    hasForceUpdate = !1;
    queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);

    for (var newBaseState = queue.baseState, newFirstUpdate = null, newExpirationTime = 0, update = queue.firstUpdate, resultState = newBaseState; null !== update;) {
      var updateExpirationTime = update.expirationTime;
      updateExpirationTime < renderExpirationTime ? (null === newFirstUpdate && (newFirstUpdate = update, newBaseState = resultState), newExpirationTime < updateExpirationTime && (newExpirationTime = updateExpirationTime)) : (resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance), null !== update.callback && (workInProgress.effectTag |= 32, update.nextEffect = null, null === queue.lastEffect ? queue.firstEffect = queue.lastEffect = update : (queue.lastEffect.nextEffect = update, queue.lastEffect = update)));
      update = update.next;
    }

    updateExpirationTime = null;

    for (update = queue.firstCapturedUpdate; null !== update;) {
      var _updateExpirationTime = update.expirationTime;
      _updateExpirationTime < renderExpirationTime ? (null === updateExpirationTime && (updateExpirationTime = update, null === newFirstUpdate && (newBaseState = resultState)), newExpirationTime < _updateExpirationTime && (newExpirationTime = _updateExpirationTime)) : (resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance), null !== update.callback && (workInProgress.effectTag |= 32, update.nextEffect = null, null === queue.lastCapturedEffect ? queue.firstCapturedEffect = queue.lastCapturedEffect = update : (queue.lastCapturedEffect.nextEffect = update, queue.lastCapturedEffect = update)));
      update = update.next;
    }

    null === newFirstUpdate && (queue.lastUpdate = null);
    null === updateExpirationTime ? queue.lastCapturedUpdate = null : workInProgress.effectTag |= 32;
    null === newFirstUpdate && null === updateExpirationTime && (newBaseState = resultState);
    queue.baseState = newBaseState;
    queue.firstUpdate = newFirstUpdate;
    queue.firstCapturedUpdate = updateExpirationTime;
    workInProgress.expirationTime = newExpirationTime;
    workInProgress.memoizedState = resultState;
  }

  function commitUpdateQueue(finishedWork, finishedQueue, instance) {
    null !== finishedQueue.firstCapturedUpdate && (null !== finishedQueue.lastUpdate && (finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate, finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate), finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null);
    commitUpdateEffects(finishedQueue.firstEffect, instance);
    finishedQueue.firstEffect = finishedQueue.lastEffect = null;
    commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);
    finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;
  }

  function commitUpdateEffects(effect, instance) {
    for (; null !== effect;) {
      var _callback3 = effect.callback;

      if (null !== _callback3) {
        effect.callback = null;
        var context = instance;
        invariant("function" === typeof _callback3, "Invalid argument passed as callback. Expected a function. Instead received: %s", _callback3);

        _callback3.call(context);
      }

      effect = effect.nextEffect;
    }
  }

  function createCapturedValue(value, source) {
    return {
      value: value,
      source: source,
      stack: getStackByFiberInDevAndProd(source)
    };
  }

  var valueCursor = {
    current: null
  },
      currentlyRenderingFiber = null,
      lastContextDependency = null,
      lastContextWithAllBitsObserved = null;

  function pushProvider(providerFiber, nextValue) {
    var context = providerFiber.type._context;
    push(valueCursor, context._currentValue2, providerFiber);
    context._currentValue2 = nextValue;
  }

  function popProvider(providerFiber) {
    var currentValue = valueCursor.current;
    pop(valueCursor, providerFiber);
    providerFiber.type._context._currentValue2 = currentValue;
  }

  function prepareToReadContext(workInProgress) {
    currentlyRenderingFiber = workInProgress;
    lastContextWithAllBitsObserved = lastContextDependency = null;
    workInProgress.firstContextDependency = null;
  }

  function readContext(context, observedBits) {
    if (lastContextWithAllBitsObserved !== context && !1 !== observedBits && 0 !== observedBits) {
      if ("number" !== typeof observedBits || 1073741823 === observedBits) lastContextWithAllBitsObserved = context, observedBits = 1073741823;
      observedBits = {
        context: context,
        observedBits: observedBits,
        next: null
      };
      null === lastContextDependency ? (invariant(null !== currentlyRenderingFiber, "Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps."), currentlyRenderingFiber.firstContextDependency = lastContextDependency = observedBits) : lastContextDependency = lastContextDependency.next = observedBits;
    }

    return context._currentValue2;
  }

  var NO_CONTEXT = {},
      contextStackCursor$1 = {
    current: NO_CONTEXT
  },
      contextFiberStackCursor = {
    current: NO_CONTEXT
  },
      rootInstanceStackCursor = {
    current: NO_CONTEXT
  };

  function requiredContext(c) {
    invariant(c !== NO_CONTEXT, "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
    return c;
  }

  function pushHostContainer(fiber, nextRootInstance) {
    push(rootInstanceStackCursor, nextRootInstance, fiber);
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor$1, NO_CONTEXT, fiber);
    pop(contextStackCursor$1, fiber);
    push(contextStackCursor$1, {
      isInAParentText: !1
    }, fiber);
  }

  function popHostContainer(fiber) {
    pop(contextStackCursor$1, fiber);
    pop(contextFiberStackCursor, fiber);
    pop(rootInstanceStackCursor, fiber);
  }

  function pushHostContext(fiber) {
    requiredContext(rootInstanceStackCursor.current);
    var context = requiredContext(contextStackCursor$1.current);
    var nextContext = fiber.type;
    nextContext = "AndroidTextInput" === nextContext || "RCTMultilineTextInputView" === nextContext || "RCTSinglelineTextInputView" === nextContext || "RCTText" === nextContext || "RCTVirtualText" === nextContext;
    nextContext = context.isInAParentText !== nextContext ? {
      isInAParentText: nextContext
    } : context;
    context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor$1, nextContext, fiber));
  }

  function popHostContext(fiber) {
    contextFiberStackCursor.current === fiber && (pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber));
  }

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  function is(x, y) {
    return x === y ? 0 !== x || 0 !== y || 1 / x === 1 / y : x !== x && y !== y;
  }

  function shallowEqual(objA, objB) {
    if (is(objA, objB)) return !0;
    if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB) return !1;
    var keysA = Object.keys(objA),
        keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return !1;

    for (keysB = 0; keysB < keysA.length; keysB++) {
      if (!hasOwnProperty.call(objB, keysA[keysB]) || !is(objA[keysA[keysB]], objB[keysA[keysB]])) return !1;
    }

    return !0;
  }

  function resolveDefaultProps(Component, baseProps) {
    if (Component && Component.defaultProps) {
      baseProps = _extends({}, baseProps);
      Component = Component.defaultProps;

      for (var propName in Component) {
        void 0 === baseProps[propName] && (baseProps[propName] = Component[propName]);
      }
    }

    return baseProps;
  }

  function readLazyComponentType(lazyComponent) {
    var result = lazyComponent._result;

    switch (lazyComponent._status) {
      case 1:
        return result;

      case 2:
        throw result;

      case 0:
        throw result;

      default:
        throw lazyComponent._status = 0, result = lazyComponent._ctor, result = result(), result.then(function (moduleObject) {
          0 === lazyComponent._status && (moduleObject = moduleObject.default, lazyComponent._status = 1, lazyComponent._result = moduleObject);
        }, function (error) {
          0 === lazyComponent._status && (lazyComponent._status = 2, lazyComponent._result = error);
        }), lazyComponent._result = result, result;
    }
  }

  var ReactCurrentOwner$4 = ReactSharedInternals.ReactCurrentOwner,
      emptyRefsObject = new React.Component().refs;

  function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
    ctor = workInProgress.memoizedState;
    getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
    getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : _extends({}, ctor, getDerivedStateFromProps);
    workInProgress.memoizedState = getDerivedStateFromProps;
    nextProps = workInProgress.updateQueue;
    null !== nextProps && 0 === workInProgress.expirationTime && (nextProps.baseState = getDerivedStateFromProps);
  }

  var classComponentUpdater = {
    isMounted: function isMounted(component) {
      return (component = component._reactInternalFiber) ? 2 === isFiberMountedImpl(component) : !1;
    },
    enqueueSetState: function enqueueSetState(inst, payload, callback) {
      inst = inst._reactInternalFiber;
      var currentTime = requestCurrentTime();
      currentTime = computeExpirationForFiber(currentTime, inst);
      var update = createUpdate(currentTime);
      update.payload = payload;
      void 0 !== callback && null !== callback && (update.callback = callback);
      flushPassiveEffects();
      enqueueUpdate(inst, update);
      scheduleWork(inst, currentTime);
    },
    enqueueReplaceState: function enqueueReplaceState(inst, payload, callback) {
      inst = inst._reactInternalFiber;
      var currentTime = requestCurrentTime();
      currentTime = computeExpirationForFiber(currentTime, inst);
      var update = createUpdate(currentTime);
      update.tag = 1;
      update.payload = payload;
      void 0 !== callback && null !== callback && (update.callback = callback);
      flushPassiveEffects();
      enqueueUpdate(inst, update);
      scheduleWork(inst, currentTime);
    },
    enqueueForceUpdate: function enqueueForceUpdate(inst, callback) {
      inst = inst._reactInternalFiber;
      var currentTime = requestCurrentTime();
      currentTime = computeExpirationForFiber(currentTime, inst);
      var update = createUpdate(currentTime);
      update.tag = 2;
      void 0 !== callback && null !== callback && (update.callback = callback);
      flushPassiveEffects();
      enqueueUpdate(inst, update);
      scheduleWork(inst, currentTime);
    }
  };

  function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
    workInProgress = workInProgress.stateNode;
    return "function" === typeof workInProgress.shouldComponentUpdate ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;
  }

  function constructClassInstance(workInProgress, ctor, props) {
    var isLegacyContextConsumer = !1,
        unmaskedContext = emptyContextObject;
    var context = ctor.contextType;
    "object" === typeof context && null !== context ? context = ReactCurrentOwner$4.currentDispatcher.readContext(context) : (unmaskedContext = isContextProvider(ctor) ? previousContext : contextStackCursor.current, isLegacyContextConsumer = ctor.contextTypes, context = (isLegacyContextConsumer = null !== isLegacyContextConsumer && void 0 !== isLegacyContextConsumer) ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject);
    ctor = new ctor(props, context);
    workInProgress.memoizedState = null !== ctor.state && void 0 !== ctor.state ? ctor.state : null;
    ctor.updater = classComponentUpdater;
    workInProgress.stateNode = ctor;
    ctor._reactInternalFiber = workInProgress;
    isLegacyContextConsumer && (workInProgress = workInProgress.stateNode, workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext, workInProgress.__reactInternalMemoizedMaskedChildContext = context);
    return ctor;
  }

  function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
    workInProgress = instance.state;
    "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
    "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
    instance.state !== workInProgress && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }

  function mountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
    var instance = workInProgress.stateNode;
    instance.props = newProps;
    instance.state = workInProgress.memoizedState;
    instance.refs = emptyRefsObject;
    var contextType = ctor.contextType;
    "object" === typeof contextType && null !== contextType ? instance.context = ReactCurrentOwner$4.currentDispatcher.readContext(contextType) : (contextType = isContextProvider(ctor) ? previousContext : contextStackCursor.current, instance.context = getMaskedContext(workInProgress, contextType));
    contextType = workInProgress.updateQueue;
    null !== contextType && (processUpdateQueue(workInProgress, contextType, newProps, instance, renderExpirationTime), instance.state = workInProgress.memoizedState);
    contextType = ctor.getDerivedStateFromProps;
    "function" === typeof contextType && (applyDerivedStateFromProps(workInProgress, ctor, contextType, newProps), instance.state = workInProgress.memoizedState);
    "function" === typeof ctor.getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate || "function" !== typeof instance.UNSAFE_componentWillMount && "function" !== typeof instance.componentWillMount || (ctor = instance.state, "function" === typeof instance.componentWillMount && instance.componentWillMount(), "function" === typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount(), ctor !== instance.state && classComponentUpdater.enqueueReplaceState(instance, instance.state, null), contextType = workInProgress.updateQueue, null !== contextType && (processUpdateQueue(workInProgress, contextType, newProps, instance, renderExpirationTime), instance.state = workInProgress.memoizedState));
    "function" === typeof instance.componentDidMount && (workInProgress.effectTag |= 4);
  }

  var isArray = Array.isArray;

  function coerceRef(returnFiber, current$$1, element) {
    returnFiber = element.ref;

    if (null !== returnFiber && "function" !== typeof returnFiber && "object" !== typeof returnFiber) {
      if (element._owner) {
        element = element._owner;
        var inst = void 0;
        element && (invariant(1 === element.tag, "Function components cannot have refs."), inst = element.stateNode);
        invariant(inst, "Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.", returnFiber);
        var stringRef = "" + returnFiber;
        if (null !== current$$1 && null !== current$$1.ref && "function" === typeof current$$1.ref && current$$1.ref._stringRef === stringRef) return current$$1.ref;

        current$$1 = function current$$1(value) {
          var refs = inst.refs;
          refs === emptyRefsObject && (refs = inst.refs = {});
          null === value ? delete refs[stringRef] : refs[stringRef] = value;
        };

        current$$1._stringRef = stringRef;
        return current$$1;
      }

      invariant("string" === typeof returnFiber, "Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
      invariant(element._owner, "Element ref was specified as a string (%s) but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://fb.me/react-refs-must-have-owner for more information.", returnFiber);
    }

    return returnFiber;
  }

  function throwOnInvalidObjectType(returnFiber, newChild) {
    "textarea" !== returnFiber.type && invariant(!1, "Objects are not valid as a React child (found: %s).%s", "[object Object]" === Object.prototype.toString.call(newChild) ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : newChild, "");
  }

  function ChildReconciler(shouldTrackSideEffects) {
    function deleteChild(returnFiber, childToDelete) {
      if (shouldTrackSideEffects) {
        var last = returnFiber.lastEffect;
        null !== last ? (last.nextEffect = childToDelete, returnFiber.lastEffect = childToDelete) : returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
        childToDelete.nextEffect = null;
        childToDelete.effectTag = 8;
      }
    }

    function deleteRemainingChildren(returnFiber, currentFirstChild) {
      if (!shouldTrackSideEffects) return null;

      for (; null !== currentFirstChild;) {
        deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      }

      return null;
    }

    function mapRemainingChildren(returnFiber, currentFirstChild) {
      for (returnFiber = new Map(); null !== currentFirstChild;) {
        null !== currentFirstChild.key ? returnFiber.set(currentFirstChild.key, currentFirstChild) : returnFiber.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      }

      return returnFiber;
    }

    function useFiber(fiber, pendingProps, expirationTime) {
      fiber = createWorkInProgress(fiber, pendingProps, expirationTime);
      fiber.index = 0;
      fiber.sibling = null;
      return fiber;
    }

    function placeChild(newFiber, lastPlacedIndex, newIndex) {
      newFiber.index = newIndex;
      if (!shouldTrackSideEffects) return lastPlacedIndex;
      newIndex = newFiber.alternate;
      if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.effectTag = 2, lastPlacedIndex) : newIndex;
      newFiber.effectTag = 2;
      return lastPlacedIndex;
    }

    function placeSingleChild(newFiber) {
      shouldTrackSideEffects && null === newFiber.alternate && (newFiber.effectTag = 2);
      return newFiber;
    }

    function updateTextNode(returnFiber, current$$1, textContent, expirationTime) {
      if (null === current$$1 || 6 !== current$$1.tag) return current$$1 = createFiberFromText(textContent, returnFiber.mode, expirationTime), current$$1.return = returnFiber, current$$1;
      current$$1 = useFiber(current$$1, textContent, expirationTime);
      current$$1.return = returnFiber;
      return current$$1;
    }

    function updateElement(returnFiber, current$$1, element, expirationTime) {
      if (null !== current$$1 && current$$1.elementType === element.type) return expirationTime = useFiber(current$$1, element.props, expirationTime), expirationTime.ref = coerceRef(returnFiber, current$$1, element), expirationTime.return = returnFiber, expirationTime;
      expirationTime = createFiberFromTypeAndProps(element.type, element.key, element.props, null, returnFiber.mode, expirationTime);
      expirationTime.ref = coerceRef(returnFiber, current$$1, element);
      expirationTime.return = returnFiber;
      return expirationTime;
    }

    function updatePortal(returnFiber, current$$1, portal, expirationTime) {
      if (null === current$$1 || 4 !== current$$1.tag || current$$1.stateNode.containerInfo !== portal.containerInfo || current$$1.stateNode.implementation !== portal.implementation) return current$$1 = createFiberFromPortal(portal, returnFiber.mode, expirationTime), current$$1.return = returnFiber, current$$1;
      current$$1 = useFiber(current$$1, portal.children || [], expirationTime);
      current$$1.return = returnFiber;
      return current$$1;
    }

    function updateFragment(returnFiber, current$$1, fragment, expirationTime, key) {
      if (null === current$$1 || 7 !== current$$1.tag) return current$$1 = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key), current$$1.return = returnFiber, current$$1;
      current$$1 = useFiber(current$$1, fragment, expirationTime);
      current$$1.return = returnFiber;
      return current$$1;
    }

    function createChild(returnFiber, newChild, expirationTime) {
      if ("string" === typeof newChild || "number" === typeof newChild) return newChild = createFiberFromText("" + newChild, returnFiber.mode, expirationTime), newChild.return = returnFiber, newChild;

      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return expirationTime = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, expirationTime), expirationTime.ref = coerceRef(returnFiber, null, newChild), expirationTime.return = returnFiber, expirationTime;

          case REACT_PORTAL_TYPE:
            return newChild = createFiberFromPortal(newChild, returnFiber.mode, expirationTime), newChild.return = returnFiber, newChild;
        }

        if (isArray(newChild) || getIteratorFn(newChild)) return newChild = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null), newChild.return = returnFiber, newChild;
        throwOnInvalidObjectType(returnFiber, newChild);
      }

      return null;
    }

    function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
      var key = null !== oldFiber ? oldFiber.key : null;
      if ("string" === typeof newChild || "number" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, expirationTime);

      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return newChild.key === key ? newChild.type === REACT_FRAGMENT_TYPE ? updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key) : updateElement(returnFiber, oldFiber, newChild, expirationTime) : null;

          case REACT_PORTAL_TYPE:
            return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, expirationTime) : null;
        }

        if (isArray(newChild) || getIteratorFn(newChild)) return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
        throwOnInvalidObjectType(returnFiber, newChild);
      }

      return null;
    }

    function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
      if ("string" === typeof newChild || "number" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, expirationTime);

      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, newChild.type === REACT_FRAGMENT_TYPE ? updateFragment(returnFiber, existingChildren, newChild.props.children, expirationTime, newChild.key) : updateElement(returnFiber, existingChildren, newChild, expirationTime);

          case REACT_PORTAL_TYPE:
            return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, expirationTime);
        }

        if (isArray(newChild) || getIteratorFn(newChild)) return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, expirationTime, null);
        throwOnInvalidObjectType(returnFiber, newChild);
      }

      return null;
    }

    function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
      for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);

        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }

        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }

      if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), resultingFirstChild;

      if (null === oldFiber) {
        for (; newIdx < newChildren.length; newIdx++) {
          if (oldFiber = createChild(returnFiber, newChildren[newIdx], expirationTime)) currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber;
        }

        return resultingFirstChild;
      }

      for (oldFiber = mapRemainingChildren(returnFiber, oldFiber); newIdx < newChildren.length; newIdx++) {
        if (nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], expirationTime)) shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber;
      }

      shouldTrackSideEffects && oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
      return resultingFirstChild;
    }

    function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
      var iteratorFn = getIteratorFn(newChildrenIterable);
      invariant("function" === typeof iteratorFn, "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
      newChildrenIterable = iteratorFn.call(newChildrenIterable);
      invariant(null != newChildrenIterable, "An iterable object provided no iterator.");

      for (var previousNewFiber = iteratorFn = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildrenIterable.next(); null !== oldFiber && !step.done; newIdx++, step = newChildrenIterable.next()) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);

        if (null === newFiber) {
          oldFiber || (oldFiber = nextOldFiber);
          break;
        }

        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? iteratorFn = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }

      if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), iteratorFn;

      if (null === oldFiber) {
        for (; !step.done; newIdx++, step = newChildrenIterable.next()) {
          step = createChild(returnFiber, step.value, expirationTime), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? iteratorFn = step : previousNewFiber.sibling = step, previousNewFiber = step);
        }

        return iteratorFn;
      }

      for (oldFiber = mapRemainingChildren(returnFiber, oldFiber); !step.done; newIdx++, step = newChildrenIterable.next()) {
        step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, expirationTime), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? iteratorFn = step : previousNewFiber.sibling = step, previousNewFiber = step);
      }

      shouldTrackSideEffects && oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
      return iteratorFn;
    }

    return function (returnFiber, currentFirstChild, newChild, expirationTime) {
      var isUnkeyedTopLevelFragment = "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key;
      isUnkeyedTopLevelFragment && (newChild = newChild.props.children);
      var isObject = "object" === typeof newChild && null !== newChild;
      if (isObject) switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          a: {
            isObject = newChild.key;

            for (isUnkeyedTopLevelFragment = currentFirstChild; null !== isUnkeyedTopLevelFragment;) {
              if (isUnkeyedTopLevelFragment.key === isObject) {
                if (7 === isUnkeyedTopLevelFragment.tag ? newChild.type === REACT_FRAGMENT_TYPE : isUnkeyedTopLevelFragment.elementType === newChild.type) {
                  deleteRemainingChildren(returnFiber, isUnkeyedTopLevelFragment.sibling);
                  currentFirstChild = useFiber(isUnkeyedTopLevelFragment, newChild.type === REACT_FRAGMENT_TYPE ? newChild.props.children : newChild.props, expirationTime);
                  currentFirstChild.ref = coerceRef(returnFiber, isUnkeyedTopLevelFragment, newChild);
                  currentFirstChild.return = returnFiber;
                  returnFiber = currentFirstChild;
                  break a;
                } else {
                  deleteRemainingChildren(returnFiber, isUnkeyedTopLevelFragment);
                  break;
                }
              } else deleteChild(returnFiber, isUnkeyedTopLevelFragment);
              isUnkeyedTopLevelFragment = isUnkeyedTopLevelFragment.sibling;
            }

            newChild.type === REACT_FRAGMENT_TYPE ? (currentFirstChild = createFiberFromFragment(newChild.props.children, returnFiber.mode, expirationTime, newChild.key), currentFirstChild.return = returnFiber, returnFiber = currentFirstChild) : (expirationTime = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, expirationTime), expirationTime.ref = coerceRef(returnFiber, currentFirstChild, newChild), expirationTime.return = returnFiber, returnFiber = expirationTime);
          }

          return placeSingleChild(returnFiber);

        case REACT_PORTAL_TYPE:
          a: {
            for (isUnkeyedTopLevelFragment = newChild.key; null !== currentFirstChild;) {
              if (currentFirstChild.key === isUnkeyedTopLevelFragment) {
                if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                  deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                  currentFirstChild = useFiber(currentFirstChild, newChild.children || [], expirationTime);
                  currentFirstChild.return = returnFiber;
                  returnFiber = currentFirstChild;
                  break a;
                } else {
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  break;
                }
              } else deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }

            currentFirstChild = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);
            currentFirstChild.return = returnFiber;
            returnFiber = currentFirstChild;
          }

          return placeSingleChild(returnFiber);
      }
      if ("string" === typeof newChild || "number" === typeof newChild) return newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), currentFirstChild = useFiber(currentFirstChild, newChild, expirationTime), currentFirstChild.return = returnFiber, returnFiber = currentFirstChild) : (deleteRemainingChildren(returnFiber, currentFirstChild), currentFirstChild = createFiberFromText(newChild, returnFiber.mode, expirationTime), currentFirstChild.return = returnFiber, returnFiber = currentFirstChild), placeSingleChild(returnFiber);
      if (isArray(newChild)) return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
      if (getIteratorFn(newChild)) return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
      isObject && throwOnInvalidObjectType(returnFiber, newChild);
      if ("undefined" === typeof newChild && !isUnkeyedTopLevelFragment) switch (returnFiber.tag) {
        case 1:
        case 0:
          expirationTime = returnFiber.type, invariant(!1, "%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.", expirationTime.displayName || expirationTime.name || "Component");
      }
      return deleteRemainingChildren(returnFiber, currentFirstChild);
    };
  }

  var reconcileChildFibers = ChildReconciler(!0),
      mountChildFibers = ChildReconciler(!1),
      hydrationParentFiber = null,
      nextHydratableInstance = null,
      isHydrating = !1;

  function tryHydrate(fiber, nextInstance) {
    switch (fiber.tag) {
      case 5:
        return nextInstance = shim$1(nextInstance, fiber.type, fiber.pendingProps), null !== nextInstance ? (fiber.stateNode = nextInstance, !0) : !1;

      case 6:
        return nextInstance = shim$1(nextInstance, fiber.pendingProps), null !== nextInstance ? (fiber.stateNode = nextInstance, !0) : !1;

      default:
        return !1;
    }
  }

  function tryToClaimNextHydratableInstance(fiber$jscomp$0) {
    if (isHydrating) {
      var nextInstance = nextHydratableInstance;

      if (nextInstance) {
        var firstAttemptedInstance = nextInstance;

        if (!tryHydrate(fiber$jscomp$0, nextInstance)) {
          nextInstance = shim$1(firstAttemptedInstance);

          if (!nextInstance || !tryHydrate(fiber$jscomp$0, nextInstance)) {
            fiber$jscomp$0.effectTag |= 2;
            isHydrating = !1;
            hydrationParentFiber = fiber$jscomp$0;
            return;
          }

          var returnFiber = hydrationParentFiber,
              fiber = createFiber(5, null, null, 0);
          fiber.elementType = "DELETED";
          fiber.type = "DELETED";
          fiber.stateNode = firstAttemptedInstance;
          fiber.return = returnFiber;
          fiber.effectTag = 8;
          null !== returnFiber.lastEffect ? (returnFiber.lastEffect.nextEffect = fiber, returnFiber.lastEffect = fiber) : returnFiber.firstEffect = returnFiber.lastEffect = fiber;
        }

        hydrationParentFiber = fiber$jscomp$0;
        nextHydratableInstance = shim$1(nextInstance);
      } else fiber$jscomp$0.effectTag |= 2, isHydrating = !1, hydrationParentFiber = fiber$jscomp$0;
    }
  }

  var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;

  function reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime) {
    workInProgress.child = null === current$$1 ? mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime) : reconcileChildFibers(workInProgress, current$$1.child, nextChildren, renderExpirationTime);
  }

  function updateForwardRef(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
    Component = Component.render;
    var ref = workInProgress.ref;
    prepareToReadContext(workInProgress, renderExpirationTime);
    nextProps = Component(nextProps, ref);
    workInProgress.effectTag |= 1;
    reconcileChildren(current$$1, workInProgress, nextProps, renderExpirationTime);
    return workInProgress.child;
  }

  function updateMemoComponent(current$$1, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {
    if (null === current$$1) {
      var type = Component.type;
      if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare) return workInProgress.tag = 15, workInProgress.type = type, updateSimpleMemoComponent(current$$1, workInProgress, type, nextProps, updateExpirationTime, renderExpirationTime);
      current$$1 = createFiberFromTypeAndProps(Component.type, null, nextProps, null, workInProgress.mode, renderExpirationTime);
      current$$1.ref = workInProgress.ref;
      current$$1.return = workInProgress;
      return workInProgress.child = current$$1;
    }

    type = current$$1.child;
    if (updateExpirationTime < renderExpirationTime && (updateExpirationTime = type.memoizedProps, Component = Component.compare, Component = null !== Component ? Component : shallowEqual, Component(updateExpirationTime, nextProps) && current$$1.ref === workInProgress.ref)) return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
    workInProgress.effectTag |= 1;
    current$$1 = createWorkInProgress(type, nextProps, renderExpirationTime);
    current$$1.ref = workInProgress.ref;
    current$$1.return = workInProgress;
    return workInProgress.child = current$$1;
  }

  function updateSimpleMemoComponent(current$$1, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {
    return null !== current$$1 && updateExpirationTime < renderExpirationTime && shallowEqual(current$$1.memoizedProps, nextProps) && current$$1.ref === workInProgress.ref ? bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime) : updateFunctionComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime);
  }

  function markRef(current$$1, workInProgress) {
    var ref = workInProgress.ref;
    if (null === current$$1 && null !== ref || null !== current$$1 && current$$1.ref !== ref) workInProgress.effectTag |= 128;
  }

  function updateFunctionComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
    var unmaskedContext = isContextProvider(Component) ? previousContext : contextStackCursor.current;
    unmaskedContext = getMaskedContext(workInProgress, unmaskedContext);
    prepareToReadContext(workInProgress, renderExpirationTime);
    Component = Component(nextProps, unmaskedContext);
    workInProgress.effectTag |= 1;
    reconcileChildren(current$$1, workInProgress, Component, renderExpirationTime);
    return workInProgress.child;
  }

  function updateClassComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
    if (isContextProvider(Component)) {
      var hasContext = !0;
      pushContextProvider(workInProgress);
    } else hasContext = !1;

    prepareToReadContext(workInProgress, renderExpirationTime);
    if (null === workInProgress.stateNode) null !== current$$1 && (current$$1.alternate = null, workInProgress.alternate = null, workInProgress.effectTag |= 2), constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime), mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime), nextProps = !0;else if (null === current$$1) {
      var instance = workInProgress.stateNode,
          oldProps = workInProgress.memoizedProps;
      instance.props = oldProps;
      var oldContext = instance.context,
          contextType = Component.contextType;
      "object" === typeof contextType && null !== contextType ? contextType = ReactCurrentOwner$4.currentDispatcher.readContext(contextType) : (contextType = isContextProvider(Component) ? previousContext : contextStackCursor.current, contextType = getMaskedContext(workInProgress, contextType));
      var getDerivedStateFromProps = Component.getDerivedStateFromProps,
          hasNewLifecycles = "function" === typeof getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate;
      hasNewLifecycles || "function" !== typeof instance.UNSAFE_componentWillReceiveProps && "function" !== typeof instance.componentWillReceiveProps || (oldProps !== nextProps || oldContext !== contextType) && callComponentWillReceiveProps(workInProgress, instance, nextProps, contextType);
      hasForceUpdate = !1;
      var oldState = workInProgress.memoizedState;
      oldContext = instance.state = oldState;
      var updateQueue = workInProgress.updateQueue;
      null !== updateQueue && (processUpdateQueue(workInProgress, updateQueue, nextProps, instance, renderExpirationTime), oldContext = workInProgress.memoizedState);
      oldProps !== nextProps || oldState !== oldContext || didPerformWorkStackCursor.current || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, nextProps), oldContext = workInProgress.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, oldProps, nextProps, oldState, oldContext, contextType)) ? (hasNewLifecycles || "function" !== typeof instance.UNSAFE_componentWillMount && "function" !== typeof instance.componentWillMount || ("function" === typeof instance.componentWillMount && instance.componentWillMount(), "function" === typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount()), "function" === typeof instance.componentDidMount && (workInProgress.effectTag |= 4)) : ("function" === typeof instance.componentDidMount && (workInProgress.effectTag |= 4), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), instance.props = nextProps, instance.state = oldContext, instance.context = contextType, nextProps = oldProps) : ("function" === typeof instance.componentDidMount && (workInProgress.effectTag |= 4), nextProps = !1);
    } else instance = workInProgress.stateNode, oldProps = workInProgress.memoizedProps, instance.props = workInProgress.type === workInProgress.elementType ? oldProps : resolveDefaultProps(workInProgress.type, oldProps), oldContext = instance.context, contextType = Component.contextType, "object" === typeof contextType && null !== contextType ? contextType = ReactCurrentOwner$4.currentDispatcher.readContext(contextType) : (contextType = isContextProvider(Component) ? previousContext : contextStackCursor.current, contextType = getMaskedContext(workInProgress, contextType)), getDerivedStateFromProps = Component.getDerivedStateFromProps, (hasNewLifecycles = "function" === typeof getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate) || "function" !== typeof instance.UNSAFE_componentWillReceiveProps && "function" !== typeof instance.componentWillReceiveProps || (oldProps !== nextProps || oldContext !== contextType) && callComponentWillReceiveProps(workInProgress, instance, nextProps, contextType), hasForceUpdate = !1, oldContext = workInProgress.memoizedState, oldState = instance.state = oldContext, updateQueue = workInProgress.updateQueue, null !== updateQueue && (processUpdateQueue(workInProgress, updateQueue, nextProps, instance, renderExpirationTime), oldState = workInProgress.memoizedState), oldProps !== nextProps || oldContext !== oldState || didPerformWorkStackCursor.current || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, nextProps), oldState = workInProgress.memoizedState), (getDerivedStateFromProps = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, oldProps, nextProps, oldContext, oldState, contextType)) ? (hasNewLifecycles || "function" !== typeof instance.UNSAFE_componentWillUpdate && "function" !== typeof instance.componentWillUpdate || ("function" === typeof instance.componentWillUpdate && instance.componentWillUpdate(nextProps, oldState, contextType), "function" === typeof instance.UNSAFE_componentWillUpdate && instance.UNSAFE_componentWillUpdate(nextProps, oldState, contextType)), "function" === typeof instance.componentDidUpdate && (workInProgress.effectTag |= 4), "function" === typeof instance.getSnapshotBeforeUpdate && (workInProgress.effectTag |= 256)) : ("function" !== typeof instance.componentDidUpdate || oldProps === current$$1.memoizedProps && oldContext === current$$1.memoizedState || (workInProgress.effectTag |= 4), "function" !== typeof instance.getSnapshotBeforeUpdate || oldProps === current$$1.memoizedProps && oldContext === current$$1.memoizedState || (workInProgress.effectTag |= 256), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldState), instance.props = nextProps, instance.state = oldState, instance.context = contextType, nextProps = getDerivedStateFromProps) : ("function" !== typeof instance.componentDidUpdate || oldProps === current$$1.memoizedProps && oldContext === current$$1.memoizedState || (workInProgress.effectTag |= 4), "function" !== typeof instance.getSnapshotBeforeUpdate || oldProps === current$$1.memoizedProps && oldContext === current$$1.memoizedState || (workInProgress.effectTag |= 256), nextProps = !1);
    return finishClassComponent(current$$1, workInProgress, Component, nextProps, hasContext, renderExpirationTime);
  }

  function finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime) {
    markRef(current$$1, workInProgress);
    var didCaptureError = 0 !== (workInProgress.effectTag & 64);
    if (!shouldUpdate && !didCaptureError) return hasContext && invalidateContextProvider(workInProgress, Component, !1), bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
    shouldUpdate = workInProgress.stateNode;
    ReactCurrentOwner$3.current = workInProgress;
    var nextChildren = didCaptureError && "function" !== typeof Component.getDerivedStateFromError ? null : shouldUpdate.render();
    workInProgress.effectTag |= 1;
    null !== current$$1 && didCaptureError ? (workInProgress.child = reconcileChildFibers(workInProgress, current$$1.child, null, renderExpirationTime), workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime)) : reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
    workInProgress.memoizedState = shouldUpdate.state;
    hasContext && invalidateContextProvider(workInProgress, Component, !0);
    return workInProgress.child;
  }

  function pushHostRootContext(workInProgress) {
    var root = workInProgress.stateNode;
    root.pendingContext ? pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context) : root.context && pushTopLevelContextObject(workInProgress, root.context, !1);
    pushHostContainer(workInProgress, root.containerInfo);
  }

  function updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime) {
    var mode = workInProgress.mode,
        nextProps = workInProgress.pendingProps,
        nextState = workInProgress.memoizedState;

    if (0 === (workInProgress.effectTag & 64)) {
      nextState = null;
      var nextDidTimeout = !1;
    } else nextState = {
      timedOutAt: null !== nextState ? nextState.timedOutAt : 0
    }, nextDidTimeout = !0, workInProgress.effectTag &= -65;

    null === current$$1 ? nextDidTimeout ? (nextDidTimeout = nextProps.fallback, nextProps = createFiberFromFragment(null, mode, 0, null), 0 === (workInProgress.mode & 1) && (nextProps.child = null !== workInProgress.memoizedState ? workInProgress.child.child : workInProgress.child), mode = createFiberFromFragment(nextDidTimeout, mode, renderExpirationTime, null), nextProps.sibling = mode, renderExpirationTime = nextProps, renderExpirationTime.return = mode.return = workInProgress) : renderExpirationTime = mode = mountChildFibers(workInProgress, null, nextProps.children, renderExpirationTime) : null !== current$$1.memoizedState ? (mode = current$$1.child, current$$1 = mode.sibling, nextDidTimeout ? (renderExpirationTime = nextProps.fallback, nextProps = createWorkInProgress(mode, mode.pendingProps, 0), nextProps.effectTag |= 2, 0 === (workInProgress.mode & 1) && (nextDidTimeout = null !== workInProgress.memoizedState ? workInProgress.child.child : workInProgress.child, nextDidTimeout !== mode.child && (nextProps.child = nextDidTimeout)), mode = nextProps.sibling = createWorkInProgress(current$$1, renderExpirationTime, current$$1.expirationTime), mode.effectTag |= 2, renderExpirationTime = nextProps, nextProps.childExpirationTime = 0, renderExpirationTime.return = mode.return = workInProgress) : renderExpirationTime = mode = reconcileChildFibers(workInProgress, mode.child, nextProps.children, renderExpirationTime)) : (current$$1 = current$$1.child, nextDidTimeout ? (nextDidTimeout = nextProps.fallback, nextProps = createFiberFromFragment(null, mode, 0, null), nextProps.effectTag |= 2, nextProps.child = current$$1, current$$1.return = nextProps, 0 === (workInProgress.mode & 1) && (nextProps.child = null !== workInProgress.memoizedState ? workInProgress.child.child : workInProgress.child), mode = nextProps.sibling = createFiberFromFragment(nextDidTimeout, mode, renderExpirationTime, null), mode.effectTag |= 2, renderExpirationTime = nextProps, nextProps.childExpirationTime = 0, renderExpirationTime.return = mode.return = workInProgress) : mode = renderExpirationTime = reconcileChildFibers(workInProgress, current$$1, nextProps.children, renderExpirationTime));
    workInProgress.memoizedState = nextState;
    workInProgress.child = renderExpirationTime;
    return mode;
  }

  function bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime) {
    null !== current$$1 && (workInProgress.firstContextDependency = current$$1.firstContextDependency);
    if (workInProgress.childExpirationTime < renderExpirationTime) return null;
    invariant(null === current$$1 || workInProgress.child === current$$1.child, "Resuming work not yet implemented.");

    if (null !== workInProgress.child) {
      current$$1 = workInProgress.child;
      renderExpirationTime = createWorkInProgress(current$$1, current$$1.pendingProps, current$$1.expirationTime);
      workInProgress.child = renderExpirationTime;

      for (renderExpirationTime.return = workInProgress; null !== current$$1.sibling;) {
        current$$1 = current$$1.sibling, renderExpirationTime = renderExpirationTime.sibling = createWorkInProgress(current$$1, current$$1.pendingProps, current$$1.expirationTime), renderExpirationTime.return = workInProgress;
      }

      renderExpirationTime.sibling = null;
    }

    return workInProgress.child;
  }

  function beginWork(current$$1, workInProgress, renderExpirationTime) {
    var updateExpirationTime = workInProgress.expirationTime;

    if (null !== current$$1 && current$$1.memoizedProps === workInProgress.pendingProps && !didPerformWorkStackCursor.current && updateExpirationTime < renderExpirationTime) {
      switch (workInProgress.tag) {
        case 3:
          pushHostRootContext(workInProgress);
          break;

        case 5:
          pushHostContext(workInProgress);
          break;

        case 1:
          isContextProvider(workInProgress.type) && pushContextProvider(workInProgress);
          break;

        case 4:
          pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
          break;

        case 10:
          pushProvider(workInProgress, workInProgress.memoizedProps.value);
          break;

        case 13:
          if (null !== workInProgress.memoizedState) {
            updateExpirationTime = workInProgress.child.childExpirationTime;
            if (0 !== updateExpirationTime && updateExpirationTime >= renderExpirationTime) return updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime);
            workInProgress = bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
            return null !== workInProgress ? workInProgress.sibling : null;
          }

      }

      return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
    }

    workInProgress.expirationTime = 0;

    switch (workInProgress.tag) {
      case 2:
        updateExpirationTime = workInProgress.elementType;
        null !== current$$1 && (current$$1.alternate = null, workInProgress.alternate = null, workInProgress.effectTag |= 2);
        current$$1 = workInProgress.pendingProps;
        var context = getMaskedContext(workInProgress, contextStackCursor.current);
        prepareToReadContext(workInProgress, renderExpirationTime);
        context = updateExpirationTime(current$$1, context);
        workInProgress.effectTag |= 1;

        if ("object" === typeof context && null !== context && "function" === typeof context.render && void 0 === context.$$typeof) {
          workInProgress.tag = 1;

          if (isContextProvider(updateExpirationTime)) {
            var hasContext = !0;
            pushContextProvider(workInProgress);
          } else hasContext = !1;

          workInProgress.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
          var getDerivedStateFromProps = updateExpirationTime.getDerivedStateFromProps;
          "function" === typeof getDerivedStateFromProps && applyDerivedStateFromProps(workInProgress, updateExpirationTime, getDerivedStateFromProps, current$$1);
          context.updater = classComponentUpdater;
          workInProgress.stateNode = context;
          context._reactInternalFiber = workInProgress;
          mountClassInstance(workInProgress, updateExpirationTime, current$$1, renderExpirationTime);
          workInProgress = finishClassComponent(null, workInProgress, updateExpirationTime, !0, hasContext, renderExpirationTime);
        } else workInProgress.tag = 0, reconcileChildren(null, workInProgress, context, renderExpirationTime), workInProgress = workInProgress.child;

        return workInProgress;

      case 16:
        context = workInProgress.elementType;
        null !== current$$1 && (current$$1.alternate = null, workInProgress.alternate = null, workInProgress.effectTag |= 2);
        hasContext = workInProgress.pendingProps;
        current$$1 = readLazyComponentType(context);
        workInProgress.type = current$$1;
        context = workInProgress.tag = resolveLazyComponentTag(current$$1);
        hasContext = resolveDefaultProps(current$$1, hasContext);
        getDerivedStateFromProps = void 0;

        switch (context) {
          case 0:
            getDerivedStateFromProps = updateFunctionComponent(null, workInProgress, current$$1, hasContext, renderExpirationTime);
            break;

          case 1:
            getDerivedStateFromProps = updateClassComponent(null, workInProgress, current$$1, hasContext, renderExpirationTime);
            break;

          case 11:
            getDerivedStateFromProps = updateForwardRef(null, workInProgress, current$$1, hasContext, renderExpirationTime);
            break;

          case 14:
            getDerivedStateFromProps = updateMemoComponent(null, workInProgress, current$$1, resolveDefaultProps(current$$1.type, hasContext), updateExpirationTime, renderExpirationTime);
            break;

          default:
            invariant(!1, "Element type is invalid. Received a promise that resolves to: %s. Promise elements must resolve to a class or function.", current$$1);
        }

        return getDerivedStateFromProps;

      case 0:
        return updateExpirationTime = workInProgress.type, context = workInProgress.pendingProps, context = workInProgress.elementType === updateExpirationTime ? context : resolveDefaultProps(updateExpirationTime, context), updateFunctionComponent(current$$1, workInProgress, updateExpirationTime, context, renderExpirationTime);

      case 1:
        return updateExpirationTime = workInProgress.type, context = workInProgress.pendingProps, context = workInProgress.elementType === updateExpirationTime ? context : resolveDefaultProps(updateExpirationTime, context), updateClassComponent(current$$1, workInProgress, updateExpirationTime, context, renderExpirationTime);

      case 3:
        return pushHostRootContext(workInProgress), updateExpirationTime = workInProgress.updateQueue, invariant(null !== updateExpirationTime, "If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue."), context = workInProgress.memoizedState, context = null !== context ? context.element : null, processUpdateQueue(workInProgress, updateExpirationTime, workInProgress.pendingProps, null, renderExpirationTime), updateExpirationTime = workInProgress.memoizedState.element, updateExpirationTime === context ? workInProgress = bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime) : (reconcileChildren(current$$1, workInProgress, updateExpirationTime, renderExpirationTime), workInProgress = workInProgress.child), workInProgress;

      case 5:
        return pushHostContext(workInProgress), null === current$$1 && tryToClaimNextHydratableInstance(workInProgress), updateExpirationTime = workInProgress.pendingProps.children, markRef(current$$1, workInProgress), reconcileChildren(current$$1, workInProgress, updateExpirationTime, renderExpirationTime), workInProgress = workInProgress.child, workInProgress;

      case 6:
        return null === current$$1 && tryToClaimNextHydratableInstance(workInProgress), null;

      case 13:
        return updateSuspenseComponent(current$$1, workInProgress, renderExpirationTime);

      case 4:
        return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), updateExpirationTime = workInProgress.pendingProps, null === current$$1 ? workInProgress.child = reconcileChildFibers(workInProgress, null, updateExpirationTime, renderExpirationTime) : reconcileChildren(current$$1, workInProgress, updateExpirationTime, renderExpirationTime), workInProgress.child;

      case 11:
        return updateExpirationTime = workInProgress.type, context = workInProgress.pendingProps, context = workInProgress.elementType === updateExpirationTime ? context : resolveDefaultProps(updateExpirationTime, context), updateForwardRef(current$$1, workInProgress, updateExpirationTime, context, renderExpirationTime);

      case 7:
        return reconcileChildren(current$$1, workInProgress, workInProgress.pendingProps, renderExpirationTime), workInProgress.child;

      case 8:
        return reconcileChildren(current$$1, workInProgress, workInProgress.pendingProps.children, renderExpirationTime), workInProgress.child;

      case 12:
        return reconcileChildren(current$$1, workInProgress, workInProgress.pendingProps.children, renderExpirationTime), workInProgress.child;

      case 10:
        a: {
          updateExpirationTime = workInProgress.type._context;
          context = workInProgress.pendingProps;
          getDerivedStateFromProps = workInProgress.memoizedProps;
          hasContext = context.value;
          pushProvider(workInProgress, hasContext);

          if (null !== getDerivedStateFromProps) {
            var oldValue = getDerivedStateFromProps.value;
            hasContext = oldValue === hasContext && (0 !== oldValue || 1 / oldValue === 1 / hasContext) || oldValue !== oldValue && hasContext !== hasContext ? 0 : ("function" === typeof updateExpirationTime._calculateChangedBits ? updateExpirationTime._calculateChangedBits(oldValue, hasContext) : 1073741823) | 0;

            if (0 === hasContext) {
              if (getDerivedStateFromProps.children === context.children && !didPerformWorkStackCursor.current) {
                workInProgress = bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
                break a;
              }
            } else for (getDerivedStateFromProps = workInProgress.child, null !== getDerivedStateFromProps && (getDerivedStateFromProps.return = workInProgress); null !== getDerivedStateFromProps;) {
              oldValue = getDerivedStateFromProps.firstContextDependency;

              if (null !== oldValue) {
                do {
                  if (oldValue.context === updateExpirationTime && 0 !== (oldValue.observedBits & hasContext)) {
                    if (1 === getDerivedStateFromProps.tag) {
                      var nextFiber = createUpdate(renderExpirationTime);
                      nextFiber.tag = 2;
                      enqueueUpdate(getDerivedStateFromProps, nextFiber);
                    }

                    getDerivedStateFromProps.expirationTime < renderExpirationTime && (getDerivedStateFromProps.expirationTime = renderExpirationTime);
                    nextFiber = getDerivedStateFromProps.alternate;
                    null !== nextFiber && nextFiber.expirationTime < renderExpirationTime && (nextFiber.expirationTime = renderExpirationTime);

                    for (var node = getDerivedStateFromProps.return; null !== node;) {
                      nextFiber = node.alternate;
                      if (node.childExpirationTime < renderExpirationTime) node.childExpirationTime = renderExpirationTime, null !== nextFiber && nextFiber.childExpirationTime < renderExpirationTime && (nextFiber.childExpirationTime = renderExpirationTime);else if (null !== nextFiber && nextFiber.childExpirationTime < renderExpirationTime) nextFiber.childExpirationTime = renderExpirationTime;else break;
                      node = node.return;
                    }
                  }

                  nextFiber = getDerivedStateFromProps.child;
                  oldValue = oldValue.next;
                } while (null !== oldValue);
              } else nextFiber = 10 === getDerivedStateFromProps.tag ? getDerivedStateFromProps.type === workInProgress.type ? null : getDerivedStateFromProps.child : getDerivedStateFromProps.child;

              if (null !== nextFiber) nextFiber.return = getDerivedStateFromProps;else for (nextFiber = getDerivedStateFromProps; null !== nextFiber;) {
                if (nextFiber === workInProgress) {
                  nextFiber = null;
                  break;
                }

                getDerivedStateFromProps = nextFiber.sibling;

                if (null !== getDerivedStateFromProps) {
                  getDerivedStateFromProps.return = nextFiber.return;
                  nextFiber = getDerivedStateFromProps;
                  break;
                }

                nextFiber = nextFiber.return;
              }
              getDerivedStateFromProps = nextFiber;
            }
          }

          reconcileChildren(current$$1, workInProgress, context.children, renderExpirationTime);
          workInProgress = workInProgress.child;
        }

        return workInProgress;

      case 9:
        return context = workInProgress.type, hasContext = workInProgress.pendingProps, updateExpirationTime = hasContext.children, prepareToReadContext(workInProgress, renderExpirationTime), context = readContext(context, hasContext.unstable_observedBits), updateExpirationTime = updateExpirationTime(context), workInProgress.effectTag |= 1, reconcileChildren(current$$1, workInProgress, updateExpirationTime, renderExpirationTime), workInProgress.child;

      case 14:
        return context = workInProgress.type, hasContext = resolveDefaultProps(context.type, workInProgress.pendingProps), updateMemoComponent(current$$1, workInProgress, context, hasContext, updateExpirationTime, renderExpirationTime);

      case 15:
        return updateSimpleMemoComponent(current$$1, workInProgress, workInProgress.type, workInProgress.pendingProps, updateExpirationTime, renderExpirationTime);

      case 17:
        return updateExpirationTime = workInProgress.type, context = workInProgress.pendingProps, context = workInProgress.elementType === updateExpirationTime ? context : resolveDefaultProps(updateExpirationTime, context), null !== current$$1 && (current$$1.alternate = null, workInProgress.alternate = null, workInProgress.effectTag |= 2), workInProgress.tag = 1, isContextProvider(updateExpirationTime) ? (current$$1 = !0, pushContextProvider(workInProgress)) : current$$1 = !1, prepareToReadContext(workInProgress, renderExpirationTime), constructClassInstance(workInProgress, updateExpirationTime, context, renderExpirationTime), mountClassInstance(workInProgress, updateExpirationTime, context, renderExpirationTime), finishClassComponent(null, workInProgress, updateExpirationTime, !0, current$$1, renderExpirationTime);

      default:
        invariant(!1, "Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.");
    }
  }

  var _appendAllChildren = void 0,
      updateHostContainer = void 0,
      updateHostComponent$1 = void 0,
      updateHostText$1 = void 0;

  _appendAllChildren = function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {
    for (var node = workInProgress.child; null !== node;) {
      a: if (5 === node.tag) {
        var instance = node.stateNode;

        if (needsVisibilityToggle) {
          var props = node.memoizedProps,
              type = node.type;
          instance = isHidden ? cloneHiddenInstance(instance, type, props, node) : cloneUnhiddenInstance(instance, type, props, node);
          node.stateNode = instance;
        }

        FabricUIManager.appendChild(parent.node, instance.node);
      } else if (6 === node.tag) {
        instance = node.stateNode;

        if (needsVisibilityToggle) {
          instance = node.memoizedProps;
          props = requiredContext(rootInstanceStackCursor.current);
          type = requiredContext(contextStackCursor$1.current);
          if (isHidden) throw Error("Not yet implemented.");
          instance = createTextInstance(instance, props, type, workInProgress);
          node.stateNode = instance;
        }

        FabricUIManager.appendChild(parent.node, instance.node);
      } else if (4 !== node.tag) {
        if (13 === node.tag && (props = node.alternate, null !== props && (instance = null !== node.memoizedState, null !== props.memoizedState !== instance))) {
          props = instance ? node.child : node;
          null !== props && _appendAllChildren(parent, props, !0, instance);
          break a;
        }

        if (null !== node.child) {
          node.child.return = node;
          node = node.child;
          continue;
        }
      }

      if (node === workInProgress) break;

      for (; null === node.sibling;) {
        if (null === node.return || node.return === workInProgress) return;
        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  };

  function appendAllChildrenToContainer(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {
    for (var node = workInProgress.child; null !== node;) {
      a: if (5 === node.tag) {
        var instance = node.stateNode;

        if (needsVisibilityToggle) {
          var props = node.memoizedProps,
              type = node.type;
          instance = isHidden ? cloneHiddenInstance(instance, type, props, node) : cloneUnhiddenInstance(instance, type, props, node);
          node.stateNode = instance;
        }

        FabricUIManager.appendChildToSet(containerChildSet, instance.node);
      } else if (6 === node.tag) {
        instance = node.stateNode;

        if (needsVisibilityToggle) {
          instance = node.memoizedProps;
          props = requiredContext(rootInstanceStackCursor.current);
          type = requiredContext(contextStackCursor$1.current);
          if (isHidden) throw Error("Not yet implemented.");
          instance = createTextInstance(instance, props, type, workInProgress);
          node.stateNode = instance;
        }

        FabricUIManager.appendChildToSet(containerChildSet, instance.node);
      } else if (4 !== node.tag) {
        if (13 === node.tag && (props = node.alternate, null !== props && (instance = null !== node.memoizedState, null !== props.memoizedState !== instance))) {
          props = instance ? node.child : node;
          null !== props && appendAllChildrenToContainer(containerChildSet, props, !0, instance);
          break a;
        }

        if (null !== node.child) {
          node.child.return = node;
          node = node.child;
          continue;
        }
      }

      if (node === workInProgress) break;

      for (; null === node.sibling;) {
        if (null === node.return || node.return === workInProgress) return;
        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  }

  updateHostContainer = function updateHostContainer(workInProgress) {
    var portalOrRoot = workInProgress.stateNode;

    if (null !== workInProgress.firstEffect) {
      var container = portalOrRoot.containerInfo,
          newChildSet = FabricUIManager.createChildSet(container);
      appendAllChildrenToContainer(newChildSet, workInProgress, !1, !1);
      portalOrRoot.pendingChildren = newChildSet;
      workInProgress.effectTag |= 4;
      FabricUIManager.completeRoot(container, newChildSet);
    }
  };

  updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps) {
    type = current.stateNode;
    var oldProps = current.memoizedProps;
    if ((current = null === workInProgress.firstEffect) && oldProps === newProps) workInProgress.stateNode = type;else {
      var recyclableInstance = workInProgress.stateNode;
      requiredContext(contextStackCursor$1.current);
      var updatePayload = null;
      oldProps !== newProps && (oldProps = diffProperties(null, oldProps, newProps, recyclableInstance.canonical.viewConfig.validAttributes), recyclableInstance.canonical.currentProps = newProps, updatePayload = oldProps);
      current && null === updatePayload ? workInProgress.stateNode = type : (newProps = updatePayload, recyclableInstance = type.node, type = {
        node: current ? null !== newProps ? FabricUIManager.cloneNodeWithNewProps(recyclableInstance, newProps) : FabricUIManager.cloneNode(recyclableInstance) : null !== newProps ? FabricUIManager.cloneNodeWithNewChildrenAndProps(recyclableInstance, newProps) : FabricUIManager.cloneNodeWithNewChildren(recyclableInstance),
        canonical: type.canonical
      }, workInProgress.stateNode = type, current ? workInProgress.effectTag |= 4 : _appendAllChildren(type, workInProgress, !1, !1));
    }
  };

  updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {
    oldText !== newText && (current = requiredContext(rootInstanceStackCursor.current), oldText = requiredContext(contextStackCursor$1.current), workInProgress.stateNode = createTextInstance(newText, current, oldText, workInProgress), workInProgress.effectTag |= 4);
  };

  function logCapturedError(capturedError) {
    var componentStack = capturedError.componentStack,
        error = capturedError.error;

    if (error instanceof Error) {
      capturedError = error.message;
      var name = error.name;

      try {
        error.message = (capturedError ? name + ": " + capturedError : name) + "\n\nThis error is located at:" + componentStack;
      } catch (e) {}
    } else error = "string" === typeof error ? Error(error + "\n\nThis error is located at:" + componentStack) : Error("Unspecified error at:" + componentStack);

    ExceptionsManager.handleException(error, !1);
  }

  function logError(boundary, errorInfo) {
    var source = errorInfo.source,
        stack = errorInfo.stack;
    null === stack && null !== source && (stack = getStackByFiberInDevAndProd(source));
    errorInfo = {
      componentName: null !== source ? getComponentName(source.type) : null,
      componentStack: null !== stack ? stack : "",
      error: errorInfo.value,
      errorBoundary: null,
      errorBoundaryName: null,
      errorBoundaryFound: !1,
      willRetry: !1
    };
    null !== boundary && 1 === boundary.tag && (errorInfo.errorBoundary = boundary.stateNode, errorInfo.errorBoundaryName = getComponentName(boundary.type), errorInfo.errorBoundaryFound = !0, errorInfo.willRetry = !0);

    try {
      logCapturedError(errorInfo);
    } catch (e) {
      setTimeout(function () {
        throw e;
      });
    }
  }

  function safelyDetachRef(current$$1) {
    var ref = current$$1.ref;
    if (null !== ref) if ("function" === typeof ref) try {
      ref(null);
    } catch (refError) {
      captureCommitPhaseError(current$$1, refError);
    } else ref.current = null;
  }

  function commitWork(current$$1, finishedWork) {
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        return;
    }

    switch (finishedWork.tag) {
      case 1:
        break;

      case 5:
        break;

      case 6:
        break;

      case 3:
      case 4:
        break;

      default:
        invariant(!1, "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
  }

  function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
    expirationTime = createUpdate(expirationTime);
    expirationTime.tag = 3;
    expirationTime.payload = {
      element: null
    };
    var error = errorInfo.value;

    expirationTime.callback = function () {
      onUncaughtError(error);
      logError(fiber, errorInfo);
    };

    return expirationTime;
  }

  function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
    expirationTime = createUpdate(expirationTime);
    expirationTime.tag = 3;
    var getDerivedStateFromError = fiber.type.getDerivedStateFromError;

    if ("function" === typeof getDerivedStateFromError) {
      var error$jscomp$0 = errorInfo.value;

      expirationTime.payload = function () {
        return getDerivedStateFromError(error$jscomp$0);
      };
    }

    var inst = fiber.stateNode;
    null !== inst && "function" === typeof inst.componentDidCatch && (expirationTime.callback = function () {
      "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
      var error = errorInfo.value,
          stack = errorInfo.stack;
      logError(fiber, errorInfo);
      this.componentDidCatch(error, {
        componentStack: null !== stack ? stack : ""
      });
    });
    return expirationTime;
  }

  function unwindWork(workInProgress) {
    switch (workInProgress.tag) {
      case 1:
        isContextProvider(workInProgress.type) && popContext(workInProgress);
        var effectTag = workInProgress.effectTag;
        return effectTag & 2048 ? (workInProgress.effectTag = effectTag & -2049 | 64, workInProgress) : null;

      case 3:
        return popHostContainer(workInProgress), popTopLevelContextObject(workInProgress), effectTag = workInProgress.effectTag, invariant(0 === (effectTag & 64), "The root failed to unmount after an error. This is likely a bug in React. Please file an issue."), workInProgress.effectTag = effectTag & -2049 | 64, workInProgress;

      case 5:
        return popHostContext(workInProgress), null;

      case 13:
        return effectTag = workInProgress.effectTag, effectTag & 2048 ? (workInProgress.effectTag = effectTag & -2049 | 64, workInProgress) : null;

      case 4:
        return popHostContainer(workInProgress), null;

      case 10:
        return popProvider(workInProgress), null;

      default:
        return null;
    }
  }

  var DispatcherWithoutHooks = {
    readContext: readContext
  },
      ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
      isWorking = !1,
      nextUnitOfWork = null,
      nextRoot = null,
      nextRenderExpirationTime = 0,
      nextLatestAbsoluteTimeoutMs = -1,
      nextRenderDidError = !1,
      nextEffect = null,
      isCommitting$1 = !1,
      passiveEffectCallbackHandle = null,
      passiveEffectCallback = null,
      legacyErrorBoundariesThatAlreadyFailed = null;

  function resetStack() {
    if (null !== nextUnitOfWork) for (var interruptedWork = nextUnitOfWork.return; null !== interruptedWork;) {
      var interruptedWork$jscomp$0 = interruptedWork;

      switch (interruptedWork$jscomp$0.tag) {
        case 1:
          var childContextTypes = interruptedWork$jscomp$0.type.childContextTypes;
          null !== childContextTypes && void 0 !== childContextTypes && popContext(interruptedWork$jscomp$0);
          break;

        case 3:
          popHostContainer(interruptedWork$jscomp$0);
          popTopLevelContextObject(interruptedWork$jscomp$0);
          break;

        case 5:
          popHostContext(interruptedWork$jscomp$0);
          break;

        case 4:
          popHostContainer(interruptedWork$jscomp$0);
          break;

        case 10:
          popProvider(interruptedWork$jscomp$0);
      }

      interruptedWork = interruptedWork.return;
    }
    nextRoot = null;
    nextRenderExpirationTime = 0;
    nextLatestAbsoluteTimeoutMs = -1;
    nextRenderDidError = !1;
    nextUnitOfWork = null;
  }

  function flushPassiveEffects() {
    null !== passiveEffectCallback && (scheduler.unstable_cancelCallback(passiveEffectCallbackHandle), passiveEffectCallback());
  }

  function completeUnitOfWork(workInProgress) {
    for (;;) {
      var current$$1 = workInProgress.alternate,
          returnFiber = workInProgress.return,
          siblingFiber = workInProgress.sibling;

      if (0 === (workInProgress.effectTag & 1024)) {
        nextUnitOfWork = workInProgress;

        a: {
          var current = current$$1;
          current$$1 = workInProgress;
          var renderExpirationTime = nextRenderExpirationTime;
          var instance = current$$1.pendingProps;

          switch (current$$1.tag) {
            case 2:
              break;

            case 16:
              break;

            case 15:
            case 0:
              break;

            case 1:
              isContextProvider(current$$1.type) && popContext(current$$1);
              break;

            case 3:
              popHostContainer(current$$1);
              popTopLevelContextObject(current$$1);
              instance = current$$1.stateNode;
              instance.pendingContext && (instance.context = instance.pendingContext, instance.pendingContext = null);
              if (null === current || null === current.child) current$$1.effectTag &= -3;
              updateHostContainer(current$$1);
              break;

            case 5:
              popHostContext(current$$1);
              renderExpirationTime = requiredContext(rootInstanceStackCursor.current);
              var type = current$$1.type;
              if (null !== current && null != current$$1.stateNode) updateHostComponent$1(current, current$$1, type, instance, renderExpirationTime), current.ref !== current$$1.ref && (current$$1.effectTag |= 128);else if (instance) {
                var currentHostContext = requiredContext(contextStackCursor$1.current),
                    internalInstanceHandle = current$$1;
                current = nextReactTag;
                nextReactTag += 2;
                var viewConfig = ReactNativeViewConfigRegistry.get(type);
                invariant("RCTView" !== type || !currentHostContext.isInAParentText, "Nesting of <View> within <Text> is not currently supported.");
                type = diffProperties(null, emptyObject, instance, viewConfig.validAttributes);
                renderExpirationTime = FabricUIManager.createNode(current, viewConfig.uiViewClassName, renderExpirationTime, type, internalInstanceHandle);
                instance = new ReactFabricHostComponent(current, viewConfig, instance);
                instance = {
                  node: renderExpirationTime,
                  canonical: instance
                };

                _appendAllChildren(instance, current$$1, !1, !1);

                current$$1.stateNode = instance;
                null !== current$$1.ref && (current$$1.effectTag |= 128);
              } else invariant(null !== current$$1.stateNode, "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              break;

            case 6:
              current && null != current$$1.stateNode ? updateHostText$1(current, current$$1, current.memoizedProps, instance) : ("string" !== typeof instance && invariant(null !== current$$1.stateNode, "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."), current = requiredContext(rootInstanceStackCursor.current), renderExpirationTime = requiredContext(contextStackCursor$1.current), current$$1.stateNode = createTextInstance(instance, current, renderExpirationTime, current$$1));
              break;

            case 11:
              break;

            case 13:
              instance = current$$1.memoizedState;

              if (0 !== (current$$1.effectTag & 64)) {
                current$$1.expirationTime = renderExpirationTime;
                nextUnitOfWork = current$$1;
                break a;
              }

              instance = null !== instance;
              viewConfig = null !== current && null !== current.memoizedState;
              null !== current && !instance && viewConfig && (current = current.child.sibling, null !== current && reconcileChildFibers(current$$1, current, null, renderExpirationTime));
              if (instance !== viewConfig || 0 === (current$$1.effectTag & 1) && instance) current$$1.effectTag |= 4;
              break;

            case 7:
              break;

            case 8:
              break;

            case 12:
              break;

            case 4:
              popHostContainer(current$$1);
              updateHostContainer(current$$1);
              break;

            case 10:
              popProvider(current$$1);
              break;

            case 9:
              break;

            case 14:
              break;

            case 17:
              isContextProvider(current$$1.type) && popContext(current$$1);
              break;

            default:
              invariant(!1, "Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.");
          }

          nextUnitOfWork = null;
        }

        current$$1 = workInProgress;

        if (1 === nextRenderExpirationTime || 1 !== current$$1.childExpirationTime) {
          instance = 0;

          for (current = current$$1.child; null !== current;) {
            renderExpirationTime = current.expirationTime, viewConfig = current.childExpirationTime, renderExpirationTime > instance && (instance = renderExpirationTime), viewConfig > instance && (instance = viewConfig), current = current.sibling;
          }

          current$$1.childExpirationTime = instance;
        }

        if (null !== nextUnitOfWork) return nextUnitOfWork;
        null !== returnFiber && 0 === (returnFiber.effectTag & 1024) && (null === returnFiber.firstEffect && (returnFiber.firstEffect = workInProgress.firstEffect), null !== workInProgress.lastEffect && (null !== returnFiber.lastEffect && (returnFiber.lastEffect.nextEffect = workInProgress.firstEffect), returnFiber.lastEffect = workInProgress.lastEffect), 1 < workInProgress.effectTag && (null !== returnFiber.lastEffect ? returnFiber.lastEffect.nextEffect = workInProgress : returnFiber.firstEffect = workInProgress, returnFiber.lastEffect = workInProgress));
      } else {
        workInProgress = unwindWork(workInProgress, nextRenderExpirationTime);
        if (null !== workInProgress) return workInProgress.effectTag &= 1023, workInProgress;
        null !== returnFiber && (returnFiber.firstEffect = returnFiber.lastEffect = null, returnFiber.effectTag |= 1024);
      }

      if (null !== siblingFiber) return siblingFiber;
      if (null !== returnFiber) workInProgress = returnFiber;else break;
    }

    return null;
  }

  function performUnitOfWork(workInProgress) {
    var next = beginWork(workInProgress.alternate, workInProgress, nextRenderExpirationTime);
    workInProgress.memoizedProps = workInProgress.pendingProps;
    null === next && (next = completeUnitOfWork(workInProgress));
    ReactCurrentOwner$2.current = null;
    return next;
  }

  function renderRoot(root$jscomp$0, isYieldy) {
    invariant(!isWorking, "renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.");
    flushPassiveEffects();
    isWorking = !0;
    ReactCurrentOwner$2.currentDispatcher = DispatcherWithoutHooks;
    var expirationTime = root$jscomp$0.nextExpirationTimeToWorkOn;
    if (expirationTime !== nextRenderExpirationTime || root$jscomp$0 !== nextRoot || null === nextUnitOfWork) resetStack(), nextRoot = root$jscomp$0, nextRenderExpirationTime = expirationTime, nextUnitOfWork = createWorkInProgress(nextRoot.current, null, nextRenderExpirationTime), root$jscomp$0.pendingCommitExpirationTime = 0;
    var didFatal = !1;

    do {
      try {
        if (isYieldy) for (; null !== nextUnitOfWork && !shouldYieldToRenderer();) {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        } else for (; null !== nextUnitOfWork;) {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      } catch (thrownValue) {
        if (lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null, null === nextUnitOfWork) didFatal = !0, onUncaughtError(thrownValue);else {
          invariant(null !== nextUnitOfWork, "Failed to replay rendering after an error. This is likely caused by a bug in React. Please file an issue with a reproducing case to help us find it.");
          var sourceFiber = nextUnitOfWork,
              returnFiber = sourceFiber.return;
          if (null === returnFiber) didFatal = !0, onUncaughtError(thrownValue);else {
            a: {
              var root = root$jscomp$0,
                  returnFiber$jscomp$0 = returnFiber,
                  sourceFiber$jscomp$0 = sourceFiber,
                  value = thrownValue;
              returnFiber = nextRenderExpirationTime;
              sourceFiber$jscomp$0.effectTag |= 1024;
              sourceFiber$jscomp$0.firstEffect = sourceFiber$jscomp$0.lastEffect = null;

              if (null !== value && "object" === typeof value && "function" === typeof value.then) {
                var thenable = value;
                value = returnFiber$jscomp$0;
                var earliestTimeoutMs = -1,
                    startTimeMs = -1;

                do {
                  if (13 === value.tag) {
                    var current$$1 = value.alternate;

                    if (null !== current$$1 && (current$$1 = current$$1.memoizedState, null !== current$$1)) {
                      startTimeMs = 10 * (1073741822 - current$$1.timedOutAt);
                      break;
                    }

                    current$$1 = value.pendingProps.maxDuration;
                    if ("number" === typeof current$$1) if (0 >= current$$1) earliestTimeoutMs = 0;else if (-1 === earliestTimeoutMs || current$$1 < earliestTimeoutMs) earliestTimeoutMs = current$$1;
                  }

                  value = value.return;
                } while (null !== value);

                value = returnFiber$jscomp$0;

                do {
                  if (current$$1 = 13 === value.tag) current$$1 = void 0 === value.memoizedProps.fallback ? !1 : null === value.memoizedState;

                  if (current$$1) {
                    returnFiber$jscomp$0 = retrySuspendedRoot.bind(null, root, value, sourceFiber$jscomp$0, 0 === (value.mode & 1) ? 1073741823 : returnFiber);
                    thenable.then(returnFiber$jscomp$0, returnFiber$jscomp$0);

                    if (0 === (value.mode & 1)) {
                      value.effectTag |= 64;
                      reconcileChildren(sourceFiber$jscomp$0.alternate, sourceFiber$jscomp$0, null, returnFiber);
                      sourceFiber$jscomp$0.effectTag &= -1025;
                      sourceFiber$jscomp$0.effectTag &= -933;
                      1 === sourceFiber$jscomp$0.tag && null === sourceFiber$jscomp$0.alternate && (sourceFiber$jscomp$0.tag = 17);
                      sourceFiber$jscomp$0.expirationTime = returnFiber;
                      break a;
                    }

                    -1 === earliestTimeoutMs ? root = 1073741823 : (-1 === startTimeMs && (startTimeMs = 10 * (1073741822 - findEarliestOutstandingPriorityLevel(root, returnFiber)) - 5e3), root = startTimeMs + earliestTimeoutMs);
                    0 <= root && nextLatestAbsoluteTimeoutMs < root && (nextLatestAbsoluteTimeoutMs = root);
                    value.effectTag |= 2048;
                    value.expirationTime = returnFiber;
                    break a;
                  }

                  value = value.return;
                } while (null !== value);

                value = Error((getComponentName(sourceFiber$jscomp$0.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." + getStackByFiberInDevAndProd(sourceFiber$jscomp$0));
              }

              nextRenderDidError = !0;
              value = createCapturedValue(value, sourceFiber$jscomp$0);
              root = returnFiber$jscomp$0;

              do {
                switch (root.tag) {
                  case 3:
                    sourceFiber$jscomp$0 = value;
                    root.effectTag |= 2048;
                    root.expirationTime = returnFiber;
                    returnFiber = createRootErrorUpdate(root, sourceFiber$jscomp$0, returnFiber);
                    enqueueCapturedUpdate(root, returnFiber);
                    break a;

                  case 1:
                    if (sourceFiber$jscomp$0 = value, returnFiber$jscomp$0 = root.type, thenable = root.stateNode, 0 === (root.effectTag & 64) && ("function" === typeof returnFiber$jscomp$0.getDerivedStateFromError || null !== thenable && "function" === typeof thenable.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(thenable)))) {
                      root.effectTag |= 2048;
                      root.expirationTime = returnFiber;
                      returnFiber = createClassErrorUpdate(root, sourceFiber$jscomp$0, returnFiber);
                      enqueueCapturedUpdate(root, returnFiber);
                      break a;
                    }

                }

                root = root.return;
              } while (null !== root);
            }

            nextUnitOfWork = completeUnitOfWork(sourceFiber);
            continue;
          }
        }
      }

      break;
    } while (1);

    isWorking = !1;
    lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = ReactCurrentOwner$2.currentDispatcher = null;
    if (didFatal) nextRoot = null, root$jscomp$0.finishedWork = null;else if (null !== nextUnitOfWork) root$jscomp$0.finishedWork = null;else {
      didFatal = root$jscomp$0.current.alternate;
      invariant(null !== didFatal, "Finished root should have a work-in-progress. This error is likely caused by a bug in React. Please file an issue.");
      nextRoot = null;

      if (nextRenderDidError) {
        sourceFiber = root$jscomp$0.latestPendingTime;
        returnFiber = root$jscomp$0.latestSuspendedTime;
        root = root$jscomp$0.latestPingedTime;

        if (0 !== sourceFiber && sourceFiber < expirationTime || 0 !== returnFiber && returnFiber < expirationTime || 0 !== root && root < expirationTime) {
          markSuspendedPriorityLevel(root$jscomp$0, expirationTime);
          onSuspend(root$jscomp$0, didFatal, expirationTime, root$jscomp$0.expirationTime, -1);
          return;
        }

        if (!root$jscomp$0.didError && isYieldy) {
          root$jscomp$0.didError = !0;
          expirationTime = root$jscomp$0.nextExpirationTimeToWorkOn = expirationTime;
          isYieldy = root$jscomp$0.expirationTime = 1073741823;
          onSuspend(root$jscomp$0, didFatal, expirationTime, isYieldy, -1);
          return;
        }
      }

      isYieldy && -1 !== nextLatestAbsoluteTimeoutMs ? (markSuspendedPriorityLevel(root$jscomp$0, expirationTime), isYieldy = 10 * (1073741822 - findEarliestOutstandingPriorityLevel(root$jscomp$0, expirationTime)), isYieldy < nextLatestAbsoluteTimeoutMs && (nextLatestAbsoluteTimeoutMs = isYieldy), isYieldy = 10 * (1073741822 - requestCurrentTime()), isYieldy = nextLatestAbsoluteTimeoutMs - isYieldy, onSuspend(root$jscomp$0, didFatal, expirationTime, root$jscomp$0.expirationTime, 0 > isYieldy ? 0 : isYieldy)) : (root$jscomp$0.pendingCommitExpirationTime = expirationTime, root$jscomp$0.finishedWork = didFatal);
    }
  }

  function captureCommitPhaseError(sourceFiber, value) {
    for (var fiber = sourceFiber.return; null !== fiber;) {
      switch (fiber.tag) {
        case 1:
          var instance = fiber.stateNode;

          if ("function" === typeof fiber.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
            sourceFiber = createCapturedValue(value, sourceFiber);
            sourceFiber = createClassErrorUpdate(fiber, sourceFiber, 1073741823);
            enqueueUpdate(fiber, sourceFiber);
            scheduleWork(fiber, 1073741823);
            return;
          }

          break;

        case 3:
          sourceFiber = createCapturedValue(value, sourceFiber);
          sourceFiber = createRootErrorUpdate(fiber, sourceFiber, 1073741823);
          enqueueUpdate(fiber, sourceFiber);
          scheduleWork(fiber, 1073741823);
          return;
      }

      fiber = fiber.return;
    }

    3 === sourceFiber.tag && (fiber = createCapturedValue(value, sourceFiber), fiber = createRootErrorUpdate(sourceFiber, fiber, 1073741823), enqueueUpdate(sourceFiber, fiber), scheduleWork(sourceFiber, 1073741823));
  }

  function computeExpirationForFiber(currentTime, fiber) {
    isWorking ? currentTime = isCommitting$1 ? 1073741823 : nextRenderExpirationTime : fiber.mode & 1 ? (currentTime = isBatchingInteractiveUpdates ? 1073741822 - 10 * (((1073741822 - currentTime + 15) / 10 | 0) + 1) : 1073741822 - 25 * (((1073741822 - currentTime + 500) / 25 | 0) + 1), null !== nextRoot && currentTime === nextRenderExpirationTime && --currentTime) : currentTime = 1073741823;
    isBatchingInteractiveUpdates && (0 === lowestPriorityPendingInteractiveExpirationTime || currentTime < lowestPriorityPendingInteractiveExpirationTime) && (lowestPriorityPendingInteractiveExpirationTime = currentTime);
    return currentTime;
  }

  function retrySuspendedRoot(root, boundaryFiber, sourceFiber, suspendedTime) {
    var retryTime = root.earliestSuspendedTime;
    var latestSuspendedTime = root.latestSuspendedTime;

    if (0 !== retryTime && suspendedTime <= retryTime && suspendedTime >= latestSuspendedTime) {
      latestSuspendedTime = retryTime = suspendedTime;
      root.didError = !1;
      var latestPingedTime = root.latestPingedTime;
      if (0 === latestPingedTime || latestPingedTime > latestSuspendedTime) root.latestPingedTime = latestSuspendedTime;
      findNextExpirationTimeToWorkOn(latestSuspendedTime, root);
    } else retryTime = requestCurrentTime(), retryTime = computeExpirationForFiber(retryTime, boundaryFiber), markPendingPriorityLevel(root, retryTime);

    0 !== (boundaryFiber.mode & 1) && root === nextRoot && nextRenderExpirationTime === suspendedTime && (nextRoot = null);
    scheduleWorkToRoot(boundaryFiber, retryTime);
    0 === (boundaryFiber.mode & 1) && (scheduleWorkToRoot(sourceFiber, retryTime), 1 === sourceFiber.tag && null !== sourceFiber.stateNode && (boundaryFiber = createUpdate(retryTime), boundaryFiber.tag = 2, enqueueUpdate(sourceFiber, boundaryFiber)));
    sourceFiber = root.expirationTime;
    0 !== sourceFiber && requestWork(root, sourceFiber);
  }

  function scheduleWorkToRoot(fiber, expirationTime) {
    fiber.expirationTime < expirationTime && (fiber.expirationTime = expirationTime);
    var alternate = fiber.alternate;
    null !== alternate && alternate.expirationTime < expirationTime && (alternate.expirationTime = expirationTime);
    var node = fiber.return,
        root = null;
    if (null === node && 3 === fiber.tag) root = fiber.stateNode;else for (; null !== node;) {
      alternate = node.alternate;
      node.childExpirationTime < expirationTime && (node.childExpirationTime = expirationTime);
      null !== alternate && alternate.childExpirationTime < expirationTime && (alternate.childExpirationTime = expirationTime);

      if (null === node.return && 3 === node.tag) {
        root = node.stateNode;
        break;
      }

      node = node.return;
    }
    return null === root ? null : root;
  }

  function scheduleWork(fiber, expirationTime) {
    fiber = scheduleWorkToRoot(fiber, expirationTime);
    null !== fiber && (!isWorking && 0 !== nextRenderExpirationTime && expirationTime > nextRenderExpirationTime && resetStack(), markPendingPriorityLevel(fiber, expirationTime), isWorking && !isCommitting$1 && nextRoot === fiber || requestWork(fiber, fiber.expirationTime), nestedUpdateCount > NESTED_UPDATE_LIMIT && (nestedUpdateCount = 0, invariant(!1, "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.")));
  }

  var firstScheduledRoot = null,
      lastScheduledRoot = null,
      callbackExpirationTime = 0,
      callbackID = void 0,
      isRendering = !1,
      nextFlushedRoot = null,
      nextFlushedExpirationTime = 0,
      lowestPriorityPendingInteractiveExpirationTime = 0,
      hasUnhandledError = !1,
      unhandledError = null,
      isBatchingUpdates = !1,
      isUnbatchingUpdates = !1,
      isBatchingInteractiveUpdates = !1,
      completedBatches = null,
      originalStartTimeMs = now$1(),
      currentRendererTime = 1073741822 - (originalStartTimeMs / 10 | 0),
      currentSchedulerTime = currentRendererTime,
      NESTED_UPDATE_LIMIT = 50,
      nestedUpdateCount = 0,
      lastCommittedRootDuringThisBatch = null;

  function recomputeCurrentRendererTime() {
    currentRendererTime = 1073741822 - ((now$1() - originalStartTimeMs) / 10 | 0);
  }

  function scheduleCallbackWithExpirationTime(root, expirationTime) {
    if (0 !== callbackExpirationTime) {
      if (expirationTime < callbackExpirationTime) return;
      null !== callbackID && (root = callbackID, scheduledCallback = null, clearTimeout(root));
    }

    callbackExpirationTime = expirationTime;
    now$1();
    scheduledCallback = performAsyncWork;
    callbackID = setTimeout(setTimeoutCallback, 1);
  }

  function onSuspend(root, finishedWork, suspendedExpirationTime, rootExpirationTime, msUntilTimeout) {
    root.expirationTime = rootExpirationTime;
    0 !== msUntilTimeout || shouldYieldToRenderer() ? 0 < msUntilTimeout && (root.timeoutHandle = scheduleTimeout(onTimeout.bind(null, root, finishedWork, suspendedExpirationTime), msUntilTimeout)) : (root.pendingCommitExpirationTime = suspendedExpirationTime, root.finishedWork = finishedWork);
  }

  function onTimeout(root, finishedWork, suspendedExpirationTime) {
    root.pendingCommitExpirationTime = suspendedExpirationTime;
    root.finishedWork = finishedWork;
    recomputeCurrentRendererTime();
    currentSchedulerTime = currentRendererTime;
    invariant(!isRendering, "work.commit(): Cannot commit while already rendering. This likely means you attempted to commit from inside a lifecycle method.");
    nextFlushedRoot = root;
    nextFlushedExpirationTime = suspendedExpirationTime;
    performWorkOnRoot(root, suspendedExpirationTime, !1);
    performWork(1073741823, !1);
  }

  function requestCurrentTime() {
    if (isRendering) return currentSchedulerTime;
    findHighestPriorityRoot();
    if (0 === nextFlushedExpirationTime || 1 === nextFlushedExpirationTime) recomputeCurrentRendererTime(), currentSchedulerTime = currentRendererTime;
    return currentSchedulerTime;
  }

  function requestWork(root, expirationTime) {
    null === root.nextScheduledRoot ? (root.expirationTime = expirationTime, null === lastScheduledRoot ? (firstScheduledRoot = lastScheduledRoot = root, root.nextScheduledRoot = root) : (lastScheduledRoot = lastScheduledRoot.nextScheduledRoot = root, lastScheduledRoot.nextScheduledRoot = firstScheduledRoot)) : expirationTime > root.expirationTime && (root.expirationTime = expirationTime);
    isRendering || (isBatchingUpdates ? isUnbatchingUpdates && (nextFlushedRoot = root, nextFlushedExpirationTime = 1073741823, performWorkOnRoot(root, 1073741823, !1)) : 1073741823 === expirationTime ? performWork(1073741823, !1) : scheduleCallbackWithExpirationTime(root, expirationTime));
  }

  function findHighestPriorityRoot() {
    var highestPriorityWork = 0,
        highestPriorityRoot = null;
    if (null !== lastScheduledRoot) for (var previousScheduledRoot = lastScheduledRoot, root = firstScheduledRoot; null !== root;) {
      var remainingExpirationTime = root.expirationTime;

      if (0 === remainingExpirationTime) {
        invariant(null !== previousScheduledRoot && null !== lastScheduledRoot, "Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.");

        if (root === root.nextScheduledRoot) {
          firstScheduledRoot = lastScheduledRoot = root.nextScheduledRoot = null;
          break;
        } else if (root === firstScheduledRoot) firstScheduledRoot = remainingExpirationTime = root.nextScheduledRoot, lastScheduledRoot.nextScheduledRoot = remainingExpirationTime, root.nextScheduledRoot = null;else if (root === lastScheduledRoot) {
          lastScheduledRoot = previousScheduledRoot;
          lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
          root.nextScheduledRoot = null;
          break;
        } else previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot, root.nextScheduledRoot = null;

        root = previousScheduledRoot.nextScheduledRoot;
      } else {
        remainingExpirationTime > highestPriorityWork && (highestPriorityWork = remainingExpirationTime, highestPriorityRoot = root);
        if (root === lastScheduledRoot) break;
        if (1073741823 === highestPriorityWork) break;
        previousScheduledRoot = root;
        root = root.nextScheduledRoot;
      }
    }
    nextFlushedRoot = highestPriorityRoot;
    nextFlushedExpirationTime = highestPriorityWork;
  }

  var didYield = !1;

  function shouldYieldToRenderer() {
    return didYield ? !0 : frameDeadline <= now$1() ? didYield = !0 : !1;
  }

  function performAsyncWork() {
    try {
      if (!shouldYieldToRenderer() && null !== firstScheduledRoot) {
        recomputeCurrentRendererTime();
        var root = firstScheduledRoot;

        do {
          var expirationTime = root.expirationTime;
          0 !== expirationTime && currentRendererTime <= expirationTime && (root.nextExpirationTimeToWorkOn = currentRendererTime);
          root = root.nextScheduledRoot;
        } while (root !== firstScheduledRoot);
      }

      performWork(0, !0);
    } finally {
      didYield = !1;
    }
  }

  function performWork(minExpirationTime, isYieldy) {
    findHighestPriorityRoot();
    if (isYieldy) for (recomputeCurrentRendererTime(), currentSchedulerTime = currentRendererTime; null !== nextFlushedRoot && 0 !== nextFlushedExpirationTime && minExpirationTime <= nextFlushedExpirationTime && !(didYield && currentRendererTime > nextFlushedExpirationTime);) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, currentRendererTime > nextFlushedExpirationTime), findHighestPriorityRoot(), recomputeCurrentRendererTime(), currentSchedulerTime = currentRendererTime;
    } else for (; null !== nextFlushedRoot && 0 !== nextFlushedExpirationTime && minExpirationTime <= nextFlushedExpirationTime;) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, !1), findHighestPriorityRoot();
    }
    isYieldy && (callbackExpirationTime = 0, callbackID = null);
    0 !== nextFlushedExpirationTime && scheduleCallbackWithExpirationTime(nextFlushedRoot, nextFlushedExpirationTime);
    nestedUpdateCount = 0;
    lastCommittedRootDuringThisBatch = null;
    if (null !== completedBatches) for (minExpirationTime = completedBatches, completedBatches = null, isYieldy = 0; isYieldy < minExpirationTime.length; isYieldy++) {
      var batch = minExpirationTime[isYieldy];

      try {
        batch._onComplete();
      } catch (error) {
        hasUnhandledError || (hasUnhandledError = !0, unhandledError = error);
      }
    }
    if (hasUnhandledError) throw minExpirationTime = unhandledError, unhandledError = null, hasUnhandledError = !1, minExpirationTime;
  }

  function performWorkOnRoot(root, expirationTime, isYieldy) {
    invariant(!isRendering, "performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.");
    isRendering = !0;

    if (isYieldy) {
      var _finishedWork = root.finishedWork;
      null !== _finishedWork ? completeRoot$1(root, _finishedWork, expirationTime) : (root.finishedWork = null, _finishedWork = root.timeoutHandle, -1 !== _finishedWork && (root.timeoutHandle = -1, cancelTimeout(_finishedWork)), renderRoot(root, isYieldy), _finishedWork = root.finishedWork, null !== _finishedWork && (shouldYieldToRenderer() ? root.finishedWork = _finishedWork : completeRoot$1(root, _finishedWork, expirationTime)));
    } else _finishedWork = root.finishedWork, null !== _finishedWork ? completeRoot$1(root, _finishedWork, expirationTime) : (root.finishedWork = null, _finishedWork = root.timeoutHandle, -1 !== _finishedWork && (root.timeoutHandle = -1, cancelTimeout(_finishedWork)), renderRoot(root, isYieldy), _finishedWork = root.finishedWork, null !== _finishedWork && completeRoot$1(root, _finishedWork, expirationTime));

    isRendering = !1;
  }

  function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
    var firstBatch = root.firstBatch;

    if (null !== firstBatch && firstBatch._expirationTime >= expirationTime && (null === completedBatches ? completedBatches = [firstBatch] : completedBatches.push(firstBatch), firstBatch._defer)) {
      root.finishedWork = finishedWork$jscomp$0;
      root.expirationTime = 0;
      return;
    }

    root.finishedWork = null;
    root === lastCommittedRootDuringThisBatch ? nestedUpdateCount++ : (lastCommittedRootDuringThisBatch = root, nestedUpdateCount = 0);
    isCommitting$1 = isWorking = !0;
    invariant(root.current !== finishedWork$jscomp$0, "Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.");
    expirationTime = root.pendingCommitExpirationTime;
    invariant(0 !== expirationTime, "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
    root.pendingCommitExpirationTime = 0;
    firstBatch = finishedWork$jscomp$0.expirationTime;
    var childExpirationTimeBeforeCommit = finishedWork$jscomp$0.childExpirationTime;
    firstBatch = childExpirationTimeBeforeCommit > firstBatch ? childExpirationTimeBeforeCommit : firstBatch;
    root.didError = !1;
    0 === firstBatch ? (root.earliestPendingTime = 0, root.latestPendingTime = 0, root.earliestSuspendedTime = 0, root.latestSuspendedTime = 0, root.latestPingedTime = 0) : (childExpirationTimeBeforeCommit = root.latestPendingTime, 0 !== childExpirationTimeBeforeCommit && (childExpirationTimeBeforeCommit > firstBatch ? root.earliestPendingTime = root.latestPendingTime = 0 : root.earliestPendingTime > firstBatch && (root.earliestPendingTime = root.latestPendingTime)), childExpirationTimeBeforeCommit = root.earliestSuspendedTime, 0 === childExpirationTimeBeforeCommit ? markPendingPriorityLevel(root, firstBatch) : firstBatch < root.latestSuspendedTime ? (root.earliestSuspendedTime = 0, root.latestSuspendedTime = 0, root.latestPingedTime = 0, markPendingPriorityLevel(root, firstBatch)) : firstBatch > childExpirationTimeBeforeCommit && markPendingPriorityLevel(root, firstBatch));
    findNextExpirationTimeToWorkOn(0, root);
    ReactCurrentOwner$2.current = null;
    1 < finishedWork$jscomp$0.effectTag ? null !== finishedWork$jscomp$0.lastEffect ? (finishedWork$jscomp$0.lastEffect.nextEffect = finishedWork$jscomp$0, firstBatch = finishedWork$jscomp$0.firstEffect) : firstBatch = finishedWork$jscomp$0 : firstBatch = finishedWork$jscomp$0.firstEffect;

    for (nextEffect = firstBatch; null !== nextEffect;) {
      childExpirationTimeBeforeCommit = !1;
      var error$jscomp$0 = void 0;

      try {
        for (; null !== nextEffect;) {
          if (nextEffect.effectTag & 256) a: {
            var current$$1 = nextEffect.alternate,
                finishedWork = nextEffect;

            switch (finishedWork.tag) {
              case 0:
              case 11:
              case 15:
                break a;

              case 1:
                if (finishedWork.effectTag & 256 && null !== current$$1) {
                  var prevProps = current$$1.memoizedProps,
                      prevState = current$$1.memoizedState,
                      instance = finishedWork.stateNode,
                      snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                  instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                }

                break a;

              case 3:
              case 5:
              case 6:
              case 4:
              case 17:
                break a;

              default:
                invariant(!1, "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          nextEffect = nextEffect.nextEffect;
        }
      } catch (e) {
        childExpirationTimeBeforeCommit = !0, error$jscomp$0 = e;
      }

      childExpirationTimeBeforeCommit && (invariant(null !== nextEffect, "Should have next effect. This error is likely caused by a bug in React. Please file an issue."), captureCommitPhaseError(nextEffect, error$jscomp$0), null !== nextEffect && (nextEffect = nextEffect.nextEffect));
    }

    for (nextEffect = firstBatch; null !== nextEffect;) {
      current$$1 = !1;
      prevProps = void 0;

      try {
        for (; null !== nextEffect;) {
          var effectTag = nextEffect.effectTag;

          if (effectTag & 128) {
            var current$$1$jscomp$0 = nextEffect.alternate;

            if (null !== current$$1$jscomp$0) {
              var currentRef = current$$1$jscomp$0.ref;
              null !== currentRef && ("function" === typeof currentRef ? currentRef(null) : currentRef.current = null);
            }
          }

          switch (effectTag & 14) {
            case 2:
              nextEffect.effectTag &= -3;
              break;

            case 6:
              nextEffect.effectTag &= -3;
              commitWork(nextEffect.alternate, nextEffect);
              break;

            case 4:
              commitWork(nextEffect.alternate, nextEffect);
              break;

            case 8:
              prevState = nextEffect;

              a: for (snapshot = instance = prevState;;) {
                childExpirationTimeBeforeCommit = snapshot;
                "function" === typeof onCommitFiberUnmount && onCommitFiberUnmount(childExpirationTimeBeforeCommit);

                switch (childExpirationTimeBeforeCommit.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    var updateQueue = childExpirationTimeBeforeCommit.updateQueue;

                    if (null !== updateQueue) {
                      var lastEffect = updateQueue.lastEffect;

                      if (null !== lastEffect) {
                        var firstEffect = lastEffect.next;
                        error$jscomp$0 = firstEffect;

                        do {
                          var destroy = error$jscomp$0.destroy;

                          if (null !== destroy) {
                            finishedWork = childExpirationTimeBeforeCommit;

                            try {
                              destroy();
                            } catch (error) {
                              captureCommitPhaseError(finishedWork, error);
                            }
                          }

                          error$jscomp$0 = error$jscomp$0.next;
                        } while (error$jscomp$0 !== firstEffect);
                      }
                    }

                    break;

                  case 1:
                    safelyDetachRef(childExpirationTimeBeforeCommit);
                    var instance$jscomp$0 = childExpirationTimeBeforeCommit.stateNode;
                    if ("function" === typeof instance$jscomp$0.componentWillUnmount) try {
                      instance$jscomp$0.props = childExpirationTimeBeforeCommit.memoizedProps, instance$jscomp$0.state = childExpirationTimeBeforeCommit.memoizedState, instance$jscomp$0.componentWillUnmount();
                    } catch (unmountError) {
                      captureCommitPhaseError(childExpirationTimeBeforeCommit, unmountError);
                    }
                    break;

                  case 5:
                    safelyDetachRef(childExpirationTimeBeforeCommit);
                    break;

                  case 4:
                    FabricUIManager.createChildSet(childExpirationTimeBeforeCommit.stateNode.containerInfo);
                }

                if (null !== snapshot.child) snapshot.child.return = snapshot, snapshot = snapshot.child;else {
                  if (snapshot === instance) break;

                  for (; null === snapshot.sibling;) {
                    if (null === snapshot.return || snapshot.return === instance) break a;
                    snapshot = snapshot.return;
                  }

                  snapshot.sibling.return = snapshot.return;
                  snapshot = snapshot.sibling;
                }
              }

              prevState.return = null;
              prevState.child = null;
              prevState.alternate && (prevState.alternate.child = null, prevState.alternate.return = null);
          }

          nextEffect = nextEffect.nextEffect;
        }
      } catch (e) {
        current$$1 = !0, prevProps = e;
      }

      current$$1 && (invariant(null !== nextEffect, "Should have next effect. This error is likely caused by a bug in React. Please file an issue."), captureCommitPhaseError(nextEffect, prevProps), null !== nextEffect && (nextEffect = nextEffect.nextEffect));
    }

    root.current = finishedWork$jscomp$0;

    for (nextEffect = firstBatch; null !== nextEffect;) {
      effectTag = !1;
      current$$1$jscomp$0 = void 0;

      try {
        for (currentRef = expirationTime; null !== nextEffect;) {
          var effectTag$jscomp$0 = nextEffect.effectTag;

          if (effectTag$jscomp$0 & 36) {
            var current$$1$jscomp$1 = nextEffect.alternate;
            updateQueue = nextEffect;
            lastEffect = currentRef;

            switch (updateQueue.tag) {
              case 0:
              case 11:
              case 15:
                break;

              case 1:
                var instance$jscomp$1 = updateQueue.stateNode;
                if (updateQueue.effectTag & 4) if (null === current$$1$jscomp$1) instance$jscomp$1.componentDidMount();else {
                  var prevProps$jscomp$0 = updateQueue.elementType === updateQueue.type ? current$$1$jscomp$1.memoizedProps : resolveDefaultProps(updateQueue.type, current$$1$jscomp$1.memoizedProps);
                  instance$jscomp$1.componentDidUpdate(prevProps$jscomp$0, current$$1$jscomp$1.memoizedState, instance$jscomp$1.__reactInternalSnapshotBeforeUpdate);
                }
                var updateQueue$jscomp$0 = updateQueue.updateQueue;
                null !== updateQueue$jscomp$0 && commitUpdateQueue(updateQueue, updateQueue$jscomp$0, instance$jscomp$1, lastEffect);
                break;

              case 3:
                var _updateQueue = updateQueue.updateQueue;

                if (null !== _updateQueue) {
                  firstEffect = null;
                  if (null !== updateQueue.child) switch (updateQueue.child.tag) {
                    case 5:
                      firstEffect = updateQueue.child.stateNode.canonical;
                      break;

                    case 1:
                      firstEffect = updateQueue.child.stateNode;
                  }
                  commitUpdateQueue(updateQueue, _updateQueue, firstEffect, lastEffect);
                }

                break;

              case 5:
                null === current$$1$jscomp$1 && updateQueue.effectTag & 4 && invariant(!1, "The current renderer does not support mutation. This error is likely caused by a bug in React. Please file an issue.");
                break;

              case 6:
                break;

              case 4:
                break;

              case 12:
                break;

              case 13:
                break;

              case 17:
                break;

              default:
                invariant(!1, "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
          }

          if (effectTag$jscomp$0 & 128) {
            var ref = nextEffect.ref;

            if (null !== ref) {
              var instance$jscomp$2 = nextEffect.stateNode;

              switch (nextEffect.tag) {
                case 5:
                  var instanceToUse = instance$jscomp$2.canonical;
                  break;

                default:
                  instanceToUse = instance$jscomp$2;
              }

              "function" === typeof ref ? ref(instanceToUse) : ref.current = instanceToUse;
            }
          }

          nextEffect = nextEffect.nextEffect;
        }
      } catch (e) {
        effectTag = !0, current$$1$jscomp$0 = e;
      }

      effectTag && (invariant(null !== nextEffect, "Should have next effect. This error is likely caused by a bug in React. Please file an issue."), captureCommitPhaseError(nextEffect, current$$1$jscomp$0), null !== nextEffect && (nextEffect = nextEffect.nextEffect));
    }

    isWorking = isCommitting$1 = !1;
    "function" === typeof onCommitFiberRoot && onCommitFiberRoot(finishedWork$jscomp$0.stateNode);
    effectTag$jscomp$0 = finishedWork$jscomp$0.expirationTime;
    finishedWork$jscomp$0 = finishedWork$jscomp$0.childExpirationTime;
    finishedWork$jscomp$0 = finishedWork$jscomp$0 > effectTag$jscomp$0 ? finishedWork$jscomp$0 : effectTag$jscomp$0;
    0 === finishedWork$jscomp$0 && (legacyErrorBoundariesThatAlreadyFailed = null);
    root.expirationTime = finishedWork$jscomp$0;
    root.finishedWork = null;
  }

  function onUncaughtError(error) {
    invariant(null !== nextFlushedRoot, "Should be working on a root. This error is likely caused by a bug in React. Please file an issue.");
    nextFlushedRoot.expirationTime = 0;
    hasUnhandledError || (hasUnhandledError = !0, unhandledError = error);
  }

  function findHostInstance$1(component) {
    var fiber = component._reactInternalFiber;
    void 0 === fiber && ("function" === typeof component.render ? invariant(!1, "Unable to find node on an unmounted component.") : invariant(!1, "Argument appears to not be a ReactComponent. Keys: %s", Object.keys(component)));
    component = findCurrentHostFiber(fiber);
    return null === component ? null : component.stateNode;
  }

  function updateContainer(element, container, parentComponent, callback) {
    var current$$1 = container.current,
        currentTime = requestCurrentTime();
    current$$1 = computeExpirationForFiber(currentTime, current$$1);
    currentTime = container.current;

    a: if (parentComponent) {
      parentComponent = parentComponent._reactInternalFiber;

      b: {
        invariant(2 === isFiberMountedImpl(parentComponent) && 1 === parentComponent.tag, "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var parentContext = parentComponent;

        do {
          switch (parentContext.tag) {
            case 3:
              parentContext = parentContext.stateNode.context;
              break b;

            case 1:
              if (isContextProvider(parentContext.type)) {
                parentContext = parentContext.stateNode.__reactInternalMemoizedMergedChildContext;
                break b;
              }

          }

          parentContext = parentContext.return;
        } while (null !== parentContext);

        invariant(!1, "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
        parentContext = void 0;
      }

      if (1 === parentComponent.tag) {
        var Component = parentComponent.type;

        if (isContextProvider(Component)) {
          parentComponent = processChildContext(parentComponent, Component, parentContext);
          break a;
        }
      }

      parentComponent = parentContext;
    } else parentComponent = emptyContextObject;

    null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
    container = callback;
    callback = createUpdate(current$$1);
    callback.payload = {
      element: element
    };
    container = void 0 === container ? null : container;
    null !== container && (callback.callback = container);
    flushPassiveEffects();
    enqueueUpdate(currentTime, callback);
    scheduleWork(currentTime, current$$1);
    return current$$1;
  }

  function _createPortal(children, containerInfo, implementation) {
    var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return {
      $$typeof: REACT_PORTAL_TYPE,
      key: null == key ? null : "" + key,
      children: children,
      containerInfo: containerInfo,
      implementation: implementation
    };
  }

  function _inherits(subClass, superClass) {
    if ("function" !== typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    });
    superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
  }

  var getInspectorDataForViewTag = void 0;

  getInspectorDataForViewTag = function getInspectorDataForViewTag() {
    invariant(!1, "getInspectorDataForViewTag() is not available in production");
  };

  function findNodeHandle(componentOrHandle) {
    if (null == componentOrHandle) return null;
    if ("number" === typeof componentOrHandle) return componentOrHandle;
    if (componentOrHandle._nativeTag) return componentOrHandle._nativeTag;
    if (componentOrHandle.canonical && componentOrHandle.canonical._nativeTag) return componentOrHandle.canonical._nativeTag;
    componentOrHandle = findHostInstance$1(componentOrHandle);
    return null == componentOrHandle ? componentOrHandle : componentOrHandle.canonical ? componentOrHandle.canonical._nativeTag : componentOrHandle._nativeTag;
  }

  _batchedUpdatesImpl = function _batchedUpdatesImpl(fn, a) {
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = !0;

    try {
      return fn(a);
    } finally {
      (isBatchingUpdates = previousIsBatchingUpdates) || isRendering || performWork(1073741823, !1);
    }
  };

  _flushInteractiveUpdatesImpl = function _flushInteractiveUpdatesImpl() {
    isRendering || 0 === lowestPriorityPendingInteractiveExpirationTime || (performWork(lowestPriorityPendingInteractiveExpirationTime, !1), lowestPriorityPendingInteractiveExpirationTime = 0);
  };

  var roots = new Map(),
      ReactFabric = {
    NativeComponent: function (findNodeHandle, findHostInstance) {
      return function (_React$Component) {
        function ReactNativeComponent() {
          if (!(this instanceof ReactNativeComponent)) throw new TypeError("Cannot call a class as a function");

          var call = _React$Component.apply(this, arguments);

          if (!this) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return !call || "object" !== typeof call && "function" !== typeof call ? this : call;
        }

        _inherits(ReactNativeComponent, _React$Component);

        ReactNativeComponent.prototype.blur = function () {
          TextInputState.blurTextInput(findNodeHandle(this));
        };

        ReactNativeComponent.prototype.focus = function () {
          TextInputState.focusTextInput(findNodeHandle(this));
        };

        ReactNativeComponent.prototype.measure = function (callback) {
          UIManager.measure(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
        };

        ReactNativeComponent.prototype.measureInWindow = function (callback) {
          UIManager.measureInWindow(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
        };

        ReactNativeComponent.prototype.measureLayout = function (relativeToNativeNode, onSuccess, onFail) {
          UIManager.measureLayout(findNodeHandle(this), relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
        };

        ReactNativeComponent.prototype.setNativeProps = function (nativeProps) {
          var maybeInstance = void 0;

          try {
            maybeInstance = findHostInstance(this);
          } catch (error) {}

          if (null != maybeInstance) {
            var viewConfig = maybeInstance.viewConfig || maybeInstance.canonical.viewConfig;
            nativeProps = diffProperties(null, emptyObject, nativeProps, viewConfig.validAttributes);
            null != nativeProps && UIManager.updateView(maybeInstance._nativeTag, viewConfig.uiViewClassName, nativeProps);
          }
        };

        return ReactNativeComponent;
      }(React.Component);
    }(findNodeHandle, findHostInstance$1),
    findNodeHandle: findNodeHandle,
    render: function render(element, containerTag, callback) {
      var root = roots.get(containerTag);

      if (!root) {
        root = createFiber(3, null, null, 0);
        var root$jscomp$0 = {
          current: root,
          containerInfo: containerTag,
          pendingChildren: null,
          earliestPendingTime: 0,
          latestPendingTime: 0,
          earliestSuspendedTime: 0,
          latestSuspendedTime: 0,
          latestPingedTime: 0,
          didError: !1,
          pendingCommitExpirationTime: 0,
          finishedWork: null,
          timeoutHandle: -1,
          context: null,
          pendingContext: null,
          hydrate: !1,
          nextExpirationTimeToWorkOn: 0,
          expirationTime: 0,
          firstBatch: null,
          nextScheduledRoot: null
        };
        root = root.stateNode = root$jscomp$0;
        roots.set(containerTag, root);
      }

      updateContainer(element, root, null, callback);

      a: if (element = root.current, element.child) switch (element.child.tag) {
        case 5:
          element = element.child.stateNode.canonical;
          break a;

        default:
          element = element.child.stateNode;
      } else element = null;

      return element;
    },
    unmountComponentAtNode: function unmountComponentAtNode(containerTag) {
      var root = roots.get(containerTag);
      root && updateContainer(null, root, null, function () {
        roots.delete(containerTag);
      });
    },
    createPortal: function createPortal(children, containerTag) {
      return _createPortal(children, containerTag, null, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
    },
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
      NativeMethodsMixin: function (findNodeHandle, findHostInstance) {
        return {
          measure: function measure(callback) {
            UIManager.measure(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          },
          measureInWindow: function measureInWindow(callback) {
            UIManager.measureInWindow(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
          },
          measureLayout: function measureLayout(relativeToNativeNode, onSuccess, onFail) {
            UIManager.measureLayout(findNodeHandle(this), relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
          },
          setNativeProps: function setNativeProps(nativeProps) {
            var maybeInstance = void 0;

            try {
              maybeInstance = findHostInstance(this);
            } catch (error) {}

            if (null != maybeInstance) {
              var viewConfig = maybeInstance.viewConfig;
              nativeProps = diffProperties(null, emptyObject, nativeProps, viewConfig.validAttributes);
              null != nativeProps && UIManager.updateView(maybeInstance._nativeTag, viewConfig.uiViewClassName, nativeProps);
            }
          },
          focus: function focus() {
            TextInputState.focusTextInput(findNodeHandle(this));
          },
          blur: function blur() {
            TextInputState.blurTextInput(findNodeHandle(this));
          }
        };
      }(findNodeHandle, findHostInstance$1)
    }
  };

  (function (devToolsConfig) {
    var _findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
    return injectInternals(_extends({}, devToolsConfig, {
      findHostInstanceByFiber: function findHostInstanceByFiber(fiber) {
        fiber = findCurrentHostFiber(fiber);
        return null === fiber ? null : fiber.stateNode;
      },
      findFiberByHostInstance: function findFiberByHostInstance(instance) {
        return _findFiberByHostInstance ? _findFiberByHostInstance(instance) : null;
      }
    }));
  })({
    findFiberByHostInstance: getInstanceFromInstance,
    getInspectorDataForViewTag: getInspectorDataForViewTag,
    bundleType: 0,
    version: "16.6.1",
    rendererPackageName: "react-native-renderer"
  });

  var ReactFabric$2 = {
    default: ReactFabric
  },
      ReactFabric$3 = ReactFabric$2 && ReactFabric || ReactFabric$2;
  module.exports = ReactFabric$3.default || ReactFabric$3;
},618,[112,180,257,145,109,259,174,260,617,264,188],"node_modules\\react-native\\Libraries\\Renderer\\oss\\ReactFabric-prod.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _slicedToArray = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/slicedToArray");

  var NativeModules = _$$_REQUIRE(_dependencyMap[1], "NativeModules");

  var RCTAsyncStorage = NativeModules.AsyncRocksDBStorage || NativeModules.AsyncSQLiteDBStorage || NativeModules.AsyncLocalStorage;
  var AsyncStorage = {
    _getRequests: [],
    _getKeys: [],
    _immediate: null,
    getItem: function getItem(key, callback) {
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiGet([key], function (errors, result) {
          var value = result && result[0] && result[0][1] ? result[0][1] : null;
          var errs = convertErrors(errors);
          callback && callback(errs && errs[0], value);

          if (errs) {
            reject(errs[0]);
          } else {
            resolve(value);
          }
        });
      });
    },
    setItem: function setItem(key, value, callback) {
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiSet([[key, value]], function (errors) {
          var errs = convertErrors(errors);
          callback && callback(errs && errs[0]);

          if (errs) {
            reject(errs[0]);
          } else {
            resolve(null);
          }
        });
      });
    },
    removeItem: function removeItem(key, callback) {
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiRemove([key], function (errors) {
          var errs = convertErrors(errors);
          callback && callback(errs && errs[0]);

          if (errs) {
            reject(errs[0]);
          } else {
            resolve(null);
          }
        });
      });
    },
    mergeItem: function mergeItem(key, value, callback) {
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiMerge([[key, value]], function (errors) {
          var errs = convertErrors(errors);
          callback && callback(errs && errs[0]);

          if (errs) {
            reject(errs[0]);
          } else {
            resolve(null);
          }
        });
      });
    },
    clear: function clear(callback) {
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.clear(function (error) {
          callback && callback(convertError(error));

          if (error && convertError(error)) {
            reject(convertError(error));
          } else {
            resolve(null);
          }
        });
      });
    },
    getAllKeys: function getAllKeys(callback) {
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.getAllKeys(function (error, keys) {
          callback && callback(convertError(error), keys);

          if (error) {
            reject(convertError(error));
          } else {
            resolve(keys);
          }
        });
      });
    },
    flushGetRequests: function flushGetRequests() {
      var getRequests = this._getRequests;
      var getKeys = this._getKeys;
      this._getRequests = [];
      this._getKeys = [];
      RCTAsyncStorage.multiGet(getKeys, function (errors, result) {
        var map = {};
        result && result.forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              key = _ref2[0],
              value = _ref2[1];

          map[key] = value;
          return value;
        });
        var reqLength = getRequests.length;

        for (var i = 0; i < reqLength; i++) {
          var request = getRequests[i];
          var requestKeys = request.keys;
          var requestResult = requestKeys.map(function (key) {
            return [key, map[key]];
          });
          request.callback && request.callback(null, requestResult);
          request.resolve && request.resolve(requestResult);
        }
      });
    },
    multiGet: function multiGet(keys, callback) {
      var _this = this;

      if (!this._immediate) {
        this._immediate = setImmediate(function () {
          _this._immediate = null;

          _this.flushGetRequests();
        });
      }

      var getRequest = {
        keys: keys,
        callback: callback,
        keyIndex: this._getKeys.length,
        resolve: null,
        reject: null
      };
      var promiseResult = new Promise(function (resolve, reject) {
        getRequest.resolve = resolve;
        getRequest.reject = reject;
      });

      this._getRequests.push(getRequest);

      keys.forEach(function (key) {
        if (_this._getKeys.indexOf(key) === -1) {
          _this._getKeys.push(key);
        }
      });
      return promiseResult;
    },
    multiSet: function multiSet(keyValuePairs, callback) {
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiSet(keyValuePairs, function (errors) {
          var error = convertErrors(errors);
          callback && callback(error);

          if (error) {
            reject(error);
          } else {
            resolve(null);
          }
        });
      });
    },
    multiRemove: function multiRemove(keys, callback) {
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiRemove(keys, function (errors) {
          var error = convertErrors(errors);
          callback && callback(error);

          if (error) {
            reject(error);
          } else {
            resolve(null);
          }
        });
      });
    },
    multiMerge: function multiMerge(keyValuePairs, callback) {
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiMerge(keyValuePairs, function (errors) {
          var error = convertErrors(errors);
          callback && callback(error);

          if (error) {
            reject(error);
          } else {
            resolve(null);
          }
        });
      });
    }
  };

  if (!RCTAsyncStorage.multiMerge) {
    delete AsyncStorage.mergeItem;
    delete AsyncStorage.multiMerge;
  }

  function convertErrors(errs) {
    if (!errs) {
      return null;
    }

    return (Array.isArray(errs) ? errs : [errs]).map(function (e) {
      return convertError(e);
    });
  }

  function convertError(error) {
    if (!error) {
      return null;
    }

    var out = new Error(error.message);
    out.key = error.key;
    return out;
  }

  module.exports = AsyncStorage;
},619,[122,119],"node_modules\\react-native\\Libraries\\Storage\\AsyncStorage.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var BackHandler = _$$_REQUIRE(_dependencyMap[0], "BackHandler");

  var warning = _$$_REQUIRE(_dependencyMap[1], "fbjs/lib/warning");

  var BackAndroid = {
    exitApp: function exitApp() {
      warning(false, 'BackAndroid is deprecated.  Please use BackHandler instead.');
      BackHandler.exitApp();
    },
    addEventListener: function addEventListener(eventName, handler) {
      warning(false, 'BackAndroid is deprecated.  Please use BackHandler instead.');
      return BackHandler.addEventListener(eventName, handler);
    },
    removeEventListener: function removeEventListener(eventName, handler) {
      warning(false, 'BackAndroid is deprecated.  Please use BackHandler instead.');
      BackHandler.removeEventListener(eventName, handler);
    }
  };
  module.exports = BackAndroid;
},620,[614,211],"node_modules\\react-native\\Libraries\\Utilities\\BackAndroid.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/defineProperty");

  var PropTypes = _$$_REQUIRE(_dependencyMap[3], "prop-types");

  var checkPropTypes = PropTypes.checkPropTypes;

  var RCTCameraRollManager = _$$_REQUIRE(_dependencyMap[4], "NativeModules").CameraRollManager;

  var createStrictShapeTypeChecker = _$$_REQUIRE(_dependencyMap[5], "createStrictShapeTypeChecker");

  var invariant = _$$_REQUIRE(_dependencyMap[6], "fbjs/lib/invariant");

  var GROUP_TYPES_OPTIONS = {
    Album: 'Album',
    All: 'All',
    Event: 'Event',
    Faces: 'Faces',
    Library: 'Library',
    PhotoStream: 'PhotoStream',
    SavedPhotos: 'SavedPhotos'
  };
  var ASSET_TYPE_OPTIONS = {
    All: 'All',
    Videos: 'Videos',
    Photos: 'Photos'
  };
  var getPhotosParamChecker = createStrictShapeTypeChecker({
    first: PropTypes.number.isRequired,
    after: PropTypes.string,
    groupTypes: PropTypes.oneOf(Object.keys(GROUP_TYPES_OPTIONS)),
    groupName: PropTypes.string,
    assetType: PropTypes.oneOf(Object.keys(ASSET_TYPE_OPTIONS)),
    mimeTypes: PropTypes.arrayOf(PropTypes.string)
  });
  var getPhotosReturnChecker = createStrictShapeTypeChecker({
    edges: PropTypes.arrayOf(createStrictShapeTypeChecker({
      node: createStrictShapeTypeChecker({
        type: PropTypes.string.isRequired,
        group_name: PropTypes.string.isRequired,
        image: createStrictShapeTypeChecker({
          uri: PropTypes.string.isRequired,
          height: PropTypes.number.isRequired,
          width: PropTypes.number.isRequired,
          isStored: PropTypes.bool,
          playableDuration: PropTypes.number.isRequired
        }).isRequired,
        timestamp: PropTypes.number.isRequired,
        location: createStrictShapeTypeChecker({
          latitude: PropTypes.number,
          longitude: PropTypes.number,
          altitude: PropTypes.number,
          heading: PropTypes.number,
          speed: PropTypes.number
        })
      }).isRequired
    })).isRequired,
    page_info: createStrictShapeTypeChecker({
      has_next_page: PropTypes.bool.isRequired,
      start_cursor: PropTypes.string,
      end_cursor: PropTypes.string
    }).isRequired
  });

  var CameraRoll = function () {
    function CameraRoll() {
      _classCallCheck(this, CameraRoll);
    }

    _createClass(CameraRoll, null, [{
      key: "saveImageWithTag",
      value: function saveImageWithTag(tag) {
        console.warn('`CameraRoll.saveImageWithTag()` is deprecated. Use `CameraRoll.saveToCameraRoll()` instead.');
        return this.saveToCameraRoll(tag, 'photo');
      }
    }, {
      key: "deletePhotos",
      value: function deletePhotos(photos) {
        return RCTCameraRollManager.deletePhotos(photos);
      }
    }, {
      key: "saveToCameraRoll",
      value: function saveToCameraRoll(tag, type) {
        invariant(typeof tag === 'string', 'CameraRoll.saveToCameraRoll must be a valid string.');
        invariant(type === 'photo' || type === 'video' || type === undefined, "The second argument to saveToCameraRoll must be 'photo' or 'video'. You passed " + (type || 'unknown'));
        var mediaType = 'photo';

        if (type) {
          mediaType = type;
        } else if (['mov', 'mp4'].indexOf(tag.split('.').slice(-1)[0]) >= 0) {
          mediaType = 'video';
        }

        return RCTCameraRollManager.saveToCameraRoll(tag, mediaType);
      }
    }, {
      key: "getPhotos",
      value: function getPhotos(params) {
        if (__DEV__) {
          checkPropTypes({
            params: getPhotosParamChecker
          }, {
            params: params
          }, 'params', 'CameraRoll.getPhotos');
        }

        if (arguments.length > 1) {
          console.warn('CameraRoll.getPhotos(tag, success, error) is deprecated.  Use the returned Promise instead');
          var successCallback = arguments[1];

          if (__DEV__) {
            var callback = arguments[1];

            successCallback = function successCallback(response) {
              checkPropTypes({
                response: getPhotosReturnChecker
              }, {
                response: response
              }, 'response', 'CameraRoll.getPhotos callback');
              callback(response);
            };
          }

          var errorCallback = arguments[2] || function () {};

          RCTCameraRollManager.getPhotos(params).then(successCallback, errorCallback);
        }

        return RCTCameraRollManager.getPhotos(params);
      }
    }]);

    return CameraRoll;
  }();

  _defineProperty(CameraRoll, "GroupTypesOptions", GROUP_TYPES_OPTIONS);

  _defineProperty(CameraRoll, "AssetTypeOptions", ASSET_TYPE_OPTIONS);

  module.exports = CameraRoll;
},621,[24,25,32,161,119,448,117],"node_modules\\react-native\\Libraries\\CameraRoll\\CameraRoll.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Clipboard = _$$_REQUIRE(_dependencyMap[0], "NativeModules").Clipboard;

  module.exports = {
    getString: function getString() {
      return Clipboard.getString();
    },
    setString: function setString(content) {
      Clipboard.setString(content);
    }
  };
},622,[119],"node_modules\\react-native\\Libraries\\Components\\Clipboard\\Clipboard.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _regeneratorRuntime = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/regenerator");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var DatePickerModule = _$$_REQUIRE(_dependencyMap[3], "NativeModules").DatePickerAndroid;

  function _toMillis(options, key) {
    var dateVal = options[key];

    if (typeof dateVal === 'object' && typeof dateVal.getMonth === 'function') {
      options[key] = dateVal.getTime();
    }
  }

  var DatePickerAndroid = function () {
    function DatePickerAndroid() {
      _classCallCheck(this, DatePickerAndroid);
    }

    _createClass(DatePickerAndroid, null, [{
      key: "open",
      value: function open(options) {
        var optionsMs;
        return _regeneratorRuntime.async(function open$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                optionsMs = options;

                if (optionsMs) {
                  _toMillis(options, 'date');

                  _toMillis(options, 'minDate');

                  _toMillis(options, 'maxDate');
                }

                return _context.abrupt("return", DatePickerModule.open(options));

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, null, this);
      }
    }, {
      key: "dateSetAction",
      get: function get() {
        return 'dateSetAction';
      }
    }, {
      key: "dismissedAction",
      get: function get() {
        return 'dismissedAction';
      }
    }]);

    return DatePickerAndroid;
  }();

  module.exports = DatePickerAndroid;
},623,[105,24,25,119],"node_modules\\react-native\\Libraries\\Components\\DatePickerAndroid\\DatePickerAndroid.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var RCTImagePicker = _$$_REQUIRE(_dependencyMap[1], "NativeModules").ImagePickerIOS;

  var ImagePickerIOS = {
    canRecordVideos: function canRecordVideos(callback) {
      return RCTImagePicker.canRecordVideos(callback);
    },
    canUseCamera: function canUseCamera(callback) {
      return RCTImagePicker.canUseCamera(callback);
    },
    openCameraDialog: function openCameraDialog(config, successCallback, cancelCallback) {
      config = _objectSpread({
        videoMode: false
      }, config);
      return RCTImagePicker.openCameraDialog(config, successCallback, cancelCallback);
    },
    openSelectDialog: function openSelectDialog(config, successCallback, cancelCallback) {
      config = _objectSpread({
        showImages: true,
        showVideos: false
      }, config);
      return RCTImagePicker.openSelectDialog(config, successCallback, cancelCallback);
    }
  };
  module.exports = ImagePickerIOS;
},624,[148,119],"node_modules\\react-native\\Libraries\\CameraRoll\\ImagePickerIOS.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _possibleConstructorReturn = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/possibleConstructorReturn");

  var _getPrototypeOf = _$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/getPrototypeOf");

  var _inherits = _$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/inherits");

  var NativeEventEmitter = _$$_REQUIRE(_dependencyMap[5], "NativeEventEmitter");

  var NativeModules = _$$_REQUIRE(_dependencyMap[6], "NativeModules");

  var Platform = _$$_REQUIRE(_dependencyMap[7], "Platform");

  var invariant = _$$_REQUIRE(_dependencyMap[8], "fbjs/lib/invariant");

  var LinkingManager = Platform.OS === 'android' ? NativeModules.IntentAndroid : NativeModules.LinkingManager;

  var Linking = function (_NativeEventEmitter) {
    _inherits(Linking, _NativeEventEmitter);

    function Linking() {
      _classCallCheck(this, Linking);

      return _possibleConstructorReturn(this, _getPrototypeOf(Linking).call(this, LinkingManager));
    }

    _createClass(Linking, [{
      key: "addEventListener",
      value: function addEventListener(type, handler) {
        this.addListener(type, handler);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, handler) {
        this.removeListener(type, handler);
      }
    }, {
      key: "openURL",
      value: function openURL(url) {
        this._validateURL(url);

        return LinkingManager.openURL(url);
      }
    }, {
      key: "canOpenURL",
      value: function canOpenURL(url) {
        this._validateURL(url);

        return LinkingManager.canOpenURL(url);
      }
    }, {
      key: "getInitialURL",
      value: function getInitialURL() {
        return LinkingManager.getInitialURL();
      }
    }, {
      key: "_validateURL",
      value: function _validateURL(url) {
        invariant(typeof url === 'string', 'Invalid URL: should be a string. Was: ' + url);
        invariant(url, 'Invalid URL: cannot be empty');
      }
    }]);

    return Linking;
  }(NativeEventEmitter);

  module.exports = new Linking();
},625,[24,25,26,29,30,219,119,146,117],"node_modules\\react-native\\Libraries\\Linking\\Linking.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Map = _$$_REQUIRE(_dependencyMap[0], "Map");

  var NativeEventEmitter = _$$_REQUIRE(_dependencyMap[1], "NativeEventEmitter");

  var NativeModules = _$$_REQUIRE(_dependencyMap[2], "NativeModules");

  var Platform = _$$_REQUIRE(_dependencyMap[3], "Platform");

  var RCTNetInfo = NativeModules.NetInfo;
  var NetInfoEventEmitter = new NativeEventEmitter(RCTNetInfo);
  var DEVICE_CONNECTIVITY_EVENT = 'networkStatusDidChange';

  var _subscriptions = new Map();

  var _isConnectedDeprecated;

  if (Platform.OS === 'ios') {
    _isConnectedDeprecated = function _isConnectedDeprecated(reachability) {
      return reachability !== 'none' && reachability !== 'unknown';
    };
  } else if (Platform.OS === 'android') {
    _isConnectedDeprecated = function _isConnectedDeprecated(connectionType) {
      return connectionType !== 'NONE' && connectionType !== 'UNKNOWN';
    };
  }

  function _isConnected(connection) {
    return connection.type !== 'none' && connection.type !== 'unknown';
  }

  var _isConnectedSubscriptions = new Map();

  var NetInfo = {
    addEventListener: function addEventListener(eventName, handler) {
      var listener;

      if (eventName === 'connectionChange') {
        listener = NetInfoEventEmitter.addListener(DEVICE_CONNECTIVITY_EVENT, function (appStateData) {
          handler({
            type: appStateData.connectionType,
            effectiveType: appStateData.effectiveConnectionType
          });
        });
      } else if (eventName === 'change') {
        console.warn('NetInfo\'s "change" event is deprecated. Listen to the "connectionChange" event instead.');
        listener = NetInfoEventEmitter.addListener(DEVICE_CONNECTIVITY_EVENT, function (appStateData) {
          handler(appStateData.network_info);
        });
      } else {
        console.warn('Trying to subscribe to unknown event: "' + eventName + '"');
        return {
          remove: function remove() {}
        };
      }

      _subscriptions.set(handler, listener);

      return {
        remove: function remove() {
          return NetInfo.removeEventListener(eventName, handler);
        }
      };
    },
    removeEventListener: function removeEventListener(eventName, handler) {
      var listener = _subscriptions.get(handler);

      if (!listener) {
        return;
      }

      listener.remove();

      _subscriptions.delete(handler);
    },
    fetch: function fetch() {
      console.warn('NetInfo.fetch() is deprecated. Use NetInfo.getConnectionInfo() instead.');
      return RCTNetInfo.getCurrentConnectivity().then(function (resp) {
        return resp.network_info;
      });
    },
    getConnectionInfo: function getConnectionInfo() {
      return RCTNetInfo.getCurrentConnectivity().then(function (resp) {
        return {
          type: resp.connectionType,
          effectiveType: resp.effectiveConnectionType
        };
      });
    },
    isConnected: {
      addEventListener: function addEventListener(eventName, handler) {
        var listener = function listener(connection) {
          if (eventName === 'change') {
            handler(_isConnectedDeprecated(connection));
          } else if (eventName === 'connectionChange') {
            handler(_isConnected(connection));
          }
        };

        _isConnectedSubscriptions.set(handler, listener);

        NetInfo.addEventListener(eventName, listener);
        return {
          remove: function remove() {
            return NetInfo.isConnected.removeEventListener(eventName, handler);
          }
        };
      },
      removeEventListener: function removeEventListener(eventName, handler) {
        var listener = _isConnectedSubscriptions.get(handler);

        NetInfo.removeEventListener(eventName, listener);

        _isConnectedSubscriptions.delete(handler);
      },
      fetch: function fetch() {
        return NetInfo.getConnectionInfo().then(_isConnected);
      }
    },
    isConnectionExpensive: function isConnectionExpensive() {
      return Platform.OS === 'android' ? RCTNetInfo.isConnectionMetered() : Promise.reject(new Error('Currently not supported on iOS'));
    }
  };
  module.exports = NetInfo;
},626,[183,219,119,146],"node_modules\\react-native\\Libraries\\Network\\NetInfo.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass");

  var _defineProperty = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/defineProperty");

  var NativeEventEmitter = _$$_REQUIRE(_dependencyMap[3], "NativeEventEmitter");

  var RCTPushNotificationManager = _$$_REQUIRE(_dependencyMap[4], "NativeModules").PushNotificationManager;

  var invariant = _$$_REQUIRE(_dependencyMap[5], "fbjs/lib/invariant");

  var PushNotificationEmitter = new NativeEventEmitter(RCTPushNotificationManager);

  var _notifHandlers = new Map();

  var DEVICE_NOTIF_EVENT = 'remoteNotificationReceived';
  var NOTIF_REGISTER_EVENT = 'remoteNotificationsRegistered';
  var NOTIF_REGISTRATION_ERROR_EVENT = 'remoteNotificationRegistrationError';
  var DEVICE_LOCAL_NOTIF_EVENT = 'localNotificationReceived';

  var PushNotificationIOS = function () {
    _createClass(PushNotificationIOS, null, [{
      key: "presentLocalNotification",
      value: function presentLocalNotification(details) {
        RCTPushNotificationManager.presentLocalNotification(details);
      }
    }, {
      key: "scheduleLocalNotification",
      value: function scheduleLocalNotification(details) {
        RCTPushNotificationManager.scheduleLocalNotification(details);
      }
    }, {
      key: "cancelAllLocalNotifications",
      value: function cancelAllLocalNotifications() {
        RCTPushNotificationManager.cancelAllLocalNotifications();
      }
    }, {
      key: "removeAllDeliveredNotifications",
      value: function removeAllDeliveredNotifications() {
        RCTPushNotificationManager.removeAllDeliveredNotifications();
      }
    }, {
      key: "getDeliveredNotifications",
      value: function getDeliveredNotifications(callback) {
        RCTPushNotificationManager.getDeliveredNotifications(callback);
      }
    }, {
      key: "removeDeliveredNotifications",
      value: function removeDeliveredNotifications(identifiers) {
        RCTPushNotificationManager.removeDeliveredNotifications(identifiers);
      }
    }, {
      key: "setApplicationIconBadgeNumber",
      value: function setApplicationIconBadgeNumber(number) {
        RCTPushNotificationManager.setApplicationIconBadgeNumber(number);
      }
    }, {
      key: "getApplicationIconBadgeNumber",
      value: function getApplicationIconBadgeNumber(callback) {
        RCTPushNotificationManager.getApplicationIconBadgeNumber(callback);
      }
    }, {
      key: "cancelLocalNotifications",
      value: function cancelLocalNotifications(userInfo) {
        RCTPushNotificationManager.cancelLocalNotifications(userInfo);
      }
    }, {
      key: "getScheduledLocalNotifications",
      value: function getScheduledLocalNotifications(callback) {
        RCTPushNotificationManager.getScheduledLocalNotifications(callback);
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, handler) {
        invariant(type === 'notification' || type === 'register' || type === 'registrationError' || type === 'localNotification', 'PushNotificationIOS only supports `notification`, `register`, `registrationError`, and `localNotification` events');
        var listener;

        if (type === 'notification') {
          listener = PushNotificationEmitter.addListener(DEVICE_NOTIF_EVENT, function (notifData) {
            handler(new PushNotificationIOS(notifData));
          });
        } else if (type === 'localNotification') {
          listener = PushNotificationEmitter.addListener(DEVICE_LOCAL_NOTIF_EVENT, function (notifData) {
            handler(new PushNotificationIOS(notifData));
          });
        } else if (type === 'register') {
          listener = PushNotificationEmitter.addListener(NOTIF_REGISTER_EVENT, function (registrationInfo) {
            handler(registrationInfo.deviceToken);
          });
        } else if (type === 'registrationError') {
          listener = PushNotificationEmitter.addListener(NOTIF_REGISTRATION_ERROR_EVENT, function (errorInfo) {
            handler(errorInfo);
          });
        }

        _notifHandlers.set(type, listener);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, handler) {
        invariant(type === 'notification' || type === 'register' || type === 'registrationError' || type === 'localNotification', 'PushNotificationIOS only supports `notification`, `register`, `registrationError`, and `localNotification` events');

        var listener = _notifHandlers.get(type);

        if (!listener) {
          return;
        }

        listener.remove();

        _notifHandlers.delete(type);
      }
    }, {
      key: "requestPermissions",
      value: function requestPermissions(permissions) {
        var requestedPermissions = {};

        if (permissions) {
          requestedPermissions = {
            alert: !!permissions.alert,
            badge: !!permissions.badge,
            sound: !!permissions.sound
          };
        } else {
          requestedPermissions = {
            alert: true,
            badge: true,
            sound: true
          };
        }

        return RCTPushNotificationManager.requestPermissions(requestedPermissions);
      }
    }, {
      key: "abandonPermissions",
      value: function abandonPermissions() {
        RCTPushNotificationManager.abandonPermissions();
      }
    }, {
      key: "checkPermissions",
      value: function checkPermissions(callback) {
        invariant(typeof callback === 'function', 'Must provide a valid callback');
        RCTPushNotificationManager.checkPermissions(callback);
      }
    }, {
      key: "getInitialNotification",
      value: function getInitialNotification() {
        return RCTPushNotificationManager.getInitialNotification().then(function (notification) {
          return notification && new PushNotificationIOS(notification);
        });
      }
    }]);

    function PushNotificationIOS(nativeNotif) {
      var _this = this;

      _classCallCheck(this, PushNotificationIOS);

      _defineProperty(this, "_data", void 0);

      _defineProperty(this, "_alert", void 0);

      _defineProperty(this, "_sound", void 0);

      _defineProperty(this, "_category", void 0);

      _defineProperty(this, "_contentAvailable", void 0);

      _defineProperty(this, "_badgeCount", void 0);

      _defineProperty(this, "_notificationId", void 0);

      _defineProperty(this, "_isRemote", void 0);

      _defineProperty(this, "_remoteNotificationCompleteCallbackCalled", void 0);

      _defineProperty(this, "_threadID", void 0);

      this._data = {};
      this._remoteNotificationCompleteCallbackCalled = false;
      this._isRemote = nativeNotif.remote;

      if (this._isRemote) {
        this._notificationId = nativeNotif.notificationId;
      }

      if (nativeNotif.remote) {
        Object.keys(nativeNotif).forEach(function (notifKey) {
          var notifVal = nativeNotif[notifKey];

          if (notifKey === 'aps') {
            _this._alert = notifVal.alert;
            _this._sound = notifVal.sound;
            _this._badgeCount = notifVal.badge;
            _this._category = notifVal.category;
            _this._contentAvailable = notifVal['content-available'];
            _this._threadID = notifVal['thread-id'];
          } else {
            _this._data[notifKey] = notifVal;
          }
        });
      } else {
        this._badgeCount = nativeNotif.applicationIconBadgeNumber;
        this._sound = nativeNotif.soundName;
        this._alert = nativeNotif.alertBody;
        this._data = nativeNotif.userInfo;
        this._category = nativeNotif.category;
      }
    }

    _createClass(PushNotificationIOS, [{
      key: "finish",
      value: function finish(fetchResult) {
        if (!this._isRemote || !this._notificationId || this._remoteNotificationCompleteCallbackCalled) {
          return;
        }

        this._remoteNotificationCompleteCallbackCalled = true;
        RCTPushNotificationManager.onFinishRemoteNotification(this._notificationId, fetchResult);
      }
    }, {
      key: "getMessage",
      value: function getMessage() {
        return this._alert;
      }
    }, {
      key: "getSound",
      value: function getSound() {
        return this._sound;
      }
    }, {
      key: "getCategory",
      value: function getCategory() {
        return this._category;
      }
    }, {
      key: "getAlert",
      value: function getAlert() {
        return this._alert;
      }
    }, {
      key: "getContentAvailable",
      value: function getContentAvailable() {
        return this._contentAvailable;
      }
    }, {
      key: "getBadgeCount",
      value: function getBadgeCount() {
        return this._badgeCount;
      }
    }, {
      key: "getData",
      value: function getData() {
        return this._data;
      }
    }, {
      key: "getThreadID",
      value: function getThreadID() {
        return this._threadID;
      }
    }]);

    return PushNotificationIOS;
  }();

  _defineProperty(PushNotificationIOS, "FetchResult", {
    NewData: 'UIBackgroundFetchResultNewData',
    NoData: 'UIBackgroundFetchResultNoData',
    ResultFailed: 'UIBackgroundFetchResultFailed'
  });

  module.exports = PushNotificationIOS;
},627,[24,25,32,219,119,117],"node_modules\\react-native\\Libraries\\PushNotificationIOS\\PushNotificationIOS.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Settings = {
    get: function get(key) {
      console.warn('Settings is not yet supported on Android');
      return null;
    },
    set: function set(settings) {
      console.warn('Settings is not yet supported on Android');
    },
    watchKeys: function watchKeys(keys, callback) {
      console.warn('Settings is not yet supported on Android');
      return -1;
    },
    clearWatch: function clearWatch(watchId) {
      console.warn('Settings is not yet supported on Android');
    }
  };
  module.exports = Settings;
},628,[],"node_modules\\react-native\\Libraries\\Settings\\Settings.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _objectSpread = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/objectSpread");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var Platform = _$$_REQUIRE(_dependencyMap[3], "Platform");

  var invariant = _$$_REQUIRE(_dependencyMap[4], "fbjs/lib/invariant");

  var processColor = _$$_REQUIRE(_dependencyMap[5], "processColor");

  var _require = _$$_REQUIRE(_dependencyMap[6], "NativeModules"),
      ActionSheetManager = _require.ActionSheetManager,
      ShareModule = _require.ShareModule;

  var Share = function () {
    function Share() {
      _classCallCheck(this, Share);
    }

    _createClass(Share, null, [{
      key: "share",
      value: function share(content) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        invariant(typeof content === 'object' && content !== null, 'Content to share must be a valid object');
        invariant(typeof content.url === 'string' || typeof content.message === 'string', 'At least one of URL and message is required');
        invariant(typeof options === 'object' && options !== null, 'Options must be a valid object');

        if (Platform.OS === 'android') {
          invariant(!content.title || typeof content.title === 'string', 'Invalid title: title should be a string.');
          return ShareModule.share(content, options.dialogTitle);
        } else if (Platform.OS === 'ios') {
          return new Promise(function (resolve, reject) {
            ActionSheetManager.showShareActionSheetWithOptions(_objectSpread({}, content, options, {
              tintColor: processColor(options.tintColor)
            }), function (error) {
              return reject(error);
            }, function (success, activityType) {
              if (success) {
                resolve({
                  action: 'sharedAction',
                  activityType: activityType
                });
              } else {
                resolve({
                  action: 'dismissedAction'
                });
              }
            });
          });
        } else {
          return Promise.reject(new Error('Unsupported platform'));
        }
      }
    }, {
      key: "sharedAction",
      get: function get() {
        return 'sharedAction';
      }
    }, {
      key: "dismissedAction",
      get: function get() {
        return 'dismissedAction';
      }
    }]);

    return Share;
  }();

  module.exports = Share;
},629,[148,24,25,146,117,169,119],"node_modules\\react-native\\Libraries\\Share\\Share.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var NativeEventEmitter = _$$_REQUIRE(_dependencyMap[0], "NativeEventEmitter");

  module.exports = new NativeEventEmitter('StatusBarManager');
},630,[219],"node_modules\\react-native\\Libraries\\Components\\StatusBar\\StatusBarIOS.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _regeneratorRuntime = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/regenerator");

  var _classCallCheck = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck");

  var _createClass = _$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass");

  var TimePickerModule = _$$_REQUIRE(_dependencyMap[3], "NativeModules").TimePickerAndroid;

  var TimePickerAndroid = function () {
    function TimePickerAndroid() {
      _classCallCheck(this, TimePickerAndroid);
    }

    _createClass(TimePickerAndroid, null, [{
      key: "open",
      value: function open(options) {
        return _regeneratorRuntime.async(function open$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", TimePickerModule.open(options));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, null, this);
      }
    }, {
      key: "timeSetAction",
      get: function get() {
        return 'timeSetAction';
      }
    }, {
      key: "dismissedAction",
      get: function get() {
        return 'dismissedAction';
      }
    }]);

    return TimePickerAndroid;
  }();

  module.exports = TimePickerAndroid;
},631,[105,24,25,119],"node_modules\\react-native\\Libraries\\Components\\TimePickerAndroid\\TimePickerAndroid.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var RCTVibration = _$$_REQUIRE(_dependencyMap[0], "NativeModules").Vibration;

  var Platform = _$$_REQUIRE(_dependencyMap[1], "Platform");

  var _vibrating = false;
  var _id = 0;

  function vibrateByPattern(pattern) {
    var repeat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (_vibrating) {
      return;
    }

    _vibrating = true;

    if (pattern[0] === 0) {
      RCTVibration.vibrate();
      pattern = pattern.slice(1);
    }

    if (pattern.length === 0) {
      _vibrating = false;
      return;
    }

    setTimeout(function () {
      return vibrateScheduler(++_id, pattern, repeat, 1);
    }, pattern[0]);
  }

  function vibrateScheduler(id, pattern, repeat, nextIndex) {
    if (!_vibrating || id !== _id) {
      return;
    }

    RCTVibration.vibrate();

    if (nextIndex >= pattern.length) {
      if (repeat) {
        nextIndex = 0;
      } else {
        _vibrating = false;
        return;
      }
    }

    setTimeout(function () {
      return vibrateScheduler(id, pattern, repeat, nextIndex + 1);
    }, pattern[nextIndex]);
  }

  var Vibration = {
    vibrate: function vibrate() {
      var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 400;
      var repeat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (Platform.OS === 'android') {
        if (typeof pattern === 'number') {
          RCTVibration.vibrate(pattern);
        } else if (Array.isArray(pattern)) {
          RCTVibration.vibrateByPattern(pattern, repeat ? 0 : -1);
        } else {
          throw new Error('Vibration pattern should be a number or array');
        }
      } else {
        if (_vibrating) {
          return;
        }

        if (typeof pattern === 'number') {
          RCTVibration.vibrate();
        } else if (Array.isArray(pattern)) {
          vibrateByPattern(pattern, repeat);
        } else {
          throw new Error('Vibration pattern should be a number or array');
        }
      }
    },
    cancel: function cancel() {
      if (Platform.OS === 'ios') {
        _vibrating = false;
      } else {
        RCTVibration.cancel();
      }
    }
  };
  module.exports = Vibration;
},632,[119,146],"node_modules\\react-native\\Libraries\\Vibration\\Vibration.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var warning = _$$_REQUIRE(_dependencyMap[0], "fbjs/lib/warning");

  var VibrationIOS = {
    vibrate: function vibrate() {
      warning('VibrationIOS is not supported on this platform!');
    }
  };
  module.exports = VibrationIOS;
},633,[211],"node_modules\\react-native\\Libraries\\Vibration\\VibrationIOS.android.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var ReactNative = _$$_REQUIRE(_dependencyMap[0], "ReactNative");

  var UIManager = _$$_REQUIRE(_dependencyMap[1], "UIManager");

  module.exports = function takeSnapshot(view, options) {
    if (typeof view !== 'number' && view !== 'window') {
      view = ReactNative.findNodeHandle(view) || 'window';
    }

    return UIManager.__takeSnapshot(view, options);
  };
},634,[178,145],"node_modules\\react-native\\Libraries\\ReactNative\\takeSnapshot.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var PropTypes = _$$_REQUIRE(_dependencyMap[0], "prop-types");

  var PointPropType = PropTypes.shape({
    x: PropTypes.number,
    y: PropTypes.number
  });
  module.exports = PointPropType;
},635,[161],"node_modules\\react-native\\Libraries\\StyleSheet\\PointPropType.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireWildcard = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireWildcard");

  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "Button", {
    enumerable: true,
    get: function get() {
      return _Button.default;
    }
  });
  Object.defineProperty(exports, "Icon", {
    enumerable: true,
    get: function get() {
      return _Icon.default;
    }
  });
  Object.defineProperty(exports, "List", {
    enumerable: true,
    get: function get() {
      return _List.default;
    }
  });
  Object.defineProperty(exports, "ListItem", {
    enumerable: true,
    get: function get() {
      return _ListItem.default;
    }
  });
  Object.defineProperty(exports, "SocialIcon", {
    enumerable: true,
    get: function get() {
      return _SocialIcon.default;
    }
  });
  Object.defineProperty(exports, "Badge", {
    enumerable: true,
    get: function get() {
      return _badge.default;
    }
  });
  Object.defineProperty(exports, "CheckBox", {
    enumerable: true,
    get: function get() {
      return _CheckBox.default;
    }
  });
  Object.defineProperty(exports, "Divider", {
    enumerable: true,
    get: function get() {
      return _Divider.default;
    }
  });
  Object.defineProperty(exports, "Slider", {
    enumerable: true,
    get: function get() {
      return _Slider.default;
    }
  });
  Object.defineProperty(exports, "ButtonGroup", {
    enumerable: true,
    get: function get() {
      return _ButtonGroup.default;
    }
  });
  Object.defineProperty(exports, "Card", {
    enumerable: true,
    get: function get() {
      return _Card.default;
    }
  });
  Object.defineProperty(exports, "Tile", {
    enumerable: true,
    get: function get() {
      return _Tile.default;
    }
  });
  Object.defineProperty(exports, "Avatar", {
    enumerable: true,
    get: function get() {
      return _Avatar.default;
    }
  });
  Object.defineProperty(exports, "Rating", {
    enumerable: true,
    get: function get() {
      return _Rating.default;
    }
  });
  Object.defineProperty(exports, "Header", {
    enumerable: true,
    get: function get() {
      return _Header.default;
    }
  });
  Object.defineProperty(exports, "PricingCard", {
    enumerable: true,
    get: function get() {
      return _PricingCard.default;
    }
  });
  Object.defineProperty(exports, "FormInput", {
    enumerable: true,
    get: function get() {
      return _FormInput.default;
    }
  });
  Object.defineProperty(exports, "FormLabel", {
    enumerable: true,
    get: function get() {
      return _FormLabel.default;
    }
  });
  Object.defineProperty(exports, "FormValidationMessage", {
    enumerable: true,
    get: function get() {
      return _FormValidationMessage.default;
    }
  });
  Object.defineProperty(exports, "SearchBar", {
    enumerable: true,
    get: function get() {
      return _Search.default;
    }
  });
  Object.defineProperty(exports, "Text", {
    enumerable: true,
    get: function get() {
      return _Text.default;
    }
  });
  Object.defineProperty(exports, "colors", {
    enumerable: true,
    get: function get() {
      return _colors.default;
    }
  });
  Object.defineProperty(exports, "getIconType", {
    enumerable: true,
    get: function get() {
      return _getIconType.default;
    }
  });
  Object.defineProperty(exports, "registerCustomIconType", {
    enumerable: true,
    get: function get() {
      return _getIconType.registerCustomIconType;
    }
  });
  Object.defineProperty(exports, "normalize", {
    enumerable: true,
    get: function get() {
      return _normalizeText.default;
    }
  });

  var _Button = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "./buttons/Button"));

  var _Icon = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "./icons/Icon"));

  var _List = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "./list/List"));

  var _ListItem = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "./list/ListItem"));

  var _SocialIcon = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "./social/SocialIcon"));

  var _badge = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "./badge/badge"));

  var _CheckBox = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "./checkbox/CheckBox"));

  var _Divider = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "./divider/Divider"));

  var _Slider = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "./slider/Slider"));

  var _ButtonGroup = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "./buttons/ButtonGroup"));

  var _Card = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[12], "./card/Card"));

  var _Tile = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[13], "./tile/Tile"));

  var _Avatar = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[14], "./avatar/Avatar"));

  var _Rating = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[15], "./rating/Rating"));

  var _Header = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[16], "./header/Header"));

  var _PricingCard = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[17], "./pricing/PricingCard"));

  var _FormInput = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[18], "./form/FormInput"));

  var _FormLabel = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[19], "./form/FormLabel"));

  var _FormValidationMessage = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[20], "./form/FormValidationMessage"));

  var _Search = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[21], "./input/Search"));

  var _Text = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[22], "./text/Text"));

  var _colors = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[23], "./config/colors"));

  var _getIconType = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[24], "./helpers/getIconType"));

  var _normalizeText = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[25], "./helpers/normalizeText"));
},636,[637,23,638,715,716,717,720,719,721,722,723,724,725,727,718,729,735,740,741,742,743,744,640,639,693,642],"node_modules\\react-native-elements\\src\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

            if (desc.get || desc.set) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  module.exports = _interopRequireWildcard;
},637,[],"node_modules\\@babel\\runtime\\helpers\\interopRequireWildcard.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _objectSpread2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread"));

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/objectWithoutProperties"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "prop-types"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[6], "react-native");

  var _colors = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "../config/colors"));

  var _Text = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "../text/Text"));

  var _MaterialIcons = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "react-native-vector-icons/MaterialIcons"));

  var _getIconType = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "../helpers/getIconType"));

  var _normalizeText = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "../helpers/normalizeText"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[12], "../config/ViewPropTypes"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\buttons\\Button.js";

  var log = function log() {
    console.log('please attach method to this component');
  };

  var Button = function Button(props) {
    var disabled = props.disabled,
        loading = props.loading,
        loadingRight = props.loadingRight,
        activityIndicatorStyle = props.activityIndicatorStyle,
        buttonStyle = props.buttonStyle,
        borderRadius = props.borderRadius,
        title = props.title,
        onPress = props.onPress,
        icon = props.icon,
        iconComponent = props.iconComponent,
        secondary = props.secondary,
        secondary2 = props.secondary2,
        secondary3 = props.secondary3,
        primary1 = props.primary1,
        primary2 = props.primary2,
        backgroundColor = props.backgroundColor,
        color = props.color,
        fontSize = props.fontSize,
        underlayColor = props.underlayColor,
        raised = props.raised,
        textStyle = props.textStyle,
        large = props.large,
        iconRight = props.iconRight,
        fontWeight = props.fontWeight,
        disabledStyle = props.disabledStyle,
        disabledTextStyle = props.disabledTextStyle,
        fontFamily = props.fontFamily,
        containerViewStyle = props.containerViewStyle,
        rounded = props.rounded,
        outline = props.outline,
        transparent = props.transparent,
        textNumberOfLines = props.textNumberOfLines,
        textEllipsizeMode = props.textEllipsizeMode,
        allowFontScaling = props.allowFontScaling,
        attributes = (0, _objectWithoutProperties2.default)(props, ["disabled", "loading", "loadingRight", "activityIndicatorStyle", "buttonStyle", "borderRadius", "title", "onPress", "icon", "iconComponent", "secondary", "secondary2", "secondary3", "primary1", "primary2", "backgroundColor", "color", "fontSize", "underlayColor", "raised", "textStyle", "large", "iconRight", "fontWeight", "disabledStyle", "disabledTextStyle", "fontFamily", "containerViewStyle", "rounded", "outline", "transparent", "textNumberOfLines", "textEllipsizeMode", "allowFontScaling"]);
    var Component = props.Component,
        rightIcon = props.rightIcon,
        leftIcon = props.leftIcon;
    var leftIconElement;

    if (!leftIcon && icon) {
      leftIcon = icon;
    }

    if (leftIcon) {
      var Icon;

      if (iconComponent) {
        Icon = iconComponent;
      } else if (!leftIcon.type) {
        Icon = _MaterialIcons.default;
      } else {
        Icon = (0, _getIconType.default)(leftIcon.type);
      }

      leftIconElement = _react.default.createElement(Icon, (0, _extends2.default)({}, leftIcon, {
        color: leftIcon.color || 'white',
        size: leftIcon.size || (large ? 26 : 18),
        style: [styles.icon, leftIcon.style && leftIcon.style],
        __source: {
          fileName: _jsxFileName,
          lineNumber: 77
        }
      }));
    }

    var rightIconElement;

    if (iconRight || rightIcon) {
      if (!rightIcon) {
        rightIcon = iconRight;
      }

      var _Icon;

      if (iconComponent) {
        _Icon = iconComponent;
      } else if (!rightIcon.type) {
        _Icon = _MaterialIcons.default;
      } else {
        _Icon = (0, _getIconType.default)(rightIcon.type);
      }

      rightIconElement = _react.default.createElement(_Icon, (0, _extends2.default)({}, rightIcon, {
        color: rightIcon.color || 'white',
        size: rightIcon.size || (large ? 26 : 18),
        style: [styles.iconRight, rightIcon.style && rightIcon.style],
        __source: {
          fileName: _jsxFileName,
          lineNumber: 99
        }
      }));
    }

    var loadingElement;

    if (loading) {
      loadingElement = _react.default.createElement(_reactNative.ActivityIndicator, {
        animating: true,
        style: [styles.activityIndicatorStyle, activityIndicatorStyle],
        color: color || 'white',
        size: large && 'large' || 'small',
        __source: {
          fileName: _jsxFileName,
          lineNumber: 110
        }
      });
    }

    if (!Component && _reactNative.Platform.OS === 'ios') {
      Component = _reactNative.TouchableHighlight;
    }

    if (!Component && _reactNative.Platform.OS === 'android') {
      Component = _reactNative.TouchableNativeFeedback;
    }

    if (!Component) {
      Component = _reactNative.TouchableHighlight;
    }

    if (_reactNative.Platform.OS === 'android' && borderRadius && !attributes.background) {
      if (_reactNative.Platform.Version >= 21) {
        attributes.background = _reactNative.TouchableNativeFeedback.Ripple('ThemeAttrAndroid', true);
      } else {
        attributes.background = _reactNative.TouchableNativeFeedback.SelectableBackground();
      }
    }

    var baseFont = {
      color: textStyle && textStyle.color || color || stylesObject.text.color,
      size: textStyle && textStyle.fontSize || fontSize || !large && stylesObject.smallFont.fontSize || stylesObject.text.fontSize
    };
    var textOptions = {};

    if (textNumberOfLines) {
      textOptions.numberOfLines = textNumberOfLines;

      if (textEllipsizeMode) {
        textOptions.ellipsizeMode = textEllipsizeMode;
      }
    }

    return _react.default.createElement(_reactNative.View, {
      style: [styles.container, raised && styles.raised, containerViewStyle, borderRadius && {
        borderRadius: borderRadius
      }],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 157
      }
    }, _react.default.createElement(Component, (0, _extends2.default)({}, attributes, {
      underlayColor: underlayColor || 'transparent',
      onPress: onPress || log,
      disabled: disabled || false,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 165
      }
    }), _react.default.createElement(_reactNative.View, {
      pointerEvents: "box-only",
      style: [styles.button, secondary && {
        backgroundColor: _colors.default.secondary
      }, secondary2 && {
        backgroundColor: _colors.default.secondary2
      }, secondary3 && {
        backgroundColor: _colors.default.secondary3
      }, primary1 && {
        backgroundColor: _colors.default.primary1
      }, primary2 && {
        backgroundColor: _colors.default.primary2
      }, backgroundColor && {
        backgroundColor: backgroundColor
      }, borderRadius && {
        borderRadius: borderRadius
      }, !large && styles.small, rounded && {
        borderRadius: baseFont.size * 3.8,
        paddingHorizontal: !large ? stylesObject.small.padding * 1.5 : stylesObject.button.padding * 1.5
      }, outline && {
        borderWidth: 1,
        backgroundColor: 'transparent',
        borderColor: baseFont.color
      }, transparent && {
        borderWidth: 0,
        backgroundColor: 'transparent'
      }, buttonStyle && buttonStyle, disabled && {
        backgroundColor: _colors.default.disabled
      }, disabled && disabledStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 171
      }
    }, icon && !iconRight || leftIconElement ? leftIconElement : null, loading && !loadingRight && loadingElement, _react.default.createElement(_Text.default, (0, _extends2.default)({
      style: [styles.text, color && {
        color: color
      }, !large && styles.smallFont, fontSize && {
        fontSize: fontSize
      }, textStyle && textStyle, fontWeight && {
        fontWeight: fontWeight
      }, fontFamily && {
        fontFamily: fontFamily
      }, disabled && disabledTextStyle]
    }, textOptions, {
      allowFontScaling: allowFontScaling,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 205
      }
    }), title), loading && loadingRight && loadingElement, icon && iconRight || rightIconElement ? rightIconElement : null)));
  };

  Button.propTypes = {
    buttonStyle: _ViewPropTypes.default.style,
    title: _propTypes.default.string,
    onPress: _propTypes.default.any,
    icon: _propTypes.default.object,
    leftIcon: _propTypes.default.object,
    rightIcon: _propTypes.default.object,
    iconRight: _propTypes.default.object,
    iconComponent: _propTypes.default.any,
    secondary: _propTypes.default.bool,
    secondary2: _propTypes.default.bool,
    secondary3: _propTypes.default.bool,
    primary1: _propTypes.default.bool,
    primary2: _propTypes.default.bool,
    backgroundColor: _propTypes.default.string,
    color: _propTypes.default.string,
    fontSize: _propTypes.default.any,
    underlayColor: _propTypes.default.string,
    raised: _propTypes.default.bool,
    textStyle: _reactNative.Text.propTypes.style,
    disabled: _propTypes.default.bool,
    loading: _propTypes.default.bool,
    activityIndicatorStyle: _ViewPropTypes.default.style,
    loadingRight: _propTypes.default.bool,
    Component: _propTypes.default.any,
    borderRadius: _propTypes.default.number,
    large: _propTypes.default.bool,
    fontWeight: _propTypes.default.string,
    disabledStyle: _ViewPropTypes.default.style,
    disabledTextStyle: _reactNative.Text.propTypes.style,
    fontFamily: _propTypes.default.string,
    containerViewStyle: _ViewPropTypes.default.style,
    rounded: _propTypes.default.bool,
    outline: _propTypes.default.bool,
    transparent: _propTypes.default.bool,
    allowFontScaling: _propTypes.default.bool,
    textNumberOfLines: _propTypes.default.number,
    textEllipsizeMode: _propTypes.default.string
  };
  var stylesObject = {
    container: {
      marginLeft: 15,
      marginRight: 15
    },
    button: {
      padding: 19,
      backgroundColor: _colors.default.primary,
      justifyContent: 'center',
      alignItems: 'center',
      flexDirection: 'row'
    },
    text: {
      color: 'white',
      fontSize: (0, _normalizeText.default)(16)
    },
    icon: {
      marginRight: 10
    },
    iconRight: {
      marginLeft: 10
    },
    small: {
      padding: 12
    },
    smallFont: {
      fontSize: (0, _normalizeText.default)(14)
    },
    activityIndicatorStyle: {
      marginHorizontal: 10,
      height: 0
    },
    raised: (0, _objectSpread2.default)({}, _reactNative.Platform.select({
      ios: {
        shadowColor: 'rgba(0,0,0, .4)',
        shadowOffset: {
          height: 1,
          width: 1
        },
        shadowOpacity: 1,
        shadowRadius: 1
      },
      android: {
        backgroundColor: '#fff',
        elevation: 2
      }
    }))
  };

  var styles = _reactNative.StyleSheet.create(stylesObject);

  var _default = Button;
  exports.default = _default;
},638,[23,148,112,120,161,109,116,639,640,643,693,642,714],"node_modules\\react-native-elements\\src\\buttons\\Button.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _default = {
    primary: '#9E9E9E',
    primary1: '#4d86f7',
    primary2: '#6296f9',
    secondary: '#8F0CE8',
    secondary2: '#00B233',
    secondary3: '#00FF48',
    grey0: '#393e42',
    grey1: '#43484d',
    grey2: '#5e6977',
    grey3: '#86939e',
    grey4: '#bdc6cf',
    grey5: '#e1e8ee',
    dkGreyBg: '#232323',
    greyOutline: '#bbb',
    searchBg: '#303337',
    disabled: '#dadee0',
    white: '#ffffff',
    error: '#ff190c'
  };
  exports.default = _default;
},639,[],"node_modules\\react-native-elements\\src\\config\\colors.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutProperties"));

  var _objectSpread2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/objectSpread"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "prop-types"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[6], "react-native");

  var _fonts = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "../config/fonts"));

  var _normalizeText = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "../helpers/normalizeText"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\text\\Text.js";

  var styles = _reactNative.StyleSheet.create({
    text: (0, _objectSpread2.default)({}, _reactNative.Platform.select({
      android: (0, _objectSpread2.default)({}, _fonts.default.android.regular)
    })),
    bold: (0, _objectSpread2.default)({}, _reactNative.Platform.select({
      android: (0, _objectSpread2.default)({}, _fonts.default.android.bold)
    }))
  });

  var TextElement = function TextElement(props) {
    var style = props.style,
        children = props.children,
        h1 = props.h1,
        h2 = props.h2,
        h3 = props.h3,
        h4 = props.h4,
        fontFamily = props.fontFamily,
        rest = (0, _objectWithoutProperties2.default)(props, ["style", "children", "h1", "h2", "h3", "h4", "fontFamily"]);
    return _react.default.createElement(_reactNative.Text, (0, _extends2.default)({
      style: [styles.text, h1 && {
        fontSize: (0, _normalizeText.default)(40)
      }, h2 && {
        fontSize: (0, _normalizeText.default)(34)
      }, h3 && {
        fontSize: (0, _normalizeText.default)(28)
      }, h4 && {
        fontSize: (0, _normalizeText.default)(22)
      }, h1 && styles.bold, h2 && styles.bold, h3 && styles.bold, h4 && styles.bold, fontFamily && {
        fontFamily: fontFamily
      }, style && style]
    }, rest, {
      __source: {
        fileName: _jsxFileName,
        lineNumber: 28
      }
    }), children);
  };

  TextElement.propTypes = {
    style: _propTypes.default.any,
    h1: _propTypes.default.bool,
    h2: _propTypes.default.bool,
    h3: _propTypes.default.bool,
    h4: _propTypes.default.bool,
    fontFamily: _propTypes.default.string,
    children: _propTypes.default.any
  };
  var _default = TextElement;
  exports.default = _default;
},640,[23,112,120,148,161,109,116,641,642],"node_modules\\react-native-elements\\src\\text\\Text.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _default = {
    ios: {},
    android: {
      regular: {
        fontFamily: 'sans-serif'
      },
      light: {
        fontFamily: 'sans-serif-light'
      },
      condensed: {
        fontFamily: 'sans-serif-condensed'
      },
      condensed_light: {
        fontFamily: 'sans-serif-condensed',
        fontWeight: 'light'
      },
      black: {
        fontFamily: 'sans-serif',
        fontWeight: 'bold'
      },
      thin: {
        fontFamily: 'sans-serif-thin'
      },
      medium: {
        fontFamily: 'sans-serif-medium'
      },
      bold: {
        fontFamily: 'sans-serif',
        fontWeight: 'bold'
      }
    }
  };
  exports.default = _default;
},641,[],"node_modules\\react-native-elements\\src\\config\\fonts.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var React = _$$_REQUIRE(_dependencyMap[0], "react-native");

  var PixelRatio = React.PixelRatio,
      Dimensions = React.Dimensions;
  var pixelRatio = PixelRatio.get();
  var deviceHeight = Dimensions.get('window').height;
  var deviceWidth = Dimensions.get('window').width;

  var normalize = function normalize(size) {
    if (pixelRatio >= 2 && pixelRatio < 3) {
      if (deviceWidth < 360) {
        return size * 0.95;
      }

      if (deviceHeight < 667) {
        return size;
      } else if (deviceHeight >= 667 && deviceHeight <= 735) {
        return size * 1.15;
      }

      return size * 1.25;
    } else if (pixelRatio >= 3 && pixelRatio < 3.5) {
      if (deviceWidth <= 360) {
        return size;
      }

      if (deviceHeight < 667) {
        return size * 1.15;
      }

      if (deviceHeight >= 667 && deviceHeight <= 735) {
        return size * 1.2;
      }

      return size * 1.27;
    } else if (pixelRatio >= 3.5) {
      if (deviceWidth <= 360) {
        return size;
      }

      if (deviceHeight < 667) {
        return size * 1.2;
      }

      if (deviceHeight >= 667 && deviceHeight <= 735) {
        return size * 1.25;
      }

      return size * 1.4;
    } else return size;
  };

  module.exports = normalize;
},642,[116],"node_modules\\react-native-elements\\src\\helpers\\normalizeText.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getImageSource = exports.ToolbarAndroid = exports.TabBarItemIOS = exports.TabBarItem = exports.Button = exports.default = void 0;

  var _createIconSet = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "./lib/create-icon-set"));

  var _MaterialIcons = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "./glyphmaps/MaterialIcons.json"));

  var iconSet = (0, _createIconSet.default)(_MaterialIcons.default, 'Material Icons', 'MaterialIcons.ttf');
  var _default = iconSet;
  exports.default = _default;
  var Button = iconSet.Button;
  exports.Button = Button;
  var TabBarItem = iconSet.TabBarItem;
  exports.TabBarItem = TabBarItem;
  var TabBarItemIOS = iconSet.TabBarItemIOS;
  exports.TabBarItemIOS = TabBarItemIOS;
  var ToolbarAndroid = iconSet.ToolbarAndroid;
  exports.ToolbarAndroid = ToolbarAndroid;
  var getImageSource = iconSet.getImageSource;
  exports.getImageSource = getImageSource;
},643,[23,644,692],"node_modules\\react-native-vector-icons\\MaterialIcons.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _interopRequireWildcard = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/interopRequireWildcard");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createIconSet;
  exports.DEFAULT_ICON_COLOR = exports.DEFAULT_ICON_SIZE = exports.NativeIconAPI = void 0;

  var _toConsumableArray2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/toConsumableArray"));

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/objectWithoutProperties"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/createClass"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf3 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/getPrototypeOf"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/inherits"));

  var _assertThisInitialized2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "@babel/runtime/helpers/assertThisInitialized"));

  var _defineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "@babel/runtime/helpers/defineProperty"));

  var _react = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[12], "react"));

  var _index = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[13], "./../../react-transform-hmr/lib/index.js"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[14], "prop-types"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[15], "./react-native");

  var _ensureNativeModuleAvailable = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[16], "./ensure-native-module-available"));

  var _iconButton = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[17], "./icon-button"));

  var _tabBarItemIos = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[18], "./tab-bar-item-ios"));

  var _toolbarAndroid = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[19], "./toolbar-android"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-vector-icons\\lib\\create-icon-set.js";
  var _components = {
    Icon: {
      displayName: "Icon",
      isInFunction: true
    }
  };

  var _reactTransformHmrLibIndexJs2 = (0, _index.default)({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-vector-icons\\lib\\create-icon-set.js",
    components: _components,
    locals: [module],
    imports: [_react.default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var NativeIconAPI = _reactNative.NativeModules.RNVectorIconsManager || _reactNative.NativeModules.RNVectorIconsModule;
  exports.NativeIconAPI = NativeIconAPI;
  var DEFAULT_ICON_SIZE = 12;
  exports.DEFAULT_ICON_SIZE = DEFAULT_ICON_SIZE;
  var DEFAULT_ICON_COLOR = 'black';
  exports.DEFAULT_ICON_COLOR = DEFAULT_ICON_COLOR;

  function createIconSet(glyphMap, fontFamily, fontFile, fontStyle) {
    var fontBasename = fontFile ? fontFile.replace(/\.(otf|ttf)$/, '') : fontFamily;

    var fontReference = _reactNative.Platform.select({
      windows: "Assets/" + fontFile + "#" + fontFamily,
      android: fontBasename,
      web: fontBasename,
      default: fontFamily
    });

    var IconNamePropType = _propTypes.default.oneOf(Object.keys(glyphMap));

    var Icon = function (_PureComponent) {
      (0, _inherits2.default)(Icon, _PureComponent);

      function Icon() {
        var _getPrototypeOf2;

        var _this;

        (0, _classCallCheck2.default)(this, Icon);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(Icon)).call.apply(_getPrototypeOf2, [this].concat(args)));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "root", null);
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleRef", function (ref) {
          _this.root = ref;
        });
        return _this;
      }

      (0, _createClass2.default)(Icon, [{
        key: "setNativeProps",
        value: function setNativeProps(nativeProps) {
          if (this.root) {
            this.root.setNativeProps(nativeProps);
          }
        }
      }, {
        key: "render",
        value: function render() {
          var _this$props = this.props,
              name = _this$props.name,
              size = _this$props.size,
              color = _this$props.color,
              style = _this$props.style,
              children = _this$props.children,
              props = (0, _objectWithoutProperties2.default)(_this$props, ["name", "size", "color", "style", "children"]);
          var glyph = name ? glyphMap[name] || '?' : '';

          if (typeof glyph === 'number') {
            glyph = String.fromCharCode(glyph);
          }

          var styleDefaults = {
            fontSize: size,
            color: color
          };
          var styleOverrides = {
            fontFamily: fontReference,
            fontWeight: 'normal',
            fontStyle: 'normal'
          };
          props.style = [styleDefaults, style, styleOverrides, fontStyle || {}];
          props.ref = this.handleRef;
          return _react.default.createElement(_reactNative.Text, (0, _extends2.default)({}, props, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 92
            }
          }), glyph, children);
        }
      }]);
      return Icon;
    }(_react.PureComponent);

    (0, _defineProperty2.default)(Icon, "propTypes", {
      allowFontScaling: _propTypes.default.bool,
      name: IconNamePropType,
      size: _propTypes.default.number,
      color: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
      children: _propTypes.default.node,
      style: _propTypes.default.any
    });
    (0, _defineProperty2.default)(Icon, "defaultProps", {
      size: DEFAULT_ICON_SIZE,
      allowFontScaling: false
    });
    Icon = _wrapComponent("Icon")(Icon);
    var imageSourceCache = {};

    function getImageSource(name) {
      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ICON_SIZE;
      var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ICON_COLOR;
      (0, _ensureNativeModuleAvailable.default)();
      var glyph = glyphMap[name] || '?';

      if (typeof glyph === 'number') {
        glyph = String.fromCharCode(glyph);
      }

      var processedColor = (0, _reactNative.processColor)(color);
      var cacheKey = glyph + ":" + size + ":" + processedColor;

      var scale = _reactNative.PixelRatio.get();

      return new Promise(function (resolve, reject) {
        var cached = imageSourceCache[cacheKey];

        if (typeof cached !== 'undefined') {
          if (!cached || cached instanceof Error) {
            reject(cached);
          } else {
            resolve({
              uri: cached,
              scale: scale
            });
          }
        } else {
          NativeIconAPI.getImageForFont(fontReference, glyph, size, processedColor, function (err, image) {
            var error = typeof err === 'string' ? new Error(err) : err;
            imageSourceCache[cacheKey] = image || error || false;

            if (!error && image) {
              resolve({
                uri: image,
                scale: scale
              });
            } else {
              reject(error);
            }
          });
        }
      });
    }

    function loadFont() {
      var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : fontFile;

      if (_reactNative.Platform.OS === 'ios') {
        (0, _ensureNativeModuleAvailable.default)();

        if (!file) {
          return Promise.reject(new Error('Unable to load font, because no file was specified. '));
        }

        return NativeIconAPI.loadFontWithFileName.apply(NativeIconAPI, (0, _toConsumableArray2.default)(file.split('.')));
      }

      return Promise.resolve();
    }

    function hasIcon(name) {
      return Object.prototype.hasOwnProperty.call(glyphMap, name);
    }

    function getRawGlyphMap() {
      return glyphMap;
    }

    function getFontFamily() {
      return fontReference;
    }

    Icon.Button = (0, _iconButton.default)(Icon);
    Icon.TabBarItem = (0, _tabBarItemIos.default)(IconNamePropType, getImageSource);
    Icon.TabBarItemIOS = Icon.TabBarItem;
    Icon.ToolbarAndroid = (0, _toolbarAndroid.default)(IconNamePropType, getImageSource);
    Icon.getImageSource = getImageSource;
    Icon.loadFont = loadFont;
    Icon.hasIcon = hasIcon;
    Icon.getRawGlyphMap = getRawGlyphMap;
    Icon.getFontFamily = getFontFamily;
    return Icon;
  }
},644,[23,637,128,112,120,24,25,26,29,30,28,32,109,280,161,645,646,647,689,691],"node_modules\\react-native-vector-icons\\lib\\create-icon-set.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactNative = _$$_REQUIRE(_dependencyMap[0], "react-native");

  Object.keys(_reactNative).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _reactNative[key];
      }
    });
  });
},645,[116],"node_modules\\react-native-vector-icons\\lib\\react-native.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = ensureNativeModuleAvailable;

  var _reactNative = _$$_REQUIRE(_dependencyMap[0], "./react-native");

  var NativeIconAPI = _reactNative.NativeModules.RNVectorIconsManager || _reactNative.NativeModules.RNVectorIconsModule;

  function ensureNativeModuleAvailable() {
    if (!NativeIconAPI) {
      if (_reactNative.Platform.OS === 'android') {
        throw new Error('RNVectorIconsModule not available, did you properly integrate the module? Try running `react-native link react-native-vector-icons` and recompiling.');
      }

      throw new Error('RNVectorIconsManager not available, did you add the library to your project and link with libRNVectorIcons.a? Try running `react-native link react-native-vector-icons` and recompiling.');
    }
  }
},646,[645],"node_modules\\react-native-vector-icons\\lib\\ensure-native-module-available.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _interopRequireWildcard = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/interopRequireWildcard");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createIconButtonComponent;

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/objectWithoutProperties"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/createClass"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/getPrototypeOf"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/inherits"));

  var _defineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/defineProperty"));

  var _react = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[10], "react"));

  var _index = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "./../../react-transform-hmr/lib/index.js"));

  var _isString = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[12], "lodash/isString"));

  var _omit = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[13], "lodash/omit"));

  var _pick = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[14], "lodash/pick"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[15], "prop-types"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[16], "./react-native");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-vector-icons\\lib\\icon-button.js";
  var _components = {
    IconButton: {
      displayName: "IconButton",
      isInFunction: true
    }
  };

  var _reactTransformHmrLibIndexJs2 = (0, _index.default)({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-vector-icons\\lib\\icon-button.js",
    components: _components,
    locals: [module],
    imports: [_react.default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var styles = _reactNative.StyleSheet.create({
    container: {
      flexDirection: 'row',
      justifyContent: 'flex-start',
      alignItems: 'center',
      padding: 8
    },
    touchable: {
      overflow: 'hidden'
    },
    icon: {
      marginRight: 10
    },
    text: {
      fontWeight: '600',
      backgroundColor: 'transparent'
    }
  });

  var IOS7_BLUE = '#007AFF';
  var TEXT_PROP_NAMES = ['ellipsizeMode', 'numberOfLines', 'textBreakStrategy', 'selectable', 'suppressHighlighting', 'allowFontScaling', 'adjustsFontSizeToFit', 'minimumFontScale'];
  var TOUCHABLE_PROP_NAMES = ['accessible', 'accessibilityLabel', 'accessibilityHint', 'accessibilityComponentType', 'accessibilityRole', 'accessibilityStates', 'accessibilityTraits', 'onFocus', 'onBlur', 'disabled', 'onPress', 'onPressIn', 'onPressOut', 'onLayout', 'onLongPress', 'nativeID', 'testID', 'delayPressIn', 'delayPressOut', 'delayLongPress', 'activeOpacity', 'underlayColor', 'selectionColor', 'onShowUnderlay', 'onHideUnderlay', 'hasTVPreferredFocus', 'tvParallaxProperties'];

  function createIconButtonComponent(Icon) {
    var _class, _temp;

    return _wrapComponent("IconButton")((_temp = _class = function (_PureComponent) {
      (0, _inherits2.default)(IconButton, _PureComponent);

      function IconButton() {
        (0, _classCallCheck2.default)(this, IconButton);
        return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(IconButton).apply(this, arguments));
      }

      (0, _createClass2.default)(IconButton, [{
        key: "render",
        value: function render() {
          var _this$props = this.props,
              style = _this$props.style,
              iconStyle = _this$props.iconStyle,
              children = _this$props.children,
              restProps = (0, _objectWithoutProperties2.default)(_this$props, ["style", "iconStyle", "children"]);
          var iconProps = (0, _pick.default)(restProps, TEXT_PROP_NAMES, 'style', 'name', 'size', 'color');
          var touchableProps = (0, _pick.default)(restProps, TOUCHABLE_PROP_NAMES);
          var props = (0, _omit.default)(restProps, Object.keys(iconProps), Object.keys(touchableProps), 'iconStyle', 'borderRadius', 'backgroundColor');
          iconProps.style = iconStyle ? [styles.icon, iconStyle] : styles.icon;
          var colorStyle = (0, _pick.default)(this.props, 'color');
          var blockStyle = (0, _pick.default)(this.props, 'backgroundColor', 'borderRadius');
          return _react.default.createElement(_reactNative.TouchableHighlight, (0, _extends2.default)({
            style: [styles.touchable, blockStyle]
          }, touchableProps, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 118
            }
          }), _react.default.createElement(_reactNative.View, (0, _extends2.default)({
            style: [styles.container, blockStyle, style]
          }, props, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 122
            }
          }), _react.default.createElement(Icon, (0, _extends2.default)({}, iconProps, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 123
            }
          })), (0, _isString.default)(children) ? _react.default.createElement(_reactNative.Text, {
            style: [styles.text, colorStyle],
            __source: {
              fileName: _jsxFileName,
              lineNumber: 125
            }
          }, children) : children));
        }
      }]);
      return IconButton;
    }(_react.PureComponent), (0, _defineProperty2.default)(_class, "propTypes", {
      backgroundColor: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
      borderRadius: _propTypes.default.number,
      color: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
      size: _propTypes.default.number,
      iconStyle: _propTypes.default.any,
      style: _propTypes.default.any,
      children: _propTypes.default.node
    }), (0, _defineProperty2.default)(_class, "defaultProps", {
      backgroundColor: IOS7_BLUE,
      borderRadius: 5,
      color: 'white',
      size: 20
    }), _temp));
  }
},647,[23,637,112,120,24,25,26,29,30,32,109,280,648,649,685,161,645],"node_modules\\react-native-vector-icons\\lib\\icon-button.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseGetTag = _$$_REQUIRE(_dependencyMap[0], "./_baseGetTag"),
      isArray = _$$_REQUIRE(_dependencyMap[1], "./isArray"),
      isObjectLike = _$$_REQUIRE(_dependencyMap[2], "./isObjectLike");

  var stringTag = '[object String]';

  function isString(value) {
    return typeof value == 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
  }

  module.exports = isString;
},648,[307,349,358],"node_modules\\lodash\\isString.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var arrayMap = _$$_REQUIRE(_dependencyMap[0], "./_arrayMap"),
      baseClone = _$$_REQUIRE(_dependencyMap[1], "./_baseClone"),
      baseUnset = _$$_REQUIRE(_dependencyMap[2], "./_baseUnset"),
      castPath = _$$_REQUIRE(_dependencyMap[3], "./_castPath"),
      copyObject = _$$_REQUIRE(_dependencyMap[4], "./_copyObject"),
      customOmitClone = _$$_REQUIRE(_dependencyMap[5], "./_customOmitClone"),
      flatRest = _$$_REQUIRE(_dependencyMap[6], "./_flatRest"),
      getAllKeysIn = _$$_REQUIRE(_dependencyMap[7], "./_getAllKeysIn");

  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;
  var omit = flatRest(function (object, paths) {
    var result = {};

    if (object == null) {
      return result;
    }

    var isDeep = false;
    paths = arrayMap(paths, function (path) {
      path = castPath(path, object);
      isDeep || (isDeep = path.length > 1);
      return path;
    });
    copyObject(object, getAllKeysIn(object), result);

    if (isDeep) {
      result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
    }

    var length = paths.length;

    while (length--) {
      baseUnset(result, paths[length]);
    }

    return result;
  });
  module.exports = omit;
},649,[391,650,677,383,410,681,683,663],"node_modules\\lodash\\omit.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Stack = _$$_REQUIRE(_dependencyMap[0], "./_Stack"),
      arrayEach = _$$_REQUIRE(_dependencyMap[1], "./_arrayEach"),
      assignValue = _$$_REQUIRE(_dependencyMap[2], "./_assignValue"),
      baseAssign = _$$_REQUIRE(_dependencyMap[3], "./_baseAssign"),
      baseAssignIn = _$$_REQUIRE(_dependencyMap[4], "./_baseAssignIn"),
      cloneBuffer = _$$_REQUIRE(_dependencyMap[5], "./_cloneBuffer"),
      copyArray = _$$_REQUIRE(_dependencyMap[6], "./_copyArray"),
      copySymbols = _$$_REQUIRE(_dependencyMap[7], "./_copySymbols"),
      copySymbolsIn = _$$_REQUIRE(_dependencyMap[8], "./_copySymbolsIn"),
      getAllKeys = _$$_REQUIRE(_dependencyMap[9], "./_getAllKeys"),
      getAllKeysIn = _$$_REQUIRE(_dependencyMap[10], "./_getAllKeysIn"),
      getTag = _$$_REQUIRE(_dependencyMap[11], "./_getTag"),
      initCloneArray = _$$_REQUIRE(_dependencyMap[12], "./_initCloneArray"),
      initCloneByTag = _$$_REQUIRE(_dependencyMap[13], "./_initCloneByTag"),
      initCloneObject = _$$_REQUIRE(_dependencyMap[14], "./_initCloneObject"),
      isArray = _$$_REQUIRE(_dependencyMap[15], "./isArray"),
      isBuffer = _$$_REQUIRE(_dependencyMap[16], "./isBuffer"),
      isMap = _$$_REQUIRE(_dependencyMap[17], "./isMap"),
      isObject = _$$_REQUIRE(_dependencyMap[18], "./isObject"),
      isSet = _$$_REQUIRE(_dependencyMap[19], "./isSet"),
      keys = _$$_REQUIRE(_dependencyMap[20], "./keys");

  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;

  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result,
        isDeep = bitmask & CLONE_DEEP_FLAG,
        isFlat = bitmask & CLONE_FLAT_FLAG,
        isFull = bitmask & CLONE_SYMBOLS_FLAG;

    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }

    if (result !== undefined) {
      return result;
    }

    if (!isObject(value)) {
      return value;
    }

    var isArr = isArray(value);

    if (isArr) {
      result = initCloneArray(value);

      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value),
          isFunc = tag == funcTag || tag == genTag;

      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }

      if (tag == objectTag || tag == argsTag || isFunc && !object) {
        result = isFlat || isFunc ? {} : initCloneObject(value);

        if (!isDeep) {
          return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }

        result = initCloneByTag(value, tag, isDeep);
      }
    }

    stack || (stack = new Stack());
    var stacked = stack.get(value);

    if (stacked) {
      return stacked;
    }

    stack.set(value, result);

    if (isSet(value)) {
      value.forEach(function (subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
      return result;
    }

    if (isMap(value)) {
      value.forEach(function (subValue, key) {
        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
    var props = isArr ? undefined : keysFunc(value);
    arrayEach(props || value, function (subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      }

      assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }

  module.exports = baseClone;
},650,[289,651,407,652,653,657,658,659,660,346,663,372,664,665,671,349,359,673,313,675,353],"node_modules\\lodash\\_baseClone.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }

    return array;
  }

  module.exports = arrayEach;
},651,[],"node_modules\\lodash\\_arrayEach.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var copyObject = _$$_REQUIRE(_dependencyMap[0], "./_copyObject"),
      keys = _$$_REQUIRE(_dependencyMap[1], "./keys");

  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }

  module.exports = baseAssign;
},652,[410,353],"node_modules\\lodash\\_baseAssign.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var copyObject = _$$_REQUIRE(_dependencyMap[0], "./_copyObject"),
      keysIn = _$$_REQUIRE(_dependencyMap[1], "./keysIn");

  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
  }

  module.exports = baseAssignIn;
},653,[410,654],"node_modules\\lodash\\_baseAssignIn.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var arrayLikeKeys = _$$_REQUIRE(_dependencyMap[0], "./_arrayLikeKeys"),
      baseKeysIn = _$$_REQUIRE(_dependencyMap[1], "./_baseKeysIn"),
      isArrayLike = _$$_REQUIRE(_dependencyMap[2], "./isArrayLike");

  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  module.exports = keysIn;
},654,[354,655,371],"node_modules\\lodash\\keysIn.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var isObject = _$$_REQUIRE(_dependencyMap[0], "./isObject"),
      isPrototype = _$$_REQUIRE(_dependencyMap[1], "./_isPrototype"),
      nativeKeysIn = _$$_REQUIRE(_dependencyMap[2], "./_nativeKeysIn");

  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }

    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }

    return result;
  }

  module.exports = baseKeysIn;
},655,[313,368,656],"node_modules\\lodash\\_baseKeysIn.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function nativeKeysIn(object) {
    var result = [];

    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }

    return result;
  }

  module.exports = nativeKeysIn;
},656,[],"node_modules\\lodash\\_nativeKeysIn.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var root = _$$_REQUIRE(_dependencyMap[0], "./_root");

  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root.Buffer : undefined,
      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }

    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }

  module.exports = cloneBuffer;
},657,[309],"node_modules\\lodash\\_cloneBuffer.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function copyArray(source, array) {
    var index = -1,
        length = source.length;
    array || (array = Array(length));

    while (++index < length) {
      array[index] = source[index];
    }

    return array;
  }

  module.exports = copyArray;
},658,[],"node_modules\\lodash\\_copyArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var copyObject = _$$_REQUIRE(_dependencyMap[0], "./_copyObject"),
      getSymbols = _$$_REQUIRE(_dependencyMap[1], "./_getSymbols");

  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }

  module.exports = copySymbols;
},659,[410,350],"node_modules\\lodash\\_copySymbols.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var copyObject = _$$_REQUIRE(_dependencyMap[0], "./_copyObject"),
      getSymbolsIn = _$$_REQUIRE(_dependencyMap[1], "./_getSymbolsIn");

  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  }

  module.exports = copySymbolsIn;
},660,[410,661],"node_modules\\lodash\\_copySymbolsIn.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var arrayPush = _$$_REQUIRE(_dependencyMap[0], "./_arrayPush"),
      getPrototype = _$$_REQUIRE(_dependencyMap[1], "./_getPrototype"),
      getSymbols = _$$_REQUIRE(_dependencyMap[2], "./_getSymbols"),
      stubArray = _$$_REQUIRE(_dependencyMap[3], "./stubArray");

  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
    var result = [];

    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }

    return result;
  };
  module.exports = getSymbolsIn;
},661,[348,662,350,352],"node_modules\\lodash\\_getSymbolsIn.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var overArg = _$$_REQUIRE(_dependencyMap[0], "./_overArg");

  var getPrototype = overArg(Object.getPrototypeOf, Object);
  module.exports = getPrototype;
},662,[370],"node_modules\\lodash\\_getPrototype.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseGetAllKeys = _$$_REQUIRE(_dependencyMap[0], "./_baseGetAllKeys"),
      getSymbolsIn = _$$_REQUIRE(_dependencyMap[1], "./_getSymbolsIn"),
      keysIn = _$$_REQUIRE(_dependencyMap[2], "./keysIn");

  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }

  module.exports = getAllKeysIn;
},663,[347,661,654],"node_modules\\lodash\\_getAllKeysIn.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function initCloneArray(array) {
    var length = array.length,
        result = new array.constructor(length);

    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }

    return result;
  }

  module.exports = initCloneArray;
},664,[],"node_modules\\lodash\\_initCloneArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var cloneArrayBuffer = _$$_REQUIRE(_dependencyMap[0], "./_cloneArrayBuffer"),
      cloneDataView = _$$_REQUIRE(_dependencyMap[1], "./_cloneDataView"),
      cloneRegExp = _$$_REQUIRE(_dependencyMap[2], "./_cloneRegExp"),
      cloneSymbol = _$$_REQUIRE(_dependencyMap[3], "./_cloneSymbol"),
      cloneTypedArray = _$$_REQUIRE(_dependencyMap[4], "./_cloneTypedArray");

  var boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;

    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);

      case boolTag:
      case dateTag:
        return new Ctor(+object);

      case dataViewTag:
        return cloneDataView(object, isDeep);

      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);

      case mapTag:
        return new Ctor();

      case numberTag:
      case stringTag:
        return new Ctor(object);

      case regexpTag:
        return cloneRegExp(object);

      case setTag:
        return new Ctor();

      case symbolTag:
        return cloneSymbol(object);
    }
  }

  module.exports = initCloneByTag;
},665,[666,667,668,669,670],"node_modules\\lodash\\_initCloneByTag.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Uint8Array = _$$_REQUIRE(_dependencyMap[0], "./_Uint8Array");

  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }

  module.exports = cloneArrayBuffer;
},666,[342],"node_modules\\lodash\\_cloneArrayBuffer.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var cloneArrayBuffer = _$$_REQUIRE(_dependencyMap[0], "./_cloneArrayBuffer");

  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }

  module.exports = cloneDataView;
},667,[666],"node_modules\\lodash\\_cloneDataView.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var reFlags = /\w*$/;

  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  module.exports = cloneRegExp;
},668,[],"node_modules\\lodash\\_cloneRegExp.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Symbol = _$$_REQUIRE(_dependencyMap[0], "./_Symbol");

  var symbolProto = Symbol ? typeof Symbol === "function" ? Symbol.prototype : "@@prototype" : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }

  module.exports = cloneSymbol;
},669,[308],"node_modules\\lodash\\_cloneSymbol.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var cloneArrayBuffer = _$$_REQUIRE(_dependencyMap[0], "./_cloneArrayBuffer");

  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  module.exports = cloneTypedArray;
},670,[666],"node_modules\\lodash\\_cloneTypedArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseCreate = _$$_REQUIRE(_dependencyMap[0], "./_baseCreate"),
      getPrototype = _$$_REQUIRE(_dependencyMap[1], "./_getPrototype"),
      isPrototype = _$$_REQUIRE(_dependencyMap[2], "./_isPrototype");

  function initCloneObject(object) {
    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }

  module.exports = initCloneObject;
},671,[672,662,368],"node_modules\\lodash\\_initCloneObject.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var isObject = _$$_REQUIRE(_dependencyMap[0], "./isObject");

  var objectCreate = Object.create;

  var baseCreate = function () {
    function object() {}

    return function (proto) {
      if (!isObject(proto)) {
        return {};
      }

      if (objectCreate) {
        return objectCreate(proto);
      }

      object.prototype = proto;
      var result = new object();
      object.prototype = undefined;
      return result;
    };
  }();

  module.exports = baseCreate;
},672,[313],"node_modules\\lodash\\_baseCreate.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseIsMap = _$$_REQUIRE(_dependencyMap[0], "./_baseIsMap"),
      baseUnary = _$$_REQUIRE(_dependencyMap[1], "./_baseUnary"),
      nodeUtil = _$$_REQUIRE(_dependencyMap[2], "./_nodeUtil");

  var nodeIsMap = nodeUtil && nodeUtil.isMap;
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
  module.exports = isMap;
},673,[674,365,366],"node_modules\\lodash\\isMap.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var getTag = _$$_REQUIRE(_dependencyMap[0], "./_getTag"),
      isObjectLike = _$$_REQUIRE(_dependencyMap[1], "./isObjectLike");

  var mapTag = '[object Map]';

  function baseIsMap(value) {
    return isObjectLike(value) && getTag(value) == mapTag;
  }

  module.exports = baseIsMap;
},674,[372,358],"node_modules\\lodash\\_baseIsMap.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseIsSet = _$$_REQUIRE(_dependencyMap[0], "./_baseIsSet"),
      baseUnary = _$$_REQUIRE(_dependencyMap[1], "./_baseUnary"),
      nodeUtil = _$$_REQUIRE(_dependencyMap[2], "./_nodeUtil");

  var nodeIsSet = nodeUtil && nodeUtil.isSet;
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
  module.exports = isSet;
},675,[676,365,366],"node_modules\\lodash\\isSet.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var getTag = _$$_REQUIRE(_dependencyMap[0], "./_getTag"),
      isObjectLike = _$$_REQUIRE(_dependencyMap[1], "./isObjectLike");

  var setTag = '[object Set]';

  function baseIsSet(value) {
    return isObjectLike(value) && getTag(value) == setTag;
  }

  module.exports = baseIsSet;
},676,[372,358],"node_modules\\lodash\\_baseIsSet.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var castPath = _$$_REQUIRE(_dependencyMap[0], "./_castPath"),
      last = _$$_REQUIRE(_dependencyMap[1], "./last"),
      parent = _$$_REQUIRE(_dependencyMap[2], "./_parent"),
      toKey = _$$_REQUIRE(_dependencyMap[3], "./_toKey");

  function baseUnset(object, path) {
    path = castPath(path, object);
    object = parent(object, path);
    return object == null || delete object[toKey(last(path))];
  }

  module.exports = baseUnset;
},677,[383,678,679,392],"node_modules\\lodash\\_baseUnset.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function last(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : undefined;
  }

  module.exports = last;
},678,[],"node_modules\\lodash\\last.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseGet = _$$_REQUIRE(_dependencyMap[0], "./_baseGet"),
      baseSlice = _$$_REQUIRE(_dependencyMap[1], "./_baseSlice");

  function parent(object, path) {
    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
  }

  module.exports = parent;
},679,[382,680],"node_modules\\lodash\\_parent.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }

    end = end > length ? length : end;

    if (end < 0) {
      end += length;
    }

    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);

    while (++index < length) {
      result[index] = array[index + start];
    }

    return result;
  }

  module.exports = baseSlice;
},680,[],"node_modules\\lodash\\_baseSlice.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var isPlainObject = _$$_REQUIRE(_dependencyMap[0], "./isPlainObject");

  function customOmitClone(value) {
    return isPlainObject(value) ? undefined : value;
  }

  module.exports = customOmitClone;
},681,[682],"node_modules\\lodash\\_customOmitClone.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseGetTag = _$$_REQUIRE(_dependencyMap[0], "./_baseGetTag"),
      getPrototype = _$$_REQUIRE(_dependencyMap[1], "./_getPrototype"),
      isObjectLike = _$$_REQUIRE(_dependencyMap[2], "./isObjectLike");

  var objectTag = '[object Object]';
  var funcProto = Function.prototype,
      objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);

  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }

    var proto = getPrototype(value);

    if (proto === null) {
      return true;
    }

    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }

  module.exports = isPlainObject;
},682,[307,662,358],"node_modules\\lodash\\isPlainObject.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var flatten = _$$_REQUIRE(_dependencyMap[0], "./flatten"),
      overRest = _$$_REQUIRE(_dependencyMap[1], "./_overRest"),
      setToString = _$$_REQUIRE(_dependencyMap[2], "./_setToString");

  function flatRest(func) {
    return setToString(overRest(func, undefined, flatten), func + '');
  }

  module.exports = flatRest;
},683,[684,413,415],"node_modules\\lodash\\_flatRest.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseFlatten = _$$_REQUIRE(_dependencyMap[0], "./_baseFlatten");

  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, 1) : [];
  }

  module.exports = flatten;
},684,[427],"node_modules\\lodash\\flatten.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var basePick = _$$_REQUIRE(_dependencyMap[0], "./_basePick"),
      flatRest = _$$_REQUIRE(_dependencyMap[1], "./_flatRest");

  var pick = flatRest(function (object, paths) {
    return object == null ? {} : basePick(object, paths);
  });
  module.exports = pick;
},685,[686,683],"node_modules\\lodash\\pick.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var basePickBy = _$$_REQUIRE(_dependencyMap[0], "./_basePickBy"),
      hasIn = _$$_REQUIRE(_dependencyMap[1], "./hasIn");

  function basePick(object, paths) {
    return basePickBy(object, paths, function (value, path) {
      return hasIn(object, path);
    });
  }

  module.exports = basePick;
},686,[687,393],"node_modules\\lodash\\_basePick.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseGet = _$$_REQUIRE(_dependencyMap[0], "./_baseGet"),
      baseSet = _$$_REQUIRE(_dependencyMap[1], "./_baseSet"),
      castPath = _$$_REQUIRE(_dependencyMap[2], "./_castPath");

  function basePickBy(object, paths, predicate) {
    var index = -1,
        length = paths.length,
        result = {};

    while (++index < length) {
      var path = paths[index],
          value = baseGet(object, path);

      if (predicate(value, path)) {
        baseSet(result, castPath(path, object), value);
      }
    }

    return result;
  }

  module.exports = basePickBy;
},687,[382,688,383],"node_modules\\lodash\\_basePickBy.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var assignValue = _$$_REQUIRE(_dependencyMap[0], "./_assignValue"),
      castPath = _$$_REQUIRE(_dependencyMap[1], "./_castPath"),
      isIndex = _$$_REQUIRE(_dependencyMap[2], "./_isIndex"),
      isObject = _$$_REQUIRE(_dependencyMap[3], "./isObject"),
      toKey = _$$_REQUIRE(_dependencyMap[4], "./_toKey");

  function baseSet(object, path, value, customizer) {
    if (!isObject(object)) {
      return object;
    }

    path = castPath(path, object);
    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        nested = object;

    while (nested != null && ++index < length) {
      var key = toKey(path[index]),
          newValue = value;

      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;

        if (newValue === undefined) {
          newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
        }
      }

      assignValue(nested, key, newValue);
      nested = nested[key];
    }

    return object;
  }

  module.exports = baseSet;
},688,[407,383,361,313,392],"node_modules\\lodash\\_baseSet.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _interopRequireWildcard = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/interopRequireWildcard");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createTabBarItemIOSComponent;

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/extends"));

  var _regenerator = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/regenerator"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/createClass"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf3 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/getPrototypeOf"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/inherits"));

  var _assertThisInitialized2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/assertThisInitialized"));

  var _defineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "@babel/runtime/helpers/defineProperty"));

  var _react = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[11], "react"));

  var _index = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[12], "./../../react-transform-hmr/lib/index.js"));

  var _isEqual = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[13], "lodash/isEqual"));

  var _pick = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[14], "lodash/pick"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[15], "prop-types"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[16], "./react-native");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-vector-icons\\lib\\tab-bar-item-ios.js";
  var _components = {
    TabBarItemIOS: {
      displayName: "TabBarItemIOS",
      isInFunction: true
    }
  };

  var _reactTransformHmrLibIndexJs2 = (0, _index.default)({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-vector-icons\\lib\\tab-bar-item-ios.js",
    components: _components,
    locals: [module],
    imports: [_react.default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var ICON_PROP_NAMES = ['iconName', 'iconSize', 'iconColor'];
  var SELECTED_ICON_PROP_NAMES = ICON_PROP_NAMES.concat(['selectedIconName', 'selectedIconColor']);

  var arePropsEqual = function arePropsEqual(keys) {
    return function (prevProps, nextProps) {
      return (0, _isEqual.default)((0, _pick.default)(prevProps, keys), (0, _pick.default)(nextProps, keys));
    };
  };

  var areIconPropsEqual = arePropsEqual(ICON_PROP_NAMES);
  var areSelectedIconPropsEqual = arePropsEqual(SELECTED_ICON_PROP_NAMES);

  function createTabBarItemIOSComponent(IconNamePropType, getImageSource) {
    var _class, _temp;

    return _wrapComponent("TabBarItemIOS")((_temp = _class = function (_PureComponent) {
      (0, _inherits2.default)(TabBarItemIOS, _PureComponent);

      function TabBarItemIOS() {
        var _getPrototypeOf2;

        var _this;

        (0, _classCallCheck2.default)(this, TabBarItemIOS);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(TabBarItemIOS)).call.apply(_getPrototypeOf2, [this].concat(args)));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "state", {
          icon: undefined,
          selectedIcon: undefined
        });
        return _this;
      }

      (0, _createClass2.default)(TabBarItemIOS, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.updateIconSource();
          this.updateSelectedIconSource();
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          if (!areIconPropsEqual(prevProps, this.props)) {
            this.updateIconSource();
          }

          if (!areSelectedIconPropsEqual(prevProps, this.props)) {
            this.updateSelectedIconSource();
          }
        }
      }, {
        key: "updateIconSource",
        value: function updateIconSource() {
          var _this$props, iconName, iconSize, iconColor, icon;

          return _regenerator.default.async(function updateIconSource$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _this$props = this.props, iconName = _this$props.iconName, iconSize = _this$props.iconSize, iconColor = _this$props.iconColor;

                  if (!iconName) {
                    _context.next = 8;
                    break;
                  }

                  _context.next = 4;
                  return _regenerator.default.awrap(getImageSource(iconName, iconSize, iconColor));

                case 4:
                  icon = _context.sent;
                  this.setState({
                    icon: icon
                  });
                  _context.next = 9;
                  break;

                case 8:
                  if (this.state.icon) {
                    this.setState({
                      icon: undefined
                    });
                  }

                case 9:
                case "end":
                  return _context.stop();
              }
            }
          }, null, this);
        }
      }, {
        key: "updateSelectedIconSource",
        value: function updateSelectedIconSource() {
          var _this$props2, iconName, iconColor, iconSize, selectedIconName, selectedIconColor, selectedIcon;

          return _regenerator.default.async(function updateSelectedIconSource$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _this$props2 = this.props, iconName = _this$props2.iconName, iconColor = _this$props2.iconColor, iconSize = _this$props2.iconSize, selectedIconName = _this$props2.selectedIconName, selectedIconColor = _this$props2.selectedIconColor;

                  if (!(selectedIconName || selectedIconColor)) {
                    _context2.next = 8;
                    break;
                  }

                  _context2.next = 4;
                  return _regenerator.default.awrap(getImageSource(selectedIconName || iconName, iconSize, selectedIconColor || iconColor));

                case 4:
                  selectedIcon = _context2.sent;
                  this.setState({
                    selectedIcon: selectedIcon
                  });
                  _context2.next = 9;
                  break;

                case 8:
                  if (this.state.selectedIcon) {
                    this.setState({
                      selectedIcon: undefined
                    });
                  }

                case 9:
                case "end":
                  return _context2.stop();
              }
            }
          }, null, this);
        }
      }, {
        key: "render",
        value: function render() {
          return _react.default.createElement(_reactNative.TabBarIOS.Item, (0, _extends2.default)({}, this.state, this.props, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 93
            }
          }));
        }
      }]);
      return TabBarItemIOS;
    }(_react.PureComponent), (0, _defineProperty2.default)(_class, "propTypes", {
      iconName: IconNamePropType.isRequired,
      selectedIconName: IconNamePropType,
      iconSize: _propTypes.default.number,
      iconColor: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
      selectedIconColor: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number])
    }), (0, _defineProperty2.default)(_class, "defaultProps", {
      iconSize: 30
    }), _temp));
  }
},689,[23,637,112,105,24,25,26,29,30,28,32,109,280,690,685,161,645],"node_modules\\react-native-vector-icons\\lib\\tab-bar-item-ios.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseIsEqual = _$$_REQUIRE(_dependencyMap[0], "./_baseIsEqual");

  function isEqual(value, other) {
    return baseIsEqual(value, other);
  }

  module.exports = isEqual;
},690,[333],"node_modules\\lodash\\isEqual.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _interopRequireWildcard = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/interopRequireWildcard");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createToolbarAndroidComponent;

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/extends"));

  var _objectSpread2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/objectSpread"));

  var _regenerator = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/regenerator"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/createClass"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf3 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/getPrototypeOf"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/inherits"));

  var _assertThisInitialized2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "@babel/runtime/helpers/assertThisInitialized"));

  var _defineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "@babel/runtime/helpers/defineProperty"));

  var _react = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[12], "react"));

  var _index = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[13], "./../../react-transform-hmr/lib/index.js"));

  var _isEqual = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[14], "lodash/isEqual"));

  var _pick = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[15], "lodash/pick"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[16], "prop-types"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[17], "./react-native");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-vector-icons\\lib\\toolbar-android.js";
  var _components = {
    IconToolbarAndroid: {
      displayName: "IconToolbarAndroid",
      isInFunction: true
    }
  };

  var _reactTransformHmrLibIndexJs2 = (0, _index.default)({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-vector-icons\\lib\\toolbar-android.js",
    components: _components,
    locals: [module],
    imports: [_react.default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var ICON_PROP_NAMES = ['iconSize', 'iconColor', 'titleColor'];
  var LOGO_ICON_PROP_NAMES = ICON_PROP_NAMES.concat(['logoName']);
  var NAV_ICON_PROP_NAMES = ICON_PROP_NAMES.concat(['navIconName']);
  var OVERFLOW_ICON_PROP_NAMES = ICON_PROP_NAMES.concat(['overflowIconName']);
  var ACTIONS_PROP_NAMES = ICON_PROP_NAMES.concat(['actions']);

  var arePropsEqual = function arePropsEqual(keys) {
    return function (prevProps, nextProps) {
      return (0, _isEqual.default)((0, _pick.default)(prevProps, keys), (0, _pick.default)(nextProps, keys));
    };
  };

  var areLogoIconPropsEqual = arePropsEqual(LOGO_ICON_PROP_NAMES);
  var areNavIconPropsEqual = arePropsEqual(NAV_ICON_PROP_NAMES);
  var areOverflowIconPropsEqual = arePropsEqual(OVERFLOW_ICON_PROP_NAMES);
  var areActionPropsEqual = arePropsEqual(ACTIONS_PROP_NAMES);

  function createToolbarAndroidComponent(IconNamePropType, getImageSource) {
    var _class, _temp;

    return _wrapComponent("IconToolbarAndroid")((_temp = _class = function (_PureComponent) {
      (0, _inherits2.default)(IconToolbarAndroid, _PureComponent);

      function IconToolbarAndroid() {
        var _getPrototypeOf2;

        var _this;

        (0, _classCallCheck2.default)(this, IconToolbarAndroid);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(IconToolbarAndroid)).call.apply(_getPrototypeOf2, [this].concat(args)));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "state", {
          logo: undefined,
          navIcon: undefined,
          overflowIcon: undefined,
          actions: undefined
        });
        return _this;
      }

      (0, _createClass2.default)(IconToolbarAndroid, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.updateLogoIconSource();
          this.updateNavIconSource();
          this.updateOverflowIconSource();
          this.updateActionIconSources();
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          if (!areLogoIconPropsEqual(prevProps, this.props)) {
            this.updateLogoIconSource();
          }

          if (!areNavIconPropsEqual(prevProps, this.props)) {
            this.updateNavIconSource();
          }

          if (!areOverflowIconPropsEqual(prevProps, this.props)) {
            this.updateOverflowIconSource();
          }

          if (!areActionPropsEqual(prevProps, this.props)) {
            this.updateActionIconSources();
          }
        }
      }, {
        key: "updateLogoIconSource",
        value: function updateLogoIconSource() {
          var _this$props, logoName, iconSize, iconColor, titleColor, logo;

          return _regenerator.default.async(function updateLogoIconSource$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _this$props = this.props, logoName = _this$props.logoName, iconSize = _this$props.iconSize, iconColor = _this$props.iconColor, titleColor = _this$props.titleColor;

                  if (!logoName) {
                    _context.next = 8;
                    break;
                  }

                  _context.next = 4;
                  return _regenerator.default.awrap(getImageSource(logoName, iconSize, iconColor || titleColor));

                case 4:
                  logo = _context.sent;
                  this.setState({
                    logo: logo
                  });
                  _context.next = 9;
                  break;

                case 8:
                  if (this.state.logo) {
                    this.setState({
                      logo: undefined
                    });
                  }

                case 9:
                case "end":
                  return _context.stop();
              }
            }
          }, null, this);
        }
      }, {
        key: "updateNavIconSource",
        value: function updateNavIconSource() {
          var _this$props2, navIconName, iconSize, iconColor, titleColor, navIcon;

          return _regenerator.default.async(function updateNavIconSource$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _this$props2 = this.props, navIconName = _this$props2.navIconName, iconSize = _this$props2.iconSize, iconColor = _this$props2.iconColor, titleColor = _this$props2.titleColor;

                  if (!navIconName) {
                    _context2.next = 8;
                    break;
                  }

                  _context2.next = 4;
                  return _regenerator.default.awrap(getImageSource(navIconName, iconSize, iconColor || titleColor));

                case 4:
                  navIcon = _context2.sent;
                  this.setState({
                    navIcon: navIcon
                  });
                  _context2.next = 9;
                  break;

                case 8:
                  if (this.state.navIcon) {
                    this.setState({
                      navIcon: undefined
                    });
                  }

                case 9:
                case "end":
                  return _context2.stop();
              }
            }
          }, null, this);
        }
      }, {
        key: "updateOverflowIconSource",
        value: function updateOverflowIconSource() {
          var _this$props3, overflowIconName, iconSize, iconColor, titleColor, overflowIcon;

          return _regenerator.default.async(function updateOverflowIconSource$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _this$props3 = this.props, overflowIconName = _this$props3.overflowIconName, iconSize = _this$props3.iconSize, iconColor = _this$props3.iconColor, titleColor = _this$props3.titleColor;

                  if (!overflowIconName) {
                    _context3.next = 8;
                    break;
                  }

                  _context3.next = 4;
                  return _regenerator.default.awrap(getImageSource(overflowIconName, iconSize, iconColor || titleColor));

                case 4:
                  overflowIcon = _context3.sent;
                  this.setState({
                    overflowIcon: overflowIcon
                  });
                  _context3.next = 9;
                  break;

                case 8:
                  if (this.state.overflowIcon) {
                    this.setState({
                      overflowIcon: undefined
                    });
                  }

                case 9:
                case "end":
                  return _context3.stop();
              }
            }
          }, null, this);
        }
      }, {
        key: "updateActionIconSources",
        value: function updateActionIconSources() {
          var _this$props4, actions, iconSize, iconColor, titleColor, updatedActions;

          return _regenerator.default.async(function updateActionIconSources$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _this$props4 = this.props, actions = _this$props4.actions, iconSize = _this$props4.iconSize, iconColor = _this$props4.iconColor, titleColor = _this$props4.titleColor;
                  _context4.next = 3;
                  return _regenerator.default.awrap(Promise.all((actions || []).map(function (action) {
                    if (action.iconName) {
                      return getImageSource(action.iconName, action.iconSize || iconSize, action.iconColor || iconColor || titleColor).then(function (icon) {
                        return (0, _objectSpread2.default)({}, action, {
                          icon: icon
                        });
                      });
                    }

                    return Promise.resolve(action);
                  })));

                case 3:
                  updatedActions = _context4.sent;
                  this.setState({
                    actions: updatedActions
                  });

                case 5:
                case "end":
                  return _context4.stop();
              }
            }
          }, null, this);
        }
      }, {
        key: "render",
        value: function render() {
          return _react.default.createElement(_reactNative.ToolbarAndroid, (0, _extends2.default)({}, this.props, this.state, {
            __source: {
              fileName: _jsxFileName,
              lineNumber: 142
            }
          }));
        }
      }]);
      return IconToolbarAndroid;
    }(_react.PureComponent), (0, _defineProperty2.default)(_class, "propTypes", {
      logoName: IconNamePropType,
      navIconName: IconNamePropType,
      overflowIconName: IconNamePropType,
      actions: _propTypes.default.arrayOf(_propTypes.default.shape({
        title: _propTypes.default.string.isRequired,
        iconName: IconNamePropType,
        iconSize: _propTypes.default.number,
        iconColor: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
        show: _propTypes.default.oneOf(['always', 'ifRoom', 'never']),
        showWithText: _propTypes.default.bool
      })),
      iconSize: _propTypes.default.number,
      iconColor: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
      titleColor: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number])
    }), (0, _defineProperty2.default)(_class, "defaultProps", {
      iconSize: 24
    }), _temp));
  }
},691,[23,637,112,148,105,24,25,26,29,30,28,32,109,280,690,685,161,645],"node_modules\\react-native-vector-icons\\lib\\toolbar-android.js");
__d(function(global, require, _aUnused, _bUnused, module, exports, _cUnused) {
  module.exports = {
  "3d-rotation": 59469,
  "ac-unit": 60219,
  "access-alarm": 57744,
  "access-alarms": 57745,
  "access-time": 57746,
  "accessibility": 59470,
  "accessible": 59668,
  "account-balance": 59471,
  "account-balance-wallet": 59472,
  "account-box": 59473,
  "account-circle": 59475,
  "adb": 58894,
  "add": 57669,
  "add-a-photo": 58425,
  "add-alarm": 57747,
  "add-alert": 57347,
  "add-box": 57670,
  "add-circle": 57671,
  "add-circle-outline": 57672,
  "add-location": 58727,
  "add-shopping-cart": 59476,
  "add-to-photos": 58269,
  "add-to-queue": 57436,
  "adjust": 58270,
  "airline-seat-flat": 58928,
  "airline-seat-flat-angled": 58929,
  "airline-seat-individual-suite": 58930,
  "airline-seat-legroom-extra": 58931,
  "airline-seat-legroom-normal": 58932,
  "airline-seat-legroom-reduced": 58933,
  "airline-seat-recline-extra": 58934,
  "airline-seat-recline-normal": 58935,
  "airplanemode-active": 57749,
  "airplanemode-inactive": 57748,
  "airplay": 57429,
  "airport-shuttle": 60220,
  "alarm": 59477,
  "alarm-add": 59478,
  "alarm-off": 59479,
  "alarm-on": 59480,
  "album": 57369,
  "all-inclusive": 60221,
  "all-out": 59659,
  "android": 59481,
  "announcement": 59482,
  "apps": 58819,
  "archive": 57673,
  "arrow-back": 58820,
  "arrow-downward": 58843,
  "arrow-drop-down": 58821,
  "arrow-drop-down-circle": 58822,
  "arrow-drop-up": 58823,
  "arrow-forward": 58824,
  "arrow-upward": 58840,
  "art-track": 57440,
  "aspect-ratio": 59483,
  "assessment": 59484,
  "assignment": 59485,
  "assignment-ind": 59486,
  "assignment-late": 59487,
  "assignment-return": 59488,
  "assignment-returned": 59489,
  "assignment-turned-in": 59490,
  "assistant": 58271,
  "assistant-photo": 58272,
  "attach-file": 57894,
  "attach-money": 57895,
  "attachment": 58044,
  "audiotrack": 58273,
  "autorenew": 59491,
  "av-timer": 57371,
  "backspace": 57674,
  "backup": 59492,
  "battery-alert": 57756,
  "battery-charging-full": 57763,
  "battery-full": 57764,
  "battery-std": 57765,
  "battery-unknown": 57766,
  "beach-access": 60222,
  "beenhere": 58669,
  "block": 57675,
  "bluetooth": 57767,
  "bluetooth-audio": 58895,
  "bluetooth-connected": 57768,
  "bluetooth-disabled": 57769,
  "bluetooth-searching": 57770,
  "blur-circular": 58274,
  "blur-linear": 58275,
  "blur-off": 58276,
  "blur-on": 58277,
  "book": 59493,
  "bookmark": 59494,
  "bookmark-border": 59495,
  "border-all": 57896,
  "border-bottom": 57897,
  "border-clear": 57898,
  "border-color": 57899,
  "border-horizontal": 57900,
  "border-inner": 57901,
  "border-left": 57902,
  "border-outer": 57903,
  "border-right": 57904,
  "border-style": 57905,
  "border-top": 57906,
  "border-vertical": 57907,
  "branding-watermark": 57451,
  "brightness-1": 58278,
  "brightness-2": 58279,
  "brightness-3": 58280,
  "brightness-4": 58281,
  "brightness-5": 58282,
  "brightness-6": 58283,
  "brightness-7": 58284,
  "brightness-auto": 57771,
  "brightness-high": 57772,
  "brightness-low": 57773,
  "brightness-medium": 57774,
  "broken-image": 58285,
  "brush": 58286,
  "bubble-chart": 59101,
  "bug-report": 59496,
  "build": 59497,
  "burst-mode": 58428,
  "business": 57519,
  "business-center": 60223,
  "cached": 59498,
  "cake": 59369,
  "call": 57520,
  "call-end": 57521,
  "call-made": 57522,
  "call-merge": 57523,
  "call-missed": 57524,
  "call-missed-outgoing": 57572,
  "call-received": 57525,
  "call-split": 57526,
  "call-to-action": 57452,
  "camera": 58287,
  "camera-alt": 58288,
  "camera-enhance": 59644,
  "camera-front": 58289,
  "camera-rear": 58290,
  "camera-roll": 58291,
  "cancel": 58825,
  "card-giftcard": 59638,
  "card-membership": 59639,
  "card-travel": 59640,
  "casino": 60224,
  "cast": 58119,
  "cast-connected": 58120,
  "center-focus-strong": 58292,
  "center-focus-weak": 58293,
  "change-history": 59499,
  "chat": 57527,
  "chat-bubble": 57546,
  "chat-bubble-outline": 57547,
  "check": 58826,
  "check-box": 59444,
  "check-box-outline-blank": 59445,
  "check-circle": 59500,
  "chevron-left": 58827,
  "chevron-right": 58828,
  "child-care": 60225,
  "child-friendly": 60226,
  "chrome-reader-mode": 59501,
  "class": 59502,
  "clear": 57676,
  "clear-all": 57528,
  "close": 58829,
  "closed-caption": 57372,
  "cloud": 58045,
  "cloud-circle": 58046,
  "cloud-done": 58047,
  "cloud-download": 58048,
  "cloud-off": 58049,
  "cloud-queue": 58050,
  "cloud-upload": 58051,
  "code": 59503,
  "collections": 58294,
  "collections-bookmark": 58417,
  "color-lens": 58295,
  "colorize": 58296,
  "comment": 57529,
  "compare": 58297,
  "compare-arrows": 59669,
  "computer": 58122,
  "confirmation-number": 58936,
  "contact-mail": 57552,
  "contact-phone": 57551,
  "contacts": 57530,
  "content-copy": 57677,
  "content-cut": 57678,
  "content-paste": 57679,
  "control-point": 58298,
  "control-point-duplicate": 58299,
  "copyright": 59660,
  "create": 57680,
  "create-new-folder": 58060,
  "credit-card": 59504,
  "crop": 58302,
  "crop-16-9": 58300,
  "crop-3-2": 58301,
  "crop-5-4": 58303,
  "crop-7-5": 58304,
  "crop-din": 58305,
  "crop-free": 58306,
  "crop-landscape": 58307,
  "crop-original": 58308,
  "crop-portrait": 58309,
  "crop-rotate": 58423,
  "crop-square": 58310,
  "dashboard": 59505,
  "data-usage": 57775,
  "date-range": 59670,
  "dehaze": 58311,
  "delete": 59506,
  "delete-forever": 59691,
  "delete-sweep": 57708,
  "description": 59507,
  "desktop-mac": 58123,
  "desktop-windows": 58124,
  "details": 58312,
  "developer-board": 58125,
  "developer-mode": 57776,
  "device-hub": 58165,
  "devices": 57777,
  "devices-other": 58167,
  "dialer-sip": 57531,
  "dialpad": 57532,
  "directions": 58670,
  "directions-bike": 58671,
  "directions-boat": 58674,
  "directions-bus": 58672,
  "directions-car": 58673,
  "directions-railway": 58676,
  "directions-run": 58726,
  "directions-subway": 58675,
  "directions-transit": 58677,
  "directions-walk": 58678,
  "disc-full": 58896,
  "dns": 59509,
  "do-not-disturb": 58898,
  "do-not-disturb-alt": 58897,
  "do-not-disturb-off": 58947,
  "do-not-disturb-on": 58948,
  "dock": 58126,
  "domain": 59374,
  "done": 59510,
  "done-all": 59511,
  "donut-large": 59671,
  "donut-small": 59672,
  "drafts": 57681,
  "drag-handle": 57949,
  "drive-eta": 58899,
  "dvr": 57778,
  "edit": 58313,
  "edit-location": 58728,
  "eject": 59643,
  "email": 57534,
  "enhanced-encryption": 58943,
  "equalizer": 57373,
  "error": 57344,
  "error-outline": 57345,
  "euro-symbol": 59686,
  "ev-station": 58733,
  "event": 59512,
  "event-available": 58900,
  "event-busy": 58901,
  "event-note": 58902,
  "event-seat": 59651,
  "exit-to-app": 59513,
  "expand-less": 58830,
  "expand-more": 58831,
  "explicit": 57374,
  "explore": 59514,
  "exposure": 58314,
  "exposure-neg-1": 58315,
  "exposure-neg-2": 58316,
  "exposure-plus-1": 58317,
  "exposure-plus-2": 58318,
  "exposure-zero": 58319,
  "extension": 59515,
  "face": 59516,
  "fast-forward": 57375,
  "fast-rewind": 57376,
  "favorite": 59517,
  "favorite-border": 59518,
  "featured-play-list": 57453,
  "featured-video": 57454,
  "feedback": 59519,
  "fiber-dvr": 57437,
  "fiber-manual-record": 57441,
  "fiber-new": 57438,
  "fiber-pin": 57450,
  "fiber-smart-record": 57442,
  "file-download": 58052,
  "file-upload": 58054,
  "filter": 58323,
  "filter-1": 58320,
  "filter-2": 58321,
  "filter-3": 58322,
  "filter-4": 58324,
  "filter-5": 58325,
  "filter-6": 58326,
  "filter-7": 58327,
  "filter-8": 58328,
  "filter-9": 58329,
  "filter-9-plus": 58330,
  "filter-b-and-w": 58331,
  "filter-center-focus": 58332,
  "filter-drama": 58333,
  "filter-frames": 58334,
  "filter-hdr": 58335,
  "filter-list": 57682,
  "filter-none": 58336,
  "filter-tilt-shift": 58338,
  "filter-vintage": 58339,
  "find-in-page": 59520,
  "find-replace": 59521,
  "fingerprint": 59661,
  "first-page": 58844,
  "fitness-center": 60227,
  "flag": 57683,
  "flare": 58340,
  "flash-auto": 58341,
  "flash-off": 58342,
  "flash-on": 58343,
  "flight": 58681,
  "flight-land": 59652,
  "flight-takeoff": 59653,
  "flip": 58344,
  "flip-to-back": 59522,
  "flip-to-front": 59523,
  "folder": 58055,
  "folder-open": 58056,
  "folder-shared": 58057,
  "folder-special": 58903,
  "font-download": 57703,
  "format-align-center": 57908,
  "format-align-justify": 57909,
  "format-align-left": 57910,
  "format-align-right": 57911,
  "format-bold": 57912,
  "format-clear": 57913,
  "format-color-fill": 57914,
  "format-color-reset": 57915,
  "format-color-text": 57916,
  "format-indent-decrease": 57917,
  "format-indent-increase": 57918,
  "format-italic": 57919,
  "format-line-spacing": 57920,
  "format-list-bulleted": 57921,
  "format-list-numbered": 57922,
  "format-paint": 57923,
  "format-quote": 57924,
  "format-shapes": 57950,
  "format-size": 57925,
  "format-strikethrough": 57926,
  "format-textdirection-l-to-r": 57927,
  "format-textdirection-r-to-l": 57928,
  "format-underlined": 57929,
  "forum": 57535,
  "forward": 57684,
  "forward-10": 57430,
  "forward-30": 57431,
  "forward-5": 57432,
  "free-breakfast": 60228,
  "fullscreen": 58832,
  "fullscreen-exit": 58833,
  "functions": 57930,
  "g-translate": 59687,
  "gamepad": 58127,
  "games": 57377,
  "gavel": 59662,
  "gesture": 57685,
  "get-app": 59524,
  "gif": 59656,
  "golf-course": 60229,
  "gps-fixed": 57779,
  "gps-not-fixed": 57780,
  "gps-off": 57781,
  "grade": 59525,
  "gradient": 58345,
  "grain": 58346,
  "graphic-eq": 57784,
  "grid-off": 58347,
  "grid-on": 58348,
  "group": 59375,
  "group-add": 59376,
  "group-work": 59526,
  "hd": 57426,
  "hdr-off": 58349,
  "hdr-on": 58350,
  "hdr-strong": 58353,
  "hdr-weak": 58354,
  "headset": 58128,
  "headset-mic": 58129,
  "healing": 58355,
  "hearing": 57379,
  "help": 59527,
  "help-outline": 59645,
  "high-quality": 57380,
  "highlight": 57951,
  "highlight-off": 59528,
  "history": 59529,
  "home": 59530,
  "hot-tub": 60230,
  "hotel": 58682,
  "hourglass-empty": 59531,
  "hourglass-full": 59532,
  "http": 59650,
  "https": 59533,
  "image": 58356,
  "image-aspect-ratio": 58357,
  "import-contacts": 57568,
  "import-export": 57539,
  "important-devices": 59666,
  "inbox": 57686,
  "indeterminate-check-box": 59657,
  "info": 59534,
  "info-outline": 59535,
  "input": 59536,
  "insert-chart": 57931,
  "insert-comment": 57932,
  "insert-drive-file": 57933,
  "insert-emoticon": 57934,
  "insert-invitation": 57935,
  "insert-link": 57936,
  "insert-photo": 57937,
  "invert-colors": 59537,
  "invert-colors-off": 57540,
  "iso": 58358,
  "keyboard": 58130,
  "keyboard-arrow-down": 58131,
  "keyboard-arrow-left": 58132,
  "keyboard-arrow-right": 58133,
  "keyboard-arrow-up": 58134,
  "keyboard-backspace": 58135,
  "keyboard-capslock": 58136,
  "keyboard-hide": 58138,
  "keyboard-return": 58139,
  "keyboard-tab": 58140,
  "keyboard-voice": 58141,
  "kitchen": 60231,
  "label": 59538,
  "label-outline": 59539,
  "landscape": 58359,
  "language": 59540,
  "laptop": 58142,
  "laptop-chromebook": 58143,
  "laptop-mac": 58144,
  "laptop-windows": 58145,
  "last-page": 58845,
  "launch": 59541,
  "layers": 58683,
  "layers-clear": 58684,
  "leak-add": 58360,
  "leak-remove": 58361,
  "lens": 58362,
  "library-add": 57390,
  "library-books": 57391,
  "library-music": 57392,
  "lightbulb-outline": 59663,
  "line-style": 59673,
  "line-weight": 59674,
  "linear-scale": 57952,
  "link": 57687,
  "linked-camera": 58424,
  "list": 59542,
  "live-help": 57542,
  "live-tv": 58937,
  "local-activity": 58687,
  "local-airport": 58685,
  "local-atm": 58686,
  "local-bar": 58688,
  "local-cafe": 58689,
  "local-car-wash": 58690,
  "local-convenience-store": 58691,
  "local-dining": 58710,
  "local-drink": 58692,
  "local-florist": 58693,
  "local-gas-station": 58694,
  "local-grocery-store": 58695,
  "local-hospital": 58696,
  "local-hotel": 58697,
  "local-laundry-service": 58698,
  "local-library": 58699,
  "local-mall": 58700,
  "local-movies": 58701,
  "local-offer": 58702,
  "local-parking": 58703,
  "local-pharmacy": 58704,
  "local-phone": 58705,
  "local-pizza": 58706,
  "local-play": 58707,
  "local-post-office": 58708,
  "local-printshop": 58709,
  "local-see": 58711,
  "local-shipping": 58712,
  "local-taxi": 58713,
  "location-city": 59377,
  "location-disabled": 57782,
  "location-off": 57543,
  "location-on": 57544,
  "location-searching": 57783,
  "lock": 59543,
  "lock-open": 59544,
  "lock-outline": 59545,
  "looks": 58364,
  "looks-3": 58363,
  "looks-4": 58365,
  "looks-5": 58366,
  "looks-6": 58367,
  "looks-one": 58368,
  "looks-two": 58369,
  "loop": 57384,
  "loupe": 58370,
  "low-priority": 57709,
  "loyalty": 59546,
  "mail": 57688,
  "mail-outline": 57569,
  "map": 58715,
  "markunread": 57689,
  "markunread-mailbox": 59547,
  "memory": 58146,
  "menu": 58834,
  "merge-type": 57938,
  "message": 57545,
  "mic": 57385,
  "mic-none": 57386,
  "mic-off": 57387,
  "mms": 58904,
  "mode-comment": 57939,
  "mode-edit": 57940,
  "monetization-on": 57955,
  "money-off": 57948,
  "monochrome-photos": 58371,
  "mood": 59378,
  "mood-bad": 59379,
  "more": 58905,
  "more-horiz": 58835,
  "more-vert": 58836,
  "motorcycle": 59675,
  "mouse": 58147,
  "move-to-inbox": 57704,
  "movie": 57388,
  "movie-creation": 58372,
  "movie-filter": 58426,
  "multiline-chart": 59103,
  "music-note": 58373,
  "music-video": 57443,
  "my-location": 58716,
  "nature": 58374,
  "nature-people": 58375,
  "navigate-before": 58376,
  "navigate-next": 58377,
  "navigation": 58717,
  "near-me": 58729,
  "network-cell": 57785,
  "network-check": 58944,
  "network-locked": 58906,
  "network-wifi": 57786,
  "new-releases": 57393,
  "next-week": 57706,
  "nfc": 57787,
  "no-encryption": 58945,
  "no-sim": 57548,
  "not-interested": 57395,
  "note": 57455,
  "note-add": 59548,
  "notifications": 59380,
  "notifications-active": 59383,
  "notifications-none": 59381,
  "notifications-off": 59382,
  "notifications-paused": 59384,
  "offline-pin": 59658,
  "ondemand-video": 58938,
  "opacity": 59676,
  "open-in-browser": 59549,
  "open-in-new": 59550,
  "open-with": 59551,
  "pages": 59385,
  "pageview": 59552,
  "palette": 58378,
  "pan-tool": 59685,
  "panorama": 58379,
  "panorama-fish-eye": 58380,
  "panorama-horizontal": 58381,
  "panorama-vertical": 58382,
  "panorama-wide-angle": 58383,
  "party-mode": 59386,
  "pause": 57396,
  "pause-circle-filled": 57397,
  "pause-circle-outline": 57398,
  "payment": 59553,
  "people": 59387,
  "people-outline": 59388,
  "perm-camera-mic": 59554,
  "perm-contact-calendar": 59555,
  "perm-data-setting": 59556,
  "perm-device-information": 59557,
  "perm-identity": 59558,
  "perm-media": 59559,
  "perm-phone-msg": 59560,
  "perm-scan-wifi": 59561,
  "person": 59389,
  "person-add": 59390,
  "person-outline": 59391,
  "person-pin": 58714,
  "person-pin-circle": 58730,
  "personal-video": 58939,
  "pets": 59677,
  "phone": 57549,
  "phone-android": 58148,
  "phone-bluetooth-speaker": 58907,
  "phone-forwarded": 58908,
  "phone-in-talk": 58909,
  "phone-iphone": 58149,
  "phone-locked": 58910,
  "phone-missed": 58911,
  "phone-paused": 58912,
  "phonelink": 58150,
  "phonelink-erase": 57563,
  "phonelink-lock": 57564,
  "phonelink-off": 58151,
  "phonelink-ring": 57565,
  "phonelink-setup": 57566,
  "photo": 58384,
  "photo-album": 58385,
  "photo-camera": 58386,
  "photo-filter": 58427,
  "photo-library": 58387,
  "photo-size-select-actual": 58418,
  "photo-size-select-large": 58419,
  "photo-size-select-small": 58420,
  "picture-as-pdf": 58389,
  "picture-in-picture": 59562,
  "picture-in-picture-alt": 59665,
  "pie-chart": 59076,
  "pie-chart-outlined": 59077,
  "pin-drop": 58718,
  "place": 58719,
  "play-arrow": 57399,
  "play-circle-filled": 57400,
  "play-circle-outline": 57401,
  "play-for-work": 59654,
  "playlist-add": 57403,
  "playlist-add-check": 57445,
  "playlist-play": 57439,
  "plus-one": 59392,
  "poll": 59393,
  "polymer": 59563,
  "pool": 60232,
  "portable-wifi-off": 57550,
  "portrait": 58390,
  "power": 58940,
  "power-input": 58166,
  "power-settings-new": 59564,
  "pregnant-woman": 59678,
  "present-to-all": 57567,
  "print": 59565,
  "priority-high": 58949,
  "public": 59403,
  "publish": 57941,
  "query-builder": 59566,
  "question-answer": 59567,
  "queue": 57404,
  "queue-music": 57405,
  "queue-play-next": 57446,
  "radio": 57406,
  "radio-button-checked": 59447,
  "radio-button-unchecked": 59446,
  "rate-review": 58720,
  "receipt": 59568,
  "recent-actors": 57407,
  "record-voice-over": 59679,
  "redeem": 59569,
  "redo": 57690,
  "refresh": 58837,
  "remove": 57691,
  "remove-circle": 57692,
  "remove-circle-outline": 57693,
  "remove-from-queue": 57447,
  "remove-red-eye": 58391,
  "remove-shopping-cart": 59688,
  "reorder": 59646,
  "repeat": 57408,
  "repeat-one": 57409,
  "replay": 57410,
  "replay-10": 57433,
  "replay-30": 57434,
  "replay-5": 57435,
  "reply": 57694,
  "reply-all": 57695,
  "report": 57696,
  "report-problem": 59570,
  "restaurant": 58732,
  "restaurant-menu": 58721,
  "restore": 59571,
  "restore-page": 59689,
  "ring-volume": 57553,
  "room": 59572,
  "room-service": 60233,
  "rotate-90-degrees-ccw": 58392,
  "rotate-left": 58393,
  "rotate-right": 58394,
  "rounded-corner": 59680,
  "router": 58152,
  "rowing": 59681,
  "rss-feed": 57573,
  "rv-hookup": 58946,
  "satellite": 58722,
  "save": 57697,
  "scanner": 58153,
  "schedule": 59573,
  "school": 59404,
  "screen-lock-landscape": 57790,
  "screen-lock-portrait": 57791,
  "screen-lock-rotation": 57792,
  "screen-rotation": 57793,
  "screen-share": 57570,
  "sd-card": 58915,
  "sd-storage": 57794,
  "search": 59574,
  "security": 58154,
  "select-all": 57698,
  "send": 57699,
  "sentiment-dissatisfied": 59409,
  "sentiment-neutral": 59410,
  "sentiment-satisfied": 59411,
  "sentiment-very-dissatisfied": 59412,
  "sentiment-very-satisfied": 59413,
  "settings": 59576,
  "settings-applications": 59577,
  "settings-backup-restore": 59578,
  "settings-bluetooth": 59579,
  "settings-brightness": 59581,
  "settings-cell": 59580,
  "settings-ethernet": 59582,
  "settings-input-antenna": 59583,
  "settings-input-component": 59584,
  "settings-input-composite": 59585,
  "settings-input-hdmi": 59586,
  "settings-input-svideo": 59587,
  "settings-overscan": 59588,
  "settings-phone": 59589,
  "settings-power": 59590,
  "settings-remote": 59591,
  "settings-system-daydream": 57795,
  "settings-voice": 59592,
  "share": 59405,
  "shop": 59593,
  "shop-two": 59594,
  "shopping-basket": 59595,
  "shopping-cart": 59596,
  "short-text": 57953,
  "show-chart": 59105,
  "shuffle": 57411,
  "signal-cellular-4-bar": 57800,
  "signal-cellular-connected-no-internet-4-bar": 57805,
  "signal-cellular-no-sim": 57806,
  "signal-cellular-null": 57807,
  "signal-cellular-off": 57808,
  "signal-wifi-4-bar": 57816,
  "signal-wifi-4-bar-lock": 57817,
  "signal-wifi-off": 57818,
  "sim-card": 58155,
  "sim-card-alert": 58916,
  "skip-next": 57412,
  "skip-previous": 57413,
  "slideshow": 58395,
  "slow-motion-video": 57448,
  "smartphone": 58156,
  "smoke-free": 60234,
  "smoking-rooms": 60235,
  "sms": 58917,
  "sms-failed": 58918,
  "snooze": 57414,
  "sort": 57700,
  "sort-by-alpha": 57427,
  "spa": 60236,
  "space-bar": 57942,
  "speaker": 58157,
  "speaker-group": 58158,
  "speaker-notes": 59597,
  "speaker-notes-off": 59690,
  "speaker-phone": 57554,
  "spellcheck": 59598,
  "star": 59448,
  "star-border": 59450,
  "star-half": 59449,
  "stars": 59600,
  "stay-current-landscape": 57555,
  "stay-current-portrait": 57556,
  "stay-primary-landscape": 57557,
  "stay-primary-portrait": 57558,
  "stop": 57415,
  "stop-screen-share": 57571,
  "storage": 57819,
  "store": 59601,
  "store-mall-directory": 58723,
  "straighten": 58396,
  "streetview": 58734,
  "strikethrough-s": 57943,
  "style": 58397,
  "subdirectory-arrow-left": 58841,
  "subdirectory-arrow-right": 58842,
  "subject": 59602,
  "subscriptions": 57444,
  "subtitles": 57416,
  "subway": 58735,
  "supervisor-account": 59603,
  "surround-sound": 57417,
  "swap-calls": 57559,
  "swap-horiz": 59604,
  "swap-vert": 59605,
  "swap-vertical-circle": 59606,
  "switch-camera": 58398,
  "switch-video": 58399,
  "sync": 58919,
  "sync-disabled": 58920,
  "sync-problem": 58921,
  "system-update": 58922,
  "system-update-alt": 59607,
  "tab": 59608,
  "tab-unselected": 59609,
  "tablet": 58159,
  "tablet-android": 58160,
  "tablet-mac": 58161,
  "tag-faces": 58400,
  "tap-and-play": 58923,
  "terrain": 58724,
  "text-fields": 57954,
  "text-format": 57701,
  "textsms": 57560,
  "texture": 58401,
  "theaters": 59610,
  "thumb-down": 59611,
  "thumb-up": 59612,
  "thumbs-up-down": 59613,
  "time-to-leave": 58924,
  "timelapse": 58402,
  "timeline": 59682,
  "timer": 58405,
  "timer-10": 58403,
  "timer-3": 58404,
  "timer-off": 58406,
  "title": 57956,
  "toc": 59614,
  "today": 59615,
  "toll": 59616,
  "tonality": 58407,
  "touch-app": 59667,
  "toys": 58162,
  "track-changes": 59617,
  "traffic": 58725,
  "train": 58736,
  "tram": 58737,
  "transfer-within-a-station": 58738,
  "transform": 58408,
  "translate": 59618,
  "trending-down": 59619,
  "trending-flat": 59620,
  "trending-up": 59621,
  "tune": 58409,
  "turned-in": 59622,
  "turned-in-not": 59623,
  "tv": 58163,
  "unarchive": 57705,
  "undo": 57702,
  "unfold-less": 58838,
  "unfold-more": 58839,
  "update": 59683,
  "usb": 57824,
  "verified-user": 59624,
  "vertical-align-bottom": 57944,
  "vertical-align-center": 57945,
  "vertical-align-top": 57946,
  "vibration": 58925,
  "video-call": 57456,
  "video-label": 57457,
  "video-library": 57418,
  "videocam": 57419,
  "videocam-off": 57420,
  "videogame-asset": 58168,
  "view-agenda": 59625,
  "view-array": 59626,
  "view-carousel": 59627,
  "view-column": 59628,
  "view-comfy": 58410,
  "view-compact": 58411,
  "view-day": 59629,
  "view-headline": 59630,
  "view-list": 59631,
  "view-module": 59632,
  "view-quilt": 59633,
  "view-stream": 59634,
  "view-week": 59635,
  "vignette": 58421,
  "visibility": 59636,
  "visibility-off": 59637,
  "voice-chat": 58926,
  "voicemail": 57561,
  "volume-down": 57421,
  "volume-mute": 57422,
  "volume-off": 57423,
  "volume-up": 57424,
  "vpn-key": 57562,
  "vpn-lock": 58927,
  "wallpaper": 57788,
  "warning": 57346,
  "watch": 58164,
  "watch-later": 59684,
  "wb-auto": 58412,
  "wb-cloudy": 58413,
  "wb-incandescent": 58414,
  "wb-iridescent": 58422,
  "wb-sunny": 58416,
  "wc": 58941,
  "web": 57425,
  "web-asset": 57449,
  "weekend": 57707,
  "whatshot": 59406,
  "widgets": 57789,
  "wifi": 58942,
  "wifi-lock": 57825,
  "wifi-tethering": 57826,
  "work": 59641,
  "wrap-text": 57947,
  "youtube-searched-for": 59642,
  "zoom-in": 59647,
  "zoom-out": 59648,
  "zoom-out-map": 58731
};
},692,[],"node_modules\\react-native-vector-icons\\glyphmaps\\MaterialIcons.json");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.registerCustomIconType = void 0;

  var _Zocial = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "react-native-vector-icons/Zocial"));

  var _Octicons = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "react-native-vector-icons/Octicons"));

  var _MaterialIcons = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "react-native-vector-icons/MaterialIcons"));

  var _MaterialCommunityIcons = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "react-native-vector-icons/MaterialCommunityIcons"));

  var _Ionicons = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "react-native-vector-icons/Ionicons"));

  var _Foundation = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "react-native-vector-icons/Foundation"));

  var _EvilIcons = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "react-native-vector-icons/EvilIcons"));

  var _Entypo = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "react-native-vector-icons/Entypo"));

  var _FontAwesome = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "react-native-vector-icons/FontAwesome"));

  var _SimpleLineIcons = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "react-native-vector-icons/SimpleLineIcons"));

  var _Feather = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "react-native-vector-icons/Feather"));

  var customIcons = {};

  var registerCustomIconType = function registerCustomIconType(id, customIcon) {
    customIcons[id] = customIcon;
  };

  exports.registerCustomIconType = registerCustomIconType;

  var _default = function _default(type) {
    switch (type) {
      case 'zocial':
        return _Zocial.default;

      case 'octicon':
        return _Octicons.default;

      case 'material':
        return _MaterialIcons.default;

      case 'material-community':
        return _MaterialCommunityIcons.default;

      case 'ionicon':
        return _Ionicons.default;

      case 'foundation':
        return _Foundation.default;

      case 'evilicon':
        return _EvilIcons.default;

      case 'entypo':
        return _Entypo.default;

      case 'font-awesome':
        return _FontAwesome.default;

      case 'simple-line-icon':
        return _SimpleLineIcons.default;

      case 'feather':
        return _Feather.default;

      default:
        if (customIcons.hasOwnProperty(type)) {
          return customIcons[type];
        }

        return _MaterialIcons.default;
    }
  };

  exports.default = _default;
},693,[23,694,696,643,698,700,702,704,706,708,710,712],"node_modules\\react-native-elements\\src\\helpers\\getIconType.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getImageSource = exports.ToolbarAndroid = exports.TabBarItemIOS = exports.TabBarItem = exports.Button = exports.default = void 0;

  var _createIconSet = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "./lib/create-icon-set"));

  var _Zocial = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "./glyphmaps/Zocial.json"));

  var iconSet = (0, _createIconSet.default)(_Zocial.default, 'zocial', 'Zocial.ttf');
  var _default = iconSet;
  exports.default = _default;
  var Button = iconSet.Button;
  exports.Button = Button;
  var TabBarItem = iconSet.TabBarItem;
  exports.TabBarItem = TabBarItem;
  var TabBarItemIOS = iconSet.TabBarItemIOS;
  exports.TabBarItemIOS = TabBarItemIOS;
  var ToolbarAndroid = iconSet.ToolbarAndroid;
  exports.ToolbarAndroid = ToolbarAndroid;
  var getImageSource = iconSet.getImageSource;
  exports.getImageSource = getImageSource;
},694,[23,644,695],"node_modules\\react-native-vector-icons\\Zocial.js");
__d(function(global, require, _aUnused, _bUnused, module, exports, _cUnused) {
  module.exports = {
  "acrobat": 61696,
  "amazon": 61697,
  "android": 61698,
  "angellist": 61699,
  "aol": 61700,
  "appnet": 61701,
  "appstore": 61702,
  "bitbucket": 61703,
  "bitcoin": 61704,
  "blogger": 61705,
  "buffer": 61706,
  "cal": 61707,
  "call": 61708,
  "cart": 61709,
  "chrome": 61710,
  "cloudapp": 61711,
  "creativecommons": 61712,
  "delicious": 61713,
  "digg": 61714,
  "disqus": 61715,
  "dribbble": 61716,
  "dropbox": 61717,
  "drupal": 61718,
  "dwolla": 61720,
  "email": 61721,
  "eventasaurus": 61722,
  "eventbrite": 61723,
  "eventful": 61724,
  "evernote": 61725,
  "facebook": 61726,
  "fivehundredpx": 61727,
  "flattr": 61728,
  "flickr": 61729,
  "forrst": 61730,
  "foursquare": 61731,
  "github": 61732,
  "gmail": 61733,
  "google": 61734,
  "googleplay": 61735,
  "googleplus": 61736,
  "gowalla": 61737,
  "grooveshark": 61738,
  "guest": 61739,
  "html5": 61740,
  "ie": 61741,
  "instagram": 61742,
  "instapaper": 61743,
  "intensedebate": 61744,
  "itunes": 61745,
  "klout": 61746,
  "lanyrd": 61747,
  "lastfm": 61748,
  "lego": 61749,
  "linkedin": 61750,
  "lkdto": 61751,
  "logmein": 61752,
  "macstore": 61753,
  "meetup": 61754,
  "myspace": 61755,
  "ninetyninedesigns": 61756,
  "openid": 61757,
  "opentable": 61758,
  "paypal": 61759,
  "persona": 61796,
  "pinboard": 61760,
  "pinterest": 61761,
  "plancast": 61762,
  "plurk": 61763,
  "pocket": 61764,
  "podcast": 61765,
  "posterous": 61766,
  "print": 61767,
  "quora": 61768,
  "reddit": 61769,
  "rss": 61770,
  "scribd": 61771,
  "skype": 61772,
  "smashing": 61773,
  "songkick": 61774,
  "soundcloud": 61775,
  "spotify": 61776,
  "stackoverflow": 61777,
  "statusnet": 61778,
  "steam": 61779,
  "stripe": 61780,
  "stumbleupon": 61781,
  "tumblr": 61782,
  "twitter": 61783,
  "viadeo": 61784,
  "vimeo": 61785,
  "vk": 61786,
  "weibo": 61787,
  "wikipedia": 61788,
  "windows": 61789,
  "wordpress": 61790,
  "xing": 61791,
  "yahoo": 61792,
  "ycombinator": 61793,
  "yelp": 61794,
  "youtube": 61795
};
},695,[],"node_modules\\react-native-vector-icons\\glyphmaps\\Zocial.json");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getImageSource = exports.ToolbarAndroid = exports.TabBarItemIOS = exports.TabBarItem = exports.Button = exports.default = void 0;

  var _createIconSet = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "./lib/create-icon-set"));

  var _Octicons = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "./glyphmaps/Octicons.json"));

  var iconSet = (0, _createIconSet.default)(_Octicons.default, 'Octicons', 'Octicons.ttf');
  var _default = iconSet;
  exports.default = _default;
  var Button = iconSet.Button;
  exports.Button = Button;
  var TabBarItem = iconSet.TabBarItem;
  exports.TabBarItem = TabBarItem;
  var TabBarItemIOS = iconSet.TabBarItemIOS;
  exports.TabBarItemIOS = TabBarItemIOS;
  var ToolbarAndroid = iconSet.ToolbarAndroid;
  exports.ToolbarAndroid = ToolbarAndroid;
  var getImageSource = iconSet.getImageSource;
  exports.getImageSource = getImageSource;
},696,[23,644,697],"node_modules\\react-native-vector-icons\\Octicons.js");
__d(function(global, require, _aUnused, _bUnused, module, exports, _cUnused) {
  module.exports = {
  "alert": 61696,
  "archive": 61697,
  "arrow-down": 61698,
  "arrow-left": 61699,
  "arrow-right": 61700,
  "arrow-small-down": 61701,
  "arrow-small-left": 61702,
  "arrow-small-right": 61703,
  "arrow-small-up": 61704,
  "arrow-up": 61705,
  "beaker": 61706,
  "bell": 61707,
  "bold": 61708,
  "book": 61709,
  "bookmark": 61710,
  "briefcase": 61711,
  "broadcast": 61712,
  "browser": 61713,
  "bug": 61714,
  "calendar": 61715,
  "check": 61716,
  "checklist": 61717,
  "chevron-down": 61718,
  "chevron-left": 61719,
  "chevron-right": 61720,
  "chevron-up": 61721,
  "circle-slash": 61722,
  "circuit-board": 61723,
  "clippy": 61724,
  "clock": 61725,
  "cloud-download": 61726,
  "cloud-upload": 61727,
  "code": 61728,
  "comment": 61729,
  "comment-discussion": 61730,
  "credit-card": 61731,
  "dash": 61732,
  "dashboard": 61733,
  "database": 61734,
  "desktop-download": 61735,
  "device-camera": 61736,
  "device-camera-video": 61737,
  "device-desktop": 61738,
  "device-mobile": 61739,
  "diff": 61740,
  "diff-added": 61741,
  "diff-ignored": 61742,
  "diff-modified": 61743,
  "diff-removed": 61744,
  "diff-renamed": 61745,
  "ellipsis": 61746,
  "eye": 61747,
  "file": 61748,
  "file-binary": 61749,
  "file-code": 61750,
  "file-directory": 61751,
  "file-media": 61752,
  "file-pdf": 61753,
  "file-submodule": 61754,
  "file-symlink-directory": 61755,
  "file-symlink-file": 61756,
  "file-zip": 61757,
  "flame": 61758,
  "fold": 61759,
  "gear": 61760,
  "gift": 61761,
  "gist": 61762,
  "gist-secret": 61763,
  "git-branch": 61764,
  "git-commit": 61765,
  "git-compare": 61766,
  "git-merge": 61767,
  "git-pull-request": 61768,
  "globe": 61769,
  "grabber": 61770,
  "graph": 61771,
  "heart": 61772,
  "history": 61773,
  "home": 61774,
  "horizontal-rule": 61775,
  "hubot": 61776,
  "inbox": 61777,
  "info": 61778,
  "issue-closed": 61779,
  "issue-opened": 61780,
  "issue-reopened": 61781,
  "italic": 61782,
  "jersey": 61783,
  "kebab-horizontal": 61784,
  "kebab-vertical": 61785,
  "key": 61786,
  "keyboard": 61787,
  "law": 61788,
  "light-bulb": 61789,
  "link": 61790,
  "link-external": 61791,
  "list-ordered": 61792,
  "list-unordered": 61793,
  "location": 61794,
  "lock": 61795,
  "logo-gist": 61796,
  "logo-github": 61797,
  "mail": 61798,
  "mail-read": 61799,
  "mark-github": 61800,
  "markdown": 61801,
  "megaphone": 61802,
  "mention": 61803,
  "milestone": 61804,
  "mirror": 61805,
  "mortar-board": 61806,
  "mute": 61807,
  "no-newline": 61808,
  "note": 61809,
  "octoface": 61810,
  "organization": 61811,
  "package": 61812,
  "paintcan": 61813,
  "pencil": 61814,
  "person": 61815,
  "pin": 61816,
  "plug": 61817,
  "plus": 61818,
  "plus-small": 61819,
  "primitive-dot": 61820,
  "primitive-square": 61821,
  "project": 61822,
  "pulse": 61823,
  "question": 61824,
  "quote": 61825,
  "radio-tower": 61826,
  "reply": 61827,
  "repo": 61828,
  "repo-clone": 61829,
  "repo-force-push": 61830,
  "repo-forked": 61831,
  "repo-pull": 61832,
  "repo-push": 61833,
  "report": 61834,
  "rocket": 61835,
  "rss": 61836,
  "ruby": 61837,
  "screen-full": 61838,
  "screen-normal": 61839,
  "search": 61840,
  "server": 61841,
  "settings": 61842,
  "shield": 61843,
  "sign-in": 61844,
  "sign-out": 61845,
  "smiley": 61846,
  "squirrel": 61847,
  "star": 61848,
  "stop": 61849,
  "sync": 61850,
  "tag": 61851,
  "tasklist": 61852,
  "telescope": 61853,
  "terminal": 61854,
  "text-size": 61855,
  "three-bars": 61856,
  "thumbsdown": 61857,
  "thumbsup": 61858,
  "tools": 61859,
  "trashcan": 61860,
  "triangle-down": 61861,
  "triangle-left": 61862,
  "triangle-right": 61863,
  "triangle-up": 61864,
  "unfold": 61865,
  "unmute": 61866,
  "unverified": 61867,
  "verified": 61868,
  "versions": 61869,
  "watch": 61870,
  "x": 61871,
  "zap": 61872
};
},697,[],"node_modules\\react-native-vector-icons\\glyphmaps\\Octicons.json");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getImageSource = exports.ToolbarAndroid = exports.TabBarItemIOS = exports.TabBarItem = exports.Button = exports.default = void 0;

  var _createIconSet = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "./lib/create-icon-set"));

  var _MaterialCommunityIcons = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "./glyphmaps/MaterialCommunityIcons.json"));

  var iconSet = (0, _createIconSet.default)(_MaterialCommunityIcons.default, 'Material Design Icons', 'MaterialCommunityIcons.ttf');
  var _default = iconSet;
  exports.default = _default;
  var Button = iconSet.Button;
  exports.Button = Button;
  var TabBarItem = iconSet.TabBarItem;
  exports.TabBarItem = TabBarItem;
  var TabBarItemIOS = iconSet.TabBarItemIOS;
  exports.TabBarItemIOS = TabBarItemIOS;
  var ToolbarAndroid = iconSet.ToolbarAndroid;
  exports.ToolbarAndroid = ToolbarAndroid;
  var getImageSource = iconSet.getImageSource;
  exports.getImageSource = getImageSource;
},698,[23,644,699],"node_modules\\react-native-vector-icons\\MaterialCommunityIcons.js");
__d(function(global, require, _aUnused, _bUnused, module, exports, _cUnused) {
  module.exports = {
  "access-point": 61442,
  "access-point-network": 61443,
  "account": 61444,
  "account-alert": 61445,
  "account-box": 61446,
  "account-box-multiple": 63795,
  "account-box-outline": 61447,
  "account-card-details": 62930,
  "account-check": 61448,
  "account-child": 64136,
  "account-child-circle": 64137,
  "account-circle": 61449,
  "account-convert": 61450,
  "account-details": 63025,
  "account-edit": 63163,
  "account-group": 63560,
  "account-heart": 63640,
  "account-key": 61451,
  "account-location": 61452,
  "account-minus": 61453,
  "account-minus-outline": 64235,
  "account-multiple": 61454,
  "account-multiple-check": 63684,
  "account-multiple-minus": 62931,
  "account-multiple-outline": 61455,
  "account-multiple-plus": 61456,
  "account-multiple-plus-outline": 63487,
  "account-network": 61457,
  "account-off": 61458,
  "account-outline": 61459,
  "account-plus": 61460,
  "account-plus-outline": 63488,
  "account-remove": 61461,
  "account-remove-outline": 64236,
  "account-search": 61462,
  "account-search-outline": 63796,
  "account-settings": 63024,
  "account-star": 61463,
  "account-supervisor": 64138,
  "account-supervisor-circle": 64139,
  "account-switch": 61465,
  "accusoft": 63561,
  "adjust": 61466,
  "adobe": 63797,
  "air-conditioner": 61467,
  "airballoon": 61468,
  "airplane": 61469,
  "airplane-landing": 62932,
  "airplane-off": 61470,
  "airplane-takeoff": 62933,
  "airplay": 61471,
  "airport": 63562,
  "alarm": 61472,
  "alarm-bell": 63373,
  "alarm-check": 61473,
  "alarm-light": 63374,
  "alarm-multiple": 61474,
  "alarm-off": 61475,
  "alarm-plus": 61476,
  "alarm-snooze": 63117,
  "album": 61477,
  "alert": 61478,
  "alert-box": 61479,
  "alert-circle": 61480,
  "alert-circle-outline": 62934,
  "alert-decagram": 63164,
  "alert-octagon": 61481,
  "alert-octagram": 63334,
  "alert-outline": 61482,
  "alien": 63641,
  "all-inclusive": 63165,
  "alpha": 61483,
  "alpha-a": 65,
  "alpha-a-box": 64237,
  "alpha-b": 66,
  "alpha-b-box": 64238,
  "alpha-c": 67,
  "alpha-c-box": 64239,
  "alpha-d": 68,
  "alpha-d-box": 64240,
  "alpha-e": 69,
  "alpha-e-box": 64241,
  "alpha-f": 70,
  "alpha-f-box": 64242,
  "alpha-g": 71,
  "alpha-g-box": 64243,
  "alpha-h": 72,
  "alpha-h-box": 64244,
  "alpha-i": 73,
  "alpha-i-box": 64245,
  "alpha-j": 74,
  "alpha-j-box": 64246,
  "alpha-k": 75,
  "alpha-k-box": 64247,
  "alpha-l": 76,
  "alpha-l-box": 64248,
  "alpha-m": 77,
  "alpha-m-box": 64249,
  "alpha-n": 78,
  "alpha-n-box": 64250,
  "alpha-o": 79,
  "alpha-o-box": 64251,
  "alpha-p": 80,
  "alpha-p-box": 64252,
  "alpha-q": 81,
  "alpha-q-box": 64253,
  "alpha-r": 82,
  "alpha-r-box": 64254,
  "alpha-s": 83,
  "alpha-s-box": 64255,
  "alpha-t": 84,
  "alpha-t-box": 64256,
  "alpha-u": 85,
  "alpha-u-box": 64257,
  "alpha-v": 86,
  "alpha-v-box": 64258,
  "alpha-w": 87,
  "alpha-w-box": 64259,
  "alpha-x": 88,
  "alpha-x-box": 64260,
  "alpha-y": 89,
  "alpha-y-box": 64261,
  "alpha-z": 90,
  "alpha-z-box": 64262,
  "alphabetical": 61484,
  "altimeter": 62935,
  "amazon": 61485,
  "amazon-alexa": 63685,
  "amazon-drive": 61486,
  "ambulance": 61487,
  "ampersand": 64140,
  "amplifier": 61488,
  "anchor": 61489,
  "android": 61490,
  "android-auto": 64141,
  "android-debug-bridge": 61491,
  "android-head": 63375,
  "android-studio": 61492,
  "angle-acute": 63798,
  "angle-obtuse": 63799,
  "angle-right": 63800,
  "angular": 63153,
  "angularjs": 63166,
  "animation": 62936,
  "animation-outline": 64142,
  "animation-play": 63801,
  "animation-play-outline": 64143,
  "anvil": 63642,
  "apple": 61493,
  "apple-finder": 61494,
  "apple-icloud": 61496,
  "apple-ios": 61495,
  "apple-keyboard-caps": 63026,
  "apple-keyboard-command": 63027,
  "apple-keyboard-control": 63028,
  "apple-keyboard-option": 63029,
  "apple-keyboard-shift": 63030,
  "apple-safari": 61497,
  "application": 62996,
  "apps": 61499,
  "arch": 63686,
  "archive": 61500,
  "arrange-bring-forward": 61501,
  "arrange-bring-to-front": 61502,
  "arrange-send-backward": 61503,
  "arrange-send-to-back": 61504,
  "arrow-all": 61505,
  "arrow-bottom-left": 61506,
  "arrow-bottom-left-bold-outline": 63926,
  "arrow-bottom-left-thick": 63927,
  "arrow-bottom-right": 61507,
  "arrow-bottom-right-bold-outline": 63928,
  "arrow-bottom-right-thick": 63929,
  "arrow-collapse": 62997,
  "arrow-collapse-all": 61508,
  "arrow-collapse-down": 63377,
  "arrow-collapse-horizontal": 63563,
  "arrow-collapse-left": 63378,
  "arrow-collapse-right": 63379,
  "arrow-collapse-up": 63380,
  "arrow-collapse-vertical": 63564,
  "arrow-decision": 63930,
  "arrow-decision-auto": 63931,
  "arrow-decision-auto-outline": 63932,
  "arrow-decision-outline": 63933,
  "arrow-down": 61509,
  "arrow-down-bold": 63277,
  "arrow-down-bold-box": 63278,
  "arrow-down-bold-box-outline": 63279,
  "arrow-down-bold-circle": 61511,
  "arrow-down-bold-circle-outline": 61512,
  "arrow-down-bold-hexagon-outline": 61513,
  "arrow-down-bold-outline": 63934,
  "arrow-down-box": 63167,
  "arrow-down-drop-circle": 61514,
  "arrow-down-drop-circle-outline": 61515,
  "arrow-down-thick": 61510,
  "arrow-expand": 62998,
  "arrow-expand-all": 61516,
  "arrow-expand-down": 63381,
  "arrow-expand-horizontal": 63565,
  "arrow-expand-left": 63382,
  "arrow-expand-right": 63383,
  "arrow-expand-up": 63384,
  "arrow-expand-vertical": 63566,
  "arrow-left": 61517,
  "arrow-left-bold": 63280,
  "arrow-left-bold-box": 63281,
  "arrow-left-bold-box-outline": 63282,
  "arrow-left-bold-circle": 61519,
  "arrow-left-bold-circle-outline": 61520,
  "arrow-left-bold-hexagon-outline": 61521,
  "arrow-left-bold-outline": 63935,
  "arrow-left-box": 63168,
  "arrow-left-drop-circle": 61522,
  "arrow-left-drop-circle-outline": 61523,
  "arrow-left-right-bold-outline": 63936,
  "arrow-left-thick": 61518,
  "arrow-right": 61524,
  "arrow-right-bold": 63283,
  "arrow-right-bold-box": 63284,
  "arrow-right-bold-box-outline": 63285,
  "arrow-right-bold-circle": 61526,
  "arrow-right-bold-circle-outline": 61527,
  "arrow-right-bold-hexagon-outline": 61528,
  "arrow-right-bold-outline": 63937,
  "arrow-right-box": 63169,
  "arrow-right-drop-circle": 61529,
  "arrow-right-drop-circle-outline": 61530,
  "arrow-right-thick": 61525,
  "arrow-split-horizontal": 63802,
  "arrow-split-vertical": 63803,
  "arrow-top-left": 61531,
  "arrow-top-left-bold-outline": 63938,
  "arrow-top-left-thick": 63939,
  "arrow-top-right": 61532,
  "arrow-top-right-bold-outline": 63940,
  "arrow-top-right-thick": 63941,
  "arrow-up": 61533,
  "arrow-up-bold": 63286,
  "arrow-up-bold-box": 63287,
  "arrow-up-bold-box-outline": 63288,
  "arrow-up-bold-circle": 61535,
  "arrow-up-bold-circle-outline": 61536,
  "arrow-up-bold-hexagon-outline": 61537,
  "arrow-up-bold-outline": 63942,
  "arrow-up-box": 63170,
  "arrow-up-down-bold-outline": 63943,
  "arrow-up-drop-circle": 61538,
  "arrow-up-drop-circle-outline": 61539,
  "arrow-up-thick": 61534,
  "artist": 63490,
  "aspect-ratio": 64035,
  "assistant": 61540,
  "asterisk": 63171,
  "at": 61541,
  "atlassian": 63491,
  "atom": 63335,
  "attachment": 61542,
  "audio-video": 63804,
  "audiobook": 61543,
  "augmented-reality": 63567,
  "auto-fix": 61544,
  "auto-upload": 61545,
  "autorenew": 61546,
  "av-timer": 61547,
  "axe": 63687,
  "azure": 63492,
  "babel": 64036,
  "baby": 61548,
  "baby-buggy": 63118,
  "backburger": 61549,
  "backspace": 61550,
  "backup-restore": 61551,
  "badminton": 63568,
  "balloon": 64037,
  "ballot": 63944,
  "ballot-outline": 63945,
  "bandcamp": 63092,
  "bank": 61552,
  "bank-transfer": 64038,
  "bank-transfer-in": 64039,
  "bank-transfer-out": 64040,
  "barcode": 61553,
  "barcode-scan": 61554,
  "barley": 61555,
  "barrel": 61556,
  "baseball": 63569,
  "baseball-bat": 63570,
  "basecamp": 61557,
  "basket": 61558,
  "basket-fill": 61559,
  "basket-unfill": 61560,
  "basketball": 63493,
  "battery": 61561,
  "battery-10": 61562,
  "battery-10-bluetooth": 63805,
  "battery-20": 61563,
  "battery-20-bluetooth": 63806,
  "battery-30": 61564,
  "battery-30-bluetooth": 63807,
  "battery-40": 61565,
  "battery-40-bluetooth": 63808,
  "battery-50": 61566,
  "battery-50-bluetooth": 63809,
  "battery-60": 61567,
  "battery-60-bluetooth": 63810,
  "battery-70": 61568,
  "battery-70-bluetooth": 63811,
  "battery-80": 61569,
  "battery-80-bluetooth": 63812,
  "battery-90": 61570,
  "battery-90-bluetooth": 63813,
  "battery-alert": 61571,
  "battery-alert-bluetooth": 63814,
  "battery-bluetooth": 63815,
  "battery-bluetooth-variant": 63816,
  "battery-charging": 61572,
  "battery-charging-10": 63643,
  "battery-charging-100": 61573,
  "battery-charging-20": 61574,
  "battery-charging-30": 61575,
  "battery-charging-40": 61576,
  "battery-charging-50": 63644,
  "battery-charging-60": 61577,
  "battery-charging-70": 63645,
  "battery-charging-80": 61578,
  "battery-charging-90": 61579,
  "battery-charging-outline": 63646,
  "battery-charging-wireless": 63494,
  "battery-charging-wireless-10": 63495,
  "battery-charging-wireless-20": 63496,
  "battery-charging-wireless-30": 63497,
  "battery-charging-wireless-40": 63498,
  "battery-charging-wireless-50": 63499,
  "battery-charging-wireless-60": 63500,
  "battery-charging-wireless-70": 63501,
  "battery-charging-wireless-80": 63502,
  "battery-charging-wireless-90": 63503,
  "battery-charging-wireless-alert": 63504,
  "battery-charging-wireless-outline": 63505,
  "battery-minus": 61580,
  "battery-negative": 61581,
  "battery-outline": 61582,
  "battery-plus": 61583,
  "battery-positive": 61584,
  "battery-unknown": 61585,
  "battery-unknown-bluetooth": 63817,
  "beach": 61586,
  "beaker": 63119,
  "beats": 61591,
  "bed-empty": 63647,
  "beer": 61592,
  "behance": 61593,
  "bell": 61594,
  "bell-off": 61595,
  "bell-off-outline": 64144,
  "bell-outline": 61596,
  "bell-plus": 61597,
  "bell-plus-outline": 64145,
  "bell-ring": 61598,
  "bell-ring-outline": 61599,
  "bell-sleep": 61600,
  "bell-sleep-outline": 64146,
  "beta": 61601,
  "betamax": 63946,
  "bible": 61602,
  "bike": 61603,
  "bing": 61604,
  "binoculars": 61605,
  "bio": 61606,
  "biohazard": 61607,
  "bitbucket": 61608,
  "bitcoin": 63506,
  "black-mesa": 61609,
  "blackberry": 61610,
  "blender": 61611,
  "blinds": 61612,
  "block-helper": 61613,
  "blogger": 61614,
  "bluetooth": 61615,
  "bluetooth-audio": 61616,
  "bluetooth-connect": 61617,
  "bluetooth-off": 61618,
  "bluetooth-settings": 61619,
  "bluetooth-transfer": 61620,
  "blur": 61621,
  "blur-linear": 61622,
  "blur-off": 61623,
  "blur-radial": 61624,
  "bomb": 63120,
  "bomb-off": 63172,
  "bone": 61625,
  "book": 61626,
  "book-lock": 63385,
  "book-lock-open": 63386,
  "book-minus": 62937,
  "book-multiple": 61627,
  "book-multiple-minus": 64147,
  "book-multiple-plus": 64148,
  "book-multiple-remove": 64149,
  "book-multiple-variant": 61628,
  "book-open": 61629,
  "book-open-page-variant": 62938,
  "book-open-variant": 61630,
  "book-plus": 62939,
  "book-remove": 64150,
  "book-variant": 61631,
  "bookmark": 61632,
  "bookmark-check": 61633,
  "bookmark-minus": 63947,
  "bookmark-minus-outline": 63948,
  "bookmark-music": 61634,
  "bookmark-off": 63949,
  "bookmark-off-outline": 63950,
  "bookmark-outline": 61635,
  "bookmark-plus": 61637,
  "bookmark-plus-outline": 61636,
  "bookmark-remove": 61638,
  "boombox": 62940,
  "bootstrap": 63173,
  "border-all": 61639,
  "border-all-variant": 63648,
  "border-bottom": 61640,
  "border-bottom-variant": 63649,
  "border-color": 61641,
  "border-horizontal": 61642,
  "border-inside": 61643,
  "border-left": 61644,
  "border-left-variant": 63650,
  "border-none": 61645,
  "border-none-variant": 63651,
  "border-outside": 61646,
  "border-right": 61647,
  "border-right-variant": 63652,
  "border-style": 61648,
  "border-top": 61649,
  "border-top-variant": 63653,
  "border-vertical": 61650,
  "bottle-wine": 63571,
  "bow-tie": 63095,
  "bowl": 62999,
  "bowling": 61651,
  "box": 61652,
  "box-cutter": 61653,
  "box-shadow": 63031,
  "braille": 63951,
  "brain": 63952,
  "bridge": 63000,
  "briefcase": 61654,
  "briefcase-check": 61655,
  "briefcase-download": 61656,
  "briefcase-edit": 64151,
  "briefcase-minus": 64041,
  "briefcase-outline": 63507,
  "briefcase-plus": 64042,
  "briefcase-remove": 64043,
  "briefcase-search": 64044,
  "briefcase-upload": 61657,
  "brightness-1": 61658,
  "brightness-2": 61659,
  "brightness-3": 61660,
  "brightness-4": 61661,
  "brightness-5": 61662,
  "brightness-6": 61663,
  "brightness-7": 61664,
  "brightness-auto": 61665,
  "broom": 61666,
  "brush": 61667,
  "buddhism": 63818,
  "buffer": 63001,
  "bug": 61668,
  "bug-check": 64045,
  "bug-check-outline": 64046,
  "bug-outline": 64047,
  "bulldozer": 64263,
  "bulletin-board": 61669,
  "bullhorn": 61670,
  "bullhorn-outline": 64264,
  "bullseye": 62941,
  "bullseye-arrow": 63688,
  "bus": 61671,
  "bus-alert": 64152,
  "bus-articulated-end": 63387,
  "bus-articulated-front": 63388,
  "bus-clock": 63689,
  "bus-double-decker": 63389,
  "bus-school": 63390,
  "bus-side": 63391,
  "cached": 61672,
  "cake": 61673,
  "cake-layered": 61674,
  "cake-variant": 61675,
  "calculator": 61676,
  "calculator-variant": 64153,
  "calendar": 61677,
  "calendar-alert": 64048,
  "calendar-blank": 61678,
  "calendar-check": 61679,
  "calendar-clock": 61680,
  "calendar-edit": 63654,
  "calendar-export": 64265,
  "calendar-heart": 63953,
  "calendar-import": 64266,
  "calendar-multiple": 61681,
  "calendar-multiple-check": 61682,
  "calendar-multiselect": 64049,
  "calendar-plus": 61683,
  "calendar-question": 63121,
  "calendar-range": 63096,
  "calendar-remove": 61684,
  "calendar-search": 63819,
  "calendar-star": 63954,
  "calendar-text": 61685,
  "calendar-today": 61686,
  "calendar-week": 64050,
  "calendar-week-begin": 64051,
  "call-made": 61687,
  "call-merge": 61688,
  "call-missed": 61689,
  "call-received": 61690,
  "call-split": 61691,
  "camcorder": 61692,
  "camcorder-box": 61693,
  "camcorder-box-off": 61694,
  "camcorder-off": 61695,
  "camera": 61696,
  "camera-account": 63690,
  "camera-burst": 63122,
  "camera-enhance": 61697,
  "camera-front": 61698,
  "camera-front-variant": 61699,
  "camera-gopro": 63392,
  "camera-image": 63691,
  "camera-iris": 61700,
  "camera-metering-center": 63393,
  "camera-metering-matrix": 63394,
  "camera-metering-partial": 63395,
  "camera-metering-spot": 63396,
  "camera-off": 62943,
  "camera-party-mode": 61701,
  "camera-rear": 61702,
  "camera-rear-variant": 61703,
  "camera-switch": 61704,
  "camera-timer": 61705,
  "cancel": 63289,
  "candle": 62946,
  "candycane": 61706,
  "cannabis": 63397,
  "caps-lock": 64154,
  "car": 61707,
  "car-battery": 61708,
  "car-connected": 61709,
  "car-convertible": 63398,
  "car-estate": 63399,
  "car-hatchback": 63400,
  "car-limousine": 63692,
  "car-pickup": 63401,
  "car-side": 63402,
  "car-sports": 63403,
  "car-wash": 61710,
  "caravan": 63404,
  "cards": 63032,
  "cards-club": 63693,
  "cards-diamond": 63694,
  "cards-heart": 63695,
  "cards-outline": 63033,
  "cards-playing-outline": 63034,
  "cards-spade": 63696,
  "cards-variant": 63174,
  "carrot": 61711,
  "cart": 61712,
  "cart-off": 63083,
  "cart-outline": 61713,
  "cart-plus": 61714,
  "case-sensitive-alt": 61715,
  "cash": 61716,
  "cash-100": 61717,
  "cash-multiple": 61718,
  "cash-refund": 64155,
  "cash-usd": 61719,
  "cassette": 63955,
  "cast": 61720,
  "cast-connected": 61721,
  "cast-off": 63369,
  "castle": 61722,
  "cat": 61723,
  "cctv": 63405,
  "ceiling-light": 63336,
  "cellphone": 61724,
  "cellphone-android": 61725,
  "cellphone-arrow-down": 63956,
  "cellphone-basic": 61726,
  "cellphone-dock": 61727,
  "cellphone-erase": 63820,
  "cellphone-iphone": 61728,
  "cellphone-key": 63821,
  "cellphone-link": 61729,
  "cellphone-link-off": 61730,
  "cellphone-lock": 63822,
  "cellphone-message": 63698,
  "cellphone-off": 63823,
  "cellphone-screenshot": 64052,
  "cellphone-settings": 61731,
  "cellphone-settings-variant": 63824,
  "cellphone-sound": 63825,
  "cellphone-text": 63697,
  "cellphone-wireless": 63508,
  "certificate": 61732,
  "chair-school": 61733,
  "chart-arc": 61734,
  "chart-areaspline": 61735,
  "chart-bar": 61736,
  "chart-bar-stacked": 63337,
  "chart-bubble": 62947,
  "chart-donut": 63406,
  "chart-donut-variant": 63407,
  "chart-gantt": 63084,
  "chart-histogram": 61737,
  "chart-line": 61738,
  "chart-line-stacked": 63338,
  "chart-line-variant": 63408,
  "chart-multiline": 63699,
  "chart-pie": 61739,
  "chart-scatterplot-hexbin": 63085,
  "chart-timeline": 63086,
  "check": 61740,
  "check-all": 61741,
  "check-circle": 62944,
  "check-circle-outline": 62945,
  "check-decagram": 63376,
  "check-outline": 63572,
  "checkbook": 64156,
  "checkbox-blank": 61742,
  "checkbox-blank-circle": 61743,
  "checkbox-blank-circle-outline": 61744,
  "checkbox-blank-outline": 61745,
  "checkbox-intermediate": 63573,
  "checkbox-marked": 61746,
  "checkbox-marked-circle": 61747,
  "checkbox-marked-circle-outline": 61748,
  "checkbox-marked-outline": 61749,
  "checkbox-multiple-blank": 61750,
  "checkbox-multiple-blank-circle": 63035,
  "checkbox-multiple-blank-circle-outline": 63036,
  "checkbox-multiple-blank-outline": 61751,
  "checkbox-multiple-marked": 61752,
  "checkbox-multiple-marked-circle": 63037,
  "checkbox-multiple-marked-circle-outline": 63038,
  "checkbox-multiple-marked-outline": 61753,
  "checkerboard": 61754,
  "chemical-weapon": 61755,
  "chess-bishop": 63579,
  "chess-king": 63574,
  "chess-knight": 63575,
  "chess-pawn": 63576,
  "chess-queen": 63577,
  "chess-rook": 63578,
  "chevron-double-down": 61756,
  "chevron-double-left": 61757,
  "chevron-double-right": 61758,
  "chevron-double-up": 61759,
  "chevron-down": 61760,
  "chevron-down-box": 63957,
  "chevron-down-box-outline": 63958,
  "chevron-down-circle": 64267,
  "chevron-down-circle-outline": 64268,
  "chevron-left": 61761,
  "chevron-left-box": 63959,
  "chevron-left-box-outline": 63960,
  "chevron-left-circle": 64269,
  "chevron-left-circle-outline": 64270,
  "chevron-right": 61762,
  "chevron-right-box": 63961,
  "chevron-right-box-outline": 63962,
  "chevron-right-circle": 64271,
  "chevron-right-circle-outline": 64272,
  "chevron-up": 61763,
  "chevron-up-box": 63963,
  "chevron-up-box-outline": 63964,
  "chevron-up-circle": 64273,
  "chevron-up-circle-outline": 64274,
  "chili-hot": 63409,
  "chili-medium": 63410,
  "chili-mild": 63411,
  "chip": 63002,
  "christianity": 63826,
  "church": 61764,
  "circle": 63332,
  "circle-edit-outline": 63700,
  "circle-medium": 63965,
  "circle-outline": 63333,
  "circle-slice-1": 64157,
  "circle-slice-2": 64158,
  "circle-slice-3": 64159,
  "circle-slice-4": 64160,
  "circle-slice-5": 64161,
  "circle-slice-6": 64162,
  "circle-slice-7": 64163,
  "circle-slice-8": 64164,
  "circle-small": 63966,
  "cisco-webex": 61765,
  "city": 61766,
  "city-variant": 64053,
  "city-variant-outline": 64054,
  "clipboard": 61767,
  "clipboard-account": 61768,
  "clipboard-alert": 61769,
  "clipboard-arrow-down": 61770,
  "clipboard-arrow-left": 61771,
  "clipboard-check": 61772,
  "clipboard-check-outline": 63655,
  "clipboard-flow": 63175,
  "clipboard-outline": 61773,
  "clipboard-plus": 63312,
  "clipboard-pulse": 63580,
  "clipboard-pulse-outline": 63581,
  "clipboard-text": 61774,
  "clipboard-text-outline": 64055,
  "clippy": 61775,
  "clock": 63827,
  "clock-alert": 63828,
  "clock-alert-outline": 62926,
  "clock-end": 61777,
  "clock-fast": 61778,
  "clock-in": 61779,
  "clock-out": 61780,
  "clock-outline": 61776,
  "clock-start": 61781,
  "close": 61782,
  "close-box": 61783,
  "close-box-outline": 61784,
  "close-circle": 61785,
  "close-circle-outline": 61786,
  "close-network": 61787,
  "close-octagon": 61788,
  "close-octagon-outline": 61789,
  "close-outline": 63176,
  "closed-caption": 61790,
  "cloud": 61791,
  "cloud-alert": 63967,
  "cloud-braces": 63412,
  "cloud-check": 61792,
  "cloud-circle": 61793,
  "cloud-download": 61794,
  "cloud-off-outline": 61796,
  "cloud-outline": 61795,
  "cloud-print": 61797,
  "cloud-print-outline": 61798,
  "cloud-question": 64056,
  "cloud-search": 63829,
  "cloud-search-outline": 63830,
  "cloud-sync": 63039,
  "cloud-tags": 63413,
  "cloud-upload": 61799,
  "clover": 63509,
  "code-array": 61800,
  "code-braces": 61801,
  "code-brackets": 61802,
  "code-equal": 61803,
  "code-greater-than": 61804,
  "code-greater-than-or-equal": 61805,
  "code-less-than": 61806,
  "code-less-than-or-equal": 61807,
  "code-not-equal": 61808,
  "code-not-equal-variant": 61809,
  "code-parentheses": 61810,
  "code-string": 61811,
  "code-tags": 61812,
  "code-tags-check": 63123,
  "codepen": 61813,
  "coffee": 61814,
  "coffee-outline": 63177,
  "coffee-to-go": 61815,
  "cogs": 63701,
  "coin": 61816,
  "coins": 63124,
  "collage": 63040,
  "collapse-all": 64165,
  "collapse-all-outline": 64166,
  "color-helper": 61817,
  "comment": 61818,
  "comment-account": 61819,
  "comment-account-outline": 61820,
  "comment-alert": 61821,
  "comment-alert-outline": 61822,
  "comment-arrow-left": 63968,
  "comment-arrow-left-outline": 63969,
  "comment-arrow-right": 63970,
  "comment-arrow-right-outline": 63971,
  "comment-check": 61823,
  "comment-check-outline": 61824,
  "comment-eye": 64057,
  "comment-eye-outline": 64058,
  "comment-multiple": 63582,
  "comment-multiple-outline": 61825,
  "comment-outline": 61826,
  "comment-plus": 63972,
  "comment-plus-outline": 61827,
  "comment-processing": 61828,
  "comment-processing-outline": 61829,
  "comment-question": 63510,
  "comment-question-outline": 61830,
  "comment-remove": 62942,
  "comment-remove-outline": 61831,
  "comment-search": 64059,
  "comment-search-outline": 64060,
  "comment-text": 61832,
  "comment-text-multiple": 63583,
  "comment-text-multiple-outline": 63584,
  "comment-text-outline": 61833,
  "compare": 61834,
  "compass": 61835,
  "compass-outline": 61836,
  "console": 61837,
  "console-line": 63414,
  "console-network": 63656,
  "contact-mail": 61838,
  "contacts": 63178,
  "contain": 64061,
  "contain-end": 64062,
  "contain-start": 64063,
  "content-copy": 61839,
  "content-cut": 61840,
  "content-duplicate": 61841,
  "content-paste": 61842,
  "content-save": 61843,
  "content-save-all": 61844,
  "content-save-outline": 63511,
  "content-save-settings": 63003,
  "content-save-settings-outline": 64275,
  "contrast": 61845,
  "contrast-box": 61846,
  "contrast-circle": 61847,
  "cookie": 61848,
  "copyright": 62950,
  "cordova": 63831,
  "corn": 63415,
  "counter": 61849,
  "cow": 61850,
  "crane": 63585,
  "creation": 61897,
  "credit-card": 61851,
  "credit-card-multiple": 61852,
  "credit-card-off": 62948,
  "credit-card-plus": 63093,
  "credit-card-refund": 64167,
  "credit-card-scan": 61853,
  "credit-card-settings": 63702,
  "crop": 61854,
  "crop-free": 61855,
  "crop-landscape": 61856,
  "crop-portrait": 61857,
  "crop-rotate": 63125,
  "crop-square": 61858,
  "crosshairs": 61859,
  "crosshairs-gps": 61860,
  "crown": 61861,
  "cryengine": 63832,
  "crystal-ball": 64276,
  "cube": 61862,
  "cube-outline": 61863,
  "cube-send": 61864,
  "cube-unfolded": 61865,
  "cup": 61866,
  "cup-off": 62949,
  "cup-water": 61867,
  "cupcake": 63833,
  "curling": 63586,
  "currency-bdt": 63587,
  "currency-btc": 61868,
  "currency-chf": 63416,
  "currency-cny": 63417,
  "currency-eth": 63418,
  "currency-eur": 61869,
  "currency-gbp": 61870,
  "currency-inr": 61871,
  "currency-jpy": 63419,
  "currency-krw": 63420,
  "currency-kzt": 63588,
  "currency-ngn": 61872,
  "currency-php": 63973,
  "currency-rub": 61873,
  "currency-sign": 63421,
  "currency-try": 61874,
  "currency-twd": 63422,
  "currency-usd": 61875,
  "currency-usd-off": 63097,
  "current-ac": 63834,
  "current-dc": 63835,
  "cursor-default": 61876,
  "cursor-default-outline": 61877,
  "cursor-move": 61878,
  "cursor-pointer": 61879,
  "cursor-text": 62951,
  "database": 61880,
  "database-check": 64168,
  "database-export": 63837,
  "database-import": 63836,
  "database-lock": 64169,
  "database-minus": 61881,
  "database-plus": 61882,
  "database-search": 63589,
  "death-star": 63703,
  "death-star-variant": 63704,
  "debian": 63705,
  "debug-step-into": 61883,
  "debug-step-out": 61884,
  "debug-step-over": 61885,
  "decagram": 63339,
  "decagram-outline": 63340,
  "decimal-decrease": 61886,
  "decimal-increase": 61887,
  "delete": 61888,
  "delete-circle": 63106,
  "delete-empty": 63179,
  "delete-forever": 62952,
  "delete-outline": 63974,
  "delete-restore": 63512,
  "delete-sweep": 62953,
  "delete-variant": 61889,
  "delta": 61890,
  "desk-lamp": 63838,
  "deskphone": 61891,
  "desktop-classic": 63423,
  "desktop-mac": 61892,
  "desktop-mac-dashboard": 63975,
  "desktop-tower": 61893,
  "desktop-tower-monitor": 64170,
  "details": 61894,
  "developer-board": 63126,
  "deviantart": 61895,
  "dialpad": 63004,
  "diamond": 61896,
  "dice-1": 61898,
  "dice-2": 61899,
  "dice-3": 61900,
  "dice-4": 61901,
  "dice-5": 61902,
  "dice-6": 61903,
  "dice-d10": 63342,
  "dice-d12": 63590,
  "dice-d20": 62954,
  "dice-d4": 62955,
  "dice-d6": 62956,
  "dice-d8": 62957,
  "dice-multiple": 63341,
  "dictionary": 63005,
  "dip-switch": 63424,
  "directions": 61904,
  "directions-fork": 63041,
  "disc": 62958,
  "disc-alert": 61905,
  "disc-player": 63839,
  "discord": 63087,
  "dishwasher": 64171,
  "disqus": 61906,
  "disqus-outline": 61907,
  "division": 61908,
  "division-box": 61909,
  "dlna": 64064,
  "dna": 63107,
  "dns": 61910,
  "do-not-disturb": 63127,
  "do-not-disturb-off": 63128,
  "docker": 63591,
  "doctor": 64065,
  "dog": 64066,
  "dog-service": 64172,
  "dog-side": 64067,
  "dolby": 63154,
  "domain": 61911,
  "donkey": 63425,
  "door": 63513,
  "door-closed": 63514,
  "door-open": 63515,
  "doorbell-video": 63592,
  "dot-net": 64173,
  "dots-horizontal": 61912,
  "dots-horizontal-circle": 63426,
  "dots-vertical": 61913,
  "dots-vertical-circle": 63427,
  "douban": 63129,
  "download": 61914,
  "download-multiple": 63976,
  "download-network": 63219,
  "drag": 61915,
  "drag-horizontal": 61916,
  "drag-vertical": 61917,
  "drawing": 61918,
  "drawing-box": 61919,
  "dribbble": 61920,
  "dribbble-box": 61921,
  "drone": 61922,
  "dropbox": 61923,
  "drupal": 61924,
  "duck": 61925,
  "dumbbell": 61926,
  "ear-hearing": 63428,
  "ear-hearing-off": 64068,
  "earth": 61927,
  "earth-box": 63180,
  "earth-box-off": 63181,
  "earth-off": 61928,
  "edge": 61929,
  "egg": 64174,
  "egg-easter": 64175,
  "eight-track": 63977,
  "eject": 61930,
  "elephant": 63429,
  "elevation-decline": 61931,
  "elevation-rise": 61932,
  "elevator": 61933,
  "email": 61934,
  "email-alert": 63182,
  "email-check": 64176,
  "email-check-outline": 64177,
  "email-lock": 61937,
  "email-open": 61935,
  "email-open-outline": 62959,
  "email-outline": 61936,
  "email-plus": 63978,
  "email-plus-outline": 63979,
  "email-search": 63840,
  "email-search-outline": 63841,
  "email-variant": 62960,
  "ember": 64277,
  "emby": 63155,
  "emoticon": 61938,
  "emoticon-cool": 61939,
  "emoticon-dead": 63130,
  "emoticon-devil": 61940,
  "emoticon-excited": 63131,
  "emoticon-happy": 61941,
  "emoticon-neutral": 61942,
  "emoticon-poop": 61943,
  "emoticon-sad": 61944,
  "emoticon-tongue": 61945,
  "engine": 61946,
  "engine-off": 64069,
  "engine-off-outline": 64070,
  "engine-outline": 61947,
  "equal": 61948,
  "equal-box": 61949,
  "eraser": 61950,
  "eraser-variant": 63042,
  "escalator": 61951,
  "et": 64178,
  "ethereum": 63593,
  "ethernet": 61952,
  "ethernet-cable": 61953,
  "ethernet-cable-off": 61954,
  "etsy": 61955,
  "ev-station": 62961,
  "eventbrite": 63430,
  "evernote": 61956,
  "exclamation": 61957,
  "exit-run": 64071,
  "exit-to-app": 61958,
  "expand-all": 64179,
  "expand-all-outline": 64180,
  "exponent": 63842,
  "exponent-box": 63843,
  "export": 61959,
  "eye": 61960,
  "eye-off": 61961,
  "eye-off-outline": 63184,
  "eye-outline": 63183,
  "eye-plus": 63594,
  "eye-plus-outline": 63595,
  "eye-settings": 63596,
  "eye-settings-outline": 63597,
  "eyedropper": 61962,
  "eyedropper-variant": 61963,
  "face": 63043,
  "face-profile": 63044,
  "facebook": 61964,
  "facebook-box": 61965,
  "facebook-messenger": 61966,
  "facebook-workplace": 64278,
  "factory": 61967,
  "fan": 61968,
  "fan-off": 63516,
  "fast-forward": 61969,
  "fast-forward-outline": 63185,
  "fax": 61970,
  "feather": 63186,
  "feature-search": 64072,
  "feature-search-outline": 64073,
  "fedora": 63706,
  "ferry": 61971,
  "file": 61972,
  "file-account": 63290,
  "file-alert": 64074,
  "file-alert-outline": 64075,
  "file-cabinet": 64181,
  "file-chart": 61973,
  "file-check": 61974,
  "file-cloud": 61975,
  "file-compare": 63657,
  "file-delimited": 61976,
  "file-document": 61977,
  "file-document-box": 61978,
  "file-document-box-multiple": 64182,
  "file-document-box-multiple-outline": 64183,
  "file-document-box-outline": 63980,
  "file-document-outline": 63981,
  "file-download": 63844,
  "file-download-outline": 63845,
  "file-excel": 61979,
  "file-excel-box": 61980,
  "file-export": 61981,
  "file-find": 61982,
  "file-hidden": 62995,
  "file-image": 61983,
  "file-import": 61984,
  "file-lock": 61985,
  "file-move": 64184,
  "file-multiple": 61986,
  "file-music": 61987,
  "file-outline": 61988,
  "file-pdf": 61989,
  "file-pdf-box": 61990,
  "file-percent": 63517,
  "file-plus": 63313,
  "file-powerpoint": 61991,
  "file-powerpoint-box": 61992,
  "file-presentation-box": 61993,
  "file-question": 63598,
  "file-replace": 64279,
  "file-replace-outline": 64280,
  "file-restore": 63088,
  "file-send": 61994,
  "file-tree": 63045,
  "file-undo": 63707,
  "file-upload": 64076,
  "file-upload-outline": 64077,
  "file-video": 61995,
  "file-word": 61996,
  "file-word-box": 61997,
  "file-xml": 61998,
  "film": 61999,
  "filmstrip": 62000,
  "filmstrip-off": 62001,
  "filter": 62002,
  "filter-outline": 62003,
  "filter-remove": 62004,
  "filter-remove-outline": 62005,
  "filter-variant": 62006,
  "finance": 63518,
  "find-replace": 63187,
  "fingerprint": 62007,
  "fire": 62008,
  "fire-truck": 63658,
  "firebase": 63846,
  "firefox": 62009,
  "fish": 62010,
  "flag": 62011,
  "flag-checkered": 62012,
  "flag-outline": 62013,
  "flag-triangle": 62015,
  "flag-variant": 62016,
  "flag-variant-outline": 62014,
  "flash": 62017,
  "flash-auto": 62018,
  "flash-circle": 63519,
  "flash-off": 62019,
  "flash-outline": 63188,
  "flash-red-eye": 63098,
  "flashlight": 62020,
  "flashlight-off": 62021,
  "flask": 61587,
  "flask-empty": 61588,
  "flask-empty-outline": 61589,
  "flask-outline": 61590,
  "flattr": 62022,
  "flip-to-back": 62023,
  "flip-to-front": 62024,
  "floor-lamp": 63708,
  "floor-plan": 63520,
  "floppy": 62025,
  "floppy-variant": 63982,
  "flower": 62026,
  "flower-outline": 63983,
  "flower-tulip": 63984,
  "flower-tulip-outline": 63985,
  "folder": 62027,
  "folder-account": 62028,
  "folder-clock": 64185,
  "folder-clock-outline": 64186,
  "folder-download": 62029,
  "folder-edit": 63709,
  "folder-google-drive": 62030,
  "folder-image": 62031,
  "folder-key": 63659,
  "folder-key-network": 63660,
  "folder-lock": 62032,
  "folder-lock-open": 62033,
  "folder-move": 62034,
  "folder-multiple": 62035,
  "folder-multiple-image": 62036,
  "folder-multiple-outline": 62037,
  "folder-network": 63599,
  "folder-open": 63343,
  "folder-outline": 62038,
  "folder-plus": 62039,
  "folder-remove": 62040,
  "folder-search": 63847,
  "folder-search-outline": 63848,
  "folder-star": 63132,
  "folder-upload": 62041,
  "font-awesome": 61498,
  "food": 62042,
  "food-apple": 62043,
  "food-croissant": 63431,
  "food-fork-drink": 62962,
  "food-off": 62963,
  "food-variant": 62044,
  "football": 62045,
  "football-australian": 62046,
  "football-helmet": 62047,
  "forklift": 63432,
  "format-align-bottom": 63314,
  "format-align-center": 62048,
  "format-align-justify": 62049,
  "format-align-left": 62050,
  "format-align-middle": 63315,
  "format-align-right": 62051,
  "format-align-top": 63316,
  "format-annotation-minus": 64187,
  "format-annotation-plus": 63046,
  "format-bold": 62052,
  "format-clear": 62053,
  "format-color-fill": 62054,
  "format-color-text": 63133,
  "format-columns": 63710,
  "format-float-center": 62055,
  "format-float-left": 62056,
  "format-float-none": 62057,
  "format-float-right": 62058,
  "format-font": 63189,
  "format-font-size-decrease": 63986,
  "format-font-size-increase": 63987,
  "format-header-1": 62059,
  "format-header-2": 62060,
  "format-header-3": 62061,
  "format-header-4": 62062,
  "format-header-5": 62063,
  "format-header-6": 62064,
  "format-header-decrease": 62065,
  "format-header-equal": 62066,
  "format-header-increase": 62067,
  "format-header-pound": 62068,
  "format-horizontal-align-center": 63006,
  "format-horizontal-align-left": 63007,
  "format-horizontal-align-right": 63008,
  "format-indent-decrease": 62069,
  "format-indent-increase": 62070,
  "format-italic": 62071,
  "format-letter-case": 64281,
  "format-letter-case-lower": 64282,
  "format-letter-case-upper": 64283,
  "format-line-spacing": 62072,
  "format-line-style": 62920,
  "format-line-weight": 62921,
  "format-list-bulleted": 62073,
  "format-list-bulleted-type": 62074,
  "format-list-checkbox": 63849,
  "format-list-checks": 63317,
  "format-list-numbers": 62075,
  "format-page-break": 63190,
  "format-paint": 62076,
  "format-paragraph": 62077,
  "format-pilcrow": 63191,
  "format-quote-close": 62078,
  "format-quote-open": 63318,
  "format-rotate-90": 63145,
  "format-section": 63134,
  "format-size": 62079,
  "format-strikethrough": 62080,
  "format-strikethrough-variant": 62081,
  "format-subscript": 62082,
  "format-superscript": 62083,
  "format-text": 62084,
  "format-textdirection-l-to-r": 62085,
  "format-textdirection-r-to-l": 62086,
  "format-title": 62964,
  "format-underline": 62087,
  "format-vertical-align-bottom": 63009,
  "format-vertical-align-center": 63010,
  "format-vertical-align-top": 63011,
  "format-wrap-inline": 62088,
  "format-wrap-square": 62089,
  "format-wrap-tight": 62090,
  "format-wrap-top-bottom": 62091,
  "forum": 62092,
  "forum-outline": 63521,
  "forward": 62093,
  "fountain": 63850,
  "foursquare": 62094,
  "freebsd": 63711,
  "fridge": 62095,
  "fridge-filled": 62096,
  "fridge-filled-bottom": 62097,
  "fridge-filled-top": 62098,
  "fuel": 63433,
  "fullscreen": 62099,
  "fullscreen-exit": 62100,
  "function": 62101,
  "function-variant": 63600,
  "gamepad": 62102,
  "gamepad-variant": 62103,
  "garage": 63192,
  "garage-alert": 63601,
  "garage-open": 63193,
  "gas-cylinder": 63047,
  "gas-station": 62104,
  "gate": 62105,
  "gate-and": 63712,
  "gate-nand": 63713,
  "gate-nor": 63714,
  "gate-not": 63715,
  "gate-or": 63716,
  "gate-xnor": 63717,
  "gate-xor": 63718,
  "gauge": 62106,
  "gauge-empty": 63602,
  "gauge-full": 63603,
  "gauge-low": 63604,
  "gavel": 62107,
  "gender-female": 62108,
  "gender-male": 62109,
  "gender-male-female": 62110,
  "gender-transgender": 62111,
  "gentoo": 63719,
  "gesture": 63434,
  "gesture-double-tap": 63291,
  "gesture-pinch": 64188,
  "gesture-spread": 64189,
  "gesture-swipe-down": 63292,
  "gesture-swipe-horizontal": 64190,
  "gesture-swipe-left": 63293,
  "gesture-swipe-right": 63294,
  "gesture-swipe-up": 63295,
  "gesture-swipe-vertical": 64191,
  "gesture-tap": 63296,
  "gesture-two-double-tap": 63297,
  "gesture-two-tap": 63298,
  "ghost": 62112,
  "ghost-off": 63988,
  "gift": 62113,
  "git": 62114,
  "github-box": 62115,
  "github-circle": 62116,
  "github-face": 63194,
  "glass-cocktail": 62294,
  "glass-flute": 62117,
  "glass-mug": 62118,
  "glass-stange": 62119,
  "glass-tulip": 62120,
  "glass-wine": 63605,
  "glassdoor": 62121,
  "glasses": 62122,
  "globe-model": 63720,
  "gmail": 62123,
  "gnome": 62124,
  "golf": 63522,
  "gondola": 63109,
  "google": 62125,
  "google-allo": 63489,
  "google-analytics": 63435,
  "google-assistant": 63436,
  "google-cardboard": 62126,
  "google-chrome": 62127,
  "google-circles": 62128,
  "google-circles-communities": 62129,
  "google-circles-extended": 62130,
  "google-circles-group": 62131,
  "google-controller": 62132,
  "google-controller-off": 62133,
  "google-drive": 62134,
  "google-earth": 62135,
  "google-fit": 63851,
  "google-glass": 62136,
  "google-hangouts": 62153,
  "google-home": 63523,
  "google-keep": 63195,
  "google-lens": 63989,
  "google-maps": 62965,
  "google-nearby": 62137,
  "google-pages": 62138,
  "google-photos": 63196,
  "google-physical-web": 62139,
  "google-play": 62140,
  "google-plus": 62141,
  "google-plus-box": 62142,
  "google-spreadsheet": 63990,
  "google-translate": 62143,
  "google-wallet": 62144,
  "gpu": 63661,
  "gradient": 63135,
  "graphql": 63606,
  "grease-pencil": 63048,
  "greater-than": 63852,
  "greater-than-or-equal": 63853,
  "grid": 62145,
  "grid-large": 63319,
  "grid-off": 62146,
  "group": 62147,
  "guitar-acoustic": 63344,
  "guitar-electric": 62148,
  "guitar-pick": 62149,
  "guitar-pick-outline": 62150,
  "guy-fawkes-mask": 63524,
  "hackernews": 63012,
  "hail": 64192,
  "hamburger": 63108,
  "hammer": 63721,
  "hand": 64078,
  "hand-okay": 64079,
  "hand-peace": 64080,
  "hand-peace-variant": 64081,
  "hand-pointing-down": 64082,
  "hand-pointing-left": 64083,
  "hand-pointing-right": 62151,
  "hand-pointing-up": 64084,
  "hanger": 62152,
  "hard-hat": 63854,
  "harddisk": 62154,
  "headphones": 62155,
  "headphones-bluetooth": 63855,
  "headphones-box": 62156,
  "headphones-off": 63437,
  "headphones-settings": 62157,
  "headset": 62158,
  "headset-dock": 62159,
  "headset-off": 62160,
  "heart": 62161,
  "heart-box": 62162,
  "heart-box-outline": 62163,
  "heart-broken": 62164,
  "heart-circle": 63856,
  "heart-circle-outline": 63857,
  "heart-half": 63198,
  "heart-half-full": 63197,
  "heart-half-outline": 63199,
  "heart-multiple": 64085,
  "heart-multiple-outline": 64086,
  "heart-off": 63320,
  "heart-outline": 62165,
  "heart-pulse": 62966,
  "helicopter": 64193,
  "help": 62166,
  "help-box": 63370,
  "help-circle": 62167,
  "help-circle-outline": 63013,
  "help-network": 63220,
  "hexagon": 62168,
  "hexagon-multiple": 63200,
  "hexagon-outline": 62169,
  "hexagon-slice-1": 64194,
  "hexagon-slice-2": 64195,
  "hexagon-slice-3": 64196,
  "hexagon-slice-4": 64197,
  "hexagon-slice-5": 64198,
  "hexagon-slice-6": 64199,
  "hexagram": 64200,
  "hexagram-outline": 64201,
  "high-definition": 63438,
  "high-definition-box": 63607,
  "highway": 62967,
  "hinduism": 63858,
  "history": 62170,
  "hockey-puck": 63608,
  "hockey-sticks": 63609,
  "hololens": 62171,
  "home": 62172,
  "home-account": 63525,
  "home-alert": 63610,
  "home-assistant": 63439,
  "home-automation": 63440,
  "home-circle": 63441,
  "home-currency-usd": 63662,
  "home-heart": 63526,
  "home-lock": 63722,
  "home-lock-open": 63723,
  "home-map-marker": 62968,
  "home-minus": 63859,
  "home-modern": 62173,
  "home-outline": 63136,
  "home-plus": 63860,
  "home-variant": 62174,
  "hook": 63201,
  "hook-off": 63202,
  "hops": 62175,
  "horseshoe": 64087,
  "hospital": 62176,
  "hospital-building": 62177,
  "hospital-marker": 62178,
  "hot-tub": 63527,
  "hotel": 62179,
  "houzz": 62180,
  "houzz-box": 62181,
  "hulu": 63528,
  "human": 62182,
  "human-child": 62183,
  "human-female": 63049,
  "human-female-boy": 64088,
  "human-female-female": 64089,
  "human-female-girl": 64090,
  "human-greeting": 63050,
  "human-handsdown": 63051,
  "human-handsup": 63052,
  "human-male": 63053,
  "human-male-boy": 64091,
  "human-male-female": 62184,
  "human-male-girl": 64092,
  "human-male-male": 64093,
  "human-pregnant": 62927,
  "humble-bundle": 63299,
  "ice-cream": 63529,
  "image": 62185,
  "image-album": 62186,
  "image-area": 62187,
  "image-area-close": 62188,
  "image-broken": 62189,
  "image-broken-variant": 62190,
  "image-filter": 62191,
  "image-filter-black-white": 62192,
  "image-filter-center-focus": 62193,
  "image-filter-center-focus-weak": 62194,
  "image-filter-drama": 62195,
  "image-filter-frames": 62196,
  "image-filter-hdr": 62197,
  "image-filter-none": 62198,
  "image-filter-tilt-shift": 62199,
  "image-filter-vintage": 62200,
  "image-move": 63991,
  "image-multiple": 62201,
  "image-off": 63530,
  "image-outline": 63861,
  "image-plus": 63611,
  "image-search": 63862,
  "image-search-outline": 63863,
  "import": 62202,
  "inbox": 63110,
  "inbox-arrow-down": 62203,
  "inbox-arrow-up": 62417,
  "inbox-multiple": 63663,
  "incognito": 62969,
  "infinity": 63203,
  "information": 62204,
  "information-outline": 62205,
  "information-variant": 63054,
  "instagram": 62206,
  "instapaper": 62207,
  "internet-explorer": 62208,
  "invert-colors": 62209,
  "ip": 64094,
  "ip-network": 64095,
  "islam": 63864,
  "itunes": 63094,
  "jeepney": 62210,
  "jira": 62211,
  "jquery": 63612,
  "jsfiddle": 62212,
  "json": 63014,
  "judaism": 63865,
  "karate": 63531,
  "keg": 62213,
  "kettle": 62970,
  "key": 62214,
  "key-change": 62215,
  "key-minus": 62216,
  "key-plus": 62217,
  "key-remove": 62218,
  "key-variant": 62219,
  "keyboard": 62220,
  "keyboard-backspace": 62221,
  "keyboard-caps": 62222,
  "keyboard-close": 62223,
  "keyboard-off": 62224,
  "keyboard-outline": 63866,
  "keyboard-return": 62225,
  "keyboard-settings": 63992,
  "keyboard-settings-outline": 63993,
  "keyboard-tab": 62226,
  "keyboard-variant": 62227,
  "kickstarter": 63300,
  "knife": 63994,
  "knife-military": 63995,
  "kodi": 62228,
  "label": 62229,
  "label-off": 64202,
  "label-off-outline": 64203,
  "label-outline": 62230,
  "label-variant": 64204,
  "label-variant-outline": 64205,
  "ladybug": 63532,
  "lambda": 63015,
  "lamp": 63156,
  "lan": 62231,
  "lan-connect": 62232,
  "lan-disconnect": 62233,
  "lan-pending": 62234,
  "language-c": 63089,
  "language-cpp": 63090,
  "language-csharp": 62235,
  "language-css3": 62236,
  "language-go": 63442,
  "language-html5": 62237,
  "language-java": 64284,
  "language-javascript": 62238,
  "language-lua": 63664,
  "language-php": 62239,
  "language-python": 62240,
  "language-python-text": 62241,
  "language-r": 63443,
  "language-ruby-on-rails": 64206,
  "language-swift": 63204,
  "language-typescript": 63205,
  "laptop": 62242,
  "laptop-chromebook": 62243,
  "laptop-mac": 62244,
  "laptop-off": 63206,
  "laptop-windows": 62245,
  "laravel": 64207,
  "lastfm": 62246,
  "lastpass": 62534,
  "launch": 62247,
  "lava-lamp": 63444,
  "layers": 62248,
  "layers-off": 62249,
  "layers-off-outline": 63996,
  "layers-outline": 63997,
  "lead-pencil": 63055,
  "leaf": 62250,
  "led-off": 62251,
  "led-on": 62252,
  "led-outline": 62253,
  "led-strip": 63445,
  "led-variant-off": 62254,
  "led-variant-on": 62255,
  "led-variant-outline": 62256,
  "less-than": 63867,
  "less-than-or-equal": 63868,
  "library": 62257,
  "library-books": 62258,
  "library-music": 62259,
  "library-plus": 62260,
  "lifebuoy": 63613,
  "light-switch": 63869,
  "lightbulb": 62261,
  "lightbulb-on": 63207,
  "lightbulb-on-outline": 63208,
  "lightbulb-outline": 62262,
  "lighthouse": 63998,
  "lighthouse-on": 63999,
  "link": 62263,
  "link-off": 62264,
  "link-variant": 62265,
  "link-variant-off": 62266,
  "linkedin": 62267,
  "linkedin-box": 62268,
  "linux": 62269,
  "linux-mint": 63724,
  "litecoin": 64096,
  "loading": 63345,
  "lock": 62270,
  "lock-alert": 63725,
  "lock-clock": 63870,
  "lock-open": 62271,
  "lock-open-outline": 62272,
  "lock-outline": 62273,
  "lock-pattern": 63209,
  "lock-plus": 62971,
  "lock-question": 63726,
  "lock-reset": 63346,
  "lock-smart": 63665,
  "locker": 63446,
  "locker-multiple": 63447,
  "login": 62274,
  "login-variant": 62972,
  "logout": 62275,
  "logout-variant": 62973,
  "looks": 62276,
  "loop": 63210,
  "loupe": 62277,
  "lumx": 62278,
  "lyft": 64285,
  "magnet": 62279,
  "magnet-on": 62280,
  "magnify": 62281,
  "magnify-close": 63871,
  "magnify-minus": 62282,
  "magnify-minus-cursor": 64097,
  "magnify-minus-outline": 63211,
  "magnify-plus": 62283,
  "magnify-plus-cursor": 64098,
  "magnify-plus-outline": 63212,
  "mail-ru": 62284,
  "mailbox": 63213,
  "map": 62285,
  "map-legend": 64000,
  "map-marker": 62286,
  "map-marker-circle": 62287,
  "map-marker-distance": 63727,
  "map-marker-minus": 63056,
  "map-marker-multiple": 62288,
  "map-marker-off": 62289,
  "map-marker-outline": 63448,
  "map-marker-plus": 63057,
  "map-marker-radius": 62290,
  "map-minus": 63872,
  "map-outline": 63873,
  "map-plus": 63874,
  "map-search": 63875,
  "map-search-outline": 63876,
  "margin": 62291,
  "markdown": 62292,
  "marker": 63058,
  "marker-check": 62293,
  "mastodon": 64208,
  "mastodon-variant": 64209,
  "material-design": 63877,
  "material-ui": 62295,
  "math-compass": 62296,
  "matrix": 63016,
  "maxcdn": 62297,
  "medal": 63878,
  "medical-bag": 63214,
  "medium": 62298,
  "meetup": 64210,
  "memory": 62299,
  "menu": 62300,
  "menu-down": 62301,
  "menu-down-outline": 63157,
  "menu-left": 62302,
  "menu-left-outline": 64001,
  "menu-right": 62303,
  "menu-right-outline": 64002,
  "menu-swap": 64099,
  "menu-swap-outline": 64100,
  "menu-up": 62304,
  "menu-up-outline": 63158,
  "message": 62305,
  "message-alert": 62306,
  "message-alert-outline": 64003,
  "message-bulleted": 63137,
  "message-bulleted-off": 63138,
  "message-draw": 62307,
  "message-image": 62308,
  "message-outline": 62309,
  "message-plus": 63059,
  "message-processing": 62310,
  "message-reply": 62311,
  "message-reply-text": 62312,
  "message-settings": 63215,
  "message-settings-variant": 63216,
  "message-text": 62313,
  "message-text-outline": 62314,
  "message-video": 62315,
  "meteor": 63017,
  "metronome": 63449,
  "metronome-tick": 63450,
  "micro-sd": 63451,
  "microphone": 62316,
  "microphone-minus": 63666,
  "microphone-off": 62317,
  "microphone-outline": 62318,
  "microphone-plus": 63667,
  "microphone-settings": 62319,
  "microphone-variant": 62320,
  "microphone-variant-off": 62321,
  "microscope": 63060,
  "microsoft": 62322,
  "microsoft-dynamics": 63879,
  "midi": 63728,
  "midi-port": 63729,
  "minecraft": 62323,
  "mini-sd": 64004,
  "minidisc": 64005,
  "minus": 62324,
  "minus-box": 62325,
  "minus-box-outline": 63217,
  "minus-circle": 62326,
  "minus-circle-outline": 62327,
  "minus-network": 62328,
  "mixcloud": 63018,
  "mixed-reality": 63614,
  "mixer": 63452,
  "monitor": 62329,
  "monitor-cellphone": 63880,
  "monitor-cellphone-star": 63881,
  "monitor-dashboard": 64006,
  "monitor-multiple": 62330,
  "more": 62331,
  "motorbike": 62332,
  "mouse": 62333,
  "mouse-bluetooth": 63882,
  "mouse-off": 62334,
  "mouse-variant": 62335,
  "mouse-variant-off": 62336,
  "move-resize": 63061,
  "move-resize-variant": 63062,
  "movie": 62337,
  "movie-roll": 63453,
  "muffin": 63883,
  "multiplication": 62338,
  "multiplication-box": 62339,
  "mushroom": 63454,
  "mushroom-outline": 63455,
  "music": 63321,
  "music-box": 62340,
  "music-box-outline": 62341,
  "music-circle": 62342,
  "music-circle-outline": 64211,
  "music-note": 62343,
  "music-note-bluetooth": 62974,
  "music-note-bluetooth-off": 62975,
  "music-note-eighth": 62344,
  "music-note-half": 62345,
  "music-note-off": 62346,
  "music-note-quarter": 62347,
  "music-note-sixteenth": 62348,
  "music-note-whole": 62349,
  "music-off": 63322,
  "nas": 63730,
  "nativescript": 63615,
  "nature": 62350,
  "nature-people": 62351,
  "navigation": 62352,
  "near-me": 62925,
  "needle": 62353,
  "netflix": 63301,
  "network": 63218,
  "network-strength-1": 63731,
  "network-strength-1-alert": 63732,
  "network-strength-2": 63733,
  "network-strength-2-alert": 63734,
  "network-strength-3": 63735,
  "network-strength-3-alert": 63736,
  "network-strength-4": 63737,
  "network-strength-4-alert": 63738,
  "network-strength-off": 63739,
  "network-strength-off-outline": 63740,
  "network-strength-outline": 63741,
  "new-box": 62356,
  "newspaper": 62357,
  "nfc": 62358,
  "nfc-tap": 62359,
  "nfc-variant": 62360,
  "ninja": 63347,
  "nintendo-switch": 63456,
  "nodejs": 62361,
  "not-equal": 63884,
  "not-equal-variant": 63885,
  "note": 62362,
  "note-multiple": 63159,
  "note-multiple-outline": 63160,
  "note-outline": 62363,
  "note-plus": 62364,
  "note-plus-outline": 62365,
  "note-text": 62366,
  "notebook": 63533,
  "notification-clear-all": 62367,
  "npm": 63222,
  "npm-variant": 63886,
  "npm-variant-outline": 63887,
  "nuke": 63139,
  "null": 63457,
  "numeric": 62368,
  "numeric-0": 48,
  "numeric-0-box": 62369,
  "numeric-0-box-multiple-outline": 62370,
  "numeric-0-box-outline": 62371,
  "numeric-1": 49,
  "numeric-1-box": 62372,
  "numeric-1-box-multiple-outline": 62373,
  "numeric-1-box-outline": 62374,
  "numeric-2": 50,
  "numeric-2-box": 62375,
  "numeric-2-box-multiple-outline": 62376,
  "numeric-2-box-outline": 62377,
  "numeric-3": 51,
  "numeric-3-box": 62378,
  "numeric-3-box-multiple-outline": 62379,
  "numeric-3-box-outline": 62380,
  "numeric-4": 52,
  "numeric-4-box": 62381,
  "numeric-4-box-multiple-outline": 62382,
  "numeric-4-box-outline": 62383,
  "numeric-5": 53,
  "numeric-5-box": 62384,
  "numeric-5-box-multiple-outline": 62385,
  "numeric-5-box-outline": 62386,
  "numeric-6": 54,
  "numeric-6-box": 62387,
  "numeric-6-box-multiple-outline": 62388,
  "numeric-6-box-outline": 62389,
  "numeric-7": 55,
  "numeric-7-box": 62390,
  "numeric-7-box-multiple-outline": 62391,
  "numeric-7-box-outline": 62392,
  "numeric-8": 56,
  "numeric-8-box": 62393,
  "numeric-8-box-multiple-outline": 62394,
  "numeric-8-box-outline": 62395,
  "numeric-9": 57,
  "numeric-9-box": 62396,
  "numeric-9-box-multiple-outline": 62397,
  "numeric-9-box-outline": 62398,
  "numeric-9-plus-box": 62399,
  "numeric-9-plus-box-multiple-outline": 62400,
  "numeric-9-plus-box-outline": 62401,
  "nut": 63223,
  "nutrition": 62402,
  "oar": 63099,
  "octagon": 62403,
  "octagon-outline": 62404,
  "octagram": 63224,
  "octagram-outline": 63348,
  "odnoklassniki": 62405,
  "office": 62406,
  "office-building": 63888,
  "oil": 62407,
  "oil-temperature": 62408,
  "omega": 62409,
  "onedrive": 62410,
  "onenote": 63302,
  "onepassword": 63616,
  "opacity": 62924,
  "open-in-app": 62411,
  "open-in-new": 62412,
  "openid": 62413,
  "opera": 62414,
  "orbit": 61464,
  "origin": 64299,
  "ornament": 62415,
  "ornament-variant": 62416,
  "owl": 62418,
  "package": 62419,
  "package-down": 62420,
  "package-up": 62421,
  "package-variant": 62422,
  "package-variant-closed": 62423,
  "page-first": 62976,
  "page-last": 62977,
  "page-layout-body": 63225,
  "page-layout-footer": 63226,
  "page-layout-header": 63227,
  "page-layout-sidebar-left": 63228,
  "page-layout-sidebar-right": 63229,
  "palette": 62424,
  "palette-advanced": 62425,
  "palette-swatch": 63668,
  "panda": 62426,
  "pandora": 62427,
  "panorama": 62428,
  "panorama-fisheye": 62429,
  "panorama-horizontal": 62430,
  "panorama-vertical": 62431,
  "panorama-wide-angle": 62432,
  "paper-cut-vertical": 62433,
  "paperclip": 62434,
  "parking": 62435,
  "passport": 63458,
  "patreon": 63617,
  "pause": 62436,
  "pause-circle": 62437,
  "pause-circle-outline": 62438,
  "pause-octagon": 62439,
  "pause-octagon-outline": 62440,
  "paw": 62441,
  "paw-off": 63063,
  "paypal": 63618,
  "peace": 63619,
  "pen": 62442,
  "pencil": 62443,
  "pencil-box": 62444,
  "pencil-box-outline": 62445,
  "pencil-circle": 63230,
  "pencil-circle-outline": 63349,
  "pencil-lock": 62446,
  "pencil-off": 62447,
  "pentagon": 63231,
  "pentagon-outline": 63232,
  "percent": 62448,
  "periodic-table": 63669,
  "periodic-table-co2": 63459,
  "periscope": 63303,
  "pharmacy": 62449,
  "phone": 62450,
  "phone-bluetooth": 62451,
  "phone-classic": 62978,
  "phone-forward": 62452,
  "phone-hangup": 62453,
  "phone-in-talk": 62454,
  "phone-incoming": 62455,
  "phone-lock": 62456,
  "phone-log": 62457,
  "phone-minus": 63064,
  "phone-missed": 62458,
  "phone-outgoing": 62459,
  "phone-paused": 62460,
  "phone-plus": 63065,
  "phone-return": 63534,
  "phone-rotate-landscape": 63620,
  "phone-rotate-portrait": 63621,
  "phone-settings": 62461,
  "phone-voip": 62462,
  "pi": 62463,
  "pi-box": 62464,
  "piano": 63100,
  "pickaxe": 63670,
  "pier": 63622,
  "pier-crane": 63623,
  "pig": 62465,
  "pill": 62466,
  "pillar": 63233,
  "pin": 62467,
  "pin-off": 62468,
  "pin-off-outline": 63791,
  "pin-outline": 63792,
  "pine-tree": 62469,
  "pine-tree-box": 62470,
  "pinterest": 62471,
  "pinterest-box": 62472,
  "pinwheel": 64212,
  "pinwheel-outline": 64213,
  "pipe": 63460,
  "pipe-disconnected": 63461,
  "pipe-leak": 63624,
  "pirate": 64007,
  "pistol": 63234,
  "piston": 63625,
  "pizza": 62473,
  "plane-shield": 63162,
  "play": 62474,
  "play-box-outline": 62475,
  "play-circle": 62476,
  "play-circle-outline": 62477,
  "play-network": 63626,
  "play-pause": 62478,
  "play-protected-content": 62479,
  "play-speed": 63742,
  "playlist-check": 62919,
  "playlist-edit": 63743,
  "playlist-minus": 62480,
  "playlist-play": 62481,
  "playlist-plus": 62482,
  "playlist-remove": 62483,
  "playstation": 62484,
  "plex": 63161,
  "plus": 62485,
  "plus-box": 62486,
  "plus-box-outline": 63235,
  "plus-circle": 62487,
  "plus-circle-multiple-outline": 62488,
  "plus-circle-outline": 62489,
  "plus-minus": 63889,
  "plus-minus-box": 63890,
  "plus-network": 62490,
  "plus-one": 62491,
  "plus-outline": 63236,
  "pocket": 62492,
  "podcast": 63891,
  "pokeball": 62493,
  "pokemon-go": 64008,
  "poker-chip": 63535,
  "polaroid": 62494,
  "poll": 62495,
  "poll-box": 62496,
  "polymer": 62497,
  "pool": 62982,
  "popcorn": 62498,
  "pot": 63066,
  "pot-mix": 63067,
  "pound": 62499,
  "pound-box": 62500,
  "power": 62501,
  "power-cycle": 63744,
  "power-off": 63745,
  "power-on": 63746,
  "power-plug": 63140,
  "power-plug-off": 63141,
  "power-settings": 62502,
  "power-sleep": 63747,
  "power-socket": 62503,
  "power-socket-au": 63748,
  "power-socket-eu": 63462,
  "power-socket-uk": 63463,
  "power-socket-us": 63464,
  "power-standby": 63749,
  "powershell": 64009,
  "prescription": 63237,
  "presentation": 62504,
  "presentation-play": 62505,
  "printer": 62506,
  "printer-3d": 62507,
  "printer-alert": 62508,
  "printer-settings": 63238,
  "printer-wireless": 64010,
  "priority-high": 62979,
  "priority-low": 62980,
  "professional-hexagon": 62509,
  "progress-check": 63892,
  "progress-clock": 63893,
  "progress-download": 63894,
  "progress-upload": 63895,
  "projector": 62510,
  "projector-screen": 62511,
  "publish": 63142,
  "pulse": 62512,
  "puzzle": 62513,
  "puzzle-outline": 64101,
  "qi": 63896,
  "qqchat": 62981,
  "qrcode": 62514,
  "qrcode-edit": 63671,
  "qrcode-scan": 62515,
  "quadcopter": 62516,
  "quality-high": 62517,
  "quality-low": 64011,
  "quality-medium": 64012,
  "quicktime": 62518,
  "rabbit": 63750,
  "radar": 62519,
  "radiator": 62520,
  "radiator-disabled": 64214,
  "radiator-off": 64215,
  "radio": 62521,
  "radio-handheld": 62522,
  "radio-tower": 62523,
  "radioactive": 62524,
  "radiobox-blank": 62525,
  "radiobox-marked": 62526,
  "raspberrypi": 62527,
  "ray-end": 62528,
  "ray-end-arrow": 62529,
  "ray-start": 62530,
  "ray-start-arrow": 62531,
  "ray-start-end": 62532,
  "ray-vertex": 62533,
  "react": 63239,
  "read": 62535,
  "receipt": 62537,
  "record": 62538,
  "record-player": 63897,
  "record-rec": 62539,
  "recycle": 62540,
  "reddit": 62541,
  "redo": 62542,
  "redo-variant": 62543,
  "reflect-horizontal": 64013,
  "reflect-vertical": 64014,
  "refresh": 62544,
  "regex": 62545,
  "registered-trademark": 64102,
  "relative-scale": 62546,
  "reload": 62547,
  "reminder": 63627,
  "remote": 62548,
  "remote-desktop": 63672,
  "rename-box": 62549,
  "reorder-horizontal": 63111,
  "reorder-vertical": 63112,
  "repeat": 62550,
  "repeat-off": 62551,
  "repeat-once": 62552,
  "replay": 62553,
  "reply": 62554,
  "reply-all": 62555,
  "reproduction": 62556,
  "resistor": 64287,
  "resistor-nodes": 64288,
  "resize": 64103,
  "resize-bottom-right": 62557,
  "responsive": 62558,
  "restart": 63240,
  "restore": 63898,
  "restore-clock": 63143,
  "rewind": 62559,
  "rewind-outline": 63241,
  "rhombus": 63242,
  "rhombus-medium": 64015,
  "rhombus-outline": 63243,
  "rhombus-split": 64016,
  "ribbon": 62560,
  "rice": 63465,
  "ring": 63466,
  "road": 62561,
  "road-variant": 62562,
  "robot": 63144,
  "robot-industrial": 64289,
  "robot-vacuum": 63244,
  "robot-vacuum-variant": 63751,
  "rocket": 62563,
  "room-service": 63628,
  "rotate-3d": 62564,
  "rotate-left": 62565,
  "rotate-left-variant": 62566,
  "rotate-right": 62567,
  "rotate-right-variant": 62568,
  "rounded-corner": 62983,
  "router-wireless": 62569,
  "router-wireless-settings": 64104,
  "routes": 62570,
  "rowing": 62984,
  "rss": 62571,
  "rss-box": 62572,
  "ruler": 62573,
  "run": 63245,
  "run-fast": 62574,
  "safe": 64105,
  "sale": 62575,
  "salesforce": 63629,
  "sass": 63467,
  "satellite": 62576,
  "satellite-uplink": 63752,
  "satellite-variant": 62577,
  "sausage": 63673,
  "saxophone": 62985,
  "scale": 62578,
  "scale-balance": 62929,
  "scale-bathroom": 62579,
  "scanner": 63146,
  "scanner-off": 63753,
  "school": 62580,
  "scissors-cutting": 64106,
  "screen-rotation": 62581,
  "screen-rotation-lock": 62582,
  "screwdriver": 62583,
  "script": 62584,
  "sd": 62585,
  "seal": 62586,
  "search-web": 63246,
  "seat-flat": 62587,
  "seat-flat-angled": 62588,
  "seat-individual-suite": 62589,
  "seat-legroom-extra": 62590,
  "seat-legroom-normal": 62591,
  "seat-legroom-reduced": 62592,
  "seat-recline-extra": 62593,
  "seat-recline-normal": 62594,
  "security": 62595,
  "security-account": 63630,
  "security-account-outline": 64017,
  "security-close": 63899,
  "security-home": 63113,
  "security-lock": 63900,
  "security-network": 62596,
  "security-off": 63901,
  "select": 62597,
  "select-all": 62598,
  "select-compare": 64216,
  "select-drag": 64107,
  "select-inverse": 62599,
  "select-off": 62600,
  "selection": 62601,
  "selection-drag": 64108,
  "selection-off": 63350,
  "send": 62602,
  "send-lock": 63468,
  "serial-port": 63068,
  "server": 62603,
  "server-minus": 62604,
  "server-network": 62605,
  "server-network-off": 62606,
  "server-off": 62607,
  "server-plus": 62608,
  "server-remove": 62609,
  "server-security": 62610,
  "set-all": 63351,
  "set-center": 63352,
  "set-center-right": 63353,
  "set-left": 63354,
  "set-left-center": 63355,
  "set-left-right": 63356,
  "set-none": 63357,
  "set-right": 63358,
  "set-top-box": 63902,
  "settings": 62611,
  "settings-box": 62612,
  "settings-helper": 64109,
  "settings-outline": 63674,
  "shape": 63536,
  "shape-circle-plus": 63069,
  "shape-outline": 63537,
  "shape-plus": 62613,
  "shape-polygon-plus": 63070,
  "shape-rectangle-plus": 63071,
  "shape-square-plus": 63072,
  "share": 62614,
  "share-outline": 63793,
  "share-variant": 62615,
  "shield": 62616,
  "shield-half-full": 63359,
  "shield-outline": 62617,
  "shield-plus": 64217,
  "shield-plus-outline": 64218,
  "shield-remove": 64219,
  "shield-remove-outline": 64220,
  "ship-wheel": 63538,
  "shoe-formal": 64290,
  "shoe-heel": 64291,
  "shopify": 64221,
  "shopping": 62618,
  "shopping-music": 62619,
  "shovel": 63247,
  "shovel-off": 63248,
  "shower": 63903,
  "shower-head": 63904,
  "shredder": 62620,
  "shuffle": 62621,
  "shuffle-disabled": 62622,
  "shuffle-variant": 62623,
  "sigma": 62624,
  "sigma-lower": 63019,
  "sign-caution": 62625,
  "sign-direction": 63360,
  "sign-text": 63361,
  "signal": 62626,
  "signal-2g": 63249,
  "signal-3g": 63250,
  "signal-4g": 63251,
  "signal-5g": 64110,
  "signal-cellular-1": 63675,
  "signal-cellular-2": 63676,
  "signal-cellular-3": 63677,
  "signal-cellular-outline": 63678,
  "signal-hspa": 63252,
  "signal-hspa-plus": 63253,
  "signal-off": 63362,
  "signal-variant": 62986,
  "silo": 64292,
  "silverware": 62627,
  "silverware-fork": 62628,
  "silverware-fork-knife": 64111,
  "silverware-spoon": 62629,
  "silverware-variant": 62630,
  "sim": 62631,
  "sim-alert": 62632,
  "sim-off": 62633,
  "sina-weibo": 64222,
  "sitemap": 62634,
  "skip-backward": 62635,
  "skip-forward": 62636,
  "skip-next": 62637,
  "skip-next-circle": 63073,
  "skip-next-circle-outline": 63074,
  "skip-previous": 62638,
  "skip-previous-circle": 63075,
  "skip-previous-circle-outline": 63076,
  "skull": 63115,
  "skype": 62639,
  "skype-business": 62640,
  "slack": 62641,
  "slackware": 63754,
  "sleep": 62642,
  "sleep-off": 62643,
  "smog": 64112,
  "smoke-detector": 62354,
  "smoking": 62644,
  "smoking-off": 62645,
  "snapchat": 62646,
  "snowflake": 63254,
  "snowman": 62647,
  "soccer": 62648,
  "soccer-field": 63539,
  "sofa": 62649,
  "solar-power": 64113,
  "solid": 63116,
  "sort": 62650,
  "sort-alphabetical": 62651,
  "sort-ascending": 62652,
  "sort-descending": 62653,
  "sort-numeric": 62654,
  "sort-variant": 62655,
  "soundcloud": 62656,
  "source-branch": 63020,
  "source-commit": 63255,
  "source-commit-end": 63256,
  "source-commit-end-local": 63257,
  "source-commit-local": 63258,
  "source-commit-next-local": 63259,
  "source-commit-start": 63260,
  "source-commit-start-next-local": 63261,
  "source-fork": 62657,
  "source-merge": 63021,
  "source-pull": 62658,
  "soy-sauce": 63469,
  "speaker": 62659,
  "speaker-bluetooth": 63905,
  "speaker-off": 62660,
  "speaker-wireless": 63262,
  "speedometer": 62661,
  "spellcheck": 62662,
  "spotify": 62663,
  "spotlight": 62664,
  "spotlight-beam": 62665,
  "spray": 63077,
  "spray-bottle": 64223,
  "square": 63331,
  "square-edit-outline": 63755,
  "square-inc": 62666,
  "square-inc-cash": 62667,
  "square-medium": 64018,
  "square-medium-outline": 64019,
  "square-outline": 63330,
  "square-root": 63363,
  "square-root-box": 63906,
  "square-small": 64020,
  "squeegee": 64224,
  "ssh": 63679,
  "stack-exchange": 62987,
  "stack-overflow": 62668,
  "stadium": 63263,
  "stairs": 62669,
  "standard-definition": 63470,
  "star": 62670,
  "star-box": 64114,
  "star-box-outline": 64115,
  "star-circle": 62671,
  "star-circle-outline": 63907,
  "star-face": 63908,
  "star-four-points": 64225,
  "star-four-points-outline": 64226,
  "star-half": 62672,
  "star-off": 62673,
  "star-outline": 62674,
  "star-three-points": 64227,
  "star-three-points-outline": 64228,
  "steam": 62675,
  "steam-box": 63756,
  "steering": 62676,
  "steering-off": 63757,
  "step-backward": 62677,
  "step-backward-2": 62678,
  "step-forward": 62679,
  "step-forward-2": 62680,
  "stethoscope": 62681,
  "sticker": 62928,
  "sticker-emoji": 63364,
  "stocking": 62682,
  "stop": 62683,
  "stop-circle": 63078,
  "stop-circle-outline": 63079,
  "store": 62684,
  "store-24-hour": 62685,
  "stove": 62686,
  "strava": 64293,
  "subdirectory-arrow-left": 62988,
  "subdirectory-arrow-right": 62989,
  "subtitles": 64021,
  "subtitles-outline": 64022,
  "subway": 63147,
  "subway-variant": 62687,
  "summit": 63365,
  "sunglasses": 62688,
  "surround-sound": 62917,
  "surround-sound-2-0": 63471,
  "surround-sound-3-1": 63472,
  "surround-sound-5-1": 63473,
  "surround-sound-7-1": 63474,
  "svg": 63264,
  "swap-horizontal": 62689,
  "swap-horizontal-variant": 63680,
  "swap-vertical": 62690,
  "swap-vertical-variant": 63681,
  "swim": 62691,
  "switch": 62692,
  "sword": 62693,
  "sword-cross": 63366,
  "symfony": 64229,
  "sync": 62694,
  "sync-alert": 62695,
  "sync-off": 62696,
  "tab": 62697,
  "tab-minus": 64294,
  "tab-plus": 63323,
  "tab-remove": 64295,
  "tab-unselected": 62698,
  "table": 62699,
  "table-border": 64023,
  "table-column": 63540,
  "table-column-plus-after": 62700,
  "table-column-plus-before": 62701,
  "table-column-remove": 62702,
  "table-column-width": 62703,
  "table-edit": 62704,
  "table-large": 62705,
  "table-merge-cells": 63909,
  "table-of-contents": 63541,
  "table-plus": 64116,
  "table-remove": 64117,
  "table-row": 63542,
  "table-row-height": 62706,
  "table-row-plus-after": 62707,
  "table-row-plus-before": 62708,
  "table-row-remove": 62709,
  "table-search": 63758,
  "table-settings": 63543,
  "tablet": 62710,
  "tablet-android": 62711,
  "tablet-cellphone": 63910,
  "tablet-ipad": 62712,
  "taco": 63329,
  "tag": 62713,
  "tag-faces": 62714,
  "tag-heart": 63114,
  "tag-minus": 63759,
  "tag-multiple": 62715,
  "tag-outline": 62716,
  "tag-plus": 63265,
  "tag-remove": 63266,
  "tag-text-outline": 62717,
  "tape-measure": 64296,
  "target": 62718,
  "target-variant": 64118,
  "taxi": 62719,
  "teach": 63631,
  "teamviewer": 62720,
  "telegram": 62721,
  "telescope": 64297,
  "television": 62722,
  "television-box": 63544,
  "television-classic": 63475,
  "television-classic-off": 63545,
  "television-guide": 62723,
  "television-off": 63546,
  "temperature-celsius": 62724,
  "temperature-fahrenheit": 62725,
  "temperature-kelvin": 62726,
  "tennis": 62727,
  "tent": 62728,
  "terrain": 62729,
  "test-tube": 63080,
  "test-tube-empty": 63760,
  "test-tube-off": 63761,
  "text": 63911,
  "text-shadow": 63081,
  "text-short": 63912,
  "text-subject": 63913,
  "text-to-speech": 62730,
  "text-to-speech-off": 62731,
  "textbox": 62990,
  "textbox-password": 63476,
  "texture": 62732,
  "theater": 62733,
  "theme-light-dark": 62734,
  "thermometer": 62735,
  "thermometer-lines": 62736,
  "thermostat": 62355,
  "thermostat-box": 63632,
  "thought-bubble": 63477,
  "thought-bubble-outline": 63478,
  "thumb-down": 62737,
  "thumb-down-outline": 62738,
  "thumb-up": 62739,
  "thumb-up-outline": 62740,
  "thumbs-up-down": 62741,
  "ticket": 62742,
  "ticket-account": 62743,
  "ticket-confirmation": 62744,
  "ticket-outline": 63762,
  "ticket-percent": 63267,
  "tie": 62745,
  "tilde": 63268,
  "timelapse": 62746,
  "timer": 62747,
  "timer-10": 62748,
  "timer-3": 62749,
  "timer-off": 62750,
  "timer-sand": 62751,
  "timer-sand-empty": 63148,
  "timer-sand-full": 63371,
  "timetable": 62752,
  "toggle-switch": 62753,
  "toggle-switch-off": 62754,
  "toggle-switch-off-outline": 64024,
  "toggle-switch-outline": 64025,
  "toilet": 63914,
  "toolbox": 63915,
  "toolbox-outline": 63916,
  "tooltip": 62755,
  "tooltip-edit": 62756,
  "tooltip-image": 62757,
  "tooltip-outline": 62758,
  "tooltip-outline-plus": 62759,
  "tooltip-text": 62760,
  "tooth": 63682,
  "tooth-outline": 62761,
  "tor": 62762,
  "tournament": 63917,
  "tower-beach": 63104,
  "tower-fire": 63105,
  "towing": 63547,
  "track-light": 63763,
  "trackpad": 63479,
  "trackpad-lock": 63794,
  "tractor": 63633,
  "trademark": 64119,
  "traffic-light": 62763,
  "train": 62764,
  "train-variant": 63683,
  "tram": 62765,
  "transcribe": 62766,
  "transcribe-close": 62767,
  "transfer": 62768,
  "transit-transfer": 63149,
  "transition": 63764,
  "transition-masked": 63765,
  "translate": 62922,
  "trash-can": 64120,
  "trash-can-outline": 64121,
  "treasure-chest": 63269,
  "tree": 62769,
  "trello": 62770,
  "trending-down": 62771,
  "trending-neutral": 62772,
  "trending-up": 62773,
  "triangle": 62774,
  "triangle-outline": 62775,
  "trophy": 62776,
  "trophy-award": 62777,
  "trophy-outline": 62778,
  "trophy-variant": 62779,
  "trophy-variant-outline": 62780,
  "truck": 62781,
  "truck-delivery": 62782,
  "truck-fast": 63367,
  "truck-trailer": 63270,
  "tshirt-crew": 64122,
  "tshirt-crew-outline": 62783,
  "tshirt-v": 64123,
  "tshirt-v-outline": 62784,
  "tumble-dryer": 63766,
  "tumblr": 62785,
  "tumblr-box": 63767,
  "tumblr-reblog": 62786,
  "tune": 63022,
  "tune-vertical": 63082,
  "twitch": 62787,
  "twitter": 62788,
  "twitter-box": 62789,
  "twitter-circle": 62790,
  "twitter-retweet": 62791,
  "two-factor-authentication": 63918,
  "uber": 63304,
  "ubuntu": 62792,
  "ultra-high-definition": 63480,
  "umbraco": 62793,
  "umbrella": 62794,
  "umbrella-closed": 63919,
  "umbrella-outline": 62795,
  "undo": 62796,
  "undo-variant": 62797,
  "unfold-less-horizontal": 62798,
  "unfold-less-vertical": 63327,
  "unfold-more-horizontal": 62799,
  "unfold-more-vertical": 63328,
  "ungroup": 62800,
  "unity": 63150,
  "unreal": 63920,
  "untappd": 62801,
  "update": 63151,
  "upload": 62802,
  "upload-multiple": 63548,
  "upload-network": 63221,
  "usb": 62803,
  "van-passenger": 63481,
  "van-utility": 63482,
  "vanish": 63483,
  "variable": 64230,
  "vector-arrange-above": 62804,
  "vector-arrange-below": 62805,
  "vector-bezier": 64231,
  "vector-circle": 62806,
  "vector-circle-variant": 62807,
  "vector-combine": 62808,
  "vector-curve": 62809,
  "vector-difference": 62810,
  "vector-difference-ab": 62811,
  "vector-difference-ba": 62812,
  "vector-ellipse": 63634,
  "vector-intersection": 62813,
  "vector-line": 62814,
  "vector-point": 62815,
  "vector-polygon": 62816,
  "vector-polyline": 62817,
  "vector-radius": 63305,
  "vector-rectangle": 62918,
  "vector-selection": 62818,
  "vector-square": 61441,
  "vector-triangle": 62819,
  "vector-union": 62820,
  "venmo": 62840,
  "verified": 62821,
  "vhs": 64026,
  "vibrate": 62822,
  "video": 62823,
  "video-3d": 63484,
  "video-4k-box": 63549,
  "video-account": 63768,
  "video-image": 63769,
  "video-input-antenna": 63550,
  "video-input-component": 63551,
  "video-input-hdmi": 63552,
  "video-input-svideo": 63553,
  "video-minus": 63921,
  "video-off": 62824,
  "video-plus": 63922,
  "video-stabilization": 63770,
  "video-switch": 62825,
  "video-vintage": 64027,
  "view-agenda": 62826,
  "view-array": 62827,
  "view-carousel": 62828,
  "view-column": 62829,
  "view-dashboard": 62830,
  "view-dashboard-outline": 64028,
  "view-dashboard-variant": 63554,
  "view-day": 62831,
  "view-grid": 62832,
  "view-headline": 62833,
  "view-list": 62834,
  "view-module": 62835,
  "view-parallel": 63271,
  "view-quilt": 62836,
  "view-sequential": 63272,
  "view-stream": 62837,
  "view-week": 62838,
  "vimeo": 62839,
  "violin": 62991,
  "virtual-reality": 63635,
  "visual-studio": 62992,
  "visual-studio-code": 64029,
  "vk": 62841,
  "vk-box": 62842,
  "vk-circle": 62843,
  "vlc": 62844,
  "voice": 62923,
  "voicemail": 62845,
  "volleyball": 63923,
  "volume-high": 62846,
  "volume-low": 62847,
  "volume-medium": 62848,
  "volume-minus": 63325,
  "volume-mute": 63326,
  "volume-off": 62849,
  "volume-plus": 63324,
  "vote": 64030,
  "vote-outline": 64031,
  "vpn": 62850,
  "vuejs": 63555,
  "walk": 62851,
  "wall": 63485,
  "wall-sconce": 63771,
  "wall-sconce-flat": 63772,
  "wall-sconce-variant": 63773,
  "wallet": 62852,
  "wallet-giftcard": 62853,
  "wallet-membership": 62854,
  "wallet-travel": 62855,
  "wan": 62856,
  "washing-machine": 63273,
  "watch": 62857,
  "watch-export": 62858,
  "watch-export-variant": 63636,
  "watch-import": 62859,
  "watch-import-variant": 63637,
  "watch-variant": 63638,
  "watch-vibrate": 63152,
  "water": 62860,
  "water-off": 62861,
  "water-percent": 62862,
  "water-pump": 62863,
  "watermark": 62994,
  "waves": 63372,
  "weather-cloudy": 62864,
  "weather-fog": 62865,
  "weather-hail": 62866,
  "weather-hurricane": 63639,
  "weather-lightning": 62867,
  "weather-lightning-rainy": 63101,
  "weather-night": 62868,
  "weather-partlycloudy": 62869,
  "weather-pouring": 62870,
  "weather-rainy": 62871,
  "weather-snowy": 62872,
  "weather-snowy-rainy": 63102,
  "weather-sunny": 62873,
  "weather-sunset": 62874,
  "weather-sunset-down": 62875,
  "weather-sunset-up": 62876,
  "weather-windy": 62877,
  "weather-windy-variant": 62878,
  "web": 62879,
  "webcam": 62880,
  "webhook": 63023,
  "webpack": 63274,
  "wechat": 62993,
  "weight": 62881,
  "weight-kilogram": 62882,
  "weight-pound": 63924,
  "whatsapp": 62883,
  "wheelchair-accessibility": 62884,
  "whistle": 63925,
  "white-balance-auto": 62885,
  "white-balance-incandescent": 62886,
  "white-balance-iridescent": 62887,
  "white-balance-sunny": 62888,
  "widgets": 63275,
  "wifi": 62889,
  "wifi-off": 62890,
  "wifi-strength-1": 63774,
  "wifi-strength-1-alert": 63775,
  "wifi-strength-1-lock": 63776,
  "wifi-strength-2": 63777,
  "wifi-strength-2-alert": 63778,
  "wifi-strength-2-lock": 63779,
  "wifi-strength-3": 63780,
  "wifi-strength-3-alert": 63781,
  "wifi-strength-3-lock": 63782,
  "wifi-strength-4": 63783,
  "wifi-strength-4-alert": 63784,
  "wifi-strength-4-lock": 63785,
  "wifi-strength-alert-outline": 63786,
  "wifi-strength-lock-outline": 63787,
  "wifi-strength-off": 63788,
  "wifi-strength-off-outline": 63789,
  "wifi-strength-outline": 63790,
  "wii": 62891,
  "wiiu": 63276,
  "wikipedia": 62892,
  "window-close": 62893,
  "window-closed": 62894,
  "window-maximize": 62895,
  "window-minimize": 62896,
  "window-open": 62897,
  "window-restore": 62898,
  "windows": 62899,
  "windows-classic": 64032,
  "wiper": 64232,
  "wordpress": 62900,
  "worker": 62901,
  "wrap": 62902,
  "wrench": 62903,
  "wunderlist": 62904,
  "xamarin": 63556,
  "xamarin-outline": 63557,
  "xaml": 63091,
  "xbox": 62905,
  "xbox-controller": 62906,
  "xbox-controller-battery-alert": 63306,
  "xbox-controller-battery-charging": 64033,
  "xbox-controller-battery-empty": 63307,
  "xbox-controller-battery-full": 63308,
  "xbox-controller-battery-low": 63309,
  "xbox-controller-battery-medium": 63310,
  "xbox-controller-battery-unknown": 63311,
  "xbox-controller-off": 62907,
  "xda": 62908,
  "xing": 62909,
  "xing-box": 62910,
  "xing-circle": 62911,
  "xml": 62912,
  "xmpp": 63486,
  "yahoo": 64298,
  "yammer": 63368,
  "yeast": 62913,
  "yelp": 62914,
  "yin-yang": 63103,
  "youtube": 62915,
  "youtube-creator-studio": 63558,
  "youtube-gaming": 63559,
  "youtube-tv": 62536,
  "z-wave": 64233,
  "zend": 64234,
  "zip-box": 62916,
  "zip-disk": 64034,
  "zodiac-aquarius": 64124,
  "zodiac-aries": 64125,
  "zodiac-cancer": 64126,
  "zodiac-capricorn": 64127,
  "zodiac-gemini": 64128,
  "zodiac-leo": 64129,
  "zodiac-libra": 64130,
  "zodiac-pisces": 64131,
  "zodiac-sagittarius": 64132,
  "zodiac-scorpio": 64133,
  "zodiac-taurus": 64134,
  "zodiac-virgo": 64135,
  "blank": 63116
};
},699,[],"node_modules\\react-native-vector-icons\\glyphmaps\\MaterialCommunityIcons.json");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getImageSource = exports.ToolbarAndroid = exports.TabBarItemIOS = exports.TabBarItem = exports.Button = exports.default = void 0;

  var _createIconSet = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "./lib/create-icon-set"));

  var _Ionicons = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "./glyphmaps/Ionicons.json"));

  var iconSet = (0, _createIconSet.default)(_Ionicons.default, 'Ionicons', 'Ionicons.ttf');
  var _default = iconSet;
  exports.default = _default;
  var Button = iconSet.Button;
  exports.Button = Button;
  var TabBarItem = iconSet.TabBarItem;
  exports.TabBarItem = TabBarItem;
  var TabBarItemIOS = iconSet.TabBarItemIOS;
  exports.TabBarItemIOS = TabBarItemIOS;
  var ToolbarAndroid = iconSet.ToolbarAndroid;
  exports.ToolbarAndroid = ToolbarAndroid;
  var getImageSource = iconSet.getImageSource;
  exports.getImageSource = getImageSource;
},700,[23,644,701],"node_modules\\react-native-vector-icons\\Ionicons.js");
__d(function(global, require, _aUnused, _bUnused, module, exports, _cUnused) {
  module.exports = {
  "ios-add": 61698,
  "ios-add-circle": 61697,
  "ios-add-circle-outline": 61696,
  "ios-airplane": 61751,
  "ios-alarm": 62408,
  "ios-albums": 62410,
  "ios-alert": 61700,
  "ios-american-football": 61702,
  "ios-analytics": 62414,
  "ios-aperture": 61704,
  "ios-apps": 61706,
  "ios-appstore": 61708,
  "ios-archive": 61710,
  "ios-arrow-back": 62415,
  "ios-arrow-down": 62416,
  "ios-arrow-dropdown": 61712,
  "ios-arrow-dropdown-circle": 61733,
  "ios-arrow-dropleft": 61714,
  "ios-arrow-dropleft-circle": 61737,
  "ios-arrow-dropright": 61716,
  "ios-arrow-dropright-circle": 61739,
  "ios-arrow-dropup": 61718,
  "ios-arrow-dropup-circle": 61741,
  "ios-arrow-forward": 62417,
  "ios-arrow-round-back": 61719,
  "ios-arrow-round-down": 61720,
  "ios-arrow-round-forward": 61721,
  "ios-arrow-round-up": 61722,
  "ios-arrow-up": 62424,
  "ios-at": 62426,
  "ios-attach": 61723,
  "ios-backspace": 61725,
  "ios-barcode": 62428,
  "ios-baseball": 62430,
  "ios-basket": 61727,
  "ios-basketball": 62432,
  "ios-battery-charging": 61728,
  "ios-battery-dead": 61729,
  "ios-battery-full": 61730,
  "ios-beaker": 61732,
  "ios-bed": 61753,
  "ios-beer": 61734,
  "ios-bicycle": 61735,
  "ios-bluetooth": 61736,
  "ios-boat": 61738,
  "ios-body": 62436,
  "ios-bonfire": 61740,
  "ios-book": 62440,
  "ios-bookmark": 61742,
  "ios-bookmarks": 62442,
  "ios-bowtie": 61744,
  "ios-briefcase": 62446,
  "ios-browsers": 62448,
  "ios-brush": 61746,
  "ios-bug": 61748,
  "ios-build": 61750,
  "ios-bulb": 61752,
  "ios-bus": 61754,
  "ios-business": 61859,
  "ios-cafe": 61756,
  "ios-calculator": 62450,
  "ios-calendar": 62452,
  "ios-call": 61758,
  "ios-camera": 62454,
  "ios-car": 61760,
  "ios-card": 61762,
  "ios-cart": 62456,
  "ios-cash": 61764,
  "ios-cellular": 61757,
  "ios-chatboxes": 62458,
  "ios-chatbubbles": 61766,
  "ios-checkbox": 61768,
  "ios-checkbox-outline": 61767,
  "ios-checkmark": 62463,
  "ios-checkmark-circle": 61770,
  "ios-checkmark-circle-outline": 61769,
  "ios-clipboard": 61772,
  "ios-clock": 62467,
  "ios-close": 62470,
  "ios-close-circle": 61774,
  "ios-close-circle-outline": 61773,
  "ios-cloud": 62476,
  "ios-cloud-circle": 61778,
  "ios-cloud-done": 61780,
  "ios-cloud-download": 62472,
  "ios-cloud-outline": 62473,
  "ios-cloud-upload": 62475,
  "ios-cloudy": 62480,
  "ios-cloudy-night": 62478,
  "ios-code": 61783,
  "ios-code-download": 61781,
  "ios-code-working": 61782,
  "ios-cog": 62482,
  "ios-color-fill": 61785,
  "ios-color-filter": 62484,
  "ios-color-palette": 61787,
  "ios-color-wand": 62486,
  "ios-compass": 61789,
  "ios-construct": 61791,
  "ios-contact": 62490,
  "ios-contacts": 61793,
  "ios-contract": 61794,
  "ios-contrast": 61795,
  "ios-copy": 62492,
  "ios-create": 61797,
  "ios-crop": 62494,
  "ios-cube": 61800,
  "ios-cut": 61802,
  "ios-desktop": 61804,
  "ios-disc": 61806,
  "ios-document": 61808,
  "ios-done-all": 61809,
  "ios-download": 62496,
  "ios-easel": 61811,
  "ios-egg": 61813,
  "ios-exit": 61815,
  "ios-expand": 61816,
  "ios-eye": 62501,
  "ios-eye-off": 61818,
  "ios-fastforward": 62503,
  "ios-female": 61819,
  "ios-filing": 62505,
  "ios-film": 62507,
  "ios-finger-print": 61820,
  "ios-fitness": 61867,
  "ios-flag": 62509,
  "ios-flame": 62511,
  "ios-flash": 61822,
  "ios-flash-off": 61743,
  "ios-flashlight": 61761,
  "ios-flask": 62513,
  "ios-flower": 62515,
  "ios-folder": 62517,
  "ios-folder-open": 61824,
  "ios-football": 62519,
  "ios-funnel": 61826,
  "ios-gift": 61841,
  "ios-git-branch": 61827,
  "ios-git-commit": 61828,
  "ios-git-compare": 61829,
  "ios-git-merge": 61830,
  "ios-git-network": 61831,
  "ios-git-pull-request": 61832,
  "ios-glasses": 62527,
  "ios-globe": 61834,
  "ios-grid": 61836,
  "ios-hammer": 61838,
  "ios-hand": 61840,
  "ios-happy": 61842,
  "ios-headset": 61844,
  "ios-heart": 62531,
  "ios-heart-dislike": 61759,
  "ios-heart-empty": 61851,
  "ios-heart-half": 61853,
  "ios-help": 62534,
  "ios-help-buoy": 61846,
  "ios-help-circle": 61848,
  "ios-help-circle-outline": 61847,
  "ios-home": 62536,
  "ios-hourglass": 61699,
  "ios-ice-cream": 61850,
  "ios-image": 61852,
  "ios-images": 61854,
  "ios-infinite": 62538,
  "ios-information": 62541,
  "ios-information-circle": 61856,
  "ios-information-circle-outline": 61855,
  "ios-jet": 61861,
  "ios-journal": 61833,
  "ios-key": 61863,
  "ios-keypad": 62544,
  "ios-laptop": 61864,
  "ios-leaf": 61866,
  "ios-link": 61994,
  "ios-list": 62548,
  "ios-list-box": 61763,
  "ios-locate": 61870,
  "ios-lock": 61872,
  "ios-log-in": 61873,
  "ios-log-out": 61874,
  "ios-magnet": 61876,
  "ios-mail": 61880,
  "ios-mail-open": 61878,
  "ios-mail-unread": 61765,
  "ios-male": 61881,
  "ios-man": 61883,
  "ios-map": 61885,
  "ios-medal": 61887,
  "ios-medical": 62556,
  "ios-medkit": 62558,
  "ios-megaphone": 61889,
  "ios-menu": 61891,
  "ios-mic": 62561,
  "ios-mic-off": 62559,
  "ios-microphone": 61894,
  "ios-moon": 62568,
  "ios-more": 61896,
  "ios-move": 61899,
  "ios-musical-note": 62571,
  "ios-musical-notes": 62572,
  "ios-navigate": 62574,
  "ios-notifications": 61907,
  "ios-notifications-off": 61905,
  "ios-notifications-outline": 61747,
  "ios-nuclear": 61909,
  "ios-nutrition": 62576,
  "ios-open": 61911,
  "ios-options": 61913,
  "ios-outlet": 61915,
  "ios-paper": 62578,
  "ios-paper-plane": 61917,
  "ios-partly-sunny": 61919,
  "ios-pause": 62584,
  "ios-paw": 62586,
  "ios-people": 62588,
  "ios-person": 62590,
  "ios-person-add": 61921,
  "ios-phone-landscape": 61922,
  "ios-phone-portrait": 61923,
  "ios-photos": 62594,
  "ios-pie": 62596,
  "ios-pin": 61925,
  "ios-pint": 62598,
  "ios-pizza": 61927,
  "ios-planet": 61931,
  "ios-play": 62600,
  "ios-play-circle": 61715,
  "ios-podium": 61933,
  "ios-power": 61935,
  "ios-pricetag": 62605,
  "ios-pricetags": 62607,
  "ios-print": 61937,
  "ios-pulse": 62611,
  "ios-qr-scanner": 61939,
  "ios-quote": 61941,
  "ios-radio": 61945,
  "ios-radio-button-off": 61942,
  "ios-radio-button-on": 61943,
  "ios-rainy": 62613,
  "ios-recording": 62615,
  "ios-redo": 62617,
  "ios-refresh": 62620,
  "ios-refresh-circle": 61749,
  "ios-remove": 61948,
  "ios-remove-circle": 61947,
  "ios-remove-circle-outline": 61946,
  "ios-reorder": 61949,
  "ios-repeat": 61950,
  "ios-resize": 61951,
  "ios-restaurant": 61953,
  "ios-return-left": 61954,
  "ios-return-right": 61955,
  "ios-reverse-camera": 62623,
  "ios-rewind": 62625,
  "ios-ribbon": 61957,
  "ios-rocket": 61771,
  "ios-rose": 62627,
  "ios-sad": 61959,
  "ios-save": 61862,
  "ios-school": 61961,
  "ios-search": 62629,
  "ios-send": 61964,
  "ios-settings": 62631,
  "ios-share": 61969,
  "ios-share-alt": 61967,
  "ios-shirt": 61971,
  "ios-shuffle": 62633,
  "ios-skip-backward": 61973,
  "ios-skip-forward": 61975,
  "ios-snow": 61976,
  "ios-speedometer": 62640,
  "ios-square": 61978,
  "ios-square-outline": 61788,
  "ios-star": 62643,
  "ios-star-half": 62641,
  "ios-star-outline": 62642,
  "ios-stats": 61980,
  "ios-stopwatch": 62645,
  "ios-subway": 61982,
  "ios-sunny": 62647,
  "ios-swap": 61983,
  "ios-switch": 61985,
  "ios-sync": 61986,
  "ios-tablet-landscape": 61987,
  "ios-tablet-portrait": 62030,
  "ios-tennisball": 62651,
  "ios-text": 62032,
  "ios-thermometer": 62034,
  "ios-thumbs-down": 62036,
  "ios-thumbs-up": 62038,
  "ios-thunderstorm": 62653,
  "ios-time": 62655,
  "ios-timer": 62657,
  "ios-today": 61775,
  "ios-train": 62040,
  "ios-transgender": 62041,
  "ios-trash": 62661,
  "ios-trending-down": 62042,
  "ios-trending-up": 62043,
  "ios-trophy": 62045,
  "ios-tv": 61717,
  "ios-umbrella": 62047,
  "ios-undo": 62663,
  "ios-unlock": 62049,
  "ios-videocam": 62669,
  "ios-volume-high": 61724,
  "ios-volume-low": 61726,
  "ios-volume-mute": 62051,
  "ios-volume-off": 62052,
  "ios-walk": 62054,
  "ios-wallet": 61835,
  "ios-warning": 62056,
  "ios-watch": 62057,
  "ios-water": 62059,
  "ios-wifi": 62061,
  "ios-wine": 62063,
  "ios-woman": 62065,
  "logo-android": 61989,
  "logo-angular": 61991,
  "logo-apple": 61993,
  "logo-bitbucket": 61843,
  "logo-bitcoin": 61995,
  "logo-buffer": 61997,
  "logo-chrome": 61999,
  "logo-closed-captioning": 61701,
  "logo-codepen": 62000,
  "logo-css3": 62001,
  "logo-designernews": 62002,
  "logo-dribbble": 62003,
  "logo-dropbox": 62004,
  "logo-euro": 62005,
  "logo-facebook": 62006,
  "logo-flickr": 61703,
  "logo-foursquare": 62007,
  "logo-freebsd-devil": 62008,
  "logo-game-controller-a": 61755,
  "logo-game-controller-b": 61825,
  "logo-github": 62009,
  "logo-google": 62010,
  "logo-googleplus": 62011,
  "logo-hackernews": 62012,
  "logo-html5": 62013,
  "logo-instagram": 62014,
  "logo-ionic": 61776,
  "logo-ionitron": 61777,
  "logo-javascript": 62015,
  "logo-linkedin": 62016,
  "logo-markdown": 62017,
  "logo-model-s": 61779,
  "logo-no-smoking": 61705,
  "logo-nodejs": 62018,
  "logo-npm": 61845,
  "logo-octocat": 62019,
  "logo-pinterest": 62020,
  "logo-playstation": 62021,
  "logo-polymer": 61790,
  "logo-python": 62022,
  "logo-reddit": 62023,
  "logo-rss": 62024,
  "logo-sass": 62025,
  "logo-skype": 62026,
  "logo-slack": 61707,
  "logo-snapchat": 62027,
  "logo-steam": 62028,
  "logo-tumblr": 62029,
  "logo-tux": 62126,
  "logo-twitch": 62127,
  "logo-twitter": 62128,
  "logo-usd": 62129,
  "logo-vimeo": 62148,
  "logo-vk": 61709,
  "logo-whatsapp": 62149,
  "logo-windows": 62255,
  "logo-wordpress": 62256,
  "logo-xbox": 62284,
  "logo-xing": 61711,
  "logo-yahoo": 62285,
  "logo-yen": 62286,
  "logo-youtube": 62287,
  "md-add": 62067,
  "md-add-circle": 62066,
  "md-add-circle-outline": 61784,
  "md-airplane": 61786,
  "md-alarm": 62068,
  "md-albums": 62069,
  "md-alert": 62070,
  "md-american-football": 62071,
  "md-analytics": 62072,
  "md-aperture": 62073,
  "md-apps": 62074,
  "md-appstore": 62075,
  "md-archive": 62076,
  "md-arrow-back": 62077,
  "md-arrow-down": 62078,
  "md-arrow-dropdown": 62080,
  "md-arrow-dropdown-circle": 62079,
  "md-arrow-dropleft": 62082,
  "md-arrow-dropleft-circle": 62081,
  "md-arrow-dropright": 62084,
  "md-arrow-dropright-circle": 62083,
  "md-arrow-dropup": 62086,
  "md-arrow-dropup-circle": 62085,
  "md-arrow-forward": 62087,
  "md-arrow-round-back": 62088,
  "md-arrow-round-down": 62089,
  "md-arrow-round-forward": 62090,
  "md-arrow-round-up": 62091,
  "md-arrow-up": 62092,
  "md-at": 62093,
  "md-attach": 62094,
  "md-backspace": 62095,
  "md-barcode": 62096,
  "md-baseball": 62097,
  "md-basket": 62098,
  "md-basketball": 62099,
  "md-battery-charging": 62100,
  "md-battery-dead": 62101,
  "md-battery-full": 62102,
  "md-beaker": 62103,
  "md-bed": 61792,
  "md-beer": 62104,
  "md-bicycle": 62105,
  "md-bluetooth": 62106,
  "md-boat": 62107,
  "md-body": 62108,
  "md-bonfire": 62109,
  "md-book": 62110,
  "md-bookmark": 62111,
  "md-bookmarks": 62112,
  "md-bowtie": 62113,
  "md-briefcase": 62114,
  "md-browsers": 62115,
  "md-brush": 62116,
  "md-bug": 62117,
  "md-build": 62118,
  "md-bulb": 62119,
  "md-bus": 62120,
  "md-business": 61860,
  "md-cafe": 62121,
  "md-calculator": 62122,
  "md-calendar": 62123,
  "md-call": 62124,
  "md-camera": 62125,
  "md-car": 62130,
  "md-card": 62131,
  "md-cart": 62132,
  "md-cash": 62133,
  "md-cellular": 61796,
  "md-chatboxes": 62134,
  "md-chatbubbles": 62135,
  "md-checkbox": 62137,
  "md-checkbox-outline": 62136,
  "md-checkmark": 62140,
  "md-checkmark-circle": 62139,
  "md-checkmark-circle-outline": 62138,
  "md-clipboard": 62141,
  "md-clock": 62142,
  "md-close": 62144,
  "md-close-circle": 62143,
  "md-close-circle-outline": 61798,
  "md-cloud": 62153,
  "md-cloud-circle": 62146,
  "md-cloud-done": 62147,
  "md-cloud-download": 62150,
  "md-cloud-outline": 62151,
  "md-cloud-upload": 62152,
  "md-cloudy": 62155,
  "md-cloudy-night": 62154,
  "md-code": 62158,
  "md-code-download": 62156,
  "md-code-working": 62157,
  "md-cog": 62159,
  "md-color-fill": 62160,
  "md-color-filter": 62161,
  "md-color-palette": 62162,
  "md-color-wand": 62163,
  "md-compass": 62164,
  "md-construct": 62165,
  "md-contact": 62166,
  "md-contacts": 62167,
  "md-contract": 62168,
  "md-contrast": 62169,
  "md-copy": 62170,
  "md-create": 62171,
  "md-crop": 62172,
  "md-cube": 62173,
  "md-cut": 62174,
  "md-desktop": 62175,
  "md-disc": 62176,
  "md-document": 62177,
  "md-done-all": 62178,
  "md-download": 62179,
  "md-easel": 62180,
  "md-egg": 62181,
  "md-exit": 62182,
  "md-expand": 62183,
  "md-eye": 62185,
  "md-eye-off": 62184,
  "md-fastforward": 62186,
  "md-female": 62187,
  "md-filing": 62188,
  "md-film": 62189,
  "md-finger-print": 62190,
  "md-fitness": 61868,
  "md-flag": 62191,
  "md-flame": 62192,
  "md-flash": 62193,
  "md-flash-off": 61801,
  "md-flashlight": 61803,
  "md-flask": 62194,
  "md-flower": 62195,
  "md-folder": 62197,
  "md-folder-open": 62196,
  "md-football": 62198,
  "md-funnel": 62199,
  "md-gift": 61849,
  "md-git-branch": 62202,
  "md-git-commit": 62203,
  "md-git-compare": 62204,
  "md-git-merge": 62205,
  "md-git-network": 62206,
  "md-git-pull-request": 62207,
  "md-glasses": 62208,
  "md-globe": 62209,
  "md-grid": 62210,
  "md-hammer": 62211,
  "md-hand": 62212,
  "md-happy": 62213,
  "md-headset": 62214,
  "md-heart": 62216,
  "md-heart-dislike": 61799,
  "md-heart-empty": 61857,
  "md-heart-half": 61858,
  "md-help": 62219,
  "md-help-buoy": 62217,
  "md-help-circle": 62218,
  "md-help-circle-outline": 61805,
  "md-home": 62220,
  "md-hourglass": 61713,
  "md-ice-cream": 62221,
  "md-image": 62222,
  "md-images": 62223,
  "md-infinite": 62224,
  "md-information": 62226,
  "md-information-circle": 62225,
  "md-information-circle-outline": 61807,
  "md-jet": 62229,
  "md-journal": 61837,
  "md-key": 62230,
  "md-keypad": 62231,
  "md-laptop": 62232,
  "md-leaf": 62233,
  "md-link": 61998,
  "md-list": 62235,
  "md-list-box": 62234,
  "md-locate": 62236,
  "md-lock": 62237,
  "md-log-in": 62238,
  "md-log-out": 62239,
  "md-magnet": 62240,
  "md-mail": 62242,
  "md-mail-open": 62241,
  "md-mail-unread": 61810,
  "md-male": 62243,
  "md-man": 62244,
  "md-map": 62245,
  "md-medal": 62246,
  "md-medical": 62247,
  "md-medkit": 62248,
  "md-megaphone": 62249,
  "md-menu": 62250,
  "md-mic": 62252,
  "md-mic-off": 62251,
  "md-microphone": 62253,
  "md-moon": 62254,
  "md-more": 61897,
  "md-move": 62257,
  "md-musical-note": 62258,
  "md-musical-notes": 62259,
  "md-navigate": 62260,
  "md-notifications": 62264,
  "md-notifications-off": 62262,
  "md-notifications-outline": 62263,
  "md-nuclear": 62265,
  "md-nutrition": 62266,
  "md-open": 62267,
  "md-options": 62268,
  "md-outlet": 62269,
  "md-paper": 62271,
  "md-paper-plane": 62270,
  "md-partly-sunny": 62272,
  "md-pause": 62273,
  "md-paw": 62274,
  "md-people": 62275,
  "md-person": 62277,
  "md-person-add": 62276,
  "md-phone-landscape": 62278,
  "md-phone-portrait": 62279,
  "md-photos": 62280,
  "md-pie": 62281,
  "md-pin": 62282,
  "md-pint": 62283,
  "md-pizza": 62292,
  "md-planet": 62294,
  "md-play": 62295,
  "md-play-circle": 61812,
  "md-podium": 62296,
  "md-power": 62297,
  "md-pricetag": 62298,
  "md-pricetags": 62299,
  "md-print": 62300,
  "md-pulse": 62301,
  "md-qr-scanner": 62302,
  "md-quote": 62303,
  "md-radio": 62306,
  "md-radio-button-off": 62304,
  "md-radio-button-on": 62305,
  "md-rainy": 62307,
  "md-recording": 62308,
  "md-redo": 62309,
  "md-refresh": 62310,
  "md-refresh-circle": 61992,
  "md-remove": 62312,
  "md-remove-circle": 62311,
  "md-remove-circle-outline": 61814,
  "md-reorder": 62313,
  "md-repeat": 62314,
  "md-resize": 62315,
  "md-restaurant": 62316,
  "md-return-left": 62317,
  "md-return-right": 62318,
  "md-reverse-camera": 62319,
  "md-rewind": 62320,
  "md-ribbon": 62321,
  "md-rocket": 61817,
  "md-rose": 62322,
  "md-sad": 62323,
  "md-save": 61865,
  "md-school": 62324,
  "md-search": 62325,
  "md-send": 62326,
  "md-settings": 62327,
  "md-share": 62329,
  "md-share-alt": 62328,
  "md-shirt": 62330,
  "md-shuffle": 62331,
  "md-skip-backward": 62332,
  "md-skip-forward": 62333,
  "md-snow": 62334,
  "md-speedometer": 62335,
  "md-square": 62337,
  "md-square-outline": 62336,
  "md-star": 62340,
  "md-star-half": 62338,
  "md-star-outline": 62339,
  "md-stats": 62341,
  "md-stopwatch": 62342,
  "md-subway": 62343,
  "md-sunny": 62344,
  "md-swap": 62345,
  "md-switch": 62346,
  "md-sync": 62347,
  "md-tablet-landscape": 62348,
  "md-tablet-portrait": 62349,
  "md-tennisball": 62350,
  "md-text": 62351,
  "md-thermometer": 62352,
  "md-thumbs-down": 62353,
  "md-thumbs-up": 62354,
  "md-thunderstorm": 62355,
  "md-time": 62356,
  "md-timer": 62357,
  "md-today": 61821,
  "md-train": 62358,
  "md-transgender": 62359,
  "md-trash": 62360,
  "md-trending-down": 62361,
  "md-trending-up": 62362,
  "md-trophy": 62363,
  "md-tv": 61823,
  "md-umbrella": 62364,
  "md-undo": 62365,
  "md-unlock": 62366,
  "md-videocam": 62367,
  "md-volume-high": 61731,
  "md-volume-low": 61745,
  "md-volume-mute": 62369,
  "md-volume-off": 62370,
  "md-walk": 62372,
  "md-wallet": 61839,
  "md-warning": 62373,
  "md-watch": 62374,
  "md-water": 62375,
  "md-wifi": 62376,
  "md-wine": 62377,
  "md-woman": 62378
};
},701,[],"node_modules\\react-native-vector-icons\\glyphmaps\\Ionicons.json");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getImageSource = exports.ToolbarAndroid = exports.TabBarItemIOS = exports.TabBarItem = exports.Button = exports.default = void 0;

  var _createIconSet = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "./lib/create-icon-set"));

  var _Foundation = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "./glyphmaps/Foundation.json"));

  var iconSet = (0, _createIconSet.default)(_Foundation.default, 'fontcustom', 'Foundation.ttf');
  var _default = iconSet;
  exports.default = _default;
  var Button = iconSet.Button;
  exports.Button = Button;
  var TabBarItem = iconSet.TabBarItem;
  exports.TabBarItem = TabBarItem;
  var TabBarItemIOS = iconSet.TabBarItemIOS;
  exports.TabBarItemIOS = TabBarItemIOS;
  var ToolbarAndroid = iconSet.ToolbarAndroid;
  exports.ToolbarAndroid = ToolbarAndroid;
  var getImageSource = iconSet.getImageSource;
  exports.getImageSource = getImageSource;
},702,[23,644,703],"node_modules\\react-native-vector-icons\\Foundation.js");
__d(function(global, require, _aUnused, _bUnused, module, exports, _cUnused) {
  module.exports = {
  "address-book": 61696,
  "alert": 61697,
  "align-center": 61698,
  "align-justify": 61699,
  "align-left": 61700,
  "align-right": 61701,
  "anchor": 61702,
  "annotate": 61703,
  "archive": 61704,
  "arrow-down": 61705,
  "arrow-left": 61706,
  "arrow-right": 61707,
  "arrow-up": 61708,
  "arrows-compress": 61709,
  "arrows-expand": 61710,
  "arrows-in": 61711,
  "arrows-out": 61712,
  "asl": 61713,
  "asterisk": 61714,
  "at-sign": 61715,
  "background-color": 61716,
  "battery-empty": 61717,
  "battery-full": 61718,
  "battery-half": 61719,
  "bitcoin-circle": 61720,
  "bitcoin": 61721,
  "blind": 61722,
  "bluetooth": 61723,
  "bold": 61724,
  "book-bookmark": 61725,
  "book": 61726,
  "bookmark": 61727,
  "braille": 61728,
  "burst-new": 61729,
  "burst-sale": 61730,
  "burst": 61731,
  "calendar": 61732,
  "camera": 61733,
  "check": 61734,
  "checkbox": 61735,
  "clipboard-notes": 61736,
  "clipboard-pencil": 61737,
  "clipboard": 61738,
  "clock": 61739,
  "closed-caption": 61740,
  "cloud": 61741,
  "comment-minus": 61742,
  "comment-quotes": 61743,
  "comment-video": 61744,
  "comment": 61745,
  "comments": 61746,
  "compass": 61747,
  "contrast": 61748,
  "credit-card": 61749,
  "crop": 61750,
  "crown": 61751,
  "css3": 61752,
  "database": 61753,
  "die-five": 61754,
  "die-four": 61755,
  "die-one": 61756,
  "die-six": 61757,
  "die-three": 61758,
  "die-two": 61759,
  "dislike": 61760,
  "dollar-bill": 61761,
  "dollar": 61762,
  "download": 61763,
  "eject": 61764,
  "elevator": 61765,
  "euro": 61766,
  "eye": 61767,
  "fast-forward": 61768,
  "female-symbol": 61769,
  "female": 61770,
  "filter": 61771,
  "first-aid": 61772,
  "flag": 61773,
  "folder-add": 61774,
  "folder-lock": 61775,
  "folder": 61776,
  "foot": 61777,
  "foundation": 61778,
  "graph-bar": 61779,
  "graph-horizontal": 61780,
  "graph-pie": 61781,
  "graph-trend": 61782,
  "guide-dog": 61783,
  "hearing-aid": 61784,
  "heart": 61785,
  "home": 61786,
  "html5": 61787,
  "indent-less": 61788,
  "indent-more": 61789,
  "info": 61790,
  "italic": 61791,
  "key": 61792,
  "laptop": 61793,
  "layout": 61794,
  "lightbulb": 61795,
  "like": 61796,
  "link": 61797,
  "list-bullet": 61798,
  "list-number": 61799,
  "list-thumbnails": 61800,
  "list": 61801,
  "lock": 61802,
  "loop": 61803,
  "magnifying-glass": 61804,
  "mail": 61805,
  "male-female": 61806,
  "male-symbol": 61807,
  "male": 61808,
  "map": 61809,
  "marker": 61810,
  "megaphone": 61811,
  "microphone": 61812,
  "minus-circle": 61813,
  "minus": 61814,
  "mobile-signal": 61815,
  "mobile": 61816,
  "monitor": 61817,
  "mountains": 61818,
  "music": 61819,
  "next": 61820,
  "no-dogs": 61821,
  "no-smoking": 61822,
  "page-add": 61823,
  "page-copy": 61824,
  "page-csv": 61825,
  "page-delete": 61826,
  "page-doc": 61827,
  "page-edit": 61828,
  "page-export-csv": 61829,
  "page-export-doc": 61830,
  "page-export-pdf": 61831,
  "page-export": 61832,
  "page-filled": 61833,
  "page-multiple": 61834,
  "page-pdf": 61835,
  "page-remove": 61836,
  "page-search": 61837,
  "page": 61838,
  "paint-bucket": 61839,
  "paperclip": 61840,
  "pause": 61841,
  "paw": 61842,
  "paypal": 61843,
  "pencil": 61844,
  "photo": 61845,
  "play-circle": 61846,
  "play-video": 61847,
  "play": 61848,
  "plus": 61849,
  "pound": 61850,
  "power": 61851,
  "previous": 61852,
  "price-tag": 61853,
  "pricetag-multiple": 61854,
  "print": 61855,
  "prohibited": 61856,
  "projection-screen": 61857,
  "puzzle": 61858,
  "quote": 61859,
  "record": 61860,
  "refresh": 61861,
  "results-demographics": 61862,
  "results": 61863,
  "rewind-ten": 61864,
  "rewind": 61865,
  "rss": 61866,
  "safety-cone": 61867,
  "save": 61868,
  "share": 61869,
  "sheriff-badge": 61870,
  "shield": 61871,
  "shopping-bag": 61872,
  "shopping-cart": 61873,
  "shuffle": 61874,
  "skull": 61875,
  "social-500px": 61876,
  "social-adobe": 61877,
  "social-amazon": 61878,
  "social-android": 61879,
  "social-apple": 61880,
  "social-behance": 61881,
  "social-bing": 61882,
  "social-blogger": 61883,
  "social-delicious": 61884,
  "social-designer-news": 61885,
  "social-deviant-art": 61886,
  "social-digg": 61887,
  "social-dribbble": 61888,
  "social-drive": 61889,
  "social-dropbox": 61890,
  "social-evernote": 61891,
  "social-facebook": 61892,
  "social-flickr": 61893,
  "social-forrst": 61894,
  "social-foursquare": 61895,
  "social-game-center": 61896,
  "social-github": 61897,
  "social-google-plus": 61898,
  "social-hacker-news": 61899,
  "social-hi5": 61900,
  "social-instagram": 61901,
  "social-joomla": 61902,
  "social-lastfm": 61903,
  "social-linkedin": 61904,
  "social-medium": 61905,
  "social-myspace": 61906,
  "social-orkut": 61907,
  "social-path": 61908,
  "social-picasa": 61909,
  "social-pinterest": 61910,
  "social-rdio": 61911,
  "social-reddit": 61912,
  "social-skillshare": 61913,
  "social-skype": 61914,
  "social-smashing-mag": 61915,
  "social-snapchat": 61916,
  "social-spotify": 61917,
  "social-squidoo": 61918,
  "social-stack-overflow": 61919,
  "social-steam": 61920,
  "social-stumbleupon": 61921,
  "social-treehouse": 61922,
  "social-tumblr": 61923,
  "social-twitter": 61924,
  "social-vimeo": 61925,
  "social-windows": 61926,
  "social-xbox": 61927,
  "social-yahoo": 61928,
  "social-yelp": 61929,
  "social-youtube": 61930,
  "social-zerply": 61931,
  "social-zurb": 61932,
  "sound": 61933,
  "star": 61934,
  "stop": 61935,
  "strikethrough": 61936,
  "subscript": 61937,
  "superscript": 61938,
  "tablet-landscape": 61939,
  "tablet-portrait": 61940,
  "target-two": 61941,
  "target": 61942,
  "telephone-accessible": 61943,
  "telephone": 61944,
  "text-color": 61945,
  "thumbnails": 61946,
  "ticket": 61947,
  "torso-business": 61948,
  "torso-female": 61949,
  "torso": 61950,
  "torsos-all-female": 61951,
  "torsos-all": 61952,
  "torsos-female-male": 61953,
  "torsos-male-female": 61954,
  "torsos": 61955,
  "trash": 61956,
  "trees": 61957,
  "trophy": 61958,
  "underline": 61959,
  "universal-access": 61960,
  "unlink": 61961,
  "unlock": 61962,
  "upload-cloud": 61963,
  "upload": 61964,
  "usb": 61965,
  "video": 61966,
  "volume-none": 61967,
  "volume-strike": 61968,
  "volume": 61969,
  "web": 61970,
  "wheelchair": 61971,
  "widget": 61972,
  "wrench": 61973,
  "x-circle": 61974,
  "x": 61975,
  "yen": 61976,
  "zoom-in": 61977,
  "zoom-out": 61978
};
},703,[],"node_modules\\react-native-vector-icons\\glyphmaps\\Foundation.json");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getImageSource = exports.ToolbarAndroid = exports.TabBarItemIOS = exports.TabBarItem = exports.Button = exports.default = void 0;

  var _createIconSet = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "./lib/create-icon-set"));

  var _EvilIcons = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "./glyphmaps/EvilIcons.json"));

  var iconSet = (0, _createIconSet.default)(_EvilIcons.default, 'EvilIcons', 'EvilIcons.ttf');
  var _default = iconSet;
  exports.default = _default;
  var Button = iconSet.Button;
  exports.Button = Button;
  var TabBarItem = iconSet.TabBarItem;
  exports.TabBarItem = TabBarItem;
  var TabBarItemIOS = iconSet.TabBarItemIOS;
  exports.TabBarItemIOS = TabBarItemIOS;
  var ToolbarAndroid = iconSet.ToolbarAndroid;
  exports.ToolbarAndroid = ToolbarAndroid;
  var getImageSource = iconSet.getImageSource;
  exports.getImageSource = getImageSource;
},704,[23,644,705],"node_modules\\react-native-vector-icons\\EvilIcons.js");
__d(function(global, require, _aUnused, _bUnused, module, exports, _cUnused) {
  module.exports = {
  "archive": 61696,
  "arrow-down": 61697,
  "arrow-left": 61698,
  "arrow-right": 61699,
  "arrow-up": 61700,
  "bell": 61701,
  "calendar": 61702,
  "camera": 61703,
  "cart": 61704,
  "chart": 61705,
  "check": 61706,
  "chevron-down": 61707,
  "chevron-left": 61708,
  "chevron-right": 61709,
  "chevron-up": 61710,
  "clock": 61711,
  "close": 61712,
  "close-o": 61713,
  "comment": 61714,
  "credit-card": 61715,
  "envelope": 61716,
  "exclamation": 61717,
  "external-link": 61718,
  "eye": 61719,
  "gear": 61720,
  "heart": 61721,
  "image": 61722,
  "like": 61723,
  "link": 61724,
  "location": 61725,
  "lock": 61726,
  "minus": 61727,
  "navicon": 61728,
  "paperclip": 61729,
  "pencil": 61730,
  "play": 61731,
  "plus": 61732,
  "pointer": 61733,
  "question": 61734,
  "redo": 61735,
  "refresh": 61736,
  "retweet": 61737,
  "sc-facebook": 61738,
  "sc-github": 61739,
  "sc-google-plus": 61740,
  "sc-instagram": 61741,
  "sc-linkedin": 61742,
  "sc-odnoklassniki": 61743,
  "sc-pinterest": 61744,
  "sc-skype": 61745,
  "sc-soundcloud": 61746,
  "sc-telegram": 61747,
  "sc-tumblr": 61748,
  "sc-twitter": 61749,
  "sc-vimeo": 61750,
  "sc-vk": 61751,
  "sc-youtube": 61752,
  "search": 61753,
  "share-apple": 61754,
  "share-google": 61755,
  "spinner": 61756,
  "spinner-2": 61757,
  "spinner-3": 61758,
  "star": 61759,
  "tag": 61760,
  "trash": 61761,
  "trophy": 61762,
  "undo": 61763,
  "unlock": 61764,
  "user": 61765
};
},705,[],"node_modules\\react-native-vector-icons\\glyphmaps\\EvilIcons.json");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getImageSource = exports.ToolbarAndroid = exports.TabBarItemIOS = exports.TabBarItem = exports.Button = exports.default = void 0;

  var _createIconSet = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "./lib/create-icon-set"));

  var _Entypo = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "./glyphmaps/Entypo.json"));

  var iconSet = (0, _createIconSet.default)(_Entypo.default, 'Entypo', 'Entypo.ttf');
  var _default = iconSet;
  exports.default = _default;
  var Button = iconSet.Button;
  exports.Button = Button;
  var TabBarItem = iconSet.TabBarItem;
  exports.TabBarItem = TabBarItem;
  var TabBarItemIOS = iconSet.TabBarItemIOS;
  exports.TabBarItemIOS = TabBarItemIOS;
  var ToolbarAndroid = iconSet.ToolbarAndroid;
  exports.ToolbarAndroid = ToolbarAndroid;
  var getImageSource = iconSet.getImageSource;
  exports.getImageSource = getImageSource;
},706,[23,644,707],"node_modules\\react-native-vector-icons\\Entypo.js");
__d(function(global, require, _aUnused, _bUnused, module, exports, _cUnused) {
  module.exports = {
  "500px": 61696,
  "500px-with-circle": 61697,
  "add-to-list": 61698,
  "add-user": 61699,
  "address": 61700,
  "adjust": 61701,
  "air": 61702,
  "aircraft": 61703,
  "aircraft-landing": 61704,
  "aircraft-take-off": 61705,
  "align-bottom": 61706,
  "align-horizontal-middle": 61707,
  "align-left": 61708,
  "align-right": 61709,
  "align-top": 61710,
  "align-vertical-middle": 61711,
  "app-store": 61712,
  "archive": 61713,
  "area-graph": 61714,
  "arrow-bold-down": 61715,
  "arrow-bold-left": 61716,
  "arrow-bold-right": 61717,
  "arrow-bold-up": 61718,
  "arrow-down": 61719,
  "arrow-left": 61720,
  "arrow-long-down": 61721,
  "arrow-long-left": 61722,
  "arrow-long-right": 61723,
  "arrow-long-up": 61724,
  "arrow-right": 61725,
  "arrow-up": 61726,
  "arrow-with-circle-down": 61727,
  "arrow-with-circle-left": 61728,
  "arrow-with-circle-right": 61729,
  "arrow-with-circle-up": 61730,
  "attachment": 61731,
  "awareness-ribbon": 61732,
  "back": 61733,
  "back-in-time": 61734,
  "baidu": 61735,
  "bar-graph": 61736,
  "basecamp": 61737,
  "battery": 61738,
  "beamed-note": 61739,
  "behance": 61740,
  "bell": 61741,
  "blackboard": 61742,
  "block": 61743,
  "book": 61744,
  "bookmark": 61745,
  "bookmarks": 61746,
  "bowl": 61747,
  "box": 61748,
  "briefcase": 61749,
  "browser": 61750,
  "brush": 61751,
  "bucket": 61752,
  "bug": 61753,
  "cake": 61754,
  "calculator": 61755,
  "calendar": 61756,
  "camera": 61757,
  "ccw": 61758,
  "chat": 61759,
  "check": 61760,
  "chevron-down": 61761,
  "chevron-left": 61762,
  "chevron-right": 61763,
  "chevron-small-down": 61764,
  "chevron-small-left": 61765,
  "chevron-small-right": 61766,
  "chevron-small-up": 61767,
  "chevron-thin-down": 61768,
  "chevron-thin-left": 61769,
  "chevron-thin-right": 61770,
  "chevron-thin-up": 61771,
  "chevron-up": 61772,
  "chevron-with-circle-down": 61773,
  "chevron-with-circle-left": 61774,
  "chevron-with-circle-right": 61775,
  "chevron-with-circle-up": 61776,
  "circle": 61777,
  "circle-with-cross": 61778,
  "circle-with-minus": 61779,
  "circle-with-plus": 61780,
  "circular-graph": 61781,
  "clapperboard": 61782,
  "classic-computer": 61783,
  "clipboard": 61784,
  "clock": 61785,
  "cloud": 61786,
  "code": 61787,
  "cog": 61788,
  "colours": 61789,
  "compass": 61790,
  "controller-fast-backward": 61791,
  "controller-fast-forward": 61792,
  "controller-jump-to-start": 61793,
  "controller-next": 61794,
  "controller-paus": 61795,
  "controller-play": 61796,
  "controller-record": 61797,
  "controller-stop": 61798,
  "controller-volume": 61799,
  "copy": 61800,
  "creative-cloud": 61801,
  "creative-commons": 61802,
  "creative-commons-attribution": 61803,
  "creative-commons-noderivs": 61804,
  "creative-commons-noncommercial-eu": 61805,
  "creative-commons-noncommercial-us": 61806,
  "creative-commons-public-domain": 61807,
  "creative-commons-remix": 61808,
  "creative-commons-share": 61809,
  "creative-commons-sharealike": 61810,
  "credit": 61811,
  "credit-card": 61812,
  "crop": 61813,
  "cross": 61814,
  "cup": 61815,
  "cw": 61816,
  "cycle": 61817,
  "database": 61818,
  "dial-pad": 61819,
  "direction": 61820,
  "document": 61821,
  "document-landscape": 61822,
  "documents": 61823,
  "dot-single": 61824,
  "dots-three-horizontal": 61825,
  "dots-three-vertical": 61826,
  "dots-two-horizontal": 61827,
  "dots-two-vertical": 61828,
  "download": 61829,
  "dribbble": 61830,
  "dribbble-with-circle": 61831,
  "drink": 61832,
  "drive": 61833,
  "drop": 61834,
  "dropbox": 61835,
  "edit": 61836,
  "email": 61837,
  "emoji-flirt": 61838,
  "emoji-happy": 61839,
  "emoji-neutral": 61840,
  "emoji-sad": 61841,
  "erase": 61842,
  "eraser": 61843,
  "evernote": 61844,
  "export": 61845,
  "eye": 61846,
  "eye-with-line": 61847,
  "facebook": 61848,
  "facebook-with-circle": 61849,
  "feather": 61850,
  "fingerprint": 61851,
  "flag": 61852,
  "flash": 61853,
  "flashlight": 61854,
  "flat-brush": 61855,
  "flattr": 61856,
  "flickr": 61857,
  "flickr-with-circle": 61858,
  "flow-branch": 61859,
  "flow-cascade": 61860,
  "flow-line": 61861,
  "flow-parallel": 61862,
  "flow-tree": 61863,
  "flower": 61864,
  "folder": 61865,
  "folder-images": 61866,
  "folder-music": 61867,
  "folder-video": 61868,
  "forward": 61869,
  "foursquare": 61870,
  "funnel": 61871,
  "game-controller": 61872,
  "gauge": 61873,
  "github": 61874,
  "github-with-circle": 61875,
  "globe": 61876,
  "google-": 61877,
  "google--with-circle": 61878,
  "google-drive": 61879,
  "google-hangouts": 61880,
  "google-play": 61881,
  "graduation-cap": 61882,
  "grid": 61883,
  "grooveshark": 61884,
  "hair-cross": 61885,
  "hand": 61886,
  "heart": 61887,
  "heart-outlined": 61888,
  "help": 61889,
  "help-with-circle": 61890,
  "home": 61891,
  "hour-glass": 61892,
  "houzz": 61893,
  "icloud": 61894,
  "image": 61895,
  "image-inverted": 61896,
  "images": 61897,
  "inbox": 61898,
  "infinity": 61899,
  "info": 61900,
  "info-with-circle": 61901,
  "instagram": 61902,
  "instagram-with-circle": 61903,
  "install": 61904,
  "key": 61905,
  "keyboard": 61906,
  "lab-flask": 61907,
  "landline": 61908,
  "language": 61909,
  "laptop": 61910,
  "lastfm": 61911,
  "lastfm-with-circle": 61912,
  "layers": 61913,
  "leaf": 61914,
  "level-down": 61915,
  "level-up": 61916,
  "lifebuoy": 61917,
  "light-bulb": 61918,
  "light-down": 61919,
  "light-up": 61920,
  "line-graph": 61921,
  "link": 61922,
  "linkedin": 61923,
  "linkedin-with-circle": 61924,
  "list": 61925,
  "location": 61926,
  "location-pin": 61927,
  "lock": 61928,
  "lock-open": 61929,
  "log-out": 61930,
  "login": 61931,
  "loop": 61932,
  "magnet": 61933,
  "magnifying-glass": 61934,
  "mail": 61935,
  "mail-with-circle": 61936,
  "man": 61937,
  "map": 61938,
  "mask": 61939,
  "medal": 61940,
  "medium": 61941,
  "medium-with-circle": 61942,
  "megaphone": 61943,
  "menu": 61944,
  "merge": 61945,
  "message": 61946,
  "mic": 61947,
  "minus": 61948,
  "mixi": 61949,
  "mobile": 61950,
  "modern-mic": 61951,
  "moon": 61952,
  "mouse": 61953,
  "mouse-pointer": 61954,
  "music": 61955,
  "network": 61956,
  "new": 61957,
  "new-message": 61958,
  "news": 61959,
  "newsletter": 61960,
  "note": 61961,
  "notification": 61962,
  "notifications-off": 61963,
  "old-mobile": 61964,
  "old-phone": 61965,
  "onedrive": 61966,
  "open-book": 61967,
  "palette": 61968,
  "paper-plane": 61969,
  "paypal": 61970,
  "pencil": 61971,
  "phone": 61972,
  "picasa": 61973,
  "pie-chart": 61974,
  "pin": 61975,
  "pinterest": 61976,
  "pinterest-with-circle": 61977,
  "plus": 61978,
  "popup": 61979,
  "power-plug": 61980,
  "price-ribbon": 61981,
  "price-tag": 61982,
  "print": 61983,
  "progress-empty": 61984,
  "progress-full": 61985,
  "progress-one": 61986,
  "progress-two": 61987,
  "publish": 61988,
  "qq": 61989,
  "qq-with-circle": 61990,
  "quote": 61991,
  "radio": 61992,
  "raft": 61993,
  "raft-with-circle": 61994,
  "rainbow": 61995,
  "rdio": 61996,
  "rdio-with-circle": 61997,
  "remove-user": 61998,
  "renren": 61999,
  "reply": 62000,
  "reply-all": 62001,
  "resize-100-": 62002,
  "resize-full-screen": 62003,
  "retweet": 62004,
  "rocket": 62005,
  "round-brush": 62006,
  "rss": 62007,
  "ruler": 62008,
  "save": 62009,
  "scissors": 62010,
  "scribd": 62011,
  "select-arrows": 62012,
  "share": 62013,
  "share-alternative": 62014,
  "shareable": 62015,
  "shield": 62016,
  "shop": 62017,
  "shopping-bag": 62018,
  "shopping-basket": 62019,
  "shopping-cart": 62020,
  "shuffle": 62021,
  "signal": 62022,
  "sina-weibo": 62023,
  "skype": 62024,
  "skype-with-circle": 62025,
  "slideshare": 62026,
  "smashing": 62027,
  "sound": 62028,
  "sound-mix": 62029,
  "sound-mute": 62030,
  "soundcloud": 62031,
  "sports-club": 62032,
  "spotify": 62033,
  "spotify-with-circle": 62034,
  "spreadsheet": 62035,
  "squared-cross": 62036,
  "squared-minus": 62037,
  "squared-plus": 62038,
  "star": 62039,
  "star-outlined": 62040,
  "stopwatch": 62041,
  "stumbleupon": 62042,
  "stumbleupon-with-circle": 62043,
  "suitcase": 62044,
  "swap": 62045,
  "swarm": 62046,
  "sweden": 62047,
  "switch": 62048,
  "tablet": 62049,
  "tablet-mobile-combo": 62050,
  "tag": 62051,
  "text": 62052,
  "text-document": 62053,
  "text-document-inverted": 62054,
  "thermometer": 62055,
  "thumbs-down": 62056,
  "thumbs-up": 62057,
  "thunder-cloud": 62058,
  "ticket": 62059,
  "time-slot": 62060,
  "tools": 62061,
  "traffic-cone": 62062,
  "trash": 62063,
  "tree": 62064,
  "triangle-down": 62065,
  "triangle-left": 62066,
  "triangle-right": 62067,
  "triangle-up": 62068,
  "tripadvisor": 62069,
  "trophy": 62070,
  "tumblr": 62071,
  "tumblr-with-circle": 62072,
  "tv": 62073,
  "twitter": 62074,
  "twitter-with-circle": 62075,
  "typing": 62076,
  "uninstall": 62077,
  "unread": 62078,
  "untag": 62079,
  "upload": 62080,
  "upload-to-cloud": 62081,
  "user": 62082,
  "users": 62083,
  "v-card": 62084,
  "video": 62085,
  "video-camera": 62086,
  "vimeo": 62087,
  "vimeo-with-circle": 62088,
  "vine": 62089,
  "vine-with-circle": 62090,
  "vinyl": 62091,
  "vk": 62092,
  "vk-alternitive": 62093,
  "vk-with-circle": 62094,
  "voicemail": 62095,
  "wallet": 62096,
  "warning": 62097,
  "water": 62098,
  "windows-store": 62099,
  "xing": 62100,
  "xing-with-circle": 62101,
  "yelp": 62102,
  "youko": 62103,
  "youko-with-circle": 62104,
  "youtube": 62105,
  "youtube-with-circle": 62106
};
},707,[],"node_modules\\react-native-vector-icons\\glyphmaps\\Entypo.json");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getImageSource = exports.ToolbarAndroid = exports.TabBarItemIOS = exports.TabBarItem = exports.Button = exports.default = void 0;

  var _createIconSet = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "./lib/create-icon-set"));

  var _FontAwesome = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "./glyphmaps/FontAwesome.json"));

  var iconSet = (0, _createIconSet.default)(_FontAwesome.default, 'FontAwesome', 'FontAwesome.ttf');
  var _default = iconSet;
  exports.default = _default;
  var Button = iconSet.Button;
  exports.Button = Button;
  var TabBarItem = iconSet.TabBarItem;
  exports.TabBarItem = TabBarItem;
  var TabBarItemIOS = iconSet.TabBarItemIOS;
  exports.TabBarItemIOS = TabBarItemIOS;
  var ToolbarAndroid = iconSet.ToolbarAndroid;
  exports.ToolbarAndroid = ToolbarAndroid;
  var getImageSource = iconSet.getImageSource;
  exports.getImageSource = getImageSource;
},708,[23,644,709],"node_modules\\react-native-vector-icons\\FontAwesome.js");
__d(function(global, require, _aUnused, _bUnused, module, exports, _cUnused) {
  module.exports = {
  "glass": 61440,
  "music": 61441,
  "search": 61442,
  "envelope-o": 61443,
  "heart": 61444,
  "star": 61445,
  "star-o": 61446,
  "user": 61447,
  "film": 61448,
  "th-large": 61449,
  "th": 61450,
  "th-list": 61451,
  "check": 61452,
  "remove": 61453,
  "close": 61453,
  "times": 61453,
  "search-plus": 61454,
  "search-minus": 61456,
  "power-off": 61457,
  "signal": 61458,
  "gear": 61459,
  "cog": 61459,
  "trash-o": 61460,
  "home": 61461,
  "file-o": 61462,
  "clock-o": 61463,
  "road": 61464,
  "download": 61465,
  "arrow-circle-o-down": 61466,
  "arrow-circle-o-up": 61467,
  "inbox": 61468,
  "play-circle-o": 61469,
  "rotate-right": 61470,
  "repeat": 61470,
  "refresh": 61473,
  "list-alt": 61474,
  "lock": 61475,
  "flag": 61476,
  "headphones": 61477,
  "volume-off": 61478,
  "volume-down": 61479,
  "volume-up": 61480,
  "qrcode": 61481,
  "barcode": 61482,
  "tag": 61483,
  "tags": 61484,
  "book": 61485,
  "bookmark": 61486,
  "print": 61487,
  "camera": 61488,
  "font": 61489,
  "bold": 61490,
  "italic": 61491,
  "text-height": 61492,
  "text-width": 61493,
  "align-left": 61494,
  "align-center": 61495,
  "align-right": 61496,
  "align-justify": 61497,
  "list": 61498,
  "dedent": 61499,
  "outdent": 61499,
  "indent": 61500,
  "video-camera": 61501,
  "photo": 61502,
  "image": 61502,
  "picture-o": 61502,
  "pencil": 61504,
  "map-marker": 61505,
  "adjust": 61506,
  "tint": 61507,
  "edit": 61508,
  "pencil-square-o": 61508,
  "share-square-o": 61509,
  "check-square-o": 61510,
  "arrows": 61511,
  "step-backward": 61512,
  "fast-backward": 61513,
  "backward": 61514,
  "play": 61515,
  "pause": 61516,
  "stop": 61517,
  "forward": 61518,
  "fast-forward": 61520,
  "step-forward": 61521,
  "eject": 61522,
  "chevron-left": 61523,
  "chevron-right": 61524,
  "plus-circle": 61525,
  "minus-circle": 61526,
  "times-circle": 61527,
  "check-circle": 61528,
  "question-circle": 61529,
  "info-circle": 61530,
  "crosshairs": 61531,
  "times-circle-o": 61532,
  "check-circle-o": 61533,
  "ban": 61534,
  "arrow-left": 61536,
  "arrow-right": 61537,
  "arrow-up": 61538,
  "arrow-down": 61539,
  "mail-forward": 61540,
  "share": 61540,
  "expand": 61541,
  "compress": 61542,
  "plus": 61543,
  "minus": 61544,
  "asterisk": 61545,
  "exclamation-circle": 61546,
  "gift": 61547,
  "leaf": 61548,
  "fire": 61549,
  "eye": 61550,
  "eye-slash": 61552,
  "warning": 61553,
  "exclamation-triangle": 61553,
  "plane": 61554,
  "calendar": 61555,
  "random": 61556,
  "comment": 61557,
  "magnet": 61558,
  "chevron-up": 61559,
  "chevron-down": 61560,
  "retweet": 61561,
  "shopping-cart": 61562,
  "folder": 61563,
  "folder-open": 61564,
  "arrows-v": 61565,
  "arrows-h": 61566,
  "bar-chart-o": 61568,
  "bar-chart": 61568,
  "twitter-square": 61569,
  "facebook-square": 61570,
  "camera-retro": 61571,
  "key": 61572,
  "gears": 61573,
  "cogs": 61573,
  "comments": 61574,
  "thumbs-o-up": 61575,
  "thumbs-o-down": 61576,
  "star-half": 61577,
  "heart-o": 61578,
  "sign-out": 61579,
  "linkedin-square": 61580,
  "thumb-tack": 61581,
  "external-link": 61582,
  "sign-in": 61584,
  "trophy": 61585,
  "github-square": 61586,
  "upload": 61587,
  "lemon-o": 61588,
  "phone": 61589,
  "square-o": 61590,
  "bookmark-o": 61591,
  "phone-square": 61592,
  "twitter": 61593,
  "facebook-f": 61594,
  "facebook": 61594,
  "github": 61595,
  "unlock": 61596,
  "credit-card": 61597,
  "feed": 61598,
  "rss": 61598,
  "hdd-o": 61600,
  "bullhorn": 61601,
  "bell": 61683,
  "certificate": 61603,
  "hand-o-right": 61604,
  "hand-o-left": 61605,
  "hand-o-up": 61606,
  "hand-o-down": 61607,
  "arrow-circle-left": 61608,
  "arrow-circle-right": 61609,
  "arrow-circle-up": 61610,
  "arrow-circle-down": 61611,
  "globe": 61612,
  "wrench": 61613,
  "tasks": 61614,
  "filter": 61616,
  "briefcase": 61617,
  "arrows-alt": 61618,
  "group": 61632,
  "users": 61632,
  "chain": 61633,
  "link": 61633,
  "cloud": 61634,
  "flask": 61635,
  "cut": 61636,
  "scissors": 61636,
  "copy": 61637,
  "files-o": 61637,
  "paperclip": 61638,
  "save": 61639,
  "floppy-o": 61639,
  "square": 61640,
  "navicon": 61641,
  "reorder": 61641,
  "bars": 61641,
  "list-ul": 61642,
  "list-ol": 61643,
  "strikethrough": 61644,
  "underline": 61645,
  "table": 61646,
  "magic": 61648,
  "truck": 61649,
  "pinterest": 61650,
  "pinterest-square": 61651,
  "google-plus-square": 61652,
  "google-plus": 61653,
  "money": 61654,
  "caret-down": 61655,
  "caret-up": 61656,
  "caret-left": 61657,
  "caret-right": 61658,
  "columns": 61659,
  "unsorted": 61660,
  "sort": 61660,
  "sort-down": 61661,
  "sort-desc": 61661,
  "sort-up": 61662,
  "sort-asc": 61662,
  "envelope": 61664,
  "linkedin": 61665,
  "rotate-left": 61666,
  "undo": 61666,
  "legal": 61667,
  "gavel": 61667,
  "dashboard": 61668,
  "tachometer": 61668,
  "comment-o": 61669,
  "comments-o": 61670,
  "flash": 61671,
  "bolt": 61671,
  "sitemap": 61672,
  "umbrella": 61673,
  "paste": 61674,
  "clipboard": 61674,
  "lightbulb-o": 61675,
  "exchange": 61676,
  "cloud-download": 61677,
  "cloud-upload": 61678,
  "user-md": 61680,
  "stethoscope": 61681,
  "suitcase": 61682,
  "bell-o": 61602,
  "coffee": 61684,
  "cutlery": 61685,
  "file-text-o": 61686,
  "building-o": 61687,
  "hospital-o": 61688,
  "ambulance": 61689,
  "medkit": 61690,
  "fighter-jet": 61691,
  "beer": 61692,
  "h-square": 61693,
  "plus-square": 61694,
  "angle-double-left": 61696,
  "angle-double-right": 61697,
  "angle-double-up": 61698,
  "angle-double-down": 61699,
  "angle-left": 61700,
  "angle-right": 61701,
  "angle-up": 61702,
  "angle-down": 61703,
  "desktop": 61704,
  "laptop": 61705,
  "tablet": 61706,
  "mobile-phone": 61707,
  "mobile": 61707,
  "circle-o": 61708,
  "quote-left": 61709,
  "quote-right": 61710,
  "spinner": 61712,
  "circle": 61713,
  "mail-reply": 61714,
  "reply": 61714,
  "github-alt": 61715,
  "folder-o": 61716,
  "folder-open-o": 61717,
  "smile-o": 61720,
  "frown-o": 61721,
  "meh-o": 61722,
  "gamepad": 61723,
  "keyboard-o": 61724,
  "flag-o": 61725,
  "flag-checkered": 61726,
  "terminal": 61728,
  "code": 61729,
  "mail-reply-all": 61730,
  "reply-all": 61730,
  "star-half-empty": 61731,
  "star-half-full": 61731,
  "star-half-o": 61731,
  "location-arrow": 61732,
  "crop": 61733,
  "code-fork": 61734,
  "unlink": 61735,
  "chain-broken": 61735,
  "question": 61736,
  "info": 61737,
  "exclamation": 61738,
  "superscript": 61739,
  "subscript": 61740,
  "eraser": 61741,
  "puzzle-piece": 61742,
  "microphone": 61744,
  "microphone-slash": 61745,
  "shield": 61746,
  "calendar-o": 61747,
  "fire-extinguisher": 61748,
  "rocket": 61749,
  "maxcdn": 61750,
  "chevron-circle-left": 61751,
  "chevron-circle-right": 61752,
  "chevron-circle-up": 61753,
  "chevron-circle-down": 61754,
  "html5": 61755,
  "css3": 61756,
  "anchor": 61757,
  "unlock-alt": 61758,
  "bullseye": 61760,
  "ellipsis-h": 61761,
  "ellipsis-v": 61762,
  "rss-square": 61763,
  "play-circle": 61764,
  "ticket": 61765,
  "minus-square": 61766,
  "minus-square-o": 61767,
  "level-up": 61768,
  "level-down": 61769,
  "check-square": 61770,
  "pencil-square": 61771,
  "external-link-square": 61772,
  "share-square": 61773,
  "compass": 61774,
  "toggle-down": 61776,
  "caret-square-o-down": 61776,
  "toggle-up": 61777,
  "caret-square-o-up": 61777,
  "toggle-right": 61778,
  "caret-square-o-right": 61778,
  "euro": 61779,
  "eur": 61779,
  "gbp": 61780,
  "dollar": 61781,
  "usd": 61781,
  "rupee": 61782,
  "inr": 61782,
  "cny": 61783,
  "rmb": 61783,
  "yen": 61783,
  "jpy": 61783,
  "ruble": 61784,
  "rouble": 61784,
  "rub": 61784,
  "won": 61785,
  "krw": 61785,
  "bitcoin": 61786,
  "btc": 61786,
  "file": 61787,
  "file-text": 61788,
  "sort-alpha-asc": 61789,
  "sort-alpha-desc": 61790,
  "sort-amount-asc": 61792,
  "sort-amount-desc": 61793,
  "sort-numeric-asc": 61794,
  "sort-numeric-desc": 61795,
  "thumbs-up": 61796,
  "thumbs-down": 61797,
  "youtube-square": 61798,
  "youtube": 61799,
  "xing": 61800,
  "xing-square": 61801,
  "youtube-play": 61802,
  "dropbox": 61803,
  "stack-overflow": 61804,
  "instagram": 61805,
  "flickr": 61806,
  "adn": 61808,
  "bitbucket": 61809,
  "bitbucket-square": 61810,
  "tumblr": 61811,
  "tumblr-square": 61812,
  "long-arrow-down": 61813,
  "long-arrow-up": 61814,
  "long-arrow-left": 61815,
  "long-arrow-right": 61816,
  "apple": 61817,
  "windows": 61818,
  "android": 61819,
  "linux": 61820,
  "dribbble": 61821,
  "skype": 61822,
  "foursquare": 61824,
  "trello": 61825,
  "female": 61826,
  "male": 61827,
  "gittip": 61828,
  "gratipay": 61828,
  "sun-o": 61829,
  "moon-o": 61830,
  "archive": 61831,
  "bug": 61832,
  "vk": 61833,
  "weibo": 61834,
  "renren": 61835,
  "pagelines": 61836,
  "stack-exchange": 61837,
  "arrow-circle-o-right": 61838,
  "arrow-circle-o-left": 61840,
  "toggle-left": 61841,
  "caret-square-o-left": 61841,
  "dot-circle-o": 61842,
  "wheelchair": 61843,
  "vimeo-square": 61844,
  "turkish-lira": 61845,
  "try": 61845,
  "plus-square-o": 61846,
  "space-shuttle": 61847,
  "slack": 61848,
  "envelope-square": 61849,
  "wordpress": 61850,
  "openid": 61851,
  "institution": 61852,
  "bank": 61852,
  "university": 61852,
  "mortar-board": 61853,
  "graduation-cap": 61853,
  "yahoo": 61854,
  "google": 61856,
  "reddit": 61857,
  "reddit-square": 61858,
  "stumbleupon-circle": 61859,
  "stumbleupon": 61860,
  "delicious": 61861,
  "digg": 61862,
  "pied-piper-pp": 61863,
  "pied-piper-alt": 61864,
  "drupal": 61865,
  "joomla": 61866,
  "language": 61867,
  "fax": 61868,
  "building": 61869,
  "child": 61870,
  "paw": 61872,
  "spoon": 61873,
  "cube": 61874,
  "cubes": 61875,
  "behance": 61876,
  "behance-square": 61877,
  "steam": 61878,
  "steam-square": 61879,
  "recycle": 61880,
  "automobile": 61881,
  "car": 61881,
  "cab": 61882,
  "taxi": 61882,
  "tree": 61883,
  "spotify": 61884,
  "deviantart": 61885,
  "soundcloud": 61886,
  "database": 61888,
  "file-pdf-o": 61889,
  "file-word-o": 61890,
  "file-excel-o": 61891,
  "file-powerpoint-o": 61892,
  "file-photo-o": 61893,
  "file-picture-o": 61893,
  "file-image-o": 61893,
  "file-zip-o": 61894,
  "file-archive-o": 61894,
  "file-sound-o": 61895,
  "file-audio-o": 61895,
  "file-movie-o": 61896,
  "file-video-o": 61896,
  "file-code-o": 61897,
  "vine": 61898,
  "codepen": 61899,
  "jsfiddle": 61900,
  "life-bouy": 61901,
  "life-buoy": 61901,
  "life-saver": 61901,
  "support": 61901,
  "life-ring": 61901,
  "circle-o-notch": 61902,
  "ra": 61904,
  "resistance": 61904,
  "rebel": 61904,
  "ge": 61905,
  "empire": 61905,
  "git-square": 61906,
  "git": 61907,
  "y-combinator-square": 61908,
  "yc-square": 61908,
  "hacker-news": 61908,
  "tencent-weibo": 61909,
  "qq": 61910,
  "wechat": 61911,
  "weixin": 61911,
  "send": 61912,
  "paper-plane": 61912,
  "send-o": 61913,
  "paper-plane-o": 61913,
  "history": 61914,
  "circle-thin": 61915,
  "header": 61916,
  "paragraph": 61917,
  "sliders": 61918,
  "share-alt": 61920,
  "share-alt-square": 61921,
  "bomb": 61922,
  "soccer-ball-o": 61923,
  "futbol-o": 61923,
  "tty": 61924,
  "binoculars": 61925,
  "plug": 61926,
  "slideshare": 61927,
  "twitch": 61928,
  "yelp": 61929,
  "newspaper-o": 61930,
  "wifi": 61931,
  "calculator": 61932,
  "paypal": 61933,
  "google-wallet": 61934,
  "cc-visa": 61936,
  "cc-mastercard": 61937,
  "cc-discover": 61938,
  "cc-amex": 61939,
  "cc-paypal": 61940,
  "cc-stripe": 61941,
  "bell-slash": 61942,
  "bell-slash-o": 61943,
  "trash": 61944,
  "copyright": 61945,
  "at": 61946,
  "eyedropper": 61947,
  "paint-brush": 61948,
  "birthday-cake": 61949,
  "area-chart": 61950,
  "pie-chart": 61952,
  "line-chart": 61953,
  "lastfm": 61954,
  "lastfm-square": 61955,
  "toggle-off": 61956,
  "toggle-on": 61957,
  "bicycle": 61958,
  "bus": 61959,
  "ioxhost": 61960,
  "angellist": 61961,
  "cc": 61962,
  "shekel": 61963,
  "sheqel": 61963,
  "ils": 61963,
  "meanpath": 61964,
  "buysellads": 61965,
  "connectdevelop": 61966,
  "dashcube": 61968,
  "forumbee": 61969,
  "leanpub": 61970,
  "sellsy": 61971,
  "shirtsinbulk": 61972,
  "simplybuilt": 61973,
  "skyatlas": 61974,
  "cart-plus": 61975,
  "cart-arrow-down": 61976,
  "diamond": 61977,
  "ship": 61978,
  "user-secret": 61979,
  "motorcycle": 61980,
  "street-view": 61981,
  "heartbeat": 61982,
  "venus": 61985,
  "mars": 61986,
  "mercury": 61987,
  "intersex": 61988,
  "transgender": 61988,
  "transgender-alt": 61989,
  "venus-double": 61990,
  "mars-double": 61991,
  "venus-mars": 61992,
  "mars-stroke": 61993,
  "mars-stroke-v": 61994,
  "mars-stroke-h": 61995,
  "neuter": 61996,
  "genderless": 61997,
  "facebook-official": 62000,
  "pinterest-p": 62001,
  "whatsapp": 62002,
  "server": 62003,
  "user-plus": 62004,
  "user-times": 62005,
  "hotel": 62006,
  "bed": 62006,
  "viacoin": 62007,
  "train": 62008,
  "subway": 62009,
  "medium": 62010,
  "yc": 62011,
  "y-combinator": 62011,
  "optin-monster": 62012,
  "opencart": 62013,
  "expeditedssl": 62014,
  "battery-4": 62016,
  "battery": 62016,
  "battery-full": 62016,
  "battery-3": 62017,
  "battery-three-quarters": 62017,
  "battery-2": 62018,
  "battery-half": 62018,
  "battery-1": 62019,
  "battery-quarter": 62019,
  "battery-0": 62020,
  "battery-empty": 62020,
  "mouse-pointer": 62021,
  "i-cursor": 62022,
  "object-group": 62023,
  "object-ungroup": 62024,
  "sticky-note": 62025,
  "sticky-note-o": 62026,
  "cc-jcb": 62027,
  "cc-diners-club": 62028,
  "clone": 62029,
  "balance-scale": 62030,
  "hourglass-o": 62032,
  "hourglass-1": 62033,
  "hourglass-start": 62033,
  "hourglass-2": 62034,
  "hourglass-half": 62034,
  "hourglass-3": 62035,
  "hourglass-end": 62035,
  "hourglass": 62036,
  "hand-grab-o": 62037,
  "hand-rock-o": 62037,
  "hand-stop-o": 62038,
  "hand-paper-o": 62038,
  "hand-scissors-o": 62039,
  "hand-lizard-o": 62040,
  "hand-spock-o": 62041,
  "hand-pointer-o": 62042,
  "hand-peace-o": 62043,
  "trademark": 62044,
  "registered": 62045,
  "creative-commons": 62046,
  "gg": 62048,
  "gg-circle": 62049,
  "tripadvisor": 62050,
  "odnoklassniki": 62051,
  "odnoklassniki-square": 62052,
  "get-pocket": 62053,
  "wikipedia-w": 62054,
  "safari": 62055,
  "chrome": 62056,
  "firefox": 62057,
  "opera": 62058,
  "internet-explorer": 62059,
  "tv": 62060,
  "television": 62060,
  "contao": 62061,
  "500px": 62062,
  "amazon": 62064,
  "calendar-plus-o": 62065,
  "calendar-minus-o": 62066,
  "calendar-times-o": 62067,
  "calendar-check-o": 62068,
  "industry": 62069,
  "map-pin": 62070,
  "map-signs": 62071,
  "map-o": 62072,
  "map": 62073,
  "commenting": 62074,
  "commenting-o": 62075,
  "houzz": 62076,
  "vimeo": 62077,
  "black-tie": 62078,
  "fonticons": 62080,
  "reddit-alien": 62081,
  "edge": 62082,
  "credit-card-alt": 62083,
  "codiepie": 62084,
  "modx": 62085,
  "fort-awesome": 62086,
  "usb": 62087,
  "product-hunt": 62088,
  "mixcloud": 62089,
  "scribd": 62090,
  "pause-circle": 62091,
  "pause-circle-o": 62092,
  "stop-circle": 62093,
  "stop-circle-o": 62094,
  "shopping-bag": 62096,
  "shopping-basket": 62097,
  "hashtag": 62098,
  "bluetooth": 62099,
  "bluetooth-b": 62100,
  "percent": 62101,
  "gitlab": 62102,
  "wpbeginner": 62103,
  "wpforms": 62104,
  "envira": 62105,
  "universal-access": 62106,
  "wheelchair-alt": 62107,
  "question-circle-o": 62108,
  "blind": 62109,
  "audio-description": 62110,
  "volume-control-phone": 62112,
  "braille": 62113,
  "assistive-listening-systems": 62114,
  "asl-interpreting": 62115,
  "american-sign-language-interpreting": 62115,
  "deafness": 62116,
  "hard-of-hearing": 62116,
  "deaf": 62116,
  "glide": 62117,
  "glide-g": 62118,
  "signing": 62119,
  "sign-language": 62119,
  "low-vision": 62120,
  "viadeo": 62121,
  "viadeo-square": 62122,
  "snapchat": 62123,
  "snapchat-ghost": 62124,
  "snapchat-square": 62125,
  "pied-piper": 62126,
  "first-order": 62128,
  "yoast": 62129,
  "themeisle": 62130,
  "google-plus-circle": 62131,
  "google-plus-official": 62131,
  "fa": 62132,
  "font-awesome": 62132,
  "handshake-o": 62133,
  "envelope-open": 62134,
  "envelope-open-o": 62135,
  "linode": 62136,
  "address-book": 62137,
  "address-book-o": 62138,
  "vcard": 62139,
  "address-card": 62139,
  "vcard-o": 62140,
  "address-card-o": 62140,
  "user-circle": 62141,
  "user-circle-o": 62142,
  "user-o": 62144,
  "id-badge": 62145,
  "drivers-license": 62146,
  "id-card": 62146,
  "drivers-license-o": 62147,
  "id-card-o": 62147,
  "quora": 62148,
  "free-code-camp": 62149,
  "telegram": 62150,
  "thermometer-4": 62151,
  "thermometer": 62151,
  "thermometer-full": 62151,
  "thermometer-3": 62152,
  "thermometer-three-quarters": 62152,
  "thermometer-2": 62153,
  "thermometer-half": 62153,
  "thermometer-1": 62154,
  "thermometer-quarter": 62154,
  "thermometer-0": 62155,
  "thermometer-empty": 62155,
  "shower": 62156,
  "bathtub": 62157,
  "s15": 62157,
  "bath": 62157,
  "podcast": 62158,
  "window-maximize": 62160,
  "window-minimize": 62161,
  "window-restore": 62162,
  "times-rectangle": 62163,
  "window-close": 62163,
  "times-rectangle-o": 62164,
  "window-close-o": 62164,
  "bandcamp": 62165,
  "grav": 62166,
  "etsy": 62167,
  "imdb": 62168,
  "ravelry": 62169,
  "eercast": 62170,
  "microchip": 62171,
  "snowflake-o": 62172,
  "superpowers": 62173,
  "wpexplorer": 62174,
  "meetup": 62176
};
},709,[],"node_modules\\react-native-vector-icons\\glyphmaps\\FontAwesome.json");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getImageSource = exports.ToolbarAndroid = exports.TabBarItemIOS = exports.TabBarItem = exports.Button = exports.default = void 0;

  var _createIconSet = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "./lib/create-icon-set"));

  var _SimpleLineIcons = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "./glyphmaps/SimpleLineIcons.json"));

  var iconSet = (0, _createIconSet.default)(_SimpleLineIcons.default, 'simple-line-icons', 'SimpleLineIcons.ttf');
  var _default = iconSet;
  exports.default = _default;
  var Button = iconSet.Button;
  exports.Button = Button;
  var TabBarItem = iconSet.TabBarItem;
  exports.TabBarItem = TabBarItem;
  var TabBarItemIOS = iconSet.TabBarItemIOS;
  exports.TabBarItemIOS = TabBarItemIOS;
  var ToolbarAndroid = iconSet.ToolbarAndroid;
  exports.ToolbarAndroid = ToolbarAndroid;
  var getImageSource = iconSet.getImageSource;
  exports.getImageSource = getImageSource;
},710,[23,644,711],"node_modules\\react-native-vector-icons\\SimpleLineIcons.js");
__d(function(global, require, _aUnused, _bUnused, module, exports, _cUnused) {
  module.exports = {
  "user": 57349,
  "people": 57345,
  "user-female": 57344,
  "user-follow": 57346,
  "user-following": 57347,
  "user-unfollow": 57348,
  "login": 57446,
  "logout": 57445,
  "emotsmile": 57377,
  "phone": 58880,
  "call-end": 57416,
  "call-in": 57415,
  "call-out": 57414,
  "map": 57395,
  "location-pin": 57494,
  "direction": 57410,
  "directions": 57409,
  "compass": 57413,
  "layers": 57396,
  "menu": 58881,
  "list": 57447,
  "options-vertical": 58882,
  "options": 58883,
  "arrow-down": 58884,
  "arrow-left": 58885,
  "arrow-right": 58886,
  "arrow-up": 58887,
  "arrow-up-circle": 57464,
  "arrow-left-circle": 57466,
  "arrow-right-circle": 57465,
  "arrow-down-circle": 57467,
  "check": 57472,
  "clock": 57473,
  "plus": 57493,
  "minus": 58901,
  "close": 57474,
  "event": 58905,
  "exclamation": 58903,
  "organization": 58902,
  "trophy": 57350,
  "screen-smartphone": 57360,
  "screen-desktop": 57361,
  "plane": 57362,
  "notebook": 57363,
  "mustache": 57364,
  "mouse": 57365,
  "magnet": 57366,
  "energy": 57376,
  "disc": 57378,
  "cursor": 57454,
  "cursor-move": 57379,
  "crop": 57380,
  "chemistry": 57382,
  "speedometer": 57351,
  "shield": 57358,
  "screen-tablet": 57359,
  "magic-wand": 57367,
  "hourglass": 57368,
  "graduation": 57369,
  "ghost": 57370,
  "game-controller": 57371,
  "fire": 57372,
  "eyeglass": 57373,
  "envelope-open": 57374,
  "envelope-letter": 57375,
  "bell": 57383,
  "badge": 57384,
  "anchor": 57385,
  "wallet": 57386,
  "vector": 57387,
  "speech": 57388,
  "puzzle": 57389,
  "printer": 57390,
  "present": 57391,
  "playlist": 57392,
  "pin": 57393,
  "picture": 57394,
  "handbag": 57397,
  "globe-alt": 57398,
  "globe": 57399,
  "folder-alt": 57401,
  "folder": 57481,
  "film": 57402,
  "feed": 57403,
  "drop": 57406,
  "drawer": 57407,
  "docs": 57408,
  "doc": 57477,
  "diamond": 57411,
  "cup": 57412,
  "calculator": 57417,
  "bubbles": 57418,
  "briefcase": 57419,
  "book-open": 57420,
  "basket-loaded": 57421,
  "basket": 57422,
  "bag": 57423,
  "action-undo": 57424,
  "action-redo": 57425,
  "wrench": 57426,
  "umbrella": 57427,
  "trash": 57428,
  "tag": 57429,
  "support": 57430,
  "frame": 57400,
  "size-fullscreen": 57431,
  "size-actual": 57432,
  "shuffle": 57433,
  "share-alt": 57434,
  "share": 57435,
  "rocket": 57436,
  "question": 57437,
  "pie-chart": 57438,
  "pencil": 57439,
  "note": 57440,
  "loop": 57444,
  "home": 57449,
  "grid": 57450,
  "graph": 57451,
  "microphone": 57443,
  "music-tone-alt": 57441,
  "music-tone": 57442,
  "earphones-alt": 57404,
  "earphones": 57405,
  "equalizer": 57452,
  "like": 57448,
  "dislike": 57453,
  "control-start": 57455,
  "control-rewind": 57456,
  "control-play": 57457,
  "control-pause": 57458,
  "control-forward": 57459,
  "control-end": 57460,
  "volume-1": 57503,
  "volume-2": 57504,
  "volume-off": 57505,
  "calendar": 57461,
  "bulb": 57462,
  "chart": 57463,
  "ban": 57468,
  "bubble": 57469,
  "camrecorder": 57470,
  "camera": 57471,
  "cloud-download": 57475,
  "cloud-upload": 57476,
  "envelope": 57478,
  "eye": 57479,
  "flag": 57480,
  "heart": 57482,
  "info": 57483,
  "key": 57484,
  "link": 57485,
  "lock": 57486,
  "lock-open": 57487,
  "magnifier": 57488,
  "magnifier-add": 57489,
  "magnifier-remove": 57490,
  "paper-clip": 57491,
  "paper-plane": 57492,
  "power": 57495,
  "refresh": 57496,
  "reload": 57497,
  "settings": 57498,
  "star": 57499,
  "symbol-female": 57500,
  "symbol-male": 57501,
  "target": 57502,
  "credit-card": 57381,
  "paypal": 58888,
  "social-tumblr": 57354,
  "social-twitter": 57353,
  "social-facebook": 57355,
  "social-instagram": 58889,
  "social-linkedin": 58890,
  "social-pinterest": 58891,
  "social-github": 58892,
  "social-google": 58893,
  "social-reddit": 58894,
  "social-skype": 58895,
  "social-dribbble": 57357,
  "social-behance": 58896,
  "social-foursqare": 58897,
  "social-soundcloud": 58898,
  "social-spotify": 58899,
  "social-stumbleupon": 58900,
  "social-youtube": 57352,
  "social-dropbox": 57356,
  "social-vkontakte": 58904,
  "social-steam": 58912
};
},711,[],"node_modules\\react-native-vector-icons\\glyphmaps\\SimpleLineIcons.json");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getImageSource = exports.ToolbarAndroid = exports.TabBarItemIOS = exports.TabBarItem = exports.Button = exports.default = void 0;

  var _createIconSet = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "./lib/create-icon-set"));

  var _Feather = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "./glyphmaps/Feather.json"));

  var iconSet = (0, _createIconSet.default)(_Feather.default, 'Feather', 'Feather.ttf');
  var _default = iconSet;
  exports.default = _default;
  var Button = iconSet.Button;
  exports.Button = Button;
  var TabBarItem = iconSet.TabBarItem;
  exports.TabBarItem = TabBarItem;
  var TabBarItemIOS = iconSet.TabBarItemIOS;
  exports.TabBarItemIOS = TabBarItemIOS;
  var ToolbarAndroid = iconSet.ToolbarAndroid;
  exports.ToolbarAndroid = ToolbarAndroid;
  var getImageSource = iconSet.getImageSource;
  exports.getImageSource = getImageSource;
},712,[23,644,713],"node_modules\\react-native-vector-icons\\Feather.js");
__d(function(global, require, _aUnused, _bUnused, module, exports, _cUnused) {
  module.exports = {
  "activity": 59648,
  "airplay": 59649,
  "alert-circle": 59650,
  "alert-octagon": 59651,
  "alert-triangle": 59652,
  "align-center": 59653,
  "align-justify": 59654,
  "align-left": 59655,
  "align-right": 59656,
  "anchor": 59657,
  "aperture": 59658,
  "archive": 59659,
  "arrow-down": 59660,
  "arrow-down-circle": 59661,
  "arrow-down-left": 59662,
  "arrow-down-right": 59663,
  "arrow-left": 59664,
  "arrow-left-circle": 59665,
  "arrow-right": 59666,
  "arrow-right-circle": 59667,
  "arrow-up": 59668,
  "arrow-up-circle": 59669,
  "arrow-up-left": 59670,
  "arrow-up-right": 59671,
  "at-sign": 59672,
  "award": 59673,
  "bar-chart": 59674,
  "bar-chart-2": 59675,
  "battery": 59676,
  "battery-charging": 59677,
  "bell": 59678,
  "bell-off": 59679,
  "bluetooth": 59680,
  "bold": 59681,
  "book": 59682,
  "book-open": 59683,
  "bookmark": 59684,
  "box": 59685,
  "briefcase": 59686,
  "calendar": 59687,
  "camera": 59688,
  "camera-off": 59689,
  "cast": 59690,
  "check": 59691,
  "check-circle": 59692,
  "check-square": 59693,
  "chevron-down": 59694,
  "chevron-left": 59695,
  "chevron-right": 59696,
  "chevron-up": 59697,
  "chevrons-down": 59698,
  "chevrons-left": 59699,
  "chevrons-right": 59700,
  "chevrons-up": 59701,
  "chrome": 59702,
  "circle": 59703,
  "clipboard": 59704,
  "clock": 59705,
  "cloud": 59706,
  "cloud-drizzle": 59707,
  "cloud-lightning": 59708,
  "cloud-off": 59709,
  "cloud-rain": 59710,
  "cloud-snow": 59711,
  "code": 59712,
  "codepen": 59713,
  "command": 59714,
  "compass": 59715,
  "copy": 59716,
  "corner-down-left": 59717,
  "corner-down-right": 59718,
  "corner-left-down": 59719,
  "corner-left-up": 59720,
  "corner-right-down": 59721,
  "corner-right-up": 59722,
  "corner-up-left": 59723,
  "corner-up-right": 59724,
  "cpu": 59725,
  "credit-card": 59726,
  "crop": 59727,
  "crosshair": 59728,
  "database": 59729,
  "delete": 59730,
  "disc": 59731,
  "dollar-sign": 59732,
  "download": 59733,
  "download-cloud": 59734,
  "droplet": 59735,
  "edit": 59736,
  "edit-2": 59737,
  "edit-3": 59738,
  "external-link": 59739,
  "eye": 59740,
  "eye-off": 59741,
  "facebook": 59742,
  "fast-forward": 59743,
  "feather": 59744,
  "file": 59745,
  "file-minus": 59746,
  "file-plus": 59747,
  "file-text": 59748,
  "film": 59749,
  "filter": 59750,
  "flag": 59751,
  "folder": 59752,
  "folder-minus": 59753,
  "folder-plus": 59754,
  "gift": 59755,
  "git-branch": 59756,
  "git-commit": 59757,
  "git-merge": 59758,
  "git-pull-request": 59759,
  "github": 59760,
  "gitlab": 59761,
  "globe": 59762,
  "grid": 59763,
  "hard-drive": 59764,
  "hash": 59765,
  "headphones": 59766,
  "heart": 59767,
  "help-circle": 59768,
  "home": 59769,
  "image": 59770,
  "inbox": 59771,
  "info": 59772,
  "instagram": 59773,
  "italic": 59774,
  "layers": 59775,
  "layout": 59776,
  "life-buoy": 59777,
  "link": 59778,
  "link-2": 59779,
  "linkedin": 59780,
  "list": 59781,
  "loader": 59782,
  "lock": 59783,
  "log-in": 59784,
  "log-out": 59785,
  "mail": 59786,
  "map": 59787,
  "map-pin": 59788,
  "maximize": 59789,
  "maximize-2": 59790,
  "menu": 59791,
  "message-circle": 59792,
  "message-square": 59793,
  "mic": 59794,
  "mic-off": 59795,
  "minimize": 59796,
  "minimize-2": 59797,
  "minus": 59798,
  "minus-circle": 59799,
  "minus-square": 59800,
  "monitor": 59801,
  "moon": 59802,
  "more-horizontal": 59803,
  "more-vertical": 59804,
  "move": 59805,
  "music": 59806,
  "navigation": 59807,
  "navigation-2": 59808,
  "octagon": 59809,
  "package": 59810,
  "paperclip": 59811,
  "pause": 59812,
  "pause-circle": 59813,
  "percent": 59814,
  "phone": 59815,
  "phone-call": 59816,
  "phone-forwarded": 59817,
  "phone-incoming": 59818,
  "phone-missed": 59819,
  "phone-off": 59820,
  "phone-outgoing": 59821,
  "pie-chart": 59822,
  "play": 59823,
  "play-circle": 59824,
  "plus": 59825,
  "plus-circle": 59826,
  "plus-square": 59827,
  "pocket": 59828,
  "power": 59829,
  "printer": 59830,
  "radio": 59831,
  "refresh-ccw": 59832,
  "refresh-cw": 59833,
  "repeat": 59834,
  "rewind": 59835,
  "rotate-ccw": 59836,
  "rotate-cw": 59837,
  "rss": 59838,
  "save": 59839,
  "scissors": 59840,
  "search": 59841,
  "send": 59842,
  "server": 59843,
  "settings": 59844,
  "share": 59845,
  "share-2": 59846,
  "shield": 59847,
  "shield-off": 59848,
  "shopping-bag": 59849,
  "shopping-cart": 59850,
  "shuffle": 59851,
  "sidebar": 59852,
  "skip-back": 59853,
  "skip-forward": 59854,
  "slack": 59855,
  "slash": 59856,
  "sliders": 59857,
  "smartphone": 59858,
  "speaker": 59859,
  "square": 59860,
  "star": 59861,
  "stop-circle": 59862,
  "sun": 59863,
  "sunrise": 59864,
  "sunset": 59865,
  "tablet": 59866,
  "tag": 59867,
  "target": 59868,
  "terminal": 59869,
  "thermometer": 59870,
  "thumbs-down": 59871,
  "thumbs-up": 59872,
  "toggle-left": 59873,
  "toggle-right": 59874,
  "trash": 59875,
  "trash-2": 59876,
  "trending-down": 59877,
  "trending-up": 59878,
  "triangle": 59879,
  "truck": 59880,
  "tv": 59881,
  "twitter": 59882,
  "type": 59883,
  "umbrella": 59884,
  "underline": 59885,
  "unlock": 59886,
  "upload": 59887,
  "upload-cloud": 59888,
  "user": 59889,
  "user-check": 59890,
  "user-minus": 59891,
  "user-plus": 59892,
  "user-x": 59893,
  "users": 59894,
  "video": 59895,
  "video-off": 59896,
  "voicemail": 59897,
  "volume": 59898,
  "volume-1": 59899,
  "volume-2": 59900,
  "volume-x": 59901,
  "watch": 59902,
  "wifi": 59903,
  "wifi-off": 59904,
  "wind": 59905,
  "x": 59906,
  "x-circle": 59907,
  "x-square": 59908,
  "youtube": 59909,
  "zap": 59910,
  "zap-off": 59911,
  "zoom-in": 59912,
  "zoom-out": 59913
};
},713,[],"node_modules\\react-native-vector-icons\\glyphmaps\\Feather.json");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _reactNative = _$$_REQUIRE(_dependencyMap[0], "react-native");

  var ViewPropTypes = _reactNative.ViewPropTypes || _reactNative.View.propTypes;
  var _default = ViewPropTypes;
  exports.default = _default;
},714,[116],"node_modules\\react-native-elements\\src\\config\\ViewPropTypes.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _objectSpread2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread"));

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/objectWithoutProperties"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "prop-types"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[6], "react-native");

  var _getIconType = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "../helpers/getIconType"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "../config/ViewPropTypes"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\icons\\Icon.js";

  var Icon = function Icon(props) {
    var type = props.type,
        name = props.name,
        size = props.size,
        color = props.color,
        iconStyle = props.iconStyle,
        component = props.component,
        underlayColor = props.underlayColor,
        reverse = props.reverse,
        raised = props.raised,
        containerStyle = props.containerStyle,
        reverseColor = props.reverseColor,
        onPress = props.onPress,
        attributes = (0, _objectWithoutProperties2.default)(props, ["type", "name", "size", "color", "iconStyle", "component", "underlayColor", "reverse", "raised", "containerStyle", "reverseColor", "onPress"]);
    var Component = _reactNative.View;

    if (onPress) {
      Component = _reactNative.TouchableHighlight;
    }

    if (component) {
      Component = component;
    }

    var Icon;

    if (!type) {
      Icon = (0, _getIconType.default)('material');
    } else {
      Icon = (0, _getIconType.default)(type);
    }

    return _react.default.createElement(Component, (0, _extends2.default)({}, attributes, {
      underlayColor: reverse ? color : underlayColor || color,
      style: [(reverse || raised) && styles.button, (reverse || raised) && {
        borderRadius: size + 4,
        height: size * 2 + 4,
        width: size * 2 + 4
      }, raised && styles.raised, {
        backgroundColor: reverse ? color : raised ? 'white' : 'transparent',
        alignItems: 'center',
        justifyContent: 'center'
      }, containerStyle && containerStyle],
      onPress: onPress,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 44
      }
    }), _react.default.createElement(Icon, {
      style: [{
        backgroundColor: 'transparent'
      }, iconStyle && iconStyle],
      size: size,
      name: name,
      color: reverse ? reverseColor : color,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 64
      }
    }));
  };

  Icon.propTypes = {
    type: _propTypes.default.string,
    name: _propTypes.default.string,
    size: _propTypes.default.number,
    color: _propTypes.default.string,
    component: _propTypes.default.func,
    underlayColor: _propTypes.default.string,
    reverse: _propTypes.default.bool,
    raised: _propTypes.default.bool,
    containerStyle: _ViewPropTypes.default.style,
    iconStyle: _reactNative.Text.propTypes.style,
    onPress: _propTypes.default.func,
    reverseColor: _propTypes.default.string
  };
  Icon.defaultProps = {
    underlayColor: 'white',
    reverse: false,
    raised: false,
    size: 24,
    color: 'black',
    reverseColor: 'white'
  };

  var styles = _reactNative.StyleSheet.create({
    button: {
      margin: 7
    },
    raised: (0, _objectSpread2.default)({}, _reactNative.Platform.select({
      ios: {
        shadowColor: 'rgba(0,0,0, .4)',
        shadowOffset: {
          height: 1,
          width: 1
        },
        shadowOpacity: 1,
        shadowRadius: 1
      },
      android: {
        elevation: 2
      }
    }))
  });

  var _default = Icon;
  exports.default = _default;
},715,[23,148,112,120,161,109,116,693,714],"node_modules\\react-native-elements\\src\\icons\\Icon.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutProperties"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "prop-types"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[5], "react-native");

  var _colors = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "../config/colors"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "../config/ViewPropTypes"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\list\\List.js";

  var List = function List(props) {
    var children = props.children,
        containerStyle = props.containerStyle,
        attributes = (0, _objectWithoutProperties2.default)(props, ["children", "containerStyle"]);
    return _react.default.createElement(_reactNative.View, (0, _extends2.default)({}, attributes, {
      style: [styles.listContainer, containerStyle && containerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 10
      }
    }), children);
  };

  List.propTypes = {
    children: _propTypes.default.any,
    containerStyle: _ViewPropTypes.default.style
  };

  var styles = _reactNative.StyleSheet.create({
    listContainer: {
      marginTop: 20,
      borderTopWidth: 1,
      borderColor: _colors.default.greyOutline,
      backgroundColor: _colors.default.white
    }
  });

  var _default = List;
  exports.default = _default;
},716,[23,112,120,161,109,116,639,714],"node_modules\\react-native-elements\\src\\list\\List.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _objectSpread2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread"));

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/objectWithoutProperties"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "prop-types"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[6], "react-native");

  var _Avatar = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "../avatar/Avatar"));

  var _badge = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "../badge/badge"));

  var _Icon = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "../icons/Icon"));

  var _Text = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "../text/Text"));

  var _colors = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "../config/colors"));

  var _fonts = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[12], "../config/fonts"));

  var _normalizeText = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[13], "../helpers/normalizeText"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[14], "../config/ViewPropTypes"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\list\\ListItem.js";

  var ListItem = function ListItem(props) {
    var onPress = props.onPress,
        title = props.title,
        leftIcon = props.leftIcon,
        rightIcon = props.rightIcon,
        leftIconOnPress = props.leftIconOnPress,
        leftIconOnLongPress = props.leftIconOnLongPress,
        leftIconUnderlayColor = props.leftIconUnderlayColor,
        leftIconContainerStyle = props.leftIconContainerStyle,
        avatarStyle = props.avatarStyle,
        avatarContainerStyle = props.avatarContainerStyle,
        avatarOverlayContainerStyle = props.avatarOverlayContainerStyle,
        underlayColor = props.underlayColor,
        subtitle = props.subtitle,
        subtitleStyle = props.subtitleStyle,
        containerStyle = props.containerStyle,
        wrapperStyle = props.wrapperStyle,
        titleNumberOfLines = props.titleNumberOfLines,
        titleStyle = props.titleStyle,
        titleContainerStyle = props.titleContainerStyle,
        hideChevron = props.hideChevron,
        chevronColor = props.chevronColor,
        roundAvatar = props.roundAvatar,
        component = props.component,
        fontFamily = props.fontFamily,
        rightTitle = props.rightTitle,
        rightTitleContainerStyle = props.rightTitleContainerStyle,
        rightTitleStyle = props.rightTitleStyle,
        rightTitleNumberOfLines = props.rightTitleNumberOfLines,
        subtitleContainerStyle = props.subtitleContainerStyle,
        subtitleNumberOfLines = props.subtitleNumberOfLines,
        badge = props.badge,
        label = props.label,
        onLongPress = props.onLongPress,
        switchButton = props.switchButton,
        onSwitch = props.onSwitch,
        switchDisabled = props.switchDisabled,
        switchOnTintColor = props.switchOnTintColor,
        switchThumbTintColor = props.switchThumbTintColor,
        switchTintColor = props.switchTintColor,
        switched = props.switched,
        textInput = props.textInput,
        textInputAutoCapitalize = props.textInputAutoCapitalize,
        textInputAutoCorrect = props.textInputAutoCorrect,
        textInputAutoFocus = props.textInputAutoFocus,
        textInputEditable = props.textInputEditable,
        textInputKeyboardType = props.textInputKeyboardType,
        textInputMaxLength = props.textInputMaxLength,
        textInputMultiline = props.textInputMultiline,
        textInputOnChangeText = props.textInputOnChangeText,
        textInputOnFocus = props.textInputOnFocus,
        textInputOnBlur = props.textInputOnBlur,
        textInputSelectTextOnFocus = props.textInputSelectTextOnFocus,
        textInputReturnKeyType = props.textInputReturnKeyType,
        textInputValue = props.textInputValue,
        textInputSecure = props.textInputSecure,
        textInputStyle = props.textInputStyle,
        textInputContainerStyle = props.textInputContainerStyle,
        textInputPlaceholder = props.textInputPlaceholder,
        onPressRightIcon = props.onPressRightIcon,
        disabled = props.disabled,
        disabledStyle = props.disabledStyle,
        attributes = (0, _objectWithoutProperties2.default)(props, ["onPress", "title", "leftIcon", "rightIcon", "leftIconOnPress", "leftIconOnLongPress", "leftIconUnderlayColor", "leftIconContainerStyle", "avatarStyle", "avatarContainerStyle", "avatarOverlayContainerStyle", "underlayColor", "subtitle", "subtitleStyle", "containerStyle", "wrapperStyle", "titleNumberOfLines", "titleStyle", "titleContainerStyle", "hideChevron", "chevronColor", "roundAvatar", "component", "fontFamily", "rightTitle", "rightTitleContainerStyle", "rightTitleStyle", "rightTitleNumberOfLines", "subtitleContainerStyle", "subtitleNumberOfLines", "badge", "label", "onLongPress", "switchButton", "onSwitch", "switchDisabled", "switchOnTintColor", "switchThumbTintColor", "switchTintColor", "switched", "textInput", "textInputAutoCapitalize", "textInputAutoCorrect", "textInputAutoFocus", "textInputEditable", "textInputKeyboardType", "textInputMaxLength", "textInputMultiline", "textInputOnChangeText", "textInputOnFocus", "textInputOnBlur", "textInputSelectTextOnFocus", "textInputReturnKeyType", "textInputValue", "textInputSecure", "textInputStyle", "textInputContainerStyle", "textInputPlaceholder", "onPressRightIcon", "disabled", "disabledStyle"]);
    var avatar = props.avatar;
    var Component = onPress || onLongPress ? _reactNative.TouchableHighlight : _reactNative.View;
    var LeftIconWrapper = leftIconOnPress || leftIconOnLongPress ? _reactNative.TouchableHighlight : _reactNative.View;

    if (component) {
      Component = component;
    }

    if (typeof avatar === 'string') {
      avatar = {
        uri: avatar
      };
    }

    return _react.default.createElement(Component, (0, _extends2.default)({}, attributes, {
      onLongPress: onLongPress,
      onPress: onPress,
      disabled: disabled,
      underlayColor: underlayColor,
      style: [styles.container, containerStyle && containerStyle, disabled && styles.disabled, disabled && disabledStyle && disabledStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 100
      }
    }), _react.default.createElement(_reactNative.View, {
      style: [styles.wrapper, wrapperStyle && wrapperStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 113
      }
    }, _react.default.isValidElement(leftIcon) ? leftIcon : leftIcon && leftIcon.name && _react.default.createElement(LeftIconWrapper, {
      onLongPress: leftIconOnLongPress,
      onPress: leftIconOnPress,
      disabled: disabled,
      underlayColor: leftIconUnderlayColor,
      style: [styles.iconStyle, leftIconContainerStyle && leftIconContainerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 118
      }
    }, _react.default.createElement(_reactNative.View, {
      __source: {
        fileName: _jsxFileName,
        lineNumber: 128
      }
    }, _react.default.createElement(_Icon.default, {
      type: leftIcon.type,
      iconStyle: [styles.icon, leftIcon.style && leftIcon.style],
      name: leftIcon.name,
      color: leftIcon.color || _colors.default.grey4,
      size: leftIcon.size || 24,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 129
      }
    }))), avatar && _react.default.isValidElement(avatar) ? avatar : avatar && !_react.default.isValidElement(avatar) && _react.default.createElement(_Avatar.default, {
      avatarStyle: avatarStyle && avatarStyle,
      containerStyle: avatarContainerStyle && avatarContainerStyle,
      overlayContainerStyle: avatarOverlayContainerStyle && avatarOverlayContainerStyle,
      rounded: roundAvatar,
      source: avatar,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 143
      }
    }), _react.default.createElement(_reactNative.View, {
      style: styles.titleSubtitleContainer,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 153
      }
    }, _react.default.createElement(_reactNative.View, {
      style: titleContainerStyle,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 154
      }
    }, title !== null && (typeof title === 'string' || typeof title === 'number') ? _react.default.createElement(_Text.default, {
      numberOfLines: titleNumberOfLines,
      style: [styles.title, !leftIcon && {
        marginLeft: 10
      }, titleStyle && titleStyle, fontFamily && {
        fontFamily: fontFamily
      }],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 157
      }
    }, title) : _react.default.createElement(_reactNative.View, {
      __source: {
        fileName: _jsxFileName,
        lineNumber: 169
      }
    }, title)), _react.default.createElement(_reactNative.View, {
      style: subtitleContainerStyle,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 172
      }
    }, subtitle !== null && (typeof subtitle === 'string' || typeof subtitle === 'number') ? _react.default.createElement(_Text.default, {
      numberOfLines: subtitleNumberOfLines,
      style: [styles.subtitle, !leftIcon && {
        marginLeft: 10
      }, subtitleStyle && subtitleStyle, fontFamily && {
        fontFamily: fontFamily
      }],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 175
      }
    }, subtitle) : _react.default.createElement(_reactNative.View, {
      __source: {
        fileName: _jsxFileName,
        lineNumber: 187
      }
    }, subtitle))), rightTitle && rightTitle !== '' && !textInput && _react.default.createElement(_reactNative.View, {
      style: [styles.rightTitleContainer, rightTitleContainerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 194
      }
    }, _react.default.createElement(_Text.default, {
      numberOfLines: rightTitleNumberOfLines,
      style: [styles.rightTitleStyle, rightTitleStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 197
      }
    }, rightTitle)), textInput && _react.default.createElement(_reactNative.View, {
      style: [styles.rightTitleContainer, styles.textInputContainerStyle, textInputContainerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 206
      }
    }, _react.default.createElement(_reactNative.TextInput, {
      style: [styles.textInputStyle, textInputStyle],
      underlineColorAndroid: 'transparent',
      defaultValue: rightTitle,
      value: textInputValue,
      placeholder: textInputPlaceholder,
      autoCapitalize: textInputAutoCapitalize,
      autoCorrect: textInputAutoCorrect,
      autoFocus: textInputAutoFocus,
      editable: disabled ? false : textInputEditable,
      keyboardType: textInputKeyboardType,
      maxLength: textInputMaxLength,
      multiline: textInputMultiline,
      onChangeText: textInputOnChangeText,
      onFocus: textInputOnFocus,
      onBlur: textInputOnBlur,
      secureTextEntry: textInputSecure,
      selectTextOnFocus: textInputSelectTextOnFocus,
      returnKeyType: textInputReturnKeyType,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 213
      }
    })), badge && !rightTitle && _react.default.createElement(_badge.default, (0, _extends2.default)({}, badge, {
      __source: {
        fileName: _jsxFileName,
        lineNumber: 235
      }
    })), !hideChevron && (_react.default.isValidElement(rightIcon) ? rightIcon : _react.default.createElement(_reactNative.TouchableOpacity, {
      onPress: onPressRightIcon,
      disabled: disabled ? disabled : !onPressRightIcon,
      style: styles.chevronContainer,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 240
      }
    }, _react.default.createElement(_Icon.default, {
      type: rightIcon.type,
      iconStyle: rightIcon.style,
      size: 28,
      name: rightIcon.name || 'chevron-right',
      color: rightIcon.color || chevronColor,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 245
      }
    }))), switchButton && hideChevron && _react.default.createElement(_reactNative.View, {
      style: styles.switchContainer,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 256
      }
    }, _react.default.createElement(_reactNative.Switch, {
      onValueChange: onSwitch,
      disabled: disabled ? disabled : switchDisabled,
      onTintColor: switchOnTintColor,
      thumbTintColor: switchThumbTintColor,
      tintColor: switchTintColor,
      value: switched,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 257
      }
    })), label && label));
  };

  ListItem.defaultProps = {
    underlayColor: 'white',
    leftIconUnderlayColor: 'white',
    chevronColor: _colors.default.grey4,
    rightIcon: {
      name: 'chevron-right'
    },
    hideChevron: false,
    roundAvatar: false,
    switchButton: false,
    textInputEditable: true,
    titleNumberOfLines: 1,
    subtitleNumberOfLines: 1,
    rightTitleNumberOfLines: 1,
    disabled: false
  };
  ListItem.propTypes = {
    title: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number, _propTypes.default.object]),
    avatar: _propTypes.default.any,
    icon: _propTypes.default.any,
    onPress: _propTypes.default.func,
    rightIcon: _propTypes.default.oneOfType([_propTypes.default.element, _propTypes.default.object]),
    underlayColor: _propTypes.default.string,
    subtitle: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number, _propTypes.default.object]),
    subtitleStyle: _propTypes.default.any,
    subtitleNumberOfLines: _propTypes.default.number,
    containerStyle: _propTypes.default.any,
    wrapperStyle: _propTypes.default.any,
    titleStyle: _propTypes.default.any,
    titleContainerStyle: _propTypes.default.any,
    titleNumberOfLines: _propTypes.default.number,
    hideChevron: _propTypes.default.bool,
    chevronColor: _propTypes.default.string,
    roundAvatar: _propTypes.default.bool,
    badge: _propTypes.default.any,
    switchButton: _propTypes.default.bool,
    onSwitch: _propTypes.default.func,
    switchDisabled: _propTypes.default.bool,
    switchOnTintColor: _propTypes.default.string,
    switchThumbTintColor: _propTypes.default.string,
    switchTintColor: _propTypes.default.string,
    switched: _propTypes.default.bool,
    textInput: _propTypes.default.bool,
    textInputAutoCapitalize: _propTypes.default.oneOf(['none', 'sentences', 'words', 'characters']),
    textInputAutoCorrect: _propTypes.default.bool,
    textInputAutoFocus: _propTypes.default.bool,
    textInputEditable: _propTypes.default.bool,
    textInputKeyboardType: _propTypes.default.oneOf(['default', 'email-address', 'numeric', 'phone-pad', 'ascii-capable', 'numbers-and-punctuation', 'url', 'number-pad', 'name-phone-pad', 'decimal-pad', 'twitter', 'web-search']),
    textInputMaxLength: _propTypes.default.number,
    textInputMultiline: _propTypes.default.bool,
    textInputOnChangeText: _propTypes.default.func,
    textInputOnFocus: _propTypes.default.func,
    textInputOnBlur: _propTypes.default.func,
    textInputSelectTextOnFocus: _propTypes.default.bool,
    textInputReturnKeyType: _propTypes.default.string,
    textInputValue: _propTypes.default.string,
    textInputSecure: _propTypes.default.bool,
    textInputStyle: _propTypes.default.any,
    textInputContainerStyle: _propTypes.default.any,
    textInputPlaceholder: _propTypes.default.string,
    component: _propTypes.default.any,
    fontFamily: _propTypes.default.string,
    rightTitle: _propTypes.default.string,
    rightTitleContainerStyle: _ViewPropTypes.default.style,
    rightTitleStyle: _Text.default.propTypes.style,
    rightTitleNumberOfLines: _propTypes.default.number,
    subtitleContainerStyle: _ViewPropTypes.default.style,
    label: _propTypes.default.any,
    onLongPress: _propTypes.default.func,
    leftIcon: _propTypes.default.oneOfType([_propTypes.default.element, _propTypes.default.object]),
    leftIconOnPress: _propTypes.default.func,
    leftIconOnLongPress: _propTypes.default.func,
    leftIconUnderlayColor: _propTypes.default.string,
    leftIconContainerStyle: _ViewPropTypes.default.style,
    avatarStyle: _reactNative.Image.propTypes.style,
    avatarContainerStyle: _ViewPropTypes.default.style,
    avatarOverlayContainerStyle: _ViewPropTypes.default.style,
    onPressRightIcon: _propTypes.default.func,
    disabled: _propTypes.default.bool,
    disabledStyle: _ViewPropTypes.default.style
  };

  var styles = _reactNative.StyleSheet.create({
    container: {
      paddingTop: 10,
      paddingRight: 10,
      paddingBottom: 10,
      borderBottomColor: _colors.default.greyOutline,
      borderBottomWidth: 1,
      backgroundColor: 'transparent'
    },
    wrapper: {
      flexDirection: 'row',
      marginLeft: 10,
      alignItems: 'center'
    },
    iconStyle: {
      justifyContent: 'center',
      alignItems: 'center'
    },
    icon: {
      marginRight: 8
    },
    title: {
      fontSize: (0, _normalizeText.default)(14),
      color: _colors.default.grey1
    },
    subtitle: (0, _objectSpread2.default)({
      color: _colors.default.grey3,
      fontSize: (0, _normalizeText.default)(12),
      marginTop: 1
    }, _reactNative.Platform.select({
      ios: {
        fontWeight: '600'
      },
      android: (0, _objectSpread2.default)({}, _fonts.default.android.bold)
    })),
    titleSubtitleContainer: {
      justifyContent: 'center',
      flex: 1
    },
    chevronContainer: {
      alignItems: 'flex-end',
      justifyContent: 'center'
    },
    switchContainer: {
      alignItems: 'flex-end',
      justifyContent: 'center',
      marginRight: 5
    },
    rightTitleContainer: {
      flex: 1,
      alignItems: 'flex-end',
      justifyContent: 'center'
    },
    rightTitleStyle: {
      marginRight: 5,
      color: _colors.default.grey4
    },
    textInputContainerStyle: {
      alignItems: null
    },
    textInputStyle: {
      height: 20,
      flex: 1,
      textAlign: 'right'
    },
    disabled: {
      opacity: 0.5
    }
  });

  var _default = ListItem;
  exports.default = _default;
},717,[23,148,112,120,161,109,116,718,719,715,640,639,641,642,714],"node_modules\\react-native-elements\\src\\list\\ListItem.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends"));

  var _objectSpread2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectSpread"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/objectWithoutProperties"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "prop-types"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[6], "react-native");

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "../config/ViewPropTypes"));

  var _Icon = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "../icons/Icon"));

  var _Text = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "../text/Text"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\avatar\\Avatar.js";
  var DEFAULT_COLORS = ['#000', '#333', '#555', '#888', '#aaa', '#ddd'];

  var Avatar = function Avatar(props) {
    var component = props.component,
        onPress = props.onPress,
        onLongPress = props.onLongPress,
        containerStyle = props.containerStyle,
        icon = props.icon,
        iconStyle = props.iconStyle,
        source = props.source,
        small = props.small,
        medium = props.medium,
        large = props.large,
        xlarge = props.xlarge,
        avatarStyle = props.avatarStyle,
        rounded = props.rounded,
        title = props.title,
        titleStyle = props.titleStyle,
        overlayContainerStyle = props.overlayContainerStyle,
        activeOpacity = props.activeOpacity,
        showEditButton = props.showEditButton,
        editButton = props.editButton,
        onEditPress = props.onEditPress,
        imageProps = props.imageProps,
        attributes = (0, _objectWithoutProperties2.default)(props, ["component", "onPress", "onLongPress", "containerStyle", "icon", "iconStyle", "source", "small", "medium", "large", "xlarge", "avatarStyle", "rounded", "title", "titleStyle", "overlayContainerStyle", "activeOpacity", "showEditButton", "editButton", "onEditPress", "imageProps"]);
    var width = props.width,
        height = props.height;

    if (small) {
      width = 34;
      height = 34;
    } else if (medium) {
      width = 50;
      height = 50;
    } else if (large) {
      width = 75;
      height = 75;
    } else if (xlarge) {
      width = 150;
      height = 150;
    } else if (!width && !height) {
      width = 34;
      height = 34;
    } else if (!width) {
      width = height;
    } else if (!height) {
      height = width;
    }

    var titleSize = width / 2;
    var iconSize = width / 2;
    var Component = onPress || onLongPress ? _reactNative.TouchableOpacity : _reactNative.View;

    if (component) {
      Component = component;
    }

    var renderUtils = function renderUtils() {
      if (showEditButton) {
        var editButtonProps = (0, _objectSpread2.default)({}, editButton);
        var defaultEditButtonSize = (width + height) / 2 / 3;
        var editButtonSize = editButton.size || defaultEditButtonSize;
        var editButtonSizeStyle = {
          width: editButtonSize,
          height: editButtonSize,
          borderRadius: editButtonSize / 2
        };
        var editButtonIconSize = editButtonSize * 0.8;
        return _react.default.createElement(_reactNative.TouchableHighlight, {
          style: [styles.editButton, editButtonSizeStyle, editButtonProps.style],
          underlayColor: editButtonProps.underlayColor,
          onPress: onEditPress,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 92
          }
        }, _react.default.createElement(_reactNative.View, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 101
          }
        }, _react.default.createElement(_Icon.default, {
          size: editButtonIconSize,
          name: editButtonProps.iconName,
          type: editButtonProps.iconType,
          color: editButtonProps.iconColor,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 102
          }
        })));
      }
    };

    var renderContent = function renderContent() {
      if (source) {
        return _react.default.createElement(_reactNative.Image, (0, _extends2.default)({
          style: [styles.avatar, rounded && {
            borderRadius: width / 2
          }, avatarStyle && avatarStyle],
          source: source
        }, imageProps, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 117
          }
        }));
      } else if (title) {
        return _react.default.createElement(_Text.default, {
          style: [styles.title, titleStyle && titleStyle],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 129
          }
        }, title);
      } else if (icon) {
        return _react.default.createElement(_Icon.default, {
          style: iconStyle && iconStyle,
          color: icon.color || 'white',
          name: icon.name || 'user',
          size: icon.size || iconSize,
          type: icon.type && icon.type,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 135
          }
        });
      }
    };

    var styles = _reactNative.StyleSheet.create({
      container: {
        paddingTop: 10,
        paddingRight: 10,
        paddingBottom: 10,
        backgroundColor: 'transparent',
        width: width,
        height: height
      },
      avatar: {
        width: width,
        height: height
      },
      overlayContainer: {
        flex: 1,
        alignItems: 'center',
        backgroundColor: 'rgba(0,0,0,0.2)',
        alignSelf: 'stretch',
        justifyContent: 'center',
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      title: {
        color: '#ffffff',
        fontSize: titleSize,
        backgroundColor: 'rgba(0,0,0,0)',
        textAlign: 'center'
      },
      editButton: (0, _objectSpread2.default)({
        position: 'absolute',
        bottom: 0,
        right: 0,
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: DEFAULT_COLORS[4]
      }, _reactNative.Platform.select({
        ios: {
          shadowColor: DEFAULT_COLORS[0],
          shadowOffset: {
            width: 1,
            height: 1
          },
          shadowRadius: 2,
          shadowOpacity: 0.5
        },
        android: {
          elevation: 1
        }
      }))
    });

    return _react.default.createElement(Component, (0, _extends2.default)({}, attributes, {
      onPress: onPress,
      onLongPress: onLongPress,
      activeOpacity: activeOpacity,
      style: [styles.container, rounded && {
        borderRadius: width / 2
      }, containerStyle && containerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 199
      }
    }), _react.default.createElement(_reactNative.View, {
      style: [styles.overlayContainer, rounded && {
        borderRadius: width / 2
      }, overlayContainerStyle && overlayContainerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 210
      }
    }, renderContent()), renderUtils());
  };

  var defaultProps = {
    showEditButton: false,
    onEditPress: null,
    editButton: {
      size: null,
      iconName: 'mode-edit',
      iconType: 'material',
      iconColor: '#fff',
      underlayColor: DEFAULT_COLORS[0],
      style: null
    }
  };
  Avatar.propTypes = {
    component: _propTypes.default.oneOf([_reactNative.View, _reactNative.TouchableOpacity, _reactNative.TouchableHighlight, _reactNative.TouchableNativeFeedback, _reactNative.TouchableWithoutFeedback]),
    width: _propTypes.default.number,
    height: _propTypes.default.number,
    onPress: _propTypes.default.func,
    onLongPress: _propTypes.default.func,
    containerStyle: _propTypes.default.any,
    source: _reactNative.Image.propTypes.source,
    avatarStyle: _propTypes.default.any,
    rounded: _propTypes.default.bool,
    title: _propTypes.default.string,
    titleStyle: _reactNative.Text.propTypes.style,
    overlayContainerStyle: _propTypes.default.any,
    activeOpacity: _propTypes.default.number,
    icon: _propTypes.default.object,
    iconStyle: _reactNative.Text.propTypes.style,
    small: _propTypes.default.bool,
    medium: _propTypes.default.bool,
    large: _propTypes.default.bool,
    xlarge: _propTypes.default.bool,
    showEditButton: _propTypes.default.bool,
    onEditPress: _propTypes.default.func,
    editButton: _propTypes.default.shape({
      size: _propTypes.default.number,
      iconName: _propTypes.default.string,
      iconType: _propTypes.default.string,
      iconColor: _propTypes.default.string,
      underlayColor: _propTypes.default.string,
      style: _ViewPropTypes.default.style
    }),
    imageProps: _propTypes.default.object
  };
  Avatar.defaultProps = defaultProps;
  var _default = Avatar;
  exports.default = _default;
},718,[23,112,148,120,161,109,116,714,715,640],"node_modules\\react-native-elements\\src\\avatar\\Avatar.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutProperties"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "prop-types"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[5], "react-native");

  var _colors = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "../config/colors"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "../config/ViewPropTypes"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\badge\\badge.js";

  var Badge = function Badge(props) {
    var containerStyle = props.containerStyle,
        textStyle = props.textStyle,
        wrapperStyle = props.wrapperStyle,
        onPress = props.onPress,
        component = props.component,
        value = props.value,
        children = props.children,
        element = props.element,
        attributes = (0, _objectWithoutProperties2.default)(props, ["containerStyle", "textStyle", "wrapperStyle", "onPress", "component", "value", "children", "element"]);
    if (element) return element;
    var Component = _reactNative.View;

    var childElement = _react.default.createElement(_reactNative.Text, {
      style: [styles.text, textStyle && textStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 25
      }
    }, value);

    if (children) {
      childElement = children;
    }

    if (children && value) {
      console.error('Badge can only contain either child element or value');
    }

    if (!component && onPress) {
      Component = _reactNative.TouchableOpacity;
    }

    if (_react.default.isValidElement(component)) {
      Component = component;
    }

    return _react.default.createElement(_reactNative.View, {
      style: [styles.container && wrapperStyle && wrapperStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 47
      }
    }, _react.default.createElement(Component, (0, _extends2.default)({}, attributes, {
      style: [styles.badge, containerStyle && containerStyle],
      onPress: onPress,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 48
      }
    }), childElement));
  };

  Badge.propTypes = {
    containerStyle: _ViewPropTypes.default.style,
    wrapperStyle: _ViewPropTypes.default.style,
    textStyle: _reactNative.Text.propTypes.style,
    children: _propTypes.default.oneOfType([_propTypes.default.element, _propTypes.default.arrayOf(_propTypes.default.element)]),
    value: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
    onPress: _propTypes.default.func,
    component: _propTypes.default.func,
    element: _propTypes.default.element
  };

  var styles = _reactNative.StyleSheet.create({
    container: {
      flexDirection: 'row'
    },
    badge: {
      padding: 12,
      paddingTop: 3,
      paddingBottom: 3,
      backgroundColor: _colors.default.grey1,
      borderRadius: 20,
      alignItems: 'center',
      justifyContent: 'center'
    },
    text: {
      fontSize: 14,
      color: 'white'
    }
  });

  var _default = Badge;
  exports.default = _default;
},719,[23,112,120,161,109,116,639,714],"node_modules\\react-native-elements\\src\\badge\\badge.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _objectSpread2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread"));

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/objectWithoutProperties"));

  var _defineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/defineProperty"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "prop-types"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[7], "react-native");

  var _FontAwesome = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "react-native-vector-icons/FontAwesome"));

  var _Text = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "../text/Text"));

  var _fonts = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "../config/fonts"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "../config/ViewPropTypes"));

  var _colors,
      _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\social\\SocialIcon.js";

  var log = function log() {
    console.log('please attach method to this component');
  };

  var colors = (_colors = {}, (0, _defineProperty2.default)(_colors, 'github-alt', '#000000'), (0, _defineProperty2.default)(_colors, 'google-plus-official', '#dd4b39'), (0, _defineProperty2.default)(_colors, 'reddit-alien', '#fc461e'), (0, _defineProperty2.default)(_colors, 'stack-overflow', '#f27f33'), (0, _defineProperty2.default)(_colors, "angellist", '#1c4082'), (0, _defineProperty2.default)(_colors, "codepen", '#000000'), (0, _defineProperty2.default)(_colors, "envelope", '#000000'), (0, _defineProperty2.default)(_colors, "etsy", '#f2581e'), (0, _defineProperty2.default)(_colors, "facebook", '#3b5998'), (0, _defineProperty2.default)(_colors, "foursquare", '#0072b1'), (0, _defineProperty2.default)(_colors, "github", '#000000'), (0, _defineProperty2.default)(_colors, "gitlab", '#e14329'), (0, _defineProperty2.default)(_colors, "instagram", '#517fa4'), (0, _defineProperty2.default)(_colors, "linkedin", '#007bb6'), (0, _defineProperty2.default)(_colors, "medium", '#02b875'), (0, _defineProperty2.default)(_colors, "pinterest", '#cb2027'), (0, _defineProperty2.default)(_colors, "quora", '#a82400'), (0, _defineProperty2.default)(_colors, "soundcloud", '#f50'), (0, _defineProperty2.default)(_colors, "steam", '#c6c3c1'), (0, _defineProperty2.default)(_colors, "stumbleupon", '#EB4823'), (0, _defineProperty2.default)(_colors, "tumblr", '#32506d'), (0, _defineProperty2.default)(_colors, "twitch", '#6441A5'), (0, _defineProperty2.default)(_colors, "twitter", '#00aced'), (0, _defineProperty2.default)(_colors, "vimeo", '#aad450'), (0, _defineProperty2.default)(_colors, "wordpress", '#21759b'), (0, _defineProperty2.default)(_colors, "youtube", '#bb0000'), _colors);

  var SocialIcon = function SocialIcon(props) {
    var activityIndicatorStyle = props.activityIndicatorStyle,
        button = props.button,
        component = props.component,
        disabled = props.disabled,
        fontFamily = props.fontFamily,
        fontStyle = props.fontStyle,
        fontWeight = props.fontWeight,
        iconColor = props.iconColor,
        iconSize = props.iconSize,
        iconStyle = props.iconStyle,
        light = props.light,
        loading = props.loading,
        onLongPress = props.onLongPress,
        onPress = props.onPress,
        raised = props.raised,
        small = props.small,
        style = props.style,
        title = props.title,
        type = props.type,
        underlayColor = props.underlayColor,
        attributes = (0, _objectWithoutProperties2.default)(props, ["activityIndicatorStyle", "button", "component", "disabled", "fontFamily", "fontStyle", "fontWeight", "iconColor", "iconSize", "iconStyle", "light", "loading", "onLongPress", "onPress", "raised", "small", "style", "title", "type", "underlayColor"]);
    var Component = onPress || onLongPress ? component || _reactNative.TouchableHighlight : _reactNative.View;
    var loadingElement;

    if (loading) {
      loadingElement = _react.default.createElement(_reactNative.ActivityIndicator, {
        animating: true,
        style: [styles.activityIndicatorStyle, activityIndicatorStyle],
        color: iconColor || 'white',
        size: small && 'small' || 'large',
        __source: {
          fileName: _jsxFileName,
          lineNumber: 79
        }
      });
    }

    return _react.default.createElement(Component, (0, _extends2.default)({}, attributes, {
      underlayColor: light ? 'white' : underlayColor || colors[type],
      onLongPress: disabled ? null : onLongPress || log,
      onPress: (!disabled || log) && (onPress || log),
      disabled: disabled || false,
      style: [raised && styles.raised, styles.container, button && styles.button, !button && raised && styles.icon, !button && !light && !raised && {
        width: iconSize * 2 + 4,
        height: iconSize * 2 + 4,
        borderRadius: iconSize * 2
      }, {
        backgroundColor: colors[type]
      }, light && {
        backgroundColor: 'white'
      }, style && style],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 88
      }
    }), _react.default.createElement(_reactNative.View, {
      style: styles.wrapper,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 111
      }
    }, _react.default.createElement(_FontAwesome.default, {
      style: [iconStyle && iconStyle],
      color: light ? colors[type] : iconColor,
      name: type,
      size: iconSize,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 112
      }
    }), button && title && _react.default.createElement(_Text.default, {
      style: [styles.title, light && {
        color: colors[type]
      }, fontFamily && {
        fontFamily: fontFamily
      }, fontWeight && {
        fontWeight: fontWeight
      }, fontStyle && fontStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 120
      }
    }, title), loading && loadingElement));
  };

  SocialIcon.propTypes = {
    component: _propTypes.default.func,
    type: _propTypes.default.string,
    button: _propTypes.default.bool,
    onPress: _propTypes.default.func,
    onLongPress: _propTypes.default.func,
    iconStyle: _ViewPropTypes.default.style,
    style: _ViewPropTypes.default.style,
    iconColor: _propTypes.default.string,
    underlayColor: _propTypes.default.string,
    title: _propTypes.default.string,
    raised: _propTypes.default.bool,
    disabled: _propTypes.default.bool,
    loading: _propTypes.default.bool,
    activityIndicatorStyle: _ViewPropTypes.default.style,
    small: _propTypes.default.string,
    iconSize: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
    light: _propTypes.default.bool,
    fontWeight: _propTypes.default.string,
    fontStyle: _reactNative.Text.propTypes.style,
    fontFamily: _propTypes.default.string
  };
  SocialIcon.defaultProps = {
    raised: true,
    iconColor: 'white',
    iconSize: 24,
    button: false
  };

  var styles = _reactNative.StyleSheet.create({
    container: {
      margin: 7,
      borderRadius: 30,
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center'
    },
    button: {
      paddingTop: 14,
      paddingBottom: 14
    },
    raised: (0, _objectSpread2.default)({}, _reactNative.Platform.select({
      ios: {
        shadowColor: 'rgba(0,0,0, .4)',
        shadowOffset: {
          height: 1,
          width: 1
        },
        shadowOpacity: 1,
        shadowRadius: 1
      },
      android: {
        elevation: 2
      }
    })),
    wrapper: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center'
    },
    title: (0, _objectSpread2.default)({
      color: 'white',
      marginLeft: 15
    }, _reactNative.Platform.select({
      ios: {
        fontWeight: 'bold'
      },
      android: (0, _objectSpread2.default)({}, _fonts.default.android.black)
    })),
    icon: {
      height: 52,
      width: 52
    },
    activityIndicatorStyle: {
      marginHorizontal: 10,
      height: 0
    }
  });

  var _default = SocialIcon;
  exports.default = _default;
},720,[23,148,112,120,32,161,109,116,708,640,641,714],"node_modules\\react-native-elements\\src\\social\\SocialIcon.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _objectSpread2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread"));

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/objectWithoutProperties"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "prop-types"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[6], "react-native");

  var _Text = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "../text/Text"));

  var _fonts = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "../config/fonts"));

  var _colors = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "../config/colors"));

  var _FontAwesome = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "react-native-vector-icons/FontAwesome"));

  var _getIconType = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "../helpers/getIconType"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[12], "../config/ViewPropTypes"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\checkbox\\CheckBox.js";

  var CheckBox = function CheckBox(props) {
    var component = props.component,
        checked = props.checked,
        iconRight = props.iconRight,
        title = props.title,
        center = props.center,
        right = props.right,
        containerStyle = props.containerStyle,
        textStyle = props.textStyle,
        onPress = props.onPress,
        onLongPress = props.onLongPress,
        onIconPress = props.onIconPress,
        onLongIconPress = props.onLongIconPress,
        size = props.size,
        checkedIcon = props.checkedIcon,
        uncheckedIcon = props.uncheckedIcon,
        iconType = props.iconType,
        checkedColor = props.checkedColor,
        uncheckedColor = props.uncheckedColor,
        checkedTitle = props.checkedTitle,
        fontFamily = props.fontFamily,
        attributes = (0, _objectWithoutProperties2.default)(props, ["component", "checked", "iconRight", "title", "center", "right", "containerStyle", "textStyle", "onPress", "onLongPress", "onIconPress", "onLongIconPress", "size", "checkedIcon", "uncheckedIcon", "iconType", "checkedColor", "uncheckedColor", "checkedTitle", "fontFamily"]);
    var Icon = _FontAwesome.default;

    if (iconType) {
      Icon = (0, _getIconType.default)(iconType);
    }

    var Component = component || _reactNative.TouchableOpacity;
    var iconName = uncheckedIcon;

    if (checked) {
      iconName = checkedIcon;
    }

    return _react.default.createElement(Component, (0, _extends2.default)({}, attributes, {
      onLongPress: onLongPress,
      onPress: onPress,
      style: [styles.container, containerStyle && containerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 52
      }
    }), _react.default.createElement(_reactNative.View, {
      style: [styles.wrapper, right && {
        justifyContent: 'flex-end'
      }, center && {
        justifyContent: 'center'
      }],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 58
      }
    }, !iconRight && _react.default.createElement(Icon, {
      color: checked ? checkedColor : uncheckedColor,
      name: iconName,
      size: size || 24,
      onLongPress: onLongIconPress,
      onPress: onIconPress,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 66
      }
    }), _react.default.isValidElement(title) ? title : _react.default.createElement(_Text.default, {
      style: [styles.text, textStyle && textStyle, fontFamily && {
        fontFamily: fontFamily
      }],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 76
      }
    }, checked ? checkedTitle || title : title), iconRight && _react.default.createElement(Icon, {
      color: checked ? checkedColor : uncheckedColor,
      name: iconName,
      size: size || 24,
      onLongPress: onLongIconPress,
      onPress: onIconPress,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 87
      }
    })));
  };

  CheckBox.defaultProps = {
    checked: false,
    iconRight: false,
    right: false,
    center: false,
    checkedColor: 'green',
    uncheckedColor: '#bfbfbf',
    checkedIcon: 'check-square-o',
    uncheckedIcon: 'square-o',
    size: 24
  };
  CheckBox.propTypes = {
    component: _propTypes.default.any,
    checked: _propTypes.default.bool,
    iconRight: _propTypes.default.bool,
    title: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.element]),
    center: _propTypes.default.bool,
    right: _propTypes.default.bool,
    containerStyle: _ViewPropTypes.default.style,
    textStyle: _reactNative.Text.propTypes.style,
    onPress: _propTypes.default.func,
    onLongPress: _propTypes.default.func,
    checkedIcon: _propTypes.default.string,
    uncheckedIcon: _propTypes.default.string,
    iconType: _propTypes.default.string,
    size: _propTypes.default.number,
    checkedColor: _propTypes.default.string,
    uncheckedColor: _propTypes.default.string,
    checkedTitle: _propTypes.default.string,
    onIconPress: _propTypes.default.func,
    onLongIconPress: _propTypes.default.func,
    fontFamily: _propTypes.default.string
  };

  var styles = _reactNative.StyleSheet.create({
    wrapper: {
      flexDirection: 'row',
      alignItems: 'center'
    },
    container: {
      margin: 5,
      marginLeft: 10,
      marginRight: 10,
      backgroundColor: '#fafafa',
      borderColor: '#ededed',
      borderWidth: 1,
      padding: 10,
      borderRadius: 3
    },
    text: (0, _objectSpread2.default)({
      marginLeft: 10,
      marginRight: 10,
      color: _colors.default.grey1
    }, _reactNative.Platform.select({
      ios: {
        fontWeight: 'bold'
      },
      android: (0, _objectSpread2.default)({}, _fonts.default.android.bold)
    }))
  });

  var _default = CheckBox;
  exports.default = _default;
},721,[23,148,112,120,161,109,116,640,641,639,708,693,714],"node_modules\\react-native-elements\\src\\checkbox\\CheckBox.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[2], "react-native");

  var _colors = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "../config/colors"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "../config/ViewPropTypes"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\divider\\Divider.js";
  var styles = {};

  var Divider = function Divider(_ref) {
    var style = _ref.style;
    return _react.default.createElement(_reactNative.View, {
      style: [styles.container, style && style],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 9
      }
    });
  };

  Divider.propTypes = {
    style: _ViewPropTypes.default.style
  };
  styles = _reactNative.StyleSheet.create({
    container: {
      height: 1,
      backgroundColor: _colors.default.grey5
    }
  });
  var _default = Divider;
  exports.default = _default;
},722,[23,109,116,639,714],"node_modules\\react-native-elements\\src\\divider\\Divider.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _interopRequireWildcard = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/interopRequireWildcard");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _objectSpread2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectSpread"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/objectWithoutProperties"));

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/extends"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/createClass"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/getPrototypeOf"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/inherits"));

  var _react = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[10], "react"));

  var _index = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "./../../../react-transform-hmr/lib/index.js"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[12], "prop-types"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[13], "react-native");

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[14], "../config/ViewPropTypes"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\slider\\Slider.js";
  var _components = {
    Slider: {
      displayName: "Slider"
    }
  };

  var _reactTransformHmrLibIndexJs2 = (0, _index.default)({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\slider\\Slider.js",
    components: _components,
    locals: [module],
    imports: [_react.default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var TRACK_SIZE = 4;
  var THUMB_SIZE = 20;
  var DEFAULT_ANIMATION_CONFIGS = {
    spring: {
      friction: 7,
      tension: 100
    },
    timing: {
      duration: 150,
      easing: _reactNative.Easing.inOut(_reactNative.Easing.ease),
      delay: 0
    }
  };

  function Rect(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }

  Rect.prototype.containsPoint = function (x, y) {
    return x >= this.x && y >= this.y && x <= this.x + this.width && y <= this.y + this.height;
  };

  var Slider = _wrapComponent("Slider")(function (_Component) {
    (0, _inherits2.default)(Slider, _Component);

    function Slider(props) {
      var _this;

      (0, _classCallCheck2.default)(this, Slider);
      _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Slider).call(this, props));
      _this.state = {
        containerSize: {
          width: 0,
          height: 0
        },
        trackSize: {
          width: 0,
          height: 0
        },
        thumbSize: {
          width: 0,
          height: 0
        },
        allMeasured: false,
        value: new _reactNative.Animated.Value(props.value)
      };
      return _this;
    }

    (0, _createClass2.default)(Slider, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this.panResponder = _reactNative.PanResponder.create({
          onStartShouldSetPanResponder: this.handleStartShouldSetPanResponder.bind(this),
          onMoveShouldSetPanResponder: this.handleMoveShouldSetPanResponder.bind(this),
          onPanResponderGrant: this.handlePanResponderGrant.bind(this),
          onPanResponderMove: this.handlePanResponderMove.bind(this),
          onPanResponderRelease: this.handlePanResponderEnd.bind(this),
          onPanResponderTerminationRequest: this.handlePanResponderRequestEnd.bind(this),
          onPanResponderTerminate: this.handlePanResponderEnd.bind(this)
        });
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        var newValue = nextProps.value;

        if (this.props.value !== newValue) {
          if (this.props.animateTransitions) {
            this.setCurrentValueAnimated(newValue);
          } else {
            this.setCurrentValue(newValue);
          }
        }
      }
    }, {
      key: "setCurrentValue",
      value: function setCurrentValue(value) {
        this.state.value.setValue(value);
      }
    }, {
      key: "setCurrentValueAnimated",
      value: function setCurrentValueAnimated(value) {
        var animationType = this.props.animationType;
        var animationConfig = (0, _extends2.default)({}, DEFAULT_ANIMATION_CONFIGS[animationType], this.props.animationConfig, {
          toValue: value
        });

        _reactNative.Animated[animationType](this.state.value, animationConfig).start();
      }
    }, {
      key: "handleMoveShouldSetPanResponder",
      value: function handleMoveShouldSetPanResponder() {
        return false;
      }
    }, {
      key: "handlePanResponderGrant",
      value: function handlePanResponderGrant() {
        this._previousLeft = this.getThumbLeft(this.getCurrentValue());
        this.fireChangeEvent('onSlidingStart');
      }
    }, {
      key: "handlePanResponderMove",
      value: function handlePanResponderMove(e, gestureState) {
        if (this.props.disabled) {
          return;
        }

        this.setCurrentValue(this.getValue(gestureState));
        this.fireChangeEvent('onValueChange');
      }
    }, {
      key: "handlePanResponderRequestEnd",
      value: function handlePanResponderRequestEnd() {
        return false;
      }
    }, {
      key: "handlePanResponderEnd",
      value: function handlePanResponderEnd(e, gestureState) {
        if (this.props.disabled) {
          return;
        }

        this.setCurrentValue(this.getValue(gestureState));
        this.fireChangeEvent('onSlidingComplete');
      }
    }, {
      key: "thumbHitTest",
      value: function thumbHitTest(e) {
        var nativeEvent = e.nativeEvent;
        var thumbTouchRect = this.getThumbTouchRect();
        return thumbTouchRect.containsPoint(nativeEvent.locationX, nativeEvent.locationY);
      }
    }, {
      key: "handleStartShouldSetPanResponder",
      value: function handleStartShouldSetPanResponder(e) {
        return this.thumbHitTest(e);
      }
    }, {
      key: "fireChangeEvent",
      value: function fireChangeEvent(event) {
        if (this.props[event]) {
          this.props[event](this.getCurrentValue());
        }
      }
    }, {
      key: "getTouchOverflowSize",
      value: function getTouchOverflowSize() {
        var state = this.state;
        var props = this.props;
        var size = {};

        if (state.allMeasured === true) {
          size.width = Math.max(0, props.thumbTouchSize.width - state.thumbSize.width);
          size.height = Math.max(0, props.thumbTouchSize.height - state.containerSize.height);
        }

        return size;
      }
    }, {
      key: "getTouchOverflowStyle",
      value: function getTouchOverflowStyle() {
        var _this$getTouchOverflo = this.getTouchOverflowSize(),
            width = _this$getTouchOverflo.width,
            height = _this$getTouchOverflo.height;

        var touchOverflowStyle = {};

        if (width !== undefined && height !== undefined) {
          var verticalMargin = -height / 2;
          touchOverflowStyle.marginTop = verticalMargin;
          touchOverflowStyle.marginBottom = verticalMargin;
          var horizontalMargin = -width / 2;
          touchOverflowStyle.marginLeft = horizontalMargin;
          touchOverflowStyle.marginRight = horizontalMargin;
        }

        if (this.props.debugTouchArea === true) {
          touchOverflowStyle.backgroundColor = 'orange';
          touchOverflowStyle.opacity = 0.5;
        }

        return touchOverflowStyle;
      }
    }, {
      key: "handleMeasure",
      value: function handleMeasure(name, x) {
        var _x$nativeEvent$layout = x.nativeEvent.layout,
            width = _x$nativeEvent$layout.width,
            height = _x$nativeEvent$layout.height;
        var size = {
          width: width,
          height: height
        };
        var storeName = "_" + name;
        var currentSize = this[storeName];

        if (currentSize && width === currentSize.width && height === currentSize.height) {
          return;
        }

        this[storeName] = size;

        if (this._containerSize && this._trackSize && this._thumbSize) {
          this.setState({
            containerSize: this._containerSize,
            trackSize: this._trackSize,
            thumbSize: this._thumbSize,
            allMeasured: true
          });
        }
      }
    }, {
      key: "measureContainer",
      value: function measureContainer(x) {
        this.handleMeasure('containerSize', x);
      }
    }, {
      key: "measureTrack",
      value: function measureTrack(x) {
        this.handleMeasure('trackSize', x);
      }
    }, {
      key: "measureThumb",
      value: function measureThumb(x) {
        this.handleMeasure('thumbSize', x);
      }
    }, {
      key: "getValue",
      value: function getValue(gestureState) {
        var length = this.state.containerSize.width - this.state.thumbSize.width;
        var thumbLeft = this._previousLeft + (this.props.orientation === 'vertical' ? gestureState.dy : gestureState.dx);
        var ratio = thumbLeft / length;

        if (this.props.step) {
          return Math.max(this.props.minimumValue, Math.min(this.props.maximumValue, this.props.minimumValue + Math.round(ratio * (this.props.maximumValue - this.props.minimumValue) / this.props.step) * this.props.step));
        } else {
          return Math.max(this.props.minimumValue, Math.min(this.props.maximumValue, ratio * (this.props.maximumValue - this.props.minimumValue) + this.props.minimumValue));
        }
      }
    }, {
      key: "getCurrentValue",
      value: function getCurrentValue() {
        return this.state.value.__getValue();
      }
    }, {
      key: "getRatio",
      value: function getRatio(value) {
        return (value - this.props.minimumValue) / (this.props.maximumValue - this.props.minimumValue);
      }
    }, {
      key: "getThumbLeft",
      value: function getThumbLeft(value) {
        var ratio = this.getRatio(value);
        return ratio * (this.state.containerSize.width - this.state.thumbSize.width);
      }
    }, {
      key: "getThumbTouchRect",
      value: function getThumbTouchRect() {
        var state = this.state;
        var props = this.props;
        var touchOverflowSize = this.getTouchOverflowSize();
        return new Rect(touchOverflowSize.width / 2 + this.getThumbLeft(this.getCurrentValue()) + (state.thumbSize.width - props.thumbTouchSize.width) / 2, touchOverflowSize.height / 2 + (state.containerSize.height - props.thumbTouchSize.height) / 2, props.thumbTouchSize.width, props.thumbTouchSize.height);
      }
    }, {
      key: "renderDebugThumbTouchRect",
      value: function renderDebugThumbTouchRect(thumbLeft) {
        var thumbTouchRect = this.getThumbTouchRect();
        var positionStyle = {
          left: thumbLeft,
          top: thumbTouchRect.y,
          width: thumbTouchRect.width,
          height: thumbTouchRect.height
        };
        return _react.default.createElement(_reactNative.Animated.View, {
          style: positionStyle,
          pointerEvents: "none",
          __source: {
            fileName: _jsxFileName,
            lineNumber: 335
          }
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
            minimumValue = _this$props.minimumValue,
            maximumValue = _this$props.maximumValue,
            minimumTrackTintColor = _this$props.minimumTrackTintColor,
            maximumTrackTintColor = _this$props.maximumTrackTintColor,
            thumbTintColor = _this$props.thumbTintColor,
            containerStyle = _this$props.containerStyle,
            style = _this$props.style,
            trackStyle = _this$props.trackStyle,
            thumbStyle = _this$props.thumbStyle,
            debugTouchArea = _this$props.debugTouchArea,
            orientation = _this$props.orientation,
            other = (0, _objectWithoutProperties2.default)(_this$props, ["minimumValue", "maximumValue", "minimumTrackTintColor", "maximumTrackTintColor", "thumbTintColor", "containerStyle", "style", "trackStyle", "thumbStyle", "debugTouchArea", "orientation"]);
        var _this$state = this.state,
            value = _this$state.value,
            containerSize = _this$state.containerSize,
            trackSize = _this$state.trackSize,
            thumbSize = _this$state.thumbSize,
            allMeasured = _this$state.allMeasured;
        var mainStyles = containerStyle || styles;
        var thumbLeft = value.interpolate({
          inputRange: [minimumValue, maximumValue],
          outputRange: [0, containerSize.width - thumbSize.width]
        });
        var valueVisibleStyle = {};

        if (!allMeasured) {
          valueVisibleStyle.opacity = 0;
        }

        var minimumTrackStyle = (0, _objectSpread2.default)({
          position: 'absolute',
          width: _reactNative.Animated.add(thumbLeft, thumbSize.width / 2),
          marginTop: -trackSize.height,
          backgroundColor: minimumTrackTintColor
        }, valueVisibleStyle);
        var touchOverflowStyle = this.getTouchOverflowStyle();
        return _react.default.createElement(_reactNative.View, (0, _extends2.default)({}, other, {
          style: [mainStyles.container, orientation === 'vertical' && {
            transform: [{
              rotate: '90deg'
            }]
          }, style],
          onLayout: this.measureContainer.bind(this),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 384
          }
        }), _react.default.createElement(_reactNative.View, {
          style: [{
            backgroundColor: maximumTrackTintColor
          }, mainStyles.track, trackStyle],
          onLayout: this.measureTrack.bind(this),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 393
          }
        }), _react.default.createElement(_reactNative.Animated.View, {
          style: [mainStyles.track, trackStyle, minimumTrackStyle],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 401
          }
        }), _react.default.createElement(_reactNative.Animated.View, {
          onLayout: this.measureThumb.bind(this),
          style: [{
            backgroundColor: thumbTintColor
          }, mainStyles.thumb, thumbStyle, (0, _objectSpread2.default)({
            transform: [{
              translateX: thumbLeft
            }, {
              translateY: -(trackSize.height + thumbSize.height) / 2
            }]
          }, valueVisibleStyle)],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 404
          }
        }), _react.default.createElement(_reactNative.View, (0, _extends2.default)({
          style: [styles.touchArea, touchOverflowStyle]
        }, this.panResponder.panHandlers, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 419
          }
        }), debugTouchArea === true && this.renderDebugThumbTouchRect(thumbLeft)));
      }
    }]);
    return Slider;
  }(_react.Component));

  var _default2 = Slider;
  exports.default = _default2;
  Slider.propTypes = {
    value: _propTypes.default.number,
    disabled: _propTypes.default.bool,
    minimumValue: _propTypes.default.number,
    maximumValue: _propTypes.default.number,
    step: _propTypes.default.number,
    minimumTrackTintColor: _propTypes.default.string,
    maximumTrackTintColor: _propTypes.default.string,
    thumbTintColor: _propTypes.default.string,
    thumbTouchSize: _propTypes.default.shape({
      width: _propTypes.default.number,
      height: _propTypes.default.number
    }),
    onValueChange: _propTypes.default.func,
    onSlidingStart: _propTypes.default.func,
    onSlidingComplete: _propTypes.default.func,
    style: _ViewPropTypes.default.style,
    trackStyle: _ViewPropTypes.default.style,
    thumbStyle: _ViewPropTypes.default.style,
    debugTouchArea: _propTypes.default.bool,
    animateTransitions: _propTypes.default.bool,
    animationType: _propTypes.default.oneOf(['spring', 'timing']),
    orientation: _propTypes.default.oneOf(['horizontal', 'vertical']),
    animationConfig: _propTypes.default.object,
    containerStyle: _ViewPropTypes.default.style
  };
  Slider.defaultProps = {
    value: 0,
    minimumValue: 0,
    maximumValue: 1,
    step: 0,
    minimumTrackTintColor: '#3f3f3f',
    maximumTrackTintColor: '#b3b3b3',
    thumbTintColor: 'red',
    thumbTouchSize: {
      width: 40,
      height: 40
    },
    debugTouchArea: false,
    animationType: 'timing',
    orientation: 'horizontal'
  };

  var styles = _reactNative.StyleSheet.create({
    container: {
      height: 40,
      justifyContent: 'center'
    },
    track: {
      height: TRACK_SIZE,
      borderRadius: TRACK_SIZE / 2
    },
    thumb: {
      position: 'absolute',
      width: THUMB_SIZE,
      height: THUMB_SIZE,
      borderRadius: THUMB_SIZE / 2,
      top: 22
    },
    touchArea: {
      position: 'absolute',
      backgroundColor: 'transparent',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    },
    debugThumbTouchArea: {
      position: 'absolute',
      backgroundColor: 'green',
      opacity: 0.5
    }
  });
},723,[23,637,148,120,112,24,25,26,29,30,109,280,161,116,714],"node_modules\\react-native-elements\\src\\slider\\Slider.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends"));

  var _objectSpread2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectSpread"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/objectWithoutProperties"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "prop-types"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[6], "react-native");

  var _colors = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "../config/colors"));

  var _Text = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "../text/Text"));

  var _normalizeText = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "../helpers/normalizeText"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "../config/ViewPropTypes"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\buttons\\ButtonGroup.js";

  var ButtonGroup = function ButtonGroup(props) {
    var component = props.component,
        buttons = props.buttons,
        onPress = props.onPress,
        selectedIndex = props.selectedIndex,
        containerStyle = props.containerStyle,
        innerBorderStyle = props.innerBorderStyle,
        lastBorderStyle = props.lastBorderStyle,
        buttonStyle = props.buttonStyle,
        textStyle = props.textStyle,
        selectedTextStyle = props.selectedTextStyle,
        selectedButtonStyle = props.selectedButtonStyle,
        underlayColor = props.underlayColor,
        activeOpacity = props.activeOpacity,
        onHideUnderlay = props.onHideUnderlay,
        onShowUnderlay = props.onShowUnderlay,
        setOpacityTo = props.setOpacityTo,
        containerBorderRadius = props.containerBorderRadius,
        disableSelected = props.disableSelected,
        attributes = (0, _objectWithoutProperties2.default)(props, ["component", "buttons", "onPress", "selectedIndex", "containerStyle", "innerBorderStyle", "lastBorderStyle", "buttonStyle", "textStyle", "selectedTextStyle", "selectedButtonStyle", "underlayColor", "activeOpacity", "onHideUnderlay", "onShowUnderlay", "setOpacityTo", "containerBorderRadius", "disableSelected"]);
    var Component = component || _reactNative.TouchableHighlight;
    return _react.default.createElement(_reactNative.View, (0, _extends2.default)({}, attributes, {
      style: [styles.container, containerStyle && containerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 40
      }
    }), buttons.map(function (button, i) {
      var containerRadius = !isNaN(containerBorderRadius) ? containerBorderRadius : 3;
      return _react.default.createElement(Component, {
        activeOpacity: activeOpacity,
        setOpacityTo: setOpacityTo,
        onHideUnderlay: onHideUnderlay,
        onShowUnderlay: onShowUnderlay,
        underlayColor: underlayColor || '#ffffff',
        disabled: disableSelected && i === selectedIndex ? true : false,
        onPress: onPress ? function () {
          return onPress(i);
        } : function () {},
        key: i,
        style: [styles.button, i < buttons.length - 1 && {
          borderRightWidth: i === 0 ? 0 : innerBorderStyle && innerBorderStyle.width || 1,
          borderRightColor: innerBorderStyle && innerBorderStyle.color || _colors.default.grey4
        }, i === 1 && {
          borderLeftWidth: innerBorderStyle && innerBorderStyle.width || 1,
          borderLeftColor: innerBorderStyle && innerBorderStyle.color || _colors.default.grey4
        }, i === buttons.length - 1 && (0, _objectSpread2.default)({}, lastBorderStyle, {
          borderTopRightRadius: containerRadius,
          borderBottomRightRadius: containerRadius
        }), i === 0 && {
          borderTopLeftRadius: containerRadius,
          borderBottomLeftRadius: containerRadius
        }, selectedIndex === i && {
          backgroundColor: 'white'
        }],
        __source: {
          fileName: _jsxFileName,
          lineNumber: 49
        }
      }, _react.default.createElement(_reactNative.View, {
        style: [styles.textContainer, buttonStyle && buttonStyle, selectedIndex === i && selectedButtonStyle && selectedButtonStyle],
        __source: {
          fileName: _jsxFileName,
          lineNumber: 90
        }
      }, button.element ? _react.default.createElement(button.element, {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 100
        }
      }) : _react.default.createElement(_Text.default, {
        style: [styles.buttonText, textStyle && textStyle, selectedIndex === i && {
          color: _colors.default.grey1
        }, selectedIndex === i && selectedTextStyle],
        __source: {
          fileName: _jsxFileName,
          lineNumber: 102
        }
      }, button)));
    }));
  };

  var styles = _reactNative.StyleSheet.create({
    button: {
      flex: 1
    },
    textContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center'
    },
    container: {
      marginLeft: 10,
      marginRight: 10,
      marginBottom: 5,
      marginTop: 5,
      borderColor: '#e3e3e3',
      borderWidth: 1,
      flexDirection: 'row',
      borderRadius: 3,
      overflow: 'hidden',
      backgroundColor: '#f5f5f5',
      height: 40
    },
    buttonText: (0, _objectSpread2.default)({
      fontSize: (0, _normalizeText.default)(13),
      color: _colors.default.grey2
    }, _reactNative.Platform.select({
      ios: {
        fontWeight: '500'
      }
    }))
  });

  ButtonGroup.propTypes = {
    button: _propTypes.default.object,
    component: _propTypes.default.any,
    onPress: _propTypes.default.func,
    buttons: _propTypes.default.array,
    containerStyle: _ViewPropTypes.default.style,
    textStyle: _reactNative.Text.propTypes.style,
    selectedTextStyle: _reactNative.Text.propTypes.style,
    selectedButtonStyle: _ViewPropTypes.default.style,
    underlayColor: _propTypes.default.string,
    selectedIndex: _propTypes.default.number,
    activeOpacity: _propTypes.default.number,
    onHideUnderlay: _propTypes.default.func,
    onShowUnderlay: _propTypes.default.func,
    setOpacityTo: _propTypes.default.any,
    innerBorderStyle: _propTypes.default.shape({
      color: _propTypes.default.string,
      width: _propTypes.default.number
    }),
    lastBorderStyle: _propTypes.default.oneOfType([_ViewPropTypes.default.style, _reactNative.Text.propTypes.style]),
    buttonStyle: _ViewPropTypes.default.style,
    containerBorderRadius: _propTypes.default.number,
    disableSelected: _propTypes.default.bool
  };
  var _default = ButtonGroup;
  exports.default = _default;
},724,[23,112,148,120,161,109,116,639,640,642,714],"node_modules\\react-native-elements\\src\\buttons\\ButtonGroup.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _objectSpread2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread"));

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/objectWithoutProperties"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "prop-types"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[6], "react-native");

  var _fonts = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "../config/fonts"));

  var _colors = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "../config/colors"));

  var _Text = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "../text/Text"));

  var _Divider = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "../divider/Divider"));

  var _normalizeText = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "../helpers/normalizeText"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[12], "../config/ViewPropTypes"));

  var _BackgroundImage = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[13], "../config/BackgroundImage"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\card\\Card.js";

  var Card = function Card(props) {
    var children = props.children,
        flexDirection = props.flexDirection,
        containerStyle = props.containerStyle,
        wrapperStyle = props.wrapperStyle,
        imageWrapperStyle = props.imageWrapperStyle,
        title = props.title,
        titleStyle = props.titleStyle,
        titleNumberOfLines = props.titleNumberOfLines,
        featuredTitle = props.featuredTitle,
        featuredTitleStyle = props.featuredTitleStyle,
        featuredSubtitle = props.featuredSubtitle,
        featuredSubtitleStyle = props.featuredSubtitleStyle,
        dividerStyle = props.dividerStyle,
        image = props.image,
        imageStyle = props.imageStyle,
        fontFamily = props.fontFamily,
        imageProps = props.imageProps,
        attributes = (0, _objectWithoutProperties2.default)(props, ["children", "flexDirection", "containerStyle", "wrapperStyle", "imageWrapperStyle", "title", "titleStyle", "titleNumberOfLines", "featuredTitle", "featuredTitleStyle", "featuredSubtitle", "featuredSubtitleStyle", "dividerStyle", "image", "imageStyle", "fontFamily", "imageProps"]);
    return _react.default.createElement(_reactNative.View, (0, _extends2.default)({}, attributes, {
      style: [styles.container, image && {
        padding: 0
      }, containerStyle && containerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 41
      }
    }), _react.default.createElement(_reactNative.View, {
      style: [styles.wrapper, wrapperStyle && wrapperStyle, flexDirection && {
        flexDirection: flexDirection
      }],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 49
      }
    }, title === '' || title && title.length > 0 && _react.default.createElement(_reactNative.View, {
      __source: {
        fileName: _jsxFileName,
        lineNumber: 59
      }
    }, _react.default.createElement(_Text.default, {
      style: [styles.cardTitle, image && styles.imageCardTitle, titleStyle && titleStyle, fontFamily && {
        fontFamily: fontFamily
      }],
      numberOfLines: titleNumberOfLines,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 60
      }
    }, title), !image && _react.default.createElement(_Divider.default, {
      style: [styles.divider, dividerStyle && dividerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 72
      }
    })), image && _react.default.createElement(_reactNative.View, {
      style: imageWrapperStyle && imageWrapperStyle,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 77
      }
    }, _react.default.createElement(_BackgroundImage.default, (0, _extends2.default)({
      resizeMode: "cover",
      style: [{
        width: null,
        height: 150
      }, imageStyle && imageStyle],
      source: image
    }, imageProps, {
      __source: {
        fileName: _jsxFileName,
        lineNumber: 78
      }
    }), (featuredTitle || featuredSubtitle) && _react.default.createElement(_reactNative.View, {
      style: styles.overlayContainer,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 85
      }
    }, featuredTitle && _react.default.createElement(_Text.default, {
      style: [styles.featuredTitle, featuredTitleStyle && featuredTitleStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 87
      }
    }, featuredTitle), featuredSubtitle && _react.default.createElement(_Text.default, {
      style: [styles.featuredSubtitle, featuredSubtitleStyle && featuredSubtitleStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 96
      }
    }, featuredSubtitle))), _react.default.createElement(_reactNative.View, {
      style: [{
        padding: 10
      }, wrapperStyle && wrapperStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 106
      }
    }, children)), !image && children));
  };

  Card.propTypes = {
    children: _propTypes.default.any,
    flexDirection: _propTypes.default.string,
    containerStyle: _ViewPropTypes.default.style,
    wrapperStyle: _ViewPropTypes.default.style,
    overlayStyle: _ViewPropTypes.default.style,
    title: _propTypes.default.string,
    titleStyle: _reactNative.Text.propTypes.style,
    featuredTitle: _propTypes.default.string,
    featuredTitleStyle: _Text.default.propTypes.style,
    featuredSubtitle: _propTypes.default.string,
    featuredSubtitleStyle: _Text.default.propTypes.style,
    dividerStyle: _ViewPropTypes.default.style,
    image: _reactNative.Image.propTypes.source,
    imageStyle: _ViewPropTypes.default.style,
    imageWrapperStyle: _ViewPropTypes.default.style,
    fontFamily: _propTypes.default.string,
    imageProps: _propTypes.default.object,
    titleNumberOfLines: _propTypes.default.number
  };

  var styles = _reactNative.StyleSheet.create({
    container: (0, _objectSpread2.default)({
      backgroundColor: 'white',
      borderColor: _colors.default.grey5,
      borderWidth: 1,
      padding: 15,
      margin: 15,
      marginBottom: 0
    }, _reactNative.Platform.select({
      ios: {
        shadowColor: 'rgba(0,0,0, .2)',
        shadowOffset: {
          height: 0,
          width: 0
        },
        shadowOpacity: 1,
        shadowRadius: 1
      },
      android: {
        elevation: 1
      }
    })),
    featuredTitle: (0, _objectSpread2.default)({
      fontSize: (0, _normalizeText.default)(18),
      marginBottom: 8,
      color: 'white'
    }, _reactNative.Platform.select({
      ios: {
        fontWeight: '800'
      },
      android: (0, _objectSpread2.default)({}, _fonts.default.android.black)
    })),
    featuredSubtitle: (0, _objectSpread2.default)({
      fontSize: (0, _normalizeText.default)(13),
      marginBottom: 8,
      color: 'white'
    }, _reactNative.Platform.select({
      ios: {
        fontWeight: '400'
      },
      android: (0, _objectSpread2.default)({}, _fonts.default.android.black)
    })),
    wrapper: {
      backgroundColor: 'transparent'
    },
    divider: {
      marginBottom: 15
    },
    cardTitle: (0, _objectSpread2.default)({
      fontSize: (0, _normalizeText.default)(14)
    }, _reactNative.Platform.select({
      ios: {
        fontWeight: 'bold'
      },
      android: (0, _objectSpread2.default)({}, _fonts.default.android.black)
    }), {
      textAlign: 'center',
      marginBottom: 15,
      color: _colors.default.grey1
    }),
    imageCardTitle: {
      marginTop: 15
    },
    overlayContainer: {
      flex: 1,
      alignItems: 'center',
      backgroundColor: 'rgba(0, 0, 0, 0.2)',
      alignSelf: 'stretch',
      justifyContent: 'center',
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    }
  });

  var _default = Card;
  exports.default = _default;
},725,[23,148,112,120,161,109,116,641,639,640,722,642,714,726],"node_modules\\react-native-elements\\src\\card\\Card.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _reactNative = _$$_REQUIRE(_dependencyMap[0], "react-native");

  var BackgroundImage = _reactNative.ImageBackground || _reactNative.Image;
  var _default = BackgroundImage;
  exports.default = _default;
},726,[116],"node_modules\\react-native-elements\\src\\config\\BackgroundImage.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutProperties"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "prop-types"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[5], "react-native");

  var _Text = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "../text/Text"));

  var _Icon = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "../icons/Icon"));

  var _FeaturedTile = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "./FeaturedTile"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "../config/ViewPropTypes"));

  var _BackgroundImage = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "../config/BackgroundImage"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\tile\\Tile.js";

  var Tile = function Tile(props) {
    var featured = props.featured,
        imageSrc = props.imageSrc,
        icon = props.icon,
        title = props.title,
        children = props.children,
        caption = props.caption,
        titleStyle = props.titleStyle,
        onPress = props.onPress,
        activeOpacity = props.activeOpacity,
        overlayContainerStyle = props.overlayContainerStyle,
        captionStyle = props.captionStyle,
        iconContainerStyle = props.iconContainerStyle,
        imageContainerStyle = props.imageContainerStyle,
        containerStyle = props.containerStyle,
        contentContainerStyle = props.contentContainerStyle,
        titleNumberOfLines = props.titleNumberOfLines,
        attributes = (0, _objectWithoutProperties2.default)(props, ["featured", "imageSrc", "icon", "title", "children", "caption", "titleStyle", "onPress", "activeOpacity", "overlayContainerStyle", "captionStyle", "iconContainerStyle", "imageContainerStyle", "containerStyle", "contentContainerStyle", "titleNumberOfLines"]);
    var width = props.width,
        height = props.height;

    if (!width) {
      width = _reactNative.Dimensions.get('window').width;
    }

    if (!height) {
      height = width * 0.8;
    }

    var styles = _reactNative.StyleSheet.create({
      container: {
        width: width,
        height: height
      },
      imageContainer: {
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: '#ffffff',
        flex: 2
      },
      text: {
        backgroundColor: 'rgba(0,0,0,0)',
        marginBottom: 5
      },
      contentContainer: {
        paddingTop: 15,
        paddingBottom: 5,
        paddingLeft: 15,
        paddingRight: 15
      },
      iconContainer: {
        justifyContent: 'center',
        alignItems: 'center',
        alignSelf: 'center'
      }
    });

    if (featured) {
      var featuredProps = {
        title: title,
        icon: icon,
        caption: caption,
        imageSrc: imageSrc,
        onPress: onPress,
        activeOpacity: activeOpacity,
        containerStyle: containerStyle,
        imageContainerStyle: imageContainerStyle,
        overlayContainerStyle: overlayContainerStyle,
        titleStyle: titleStyle,
        captionStyle: captionStyle,
        width: width,
        height: height
      };
      return _react.default.createElement(_FeaturedTile.default, (0, _extends2.default)({}, featuredProps, {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 92
        }
      }));
    }

    return _react.default.createElement(_reactNative.TouchableOpacity, (0, _extends2.default)({}, attributes, {
      onPress: onPress,
      style: [styles.container, containerStyle && containerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 96
      }
    }), _react.default.createElement(_BackgroundImage.default, {
      source: imageSrc,
      style: [styles.imageContainer, imageContainerStyle && imageContainerStyle],
      resizeMode: "cover",
      __source: {
        fileName: _jsxFileName,
        lineNumber: 101
      }
    }, _react.default.createElement(_reactNative.View, {
      style: [styles.iconContainer, iconContainerStyle && iconContainerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 109
      }
    }, icon && _react.default.createElement(_Icon.default, (0, _extends2.default)({}, icon, {
      __source: {
        fileName: _jsxFileName,
        lineNumber: 115
      }
    })))), _react.default.createElement(_reactNative.View, {
      style: [styles.contentContainer, contentContainerStyle && contentContainerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 118
      }
    }, _react.default.createElement(_Text.default, {
      h4: true,
      style: [styles.text, titleStyle && titleStyle],
      numberOfLines: titleNumberOfLines,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 124
      }
    }, title), children));
  };

  Tile.propTypes = {
    title: _propTypes.default.string,
    icon: _propTypes.default.object,
    caption: _propTypes.default.string,
    imageSrc: _reactNative.Image.propTypes.source,
    onPress: _propTypes.default.func,
    activeOpacity: _propTypes.default.number,
    containerStyle: _ViewPropTypes.default.style,
    imageContainerStyle: _ViewPropTypes.default.style,
    iconContainerStyle: _ViewPropTypes.default.style,
    overlayContainerStyle: _ViewPropTypes.default.style,
    titleStyle: _reactNative.Text.propTypes.style,
    captionStyle: _reactNative.Text.propTypes.style,
    width: _propTypes.default.number,
    height: _propTypes.default.number,
    featured: _propTypes.default.bool,
    children: _propTypes.default.any,
    contentContainerStyle: _ViewPropTypes.default.style,
    titleNumberOfLines: _propTypes.default.number
  };
  var _default = Tile;
  exports.default = _default;
},727,[23,112,120,161,109,116,640,715,728,714,726],"node_modules\\react-native-elements\\src\\tile\\Tile.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutProperties"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "prop-types"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[5], "react-native");

  var _Text = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "../text/Text"));

  var _Icon = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "../icons/Icon"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "../config/ViewPropTypes"));

  var _BackgroundImage = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "../config/BackgroundImage"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\tile\\FeaturedTile.js";

  var FeaturedTile = function FeaturedTile(props) {
    var title = props.title,
        icon = props.icon,
        caption = props.caption,
        imageSrc = props.imageSrc,
        containerStyle = props.containerStyle,
        imageContainerStyle = props.imageContainerStyle,
        overlayContainerStyle = props.overlayContainerStyle,
        iconContainerStyle = props.iconContainerStyle,
        titleStyle = props.titleStyle,
        captionStyle = props.captionStyle,
        attributes = (0, _objectWithoutProperties2.default)(props, ["title", "icon", "caption", "imageSrc", "containerStyle", "imageContainerStyle", "overlayContainerStyle", "iconContainerStyle", "titleStyle", "captionStyle"]);
    var width = props.width,
        height = props.height;

    if (!width) {
      width = _reactNative.Dimensions.get('window').width;
    }

    if (!height) {
      height = width * 0.8;
    }

    var styles = _reactNative.StyleSheet.create({
      container: {
        width: width,
        height: height
      },
      imageContainer: {
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: '#ffffff',
        width: width,
        height: height
      },
      overlayContainer: {
        flex: 1,
        alignItems: 'center',
        backgroundColor: 'rgba(0,0,0,0.2)',
        alignSelf: 'stretch',
        justifyContent: 'center',
        paddingLeft: 25,
        paddingRight: 25,
        paddingTop: 45,
        paddingBottom: 40,
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      text: {
        color: '#ffffff',
        backgroundColor: 'rgba(0,0,0,0)',
        marginBottom: 15,
        textAlign: 'center'
      },
      iconContainer: {
        justifyContent: 'center',
        alignItems: 'center',
        alignSelf: 'center'
      }
    });

    return _react.default.createElement(_reactNative.TouchableOpacity, (0, _extends2.default)({}, attributes, {
      style: [styles.container, containerStyle && containerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 82
      }
    }), _react.default.createElement(_BackgroundImage.default, {
      source: imageSrc,
      style: [styles.imageContainer, imageContainerStyle && imageContainerStyle],
      resizeMode: "cover",
      __source: {
        fileName: _jsxFileName,
        lineNumber: 86
      }
    }, _react.default.createElement(_reactNative.View, {
      style: [styles.overlayContainer, overlayContainerStyle && overlayContainerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 94
      }
    }, _react.default.createElement(_reactNative.View, {
      style: [styles.iconContainer, iconContainerStyle && iconContainerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 100
      }
    }, icon && _react.default.createElement(_Icon.default, (0, _extends2.default)({}, icon, {
      __source: {
        fileName: _jsxFileName,
        lineNumber: 106
      }
    }))), _react.default.createElement(_Text.default, {
      h4: true,
      style: [styles.text, titleStyle && titleStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 108
      }
    }, title), _react.default.createElement(_Text.default, {
      style: [styles.text, captionStyle && captionStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 111
      }
    }, caption))));
  };

  FeaturedTile.propTypes = {
    title: _propTypes.default.string,
    icon: _propTypes.default.object,
    caption: _propTypes.default.string,
    imageSrc: _reactNative.Image.propTypes.source,
    onPress: _propTypes.default.func,
    containerStyle: _ViewPropTypes.default.style,
    iconContainerStyle: _ViewPropTypes.default.style,
    imageContainerStyle: _ViewPropTypes.default.style,
    overlayContainerStyle: _ViewPropTypes.default.style,
    titleStyle: _reactNative.Text.propTypes.style,
    captionStyle: _reactNative.Text.propTypes.style,
    width: _propTypes.default.number,
    height: _propTypes.default.number
  };
  var _default = FeaturedTile;
  exports.default = _default;
},728,[23,112,120,161,109,116,640,715,714,726],"node_modules\\react-native-elements\\src\\tile\\FeaturedTile.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _interopRequireWildcard = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/interopRequireWildcard");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/extends"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/createClass"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/getPrototypeOf"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/inherits"));

  var _defineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/defineProperty"));

  var _react = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[9], "react"));

  var _index = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "./../../../react-transform-hmr/lib/index.js"));

  var _lodash = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "lodash.times"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[12], "prop-types"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[13], "react-native");

  var _Text = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[14], "../text/Text"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[15], "../config/ViewPropTypes"));

  var _class,
      _temp,
      _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\rating\\Rating.js";

  var _components = {
    Rating: {
      displayName: "Rating"
    }
  };

  var _reactTransformHmrLibIndexJs2 = (0, _index.default)({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\rating\\Rating.js",
    components: _components,
    locals: [module],
    imports: [_react.default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var STAR_IMAGE = _$$_REQUIRE(_dependencyMap[16], "./images/star.png");

  var HEART_IMAGE = _$$_REQUIRE(_dependencyMap[17], "./images/heart.png");

  var ROCKET_IMAGE = _$$_REQUIRE(_dependencyMap[18], "./images/rocket.png");

  var BELL_IMAGE = _$$_REQUIRE(_dependencyMap[19], "./images/bell.png");

  var STAR_WIDTH = 60;
  var TYPES = {
    star: {
      source: STAR_IMAGE,
      color: '#f1c40f',
      backgroundColor: 'white'
    },
    heart: {
      source: HEART_IMAGE,
      color: '#e74c3c',
      backgroundColor: 'white'
    },
    rocket: {
      source: ROCKET_IMAGE,
      color: '#2ecc71',
      backgroundColor: 'white'
    },
    bell: {
      source: BELL_IMAGE,
      color: '#f39c12',
      backgroundColor: 'white'
    }
  };

  var Rating = _wrapComponent("Rating")((_temp = _class = function (_Component) {
    (0, _inherits2.default)(Rating, _Component);

    function Rating(props) {
      var _this;

      (0, _classCallCheck2.default)(this, Rating);
      _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Rating).call(this, props));
      var _this$props = _this.props,
          onFinishRating = _this$props.onFinishRating,
          fractions = _this$props.fractions;
      var position = new _reactNative.Animated.ValueXY();

      var panResponder = _reactNative.PanResponder.create({
        onStartShouldSetPanResponder: function onStartShouldSetPanResponder() {
          return true;
        },
        onPanResponderMove: function onPanResponderMove(event, gesture) {
          var newPosition = new _reactNative.Animated.ValueXY();
          newPosition.setValue({
            x: gesture.dx,
            y: 0
          });

          _this.setState({
            position: newPosition,
            value: gesture.dx
          });
        },
        onPanResponderRelease: function onPanResponderRelease() {
          var rating = _this.getCurrentRating();

          if (!fractions) {
            _this.setCurrentRating(rating);
          }

          onFinishRating(rating);
        }
      });

      _this.state = {
        panResponder: panResponder,
        position: position
      };
      return _this;
    }

    (0, _createClass2.default)(Rating, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.setCurrentRating(this.props.startingValue);
      }
    }, {
      key: "getPrimaryViewStyle",
      value: function getPrimaryViewStyle() {
        var position = this.state.position;
        var _this$props2 = this.props,
            imageSize = _this$props2.imageSize,
            ratingCount = _this$props2.ratingCount,
            type = _this$props2.type;
        var color = TYPES[type].color;
        var width = position.x.interpolate({
          inputRange: [-ratingCount * (imageSize / 2), 0, ratingCount * (imageSize / 2)],
          outputRange: [0, ratingCount * imageSize / 2, ratingCount * imageSize],
          extrapolate: 'clamp'
        }, {
          useNativeDriver: true
        });
        return {
          backgroundColor: color,
          width: width,
          height: width ? imageSize : 0
        };
      }
    }, {
      key: "getSecondaryViewStyle",
      value: function getSecondaryViewStyle() {
        var position = this.state.position;
        var _this$props3 = this.props,
            imageSize = _this$props3.imageSize,
            ratingCount = _this$props3.ratingCount,
            type = _this$props3.type;
        var backgroundColor = TYPES[type].backgroundColor;
        var width = position.x.interpolate({
          inputRange: [-ratingCount * (imageSize / 2), 0, ratingCount * (imageSize / 2)],
          outputRange: [ratingCount * imageSize, ratingCount * imageSize / 2, 0],
          extrapolate: 'clamp'
        }, {
          useNativeDriver: true
        });
        return {
          backgroundColor: backgroundColor,
          width: width,
          height: width ? imageSize : 0
        };
      }
    }, {
      key: "renderRatings",
      value: function renderRatings() {
        var _this$props4 = this.props,
            imageSize = _this$props4.imageSize,
            ratingCount = _this$props4.ratingCount,
            type = _this$props4.type;
        var source = TYPES[type].source;
        return (0, _lodash.default)(ratingCount, function (index) {
          return _react.default.createElement(_reactNative.View, {
            key: index,
            style: styles.starContainer,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 148
            }
          }, _react.default.createElement(_reactNative.Image, {
            source: source,
            style: {
              width: imageSize,
              height: imageSize
            },
            __source: {
              fileName: _jsxFileName,
              lineNumber: 149
            }
          }));
        });
      }
    }, {
      key: "getCurrentRating",
      value: function getCurrentRating() {
        var value = this.state.value;
        var _this$props5 = this.props,
            fractions = _this$props5.fractions,
            imageSize = _this$props5.imageSize,
            ratingCount = _this$props5.ratingCount;
        var startingValue = ratingCount / 2;
        var currentRating = 0;

        if (value > ratingCount * imageSize / 2) {
          currentRating = ratingCount;
        } else if (value < -ratingCount * imageSize / 2) {
          currentRating = 0;
        } else if (value < imageSize || value > imageSize) {
          currentRating = startingValue + value / imageSize;
          currentRating = !fractions ? Math.ceil(currentRating) : +currentRating.toFixed(fractions);
        } else {
          currentRating = !fractions ? Math.ceil(startingValue) : +startingValue.toFixed(fractions);
        }

        return currentRating;
      }
    }, {
      key: "setCurrentRating",
      value: function setCurrentRating(rating) {
        var _this$props6 = this.props,
            imageSize = _this$props6.imageSize,
            ratingCount = _this$props6.ratingCount;
        var initialRating = ratingCount / 2;
        var value = null;

        if (rating > ratingCount) {
          value = ratingCount * imageSize / 2;
        } else if (rating < 0) {
          value = -ratingCount * imageSize / 2;
        } else if (rating < ratingCount / 2 || rating > ratingCount / 2) {
          value = (rating - initialRating) * imageSize;
        } else {
          value = 0;
        }

        var newPosition = new _reactNative.Animated.ValueXY();
        newPosition.setValue({
          x: value,
          y: 0
        });
        this.setState({
          position: newPosition,
          value: value
        });
      }
    }, {
      key: "displayCurrentRating",
      value: function displayCurrentRating() {
        var _this$props7 = this.props,
            ratingCount = _this$props7.ratingCount,
            type = _this$props7.type,
            readonly = _this$props7.readonly;
        var color = TYPES[type].color;
        return _react.default.createElement(_reactNative.View, {
          style: styles.showRatingView,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 209
          }
        }, _react.default.createElement(_reactNative.View, {
          style: styles.ratingView,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 210
          }
        }, _react.default.createElement(_Text.default, {
          style: styles.ratingText,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 211
          }
        }, "Rating: "), _react.default.createElement(_Text.default, {
          style: [styles.currentRatingText, {
            color: color
          }],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 212
          }
        }, this.getCurrentRating()), _react.default.createElement(_Text.default, {
          style: styles.maxRatingText,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 215
          }
        }, "/", ratingCount)), _react.default.createElement(_reactNative.View, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 219
          }
        }, readonly && _react.default.createElement(_Text.default, {
          style: styles.readonlyLabel,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 220
          }
        }, "(readonly)")));
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props8 = this.props,
            readonly = _this$props8.readonly,
            type = _this$props8.type,
            ratingImage = _this$props8.ratingImage,
            ratingColor = _this$props8.ratingColor,
            ratingBackgroundColor = _this$props8.ratingBackgroundColor,
            style = _this$props8.style,
            showRating = _this$props8.showRating;

        if (type === 'custom') {
          var custom = {
            source: ratingImage,
            color: ratingColor,
            backgroundColor: ratingBackgroundColor
          };
          TYPES.custom = custom;
        }

        return _react.default.createElement(_reactNative.View, {
          pointerEvents: readonly ? 'none' : 'auto',
          style: style,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 247
          }
        }, showRating && this.displayCurrentRating(), _react.default.createElement(_reactNative.View, (0, _extends2.default)({
          style: styles.starsWrapper
        }, this.state.panResponder.panHandlers, {
          __source: {
            fileName: _jsxFileName,
            lineNumber: 249
          }
        }), _react.default.createElement(_reactNative.View, {
          style: styles.starsInsideWrapper,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 253
          }
        }, _react.default.createElement(_reactNative.Animated.View, {
          style: this.getPrimaryViewStyle(),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 254
          }
        }), _react.default.createElement(_reactNative.Animated.View, {
          style: this.getSecondaryViewStyle(),
          __source: {
            fileName: _jsxFileName,
            lineNumber: 255
          }
        })), this.renderRatings()));
      }
    }]);
    return Rating;
  }(_react.Component), (0, _defineProperty2.default)(_class, "defaultProps", {
    type: 'star',
    ratingImage: _$$_REQUIRE(_dependencyMap[16], "./images/star.png"),
    ratingColor: '#f1c40f',
    ratingBackgroundColor: 'white',
    ratingCount: 5,
    imageSize: STAR_WIDTH,
    onFinishRating: function onFinishRating() {
      return console.log('Attach a function here.');
    }
  }), _temp));

  var _default2 = Rating;
  exports.default = _default2;

  var styles = _reactNative.StyleSheet.create({
    starsWrapper: {
      flexDirection: 'row'
    },
    starsInsideWrapper: {
      position: 'absolute',
      top: 0,
      left: 0,
      flexDirection: 'row'
    },
    showRatingView: {
      flexDirection: 'column',
      justifyContent: 'center',
      alignItems: 'center',
      paddingBottom: 5
    },
    ratingView: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      paddingBottom: 5
    },
    ratingText: {
      fontSize: 15,
      textAlign: 'center',
      fontFamily: _reactNative.Platform.OS === 'ios' ? 'Trebuchet MS' : null,
      color: '#34495e'
    },
    readonlyLabel: {
      justifyContent: 'center',
      alignItems: 'center',
      fontSize: 12,
      textAlign: 'center',
      fontFamily: _reactNative.Platform.OS === 'ios' ? 'Trebuchet MS' : null,
      color: '#34495a'
    },
    currentRatingText: {
      fontSize: 30,
      textAlign: 'center',
      fontFamily: _reactNative.Platform.OS === 'ios' ? 'Trebuchet MS' : null
    },
    maxRatingText: {
      fontSize: 18,
      textAlign: 'center',
      fontFamily: _reactNative.Platform.OS === 'ios' ? 'Trebuchet MS' : null,
      color: '#34495e'
    }
  });

  var fractionsType = function fractionsType(props, propName, componentName) {
    if (props[propName]) {
      var value = props[propName];

      if (typeof value === 'number') {
        return value >= 0 && value <= 20 ? null : new Error("`" + propName + "` in `" + componentName + "` must be between 0 and 20");
      }

      return new Error("`" + propName + "` in `" + componentName + "` must be a number");
    }
  };

  Rating.propTypes = {
    type: _propTypes.default.string,
    ratingImage: _reactNative.Image.propTypes.source,
    ratingColor: _propTypes.default.string,
    ratingBackgroundColor: _propTypes.default.string,
    ratingCount: _propTypes.default.number,
    imageSize: _propTypes.default.number,
    onFinishRating: _propTypes.default.func,
    showRating: _propTypes.default.bool,
    style: _ViewPropTypes.default.style,
    readonly: _propTypes.default.bool,
    startingValue: _propTypes.default.number,
    fractions: fractionsType
  };
},729,[23,637,112,24,25,26,29,30,32,109,280,730,161,116,640,714,731,732,733,734],"node_modules\\react-native-elements\\src\\rating\\Rating.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;
  var MAX_ARRAY_LENGTH = 4294967295;
  var symbolTag = '[object Symbol]';
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;

  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }

  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var nativeMin = Math.min;

  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }

  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }

    value = toNumber(value);

    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }

    return value === value ? value : 0;
  }

  function toInteger(value) {
    var result = toFinite(value),
        remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }

  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol(value)) {
      return NAN;
    }

    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }

  function identity(value) {
    return value;
  }

  function times(n, iteratee) {
    n = toInteger(n);

    if (n < 1 || n > MAX_SAFE_INTEGER) {
      return [];
    }

    var index = MAX_ARRAY_LENGTH,
        length = nativeMin(n, MAX_ARRAY_LENGTH);
    iteratee = typeof iteratee == 'function' ? iteratee : identity;
    n -= MAX_ARRAY_LENGTH;
    var result = baseTimes(length, iteratee);

    while (++index < n) {
      iteratee(index);
    }

    return result;
  }

  module.exports = times;
},730,[],"node_modules\\lodash.times\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0], "react-native/Libraries/Image/AssetRegistry").registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/react-native-elements/src/rating/images",
    "width": 50,
    "height": 50,
    "scales": [1],
    "hash": "004c2bbb035d8d06bb830efc4673c886",
    "name": "star",
    "type": "png"
  });
},731,[275],"node_modules\\react-native-elements\\src\\rating\\images\\star.png");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0], "react-native/Libraries/Image/AssetRegistry").registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/react-native-elements/src/rating/images",
    "width": 50,
    "height": 50,
    "scales": [1],
    "hash": "2327736b3ea09c41abfb69be1221f430",
    "name": "heart",
    "type": "png"
  });
},732,[275],"node_modules\\react-native-elements\\src\\rating\\images\\heart.png");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0], "react-native/Libraries/Image/AssetRegistry").registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/react-native-elements/src/rating/images",
    "width": 50,
    "height": 50,
    "scales": [1],
    "hash": "51671417ef20e0bbc32f0a2bc6edfa95",
    "name": "rocket",
    "type": "png"
  });
},733,[275],"node_modules\\react-native-elements\\src\\rating\\images\\rocket.png");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0], "react-native/Libraries/Image/AssetRegistry").registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/react-native-elements/src/rating/images",
    "width": 50,
    "height": 50,
    "scales": [1],
    "hash": "a7b9dc9de5f8f1fb1afbef917619a5ac",
    "name": "bell",
    "type": "png"
  });
},734,[275],"node_modules\\react-native-elements\\src\\rating\\images\\bell.png");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutProperties"));

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/extends"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "react"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "prop-types"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[5], "react-native");

  var _lodash = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "lodash.isempty"));

  var _DummyNavButton = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "./DummyNavButton"));

  var _NavButton = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "./NavButton"));

  var _Title = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "./Title"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "../config/ViewPropTypes"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\header\\Header.js";

  function generateChild(value, type) {
    if (_react.default.isValidElement(value)) {
      return _react.default.createElement(_reactNative.View, {
        key: type,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 12
        }
      }, value);
    } else if (typeof value === 'object' && !(0, _lodash.default)(value)) {
      return type === 'center' ? _react.default.createElement(_Title.default, (0, _extends2.default)({}, value, {
        key: type,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 15
        }
      })) : _react.default.createElement(_NavButton.default, (0, _extends2.default)({}, value, {
        key: type,
        __source: {
          fileName: _jsxFileName,
          lineNumber: 17
        }
      }));
    }

    return type === 'center' ? null : _react.default.createElement(_DummyNavButton.default, {
      key: type,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 20
      }
    });
  }

  function populateChildren(propChildren) {
    var childrenArray = [];
    var leftComponent = generateChild(propChildren.leftComponent, 'left');
    var centerComponent = generateChild(propChildren.centerComponent, 'center');
    var rightComponent = generateChild(propChildren.rightComponent, 'right');
    childrenArray.push(leftComponent, centerComponent, rightComponent);
    return childrenArray;
  }

  var Header = function Header(props) {
    var children = props.children,
        statusBarProps = props.statusBarProps,
        leftComponent = props.leftComponent,
        centerComponent = props.centerComponent,
        rightComponent = props.rightComponent,
        backgroundColor = props.backgroundColor,
        outerContainerStyles = props.outerContainerStyles,
        innerContainerStyles = props.innerContainerStyles,
        attributes = (0, _objectWithoutProperties2.default)(props, ["children", "statusBarProps", "leftComponent", "centerComponent", "rightComponent", "backgroundColor", "outerContainerStyles", "innerContainerStyles"]);
    var propChildren = [];

    if (leftComponent || centerComponent || rightComponent) {
      propChildren = populateChildren({
        leftComponent: leftComponent,
        centerComponent: centerComponent,
        rightComponent: rightComponent
      });
    }

    return _react.default.createElement(_reactNative.View, (0, _extends2.default)({}, attributes, {
      style: [styles.outerContainer, backgroundColor && {
        backgroundColor: backgroundColor
      }, outerContainerStyles],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 59
      }
    }), _react.default.createElement(_reactNative.StatusBar, (0, _extends2.default)({}, statusBarProps, {
      __source: {
        fileName: _jsxFileName,
        lineNumber: 67
      }
    })), _react.default.createElement(_reactNative.View, {
      style: [styles.innerContainer, innerContainerStyles],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 68
      }
    }, propChildren.length > 0 ? propChildren : children));
  };

  Header.propTypes = {
    leftComponent: _propTypes.default.object,
    centerComponent: _propTypes.default.object,
    rightComponent: _propTypes.default.object,
    backgroundColor: _propTypes.default.string,
    outerContainerStyles: _ViewPropTypes.default.style,
    innerContainerStyles: _ViewPropTypes.default.style,
    children: _propTypes.default.oneOfType([_propTypes.default.element, _propTypes.default.arrayOf(_propTypes.default.element)]),
    statusBarProps: _propTypes.default.object
  };

  var styles = _reactNative.StyleSheet.create({
    innerContainer: {
      flex: 1,
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-end'
    },
    outerContainer: {
      backgroundColor: '#476DC5',
      borderBottomColor: '#f2f2f2',
      borderBottomWidth: 1,
      padding: 15,
      height: 70
    }
  });

  var _default = Header;
  exports.default = _default;
},735,[23,120,112,109,161,116,736,737,738,739,714],"node_modules\\react-native-elements\\src\\header\\Header.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = '[object Arguments]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      setTag = '[object Set]',
      weakMapTag = '[object WeakMap]';
  var dataViewTag = '[object DataView]';
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function('return this')();
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;

  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  function isHostObject(value) {
    var result = false;

    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }

    return result;
  }

  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  var funcProto = Function.prototype,
      objectProto = Object.prototype;
  var coreJsData = root['__core-js_shared__'];

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  var Buffer = moduleExports ? root.Buffer : undefined,
      propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
      nativeKeys = overArg(Object.keys, Object);
  var DataView = getNative(root, 'DataView'),
      Map = getNative(root, 'Map'),
      Promise = getNative(root, 'Promise'),
      Set = getNative(root, 'Set'),
      WeakMap = getNative(root, 'WeakMap');
  var nonEnumShadows = !propertyIsEnumerable.call({
    'valueOf': 1
  }, 'valueOf');
  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise),
      setCtorString = toSource(Set),
      weakMapCtorString = toSource(WeakMap);

  function baseGetTag(value) {
    return objectToString.call(value);
  }

  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }

    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  var getTag = baseGetTag;

  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function getTag(value) {
      var result = objectToString.call(value),
          Ctor = result == objectTag ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : undefined;

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;

          case mapCtorString:
            return mapTag;

          case promiseCtorString:
            return promiseTag;

          case setCtorString:
            return setTag;

          case weakMapCtorString:
            return weakMapTag;
        }
      }

      return result;
    };
  }

  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
  }

  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }

  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
  }

  var isArray = Array.isArray;

  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }

  var isBuffer = nativeIsBuffer || stubFalse;

  function isEmpty(value) {
    if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isArguments(value))) {
      return !value.length;
    }

    var tag = getTag(value);

    if (tag == mapTag || tag == setTag) {
      return !value.size;
    }

    if (nonEnumShadows || isPrototype(value)) {
      return !nativeKeys(value).length;
    }

    for (var key in value) {
      if (hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  }

  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
  }

  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  function stubFalse() {
    return false;
  }

  module.exports = isEmpty;
},736,[],"node_modules\\lodash.isempty\\index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[2], "react-native");

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\header\\DummyNavButton.js";

  var DummyNavButton = function DummyNavButton() {
    return _react.default.createElement(_reactNative.View, {
      style: styles.dummyNavBtn,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 4
      }
    });
  };

  var styles = _reactNative.StyleSheet.create({
    dummyNavBtn: {
      height: 24,
      width: 24
    }
  });

  var _default = DummyNavButton;
  exports.default = _default;
},737,[23,109,116],"node_modules\\react-native-elements\\src\\header\\DummyNavButton.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutProperties"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "react"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "prop-types"));

  var _Icon = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "../icons/Icon"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\header\\NavButton.js";

  var NavButton = function NavButton(props) {
    var icon = props.icon,
        attributes = (0, _objectWithoutProperties2.default)(props, ["icon"]);
    return _react.default.createElement(_Icon.default, (0, _extends2.default)({}, attributes, {
      name: icon,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 8
      }
    }));
  };

  NavButton.propTypes = {
    icon: _propTypes.default.string
  };
  var _default = NavButton;
  exports.default = _default;
},738,[23,112,120,109,161,715],"node_modules\\react-native-elements\\src\\header\\NavButton.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutProperties"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "react"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "prop-types"));

  var _Text = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "../text/Text"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\header\\Title.js";

  var Title = function Title(props) {
    var text = props.text,
        attributes = (0, _objectWithoutProperties2.default)(props, ["text"]);
    return _react.default.createElement(_Text.default, (0, _extends2.default)({
      numberOfLines: 1
    }, attributes, {
      __source: {
        fileName: _jsxFileName,
        lineNumber: 10
      }
    }), text);
  };

  Title.propTypes = {
    text: _propTypes.default.string
  };
  var _default = Title;
  exports.default = _default;
},739,[23,112,120,109,161,640],"node_modules\\react-native-elements\\src\\header\\Title.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _objectSpread2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread"));

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/objectWithoutProperties"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "prop-types"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[6], "react-native");

  var _Text = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "../text/Text"));

  var _fonts = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "../config/fonts"));

  var _colors = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "../config/colors"));

  var _Button = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "../buttons/Button"));

  var _normalizeText = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "../helpers/normalizeText"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[12], "../config/ViewPropTypes"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\pricing\\PricingCard.js";

  var PricingCard = function PricingCard(props) {
    var containerStyle = props.containerStyle,
        wrapperStyle = props.wrapperStyle,
        title = props.title,
        price = props.price,
        info = props.info,
        button = props.button,
        color = props.color,
        titleFont = props.titleFont,
        pricingFont = props.pricingFont,
        infoFont = props.infoFont,
        buttonFont = props.buttonFont,
        onButtonPress = props.onButtonPress,
        attributes = (0, _objectWithoutProperties2.default)(props, ["containerStyle", "wrapperStyle", "title", "price", "info", "button", "color", "titleFont", "pricingFont", "infoFont", "buttonFont", "onButtonPress"]);
    return _react.default.createElement(_reactNative.View, (0, _extends2.default)({}, attributes, {
      style: [styles.container, containerStyle && containerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 28
      }
    }), _react.default.createElement(_reactNative.View, {
      style: [styles.wrapper, wrapperStyle && wrapperStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 32
      }
    }, _react.default.createElement(_Text.default, {
      style: [styles.pricingTitle, {
        color: color
      }, titleFont && {
        fontFamily: titleFont
      }],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 33
      }
    }, title), _react.default.createElement(_Text.default, {
      style: [styles.pricingPrice, pricingFont && {
        fontFamily: pricingFont
      }],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 42
      }
    }, price), info.map(function (item, i) {
      return _react.default.createElement(_Text.default, {
        key: i,
        style: [styles.pricingInfo, infoFont && {
          fontFamily: infoFont
        }],
        __source: {
          fileName: _jsxFileName,
          lineNumber: 52
        }
      }, item);
    }), _react.default.createElement(_Button.default, {
      icon: {
        name: button.icon
      },
      buttonStyle: [styles.button, button.buttonStyle, {
        backgroundColor: color
      }],
      fontFamily: buttonFont && buttonFont,
      title: button.title,
      onPress: onButtonPress,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 60
      }
    })));
  };

  PricingCard.propTypes = {
    containerStyle: _ViewPropTypes.default.style,
    wrapperStyle: _ViewPropTypes.default.style,
    title: _propTypes.default.string,
    price: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
    info: _propTypes.default.array,
    button: _propTypes.default.object,
    color: _propTypes.default.string,
    onButtonPress: _propTypes.default.any,
    titleFont: _propTypes.default.string,
    pricingFont: _propTypes.default.string,
    infoFont: _propTypes.default.string,
    buttonFont: _propTypes.default.string
  };
  PricingCard.defaultProps = {
    color: _colors.default.primary
  };

  var styles = _reactNative.StyleSheet.create({
    container: (0, _objectSpread2.default)({
      margin: 15,
      marginBottom: 15,
      backgroundColor: 'white',
      borderColor: _colors.default.grey5,
      borderWidth: 1,
      padding: 15
    }, _reactNative.Platform.select({
      ios: {
        shadowColor: 'rgba(0,0,0, .2)',
        shadowOffset: {
          height: 1,
          width: 0
        },
        shadowOpacity: 0.5,
        shadowRadius: 0.5
      },
      android: {
        elevation: 1
      }
    })),
    wrapper: {
      backgroundColor: 'transparent'
    },
    pricingTitle: (0, _objectSpread2.default)({
      textAlign: 'center',
      color: _colors.default.primary,
      fontSize: (0, _normalizeText.default)(30)
    }, _reactNative.Platform.select({
      ios: {
        fontWeight: '800'
      },
      android: (0, _objectSpread2.default)({}, _fonts.default.android.black)
    })),
    pricingPrice: (0, _objectSpread2.default)({
      textAlign: 'center',
      marginTop: 10,
      marginBottom: 10,
      fontSize: (0, _normalizeText.default)(40)
    }, _reactNative.Platform.select({
      ios: {
        fontWeight: '700'
      },
      android: (0, _objectSpread2.default)({}, _fonts.default.android.bold)
    })),
    pricingInfo: (0, _objectSpread2.default)({
      textAlign: 'center',
      marginTop: 5,
      marginBottom: 5,
      color: _colors.default.grey3
    }, _reactNative.Platform.select({
      ios: {
        fontWeight: '600'
      },
      android: (0, _objectSpread2.default)({}, _fonts.default.android.bold)
    })),
    button: {
      marginTop: 15,
      marginBottom: 10
    }
  });

  var _default = PricingCard;
  exports.default = _default;
},740,[23,148,112,120,161,109,116,640,641,639,638,642,714],"node_modules\\react-native-elements\\src\\pricing\\PricingCard.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _interopRequireWildcard = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/interopRequireWildcard");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _objectSpread2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectSpread"));

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/objectWithoutProperties"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/createClass"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/getPrototypeOf"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/inherits"));

  var _assertThisInitialized2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "@babel/runtime/helpers/assertThisInitialized"));

  var _defineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "@babel/runtime/helpers/defineProperty"));

  var _react = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[12], "react"));

  var _index = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[13], "./../../../react-transform-hmr/lib/index.js"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[14], "prop-types"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[15], "react-native");

  var _colors = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[16], "../config/colors"));

  var _normalizeText = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[17], "../helpers/normalizeText"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[18], "../config/ViewPropTypes"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\form\\FormInput.js";
  var _components = {
    FormInput: {
      displayName: "FormInput"
    }
  };

  var _reactTransformHmrLibIndexJs2 = (0, _index.default)({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\form\\FormInput.js",
    components: _components,
    locals: [module],
    imports: [_react.default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width;

  var FormInput = function (_Component) {
    (0, _inherits2.default)(FormInput, _Component);

    function FormInput(props) {
      var _this;

      (0, _classCallCheck2.default)(this, FormInput);
      _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FormInput).call(this, props));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "getRef", function () {
        return _this.input || _this.refs[_this.props.textInputRef];
      });
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "getRefHandler", function () {
        if (_this.props.textInputRef) {
          if (typeof _this.props.textInputRef === 'function') {
            return function (input) {
              _this.input = input;

              _this.props.textInputRef(input);
            };
          } else {
            return _this.props.textInputRef;
          }
        } else {
          return function (input) {
            return _this.input = input;
          };
        }
      });
      _this.shake = _this.shake.bind((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)));
      return _this;
    }

    (0, _createClass2.default)(FormInput, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this.shakeAnimationValue = new _reactNative.Animated.Value(0);
        this.props.shake && this.shake();
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        nextProps.shake && this.props.shake !== nextProps.shake && this.shake();
      }
    }, {
      key: "focus",
      value: function focus() {
        this.getRef() && this.getRef().focus();
      }
    }, {
      key: "blur",
      value: function blur() {
        this.getRef() && this.getRef().blur();
      }
    }, {
      key: "clearText",
      value: function clearText() {
        this.getRef() && this.getRef().clear();
      }
    }, {
      key: "shake",
      value: function shake() {
        var shakeAnimationValue = this.shakeAnimationValue;
        shakeAnimationValue.setValue(0);

        _reactNative.Animated.timing(shakeAnimationValue, {
          duration: 375,
          toValue: 3,
          ease: _reactNative.Easing.bounce
        }).start();
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
            containerStyle = _this$props.containerStyle,
            inputStyle = _this$props.inputStyle,
            containerRef = _this$props.containerRef,
            normalizeFontSize = _this$props.normalizeFontSize,
            attributes = (0, _objectWithoutProperties2.default)(_this$props, ["containerStyle", "inputStyle", "containerRef", "normalizeFontSize"]);
        var translateX = this.shakeAnimationValue.interpolate({
          inputRange: [0, 0.5, 1, 1.5, 2, 2.5, 3],
          outputRange: [0, -15, 0, 15, 0, -15, 0]
        });
        return _react.default.createElement(_reactNative.Animated.View, {
          ref: containerRef,
          style: [styles.container, containerStyle && containerStyle, {
            transform: [{
              translateX: translateX
            }]
          }],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 87
          }
        }, _react.default.createElement(_reactNative.TextInput, (0, _extends2.default)({}, attributes, {
          ref: this.getRefHandler(),
          style: [styles.input, {
            fontSize: normalizeFontSize ? (0, _normalizeText.default)(14) : 14
          }, inputStyle && inputStyle],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 97
          }
        })));
      }
    }]);
    return FormInput;
  }(_react.Component);

  FormInput = _wrapComponent("FormInput")(FormInput);
  FormInput.propTypes = {
    containerStyle: _ViewPropTypes.default.style,
    inputStyle: _reactNative.Text.propTypes.style,
    textInputRef: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func]),
    containerRef: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func]),
    normalizeFontSize: _propTypes.default.bool,
    shake: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.bool, _propTypes.default.object, _propTypes.default.number, _propTypes.default.array])
  };
  FormInput.defaultProps = {
    normalizeFontSize: true
  };

  var styles = _reactNative.StyleSheet.create({
    container: (0, _objectSpread2.default)({
      marginLeft: 15,
      marginRight: 15
    }, _reactNative.Platform.select({
      ios: {
        borderBottomColor: _colors.default.grey4,
        borderBottomWidth: 1,
        marginLeft: 20,
        marginRight: 20
      }
    })),
    input: (0, _objectSpread2.default)({}, _reactNative.Platform.select({
      android: {
        minHeight: 46,
        width: width - 30
      },
      ios: {
        minHeight: 36,
        width: width
      }
    }), {
      color: _colors.default.grey3
    })
  });

  var _default2 = FormInput;
  exports.default = _default2;
},741,[23,637,148,112,120,24,25,26,29,30,28,32,109,280,161,116,639,642,714],"node_modules\\react-native-elements\\src\\form\\FormInput.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _objectSpread2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/objectSpread"));

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/objectWithoutProperties"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "prop-types"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[6], "react-native");

  var _colors = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "../config/colors"));

  var _fonts = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "../config/fonts"));

  var _Text = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "../text/Text"));

  var _normalizeText = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "../helpers/normalizeText"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "../config/ViewPropTypes"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\form\\FormLabel.js";

  var FormLabel = function FormLabel(props) {
    var containerStyle = props.containerStyle,
        labelStyle = props.labelStyle,
        children = props.children,
        fontFamily = props.fontFamily,
        attributes = (0, _objectWithoutProperties2.default)(props, ["containerStyle", "labelStyle", "children", "fontFamily"]);
    return _react.default.createElement(_reactNative.View, (0, _extends2.default)({}, attributes, {
      style: [styles.container, containerStyle && containerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 19
      }
    }), _react.default.createElement(_Text.default, {
      style: [styles.label, labelStyle && labelStyle, fontFamily && {
        fontFamily: fontFamily
      }],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 23
      }
    }, children));
  };

  FormLabel.propTypes = {
    containerStyle: _ViewPropTypes.default.style,
    labelStyle: _reactNative.Text.propTypes.style,
    children: _propTypes.default.any,
    fontFamily: _propTypes.default.string
  };

  var styles = _reactNative.StyleSheet.create({
    container: {},
    label: (0, _objectSpread2.default)({
      marginLeft: 20,
      marginRight: 20,
      marginTop: 15,
      marginBottom: 1,
      color: _colors.default.grey3,
      fontSize: (0, _normalizeText.default)(12)
    }, _reactNative.Platform.select({
      ios: {
        fontWeight: 'bold'
      },
      android: (0, _objectSpread2.default)({}, _fonts.default.android.bold)
    }))
  });

  var _default = FormLabel;
  exports.default = _default;
},742,[23,148,112,120,161,109,116,639,641,640,642,714],"node_modules\\react-native-elements\\src\\form\\FormLabel.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutProperties"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "prop-types"));

  var _react = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "react"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[5], "react-native");

  var _colors = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "../config/colors"));

  var _Text = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "../text/Text"));

  var _normalizeText = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "../helpers/normalizeText"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "../config/ViewPropTypes"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\form\\FormValidationMessage.js";

  var FormValidationMessage = function FormValidationMessage(props) {
    var containerStyle = props.containerStyle,
        labelStyle = props.labelStyle,
        children = props.children,
        fontFamily = props.fontFamily,
        attributes = (0, _objectWithoutProperties2.default)(props, ["containerStyle", "labelStyle", "children", "fontFamily"]);
    return _react.default.createElement(_reactNative.View, (0, _extends2.default)({}, attributes, {
      style: [styles.container, containerStyle && containerStyle],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 18
      }
    }), _react.default.createElement(_Text.default, {
      style: [styles.label, labelStyle && labelStyle, fontFamily && {
        fontFamily: fontFamily
      }],
      __source: {
        fileName: _jsxFileName,
        lineNumber: 22
      }
    }, children));
  };

  FormValidationMessage.propTypes = {
    containerStyle: _ViewPropTypes.default.style,
    labelStyle: _reactNative.Text.propTypes.style,
    children: _propTypes.default.any,
    fontFamily: _propTypes.default.string
  };

  var styles = _reactNative.StyleSheet.create({
    container: {},
    label: {
      marginLeft: 20,
      marginRight: 20,
      marginTop: 5,
      marginBottom: 1,
      color: _colors.default.error,
      fontSize: (0, _normalizeText.default)(12)
    }
  });

  var _default = FormValidationMessage;
  exports.default = _default;
},743,[23,112,120,161,109,116,639,640,642,714],"node_modules\\react-native-elements\\src\\form\\FormValidationMessage.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");

  var _interopRequireWildcard = _$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/interopRequireWildcard");

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _objectSpread2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/objectSpread"));

  var _extends2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/extends"));

  var _objectWithoutProperties2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/objectWithoutProperties"));

  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/classCallCheck"));

  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/createClass"));

  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/possibleConstructorReturn"));

  var _getPrototypeOf3 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/getPrototypeOf"));

  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/inherits"));

  var _assertThisInitialized2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "@babel/runtime/helpers/assertThisInitialized"));

  var _defineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "@babel/runtime/helpers/defineProperty"));

  var _react = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[12], "react"));

  var _index = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[13], "./../../../react-transform-hmr/lib/index.js"));

  var _propTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[14], "prop-types"));

  var _reactNative = _$$_REQUIRE(_dependencyMap[15], "react-native");

  var _MaterialIcons = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[16], "react-native-vector-icons/MaterialIcons"));

  var _colors = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[17], "../config/colors"));

  var _normalizeText = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[18], "../helpers/normalizeText"));

  var _ViewPropTypes = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[19], "../config/ViewPropTypes"));

  var _getIconType = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[20], "../helpers/getIconType"));

  var _jsxFileName = "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\input\\Search.js";
  var _components = {
    Search: {
      displayName: "Search"
    }
  };

  var _reactTransformHmrLibIndexJs2 = (0, _index.default)({
    filename: "c:\\Users\\atrauzzi\\Development\\artmoi\\react-native-tinkering\\node_modules\\react-native-elements\\src\\input\\Search.js",
    components: _components,
    locals: [module],
    imports: [_react.default]
  });

  function _wrapComponent(id) {
    return function (Component) {
      return _reactTransformHmrLibIndexJs2(Component, id);
    };
  }

  var Search = function (_Component) {
    (0, _inherits2.default)(Search, _Component);

    function Search() {
      var _getPrototypeOf2;

      var _this;

      (0, _classCallCheck2.default)(this, Search);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(Search)).call.apply(_getPrototypeOf2, [this].concat(args)));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "getRef", function () {
        return _this.input || _this.refs[_this.props.textInputRef];
      });
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "getRefHandler", function () {
        if (_this.props.textInputRef) {
          if (typeof _this.props.textInputRef === 'function') {
            return function (input) {
              _this.input = input;

              _this.props.textInputRef(input);
            };
          } else {
            return _this.props.textInputRef;
          }
        } else {
          return function (input) {
            return _this.input = input;
          };
        }
      });
      return _this;
    }

    (0, _createClass2.default)(Search, [{
      key: "focus",
      value: function focus() {
        this.getRef() && this.getRef().focus();
      }
    }, {
      key: "blur",
      value: function blur() {
        this.getRef() && this.getRef().blur();
      }
    }, {
      key: "clearText",
      value: function clearText() {
        this.getRef() && this.getRef().clear();
        this.props.onChangeText && this.props.onChangeText('');
        this.props.onClearText && this.props.onClearText();
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
            containerStyle = _this$props.containerStyle,
            inputStyle = _this$props.inputStyle,
            icon = _this$props.icon,
            noIcon = _this$props.noIcon,
            lightTheme = _this$props.lightTheme,
            round = _this$props.round,
            showLoadingIcon = _this$props.showLoadingIcon,
            loadingIcon = _this$props.loadingIcon,
            clearIcon = _this$props.clearIcon,
            containerRef = _this$props.containerRef,
            underlineColorAndroid = _this$props.underlineColorAndroid,
            attributes = (0, _objectWithoutProperties2.default)(_this$props, ["containerStyle", "inputStyle", "icon", "noIcon", "lightTheme", "round", "showLoadingIcon", "loadingIcon", "clearIcon", "containerRef", "underlineColorAndroid"]);
        var Icon = _MaterialIcons.default;

        if (icon.type) {
          Icon = (0, _getIconType.default)(icon.type);
        }

        return _react.default.createElement(_reactNative.View, {
          ref: containerRef,
          style: [styles.container, lightTheme && styles.containerLight, containerStyle && containerStyle],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 73
          }
        }, _react.default.createElement(_reactNative.TextInput, (0, _extends2.default)({}, attributes, {
          ref: this.getRefHandler(),
          underlineColorAndroid: underlineColorAndroid ? underlineColorAndroid : 'transparent',
          style: [styles.input, lightTheme && styles.inputLight, noIcon && {
            paddingLeft: 9
          }, round && {
            borderRadius: _reactNative.Platform.OS === 'ios' ? 15 : 20
          }, inputStyle && inputStyle, clearIcon && showLoadingIcon && {
            paddingRight: 50
          }, (clearIcon && !showLoadingIcon || !clearIcon && showLoadingIcon) && {
            paddingRight: 30
          }],
          __source: {
            fileName: _jsxFileName,
            lineNumber: 81
          }
        })), !noIcon && _react.default.createElement(Icon, {
          size: 16,
          style: [styles.icon, styles.searchIcon, icon.style && icon.style],
          name: icon.name || 'search',
          color: icon.color || _colors.default.grey3,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 99
          }
        }), clearIcon && _react.default.createElement(Icon, {
          size: 16,
          style: [styles.icon, styles.clearIcon, clearIcon.style && clearIcon.style],
          name: clearIcon.name || 'close',
          onPress: this.clearText.bind(this),
          color: clearIcon.color || _colors.default.grey3,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 107
          }
        }), showLoadingIcon && _react.default.createElement(_reactNative.ActivityIndicator, {
          style: [styles.loadingIcon, loadingIcon.style && loadingIcon.style, clearIcon && {
            right: 35
          }],
          color: icon.color || _colors.default.grey3,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 120
          }
        }));
      }
    }]);
    return Search;
  }(_react.Component);

  Search = _wrapComponent("Search")(Search);
  Search.propTypes = {
    icon: _propTypes.default.object,
    noIcon: _propTypes.default.bool,
    lightTheme: _propTypes.default.bool,
    containerStyle: _ViewPropTypes.default.style,
    inputStyle: _reactNative.Text.propTypes.style,
    round: _propTypes.default.bool,
    showLoadingIcon: _propTypes.default.bool,
    loadingIcon: _propTypes.default.object,
    clearIcon: _propTypes.default.oneOfType([_propTypes.default.object, _propTypes.default.bool]),
    textInputRef: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func]),
    containerRef: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func]),
    underlineColorAndroid: _propTypes.default.string,
    onChangeText: _propTypes.default.func,
    onClearText: _propTypes.default.func
  };
  Search.defaultProps = {
    placeholderTextColor: _colors.default.grey3,
    lightTheme: false,
    noIcon: false,
    round: false,
    icon: {},
    showLoadingIcon: false,
    loadingIcon: {}
  };

  var styles = _reactNative.StyleSheet.create({
    container: {
      borderTopWidth: 1,
      borderBottomWidth: 1,
      borderBottomColor: '#000',
      borderTopColor: '#000',
      backgroundColor: _colors.default.grey0
    },
    containerLight: {
      backgroundColor: _colors.default.grey5,
      borderTopColor: '#e1e1e1',
      borderBottomColor: '#e1e1e1'
    },
    icon: (0, _objectSpread2.default)({
      backgroundColor: 'transparent',
      position: 'absolute',
      top: 15.5
    }, _reactNative.Platform.select({
      android: {
        top: 20
      }
    })),
    loadingIcon: (0, _objectSpread2.default)({
      backgroundColor: 'transparent',
      position: 'absolute',
      right: 16,
      top: 13
    }, _reactNative.Platform.select({
      android: {
        top: 18
      }
    })),
    input: (0, _objectSpread2.default)({
      paddingLeft: 26,
      paddingRight: 19,
      margin: 8,
      borderRadius: 3,
      overflow: 'hidden',
      backgroundColor: _colors.default.searchBg,
      fontSize: (0, _normalizeText.default)(14),
      color: _colors.default.grey3,
      height: 40
    }, _reactNative.Platform.select({
      ios: {
        height: 30
      },
      android: {
        borderWidth: 0
      }
    })),
    inputLight: {
      backgroundColor: _colors.default.grey4
    },
    searchIcon: {
      left: 16
    },
    clearIcon: {
      right: 16
    }
  });

  var _default2 = Search;
  exports.default = _default2;
},744,[23,637,148,112,120,24,25,26,29,30,28,32,109,280,161,116,643,639,642,714,693],"node_modules\\react-native-elements\\src\\input\\Search.js");
__d(function(global, require, _aUnused, _bUnused, module, exports, _cUnused) {
  module.exports = {
  "name": "ReactNativeTinkering",
  "displayName": "React Native Tinkering"
};
},745,[],"app.json");
__r(180);
__r(0);
//# sourceMappingURL=index.map